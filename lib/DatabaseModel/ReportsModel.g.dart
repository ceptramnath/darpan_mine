// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'ReportsModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:InventoryMainTable.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// InventoryMainTable TABLE
class TableInventoryMainTable extends SqfEntityTableBase {
  TableInventoryMainTable() {
    // declare properties of EntityTable
    tableName = 'InventoryMainTable';
    primaryKeyName = 'InventoryID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ItemCode', DbType.text),
      SqfEntityFieldBase('ItemName', DbType.text),
      SqfEntityFieldBase('ItemDenomination', DbType.text),
      SqfEntityFieldBase('ItemBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInventoryMainTable();
  }
}

// InventoryReceiveTable TABLE
class TableInventoryReceiveTable extends SqfEntityTableBase {
  TableInventoryReceiveTable() {
    // declare properties of EntityTable
    tableName = 'InventoryReceiveTable';
    primaryKeyName = 'InventoryID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('InventoryPrice', DbType.text),
      SqfEntityFieldBase('InventoryName', DbType.text),
      SqfEntityFieldBase('InventoryQuantity', DbType.text),
      SqfEntityFieldBase('InventoryOpeningDate', DbType.text),
      SqfEntityFieldBase('InventoryOpeningTime', DbType.text),
      SqfEntityFieldBase('InventoryClosingDate', DbType.text),
      SqfEntityFieldBase('InventoryClosingTime', DbType.text),
      SqfEntityFieldBase('InventoryOpeningBalance', DbType.text),
      SqfEntityFieldBase('InventoryClosingBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInventoryReceiveTable();
  }
}

// CashReceiveTable TABLE
class TableCashReceiveTable extends SqfEntityTableBase {
  TableCashReceiveTable() {
    // declare properties of EntityTable
    tableName = 'CashReceiveTable';
    primaryKeyName = 'CashID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('CashOpeningDate', DbType.text),
      SqfEntityFieldBase('CashOpeningTime', DbType.text),
      SqfEntityFieldBase('CashOpeningBalance', DbType.text),
      SqfEntityFieldBase('CashClosingDate', DbType.text),
      SqfEntityFieldBase('CashClosingTime', DbType.text),
      SqfEntityFieldBase('CashClosingBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCashReceiveTable();
  }
}

// FileSyncDetail TABLE
class TableFileSyncDetail extends SqfEntityTableBase {
  TableFileSyncDetail() {
    // declare properties of EntityTable
    tableName = 'FileSyncDetails';
    primaryKeyName = 'ClientTransactionId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FilePath', DbType.text),
      SqfEntityFieldBase('ServiceText', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('UpdatedAt', DbType.text),
      SqfEntityFieldBase('Processed', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFileSyncDetail();
  }
}

// CashTableBackup TABLE
class TableCashTableBackup extends SqfEntityTableBase {
  TableCashTableBackup() {
    // declare properties of EntityTable
    tableName = 'CashTableBackup';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Cash_ID', DbType.text),
      SqfEntityFieldBase('Cash_Amount', DbType.real),
      SqfEntityFieldBase('Cash_Description', DbType.text),
      SqfEntityFieldBase('Cash_Type', DbType.text),
      SqfEntityFieldBase('Cash_Date', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('Cash_Time', DbType.text, isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCashTableBackup();
  }
}

// TransactionTableBackup TABLE
class TableTransactionTableBackup extends SqfEntityTableBase {
  TableTransactionTableBackup() {
    // declare properties of EntityTable
    tableName = 'TransactionTableBackup';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('tranid', DbType.text),
      SqfEntityFieldBase('tranType', DbType.text),
      SqfEntityFieldBase('tranDescription', DbType.text),
      SqfEntityFieldBase('tranDate', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('tranTime', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('tranAmount', DbType.real),
      SqfEntityFieldBase('valuation', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTransactionTableBackup();
  }
}

// PincodeUpdateTable TABLE
class TablePincodeUpdateTable extends SqfEntityTableBase {
  TablePincodeUpdateTable() {
    // declare properties of EntityTable
    tableName = 'PincodeUpdateTable';
    primaryKeyName = 'appversion';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('versiondate', DbType.text),
      SqfEntityFieldBase('pincodecount', DbType.text),
      SqfEntityFieldBase('status', DbType.text, defaultValue: 'N'),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePincodeUpdateTable();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class ReportModel extends SqfEntityModelProvider {
  ReportModel() {
    databaseName = reportModel.databaseName;
    password = reportModel.password;
    dbVersion = reportModel.dbVersion;
    preSaveAction = reportModel.preSaveAction;
    logFunction = reportModel.logFunction;
    databaseTables = [
      TableInventoryMainTable.getInstance,
      TableInventoryReceiveTable.getInstance,
      TableCashReceiveTable.getInstance,
      TableFileSyncDetail.getInstance,
      TableCashTableBackup.getInstance,
      TableTransactionTableBackup.getInstance,
      TablePincodeUpdateTable.getInstance,
    ];

    bundledDatabasePath = reportModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = reportModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region InventoryMainTable
class InventoryMainTable extends TableBase {
  InventoryMainTable(
      {this.InventoryID,
      this.ItemCode,
      this.ItemName,
      this.ItemDenomination,
      this.ItemBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  InventoryMainTable.withFields(this.InventoryID, this.ItemCode, this.ItemName,
      this.ItemDenomination, this.ItemBalance) {
    _setDefaultValues();
  }
  InventoryMainTable.withId(this.InventoryID, this.ItemCode, this.ItemName,
      this.ItemDenomination, this.ItemBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InventoryMainTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InventoryID = o['InventoryID'].toString();
    if (o['ItemCode'] != null) {
      ItemCode = o['ItemCode'].toString();
    }
    if (o['ItemName'] != null) {
      ItemName = o['ItemName'].toString();
    }
    if (o['ItemDenomination'] != null) {
      ItemDenomination = o['ItemDenomination'].toString();
    }
    if (o['ItemBalance'] != null) {
      ItemBalance = o['ItemBalance'].toString();
    }

    isSaved = true;
  }
  // FIELDS (InventoryMainTable)
  String? InventoryID;
  String? ItemCode;
  String? ItemName;
  String? ItemDenomination;
  String? ItemBalance;
  bool? isSaved;
  // end FIELDS (InventoryMainTable)

  static const bool _softDeleteActivated = false;
  InventoryMainTableManager? __mnInventoryMainTable;

  InventoryMainTableManager get _mnInventoryMainTable {
    return __mnInventoryMainTable =
        __mnInventoryMainTable ?? InventoryMainTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (ItemCode != null || !forView) {
      map['ItemCode'] = ItemCode;
    }
    if (ItemName != null || !forView) {
      map['ItemName'] = ItemName;
    }
    if (ItemDenomination != null || !forView) {
      map['ItemDenomination'] = ItemDenomination;
    }
    if (ItemBalance != null || !forView) {
      map['ItemBalance'] = ItemBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (ItemCode != null || !forView) {
      map['ItemCode'] = ItemCode;
    }
    if (ItemName != null || !forView) {
      map['ItemName'] = ItemName;
    }
    if (ItemDenomination != null || !forView) {
      map['ItemDenomination'] = ItemDenomination;
    }
    if (ItemBalance != null || !forView) {
      map['ItemBalance'] = ItemBalance;
    }

    return map;
  }

  /// This method returns Json String [InventoryMainTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InventoryMainTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance];
  }

  static Future<List<InventoryMainTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryMainTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InventoryMainTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InventoryMainTable>[];
    try {
      objList = list
          .map((inventorymaintable) => InventoryMainTable.fromMap(
              inventorymaintable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryMainTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InventoryMainTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InventoryMainTable> objList = <InventoryMainTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InventoryMainTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns InventoryMainTable by ID if exist, otherwise returns null
  /// Primary Keys: String? InventoryID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [InventoryMainTable] if exist, otherwise returns null
  Future<InventoryMainTable?> getById(String? InventoryID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InventoryID == null) {
      return null;
    }
    InventoryMainTable? obj;
    final data = await _mnInventoryMainTable.getById([InventoryID]);
    if (data.length != 0) {
      obj = InventoryMainTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InventoryMainTable) object. If the Primary Key (InventoryID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same InventoryID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnInventoryMainTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO InventoryMainTable (InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<InventoryMainTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<InventoryMainTable> inventorymaintables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in inventorymaintables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryMainTable.rawInsert(
          'INSERT OR REPLACE INTO InventoryMainTable (InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance)  VALUES (?,?,?,?,?)',
          [InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryMainTable InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryMainTable InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryMainTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryMainTable.rawInsert(
          'INSERT OR IGNORE INTO InventoryMainTable (InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance)  VALUES (?,?,?,?,?)',
          [InventoryID, ItemCode, ItemName, ItemDenomination, ItemBalance],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryMainTable InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryMainTable InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryMainTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes InventoryMainTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete InventoryMainTable invoked (InventoryID=$InventoryID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInventoryMainTable.delete(QueryParams(
          whereString: 'InventoryID=?', whereArguments: [InventoryID]));
    } else {
      return _mnInventoryMainTable.updateBatch(
          QueryParams(
              whereString: 'InventoryID=?', whereArguments: [InventoryID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [InventoryMainTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InventoryMainTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryMainTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InventoryMainTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryMainTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InventoryID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion inventorymaintable

// region InventoryMainTableField
class InventoryMainTableField extends FilterBase {
  InventoryMainTableField(InventoryMainTableFilterBuilder inventorymaintableFB)
      : super(inventorymaintableFB);

  @override
  InventoryMainTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder isNull() {
    return super.isNull() as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InventoryMainTableFilterBuilder;
  }

  @override
  InventoryMainTableField get not {
    return super.not as InventoryMainTableField;
  }
}
// endregion InventoryMainTableField

// region InventoryMainTableFilterBuilder
class InventoryMainTableFilterBuilder extends ConjunctionBase {
  InventoryMainTableFilterBuilder(InventoryMainTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInventoryMainTable = obj._mnInventoryMainTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InventoryMainTableManager? _mnInventoryMainTable;

  /// put the sql keyword 'AND'
  @override
  InventoryMainTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InventoryMainTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InventoryMainTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InventoryMainTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InventoryMainTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InventoryMainTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InventoryMainTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryMainTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryMainTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryMainTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryMainTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InventoryMainTableField _setField(
      InventoryMainTableField? field, String colName, DbType dbtype) {
    return InventoryMainTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InventoryMainTableField? _InventoryID;
  InventoryMainTableField get InventoryID {
    return _InventoryID =
        _setField(_InventoryID, 'InventoryID', DbType.integer);
  }

  InventoryMainTableField? _ItemCode;
  InventoryMainTableField get ItemCode {
    return _ItemCode = _setField(_ItemCode, 'ItemCode', DbType.text);
  }

  InventoryMainTableField? _ItemName;
  InventoryMainTableField get ItemName {
    return _ItemName = _setField(_ItemName, 'ItemName', DbType.text);
  }

  InventoryMainTableField? _ItemDenomination;
  InventoryMainTableField get ItemDenomination {
    return _ItemDenomination =
        _setField(_ItemDenomination, 'ItemDenomination', DbType.text);
  }

  InventoryMainTableField? _ItemBalance;
  InventoryMainTableField get ItemBalance {
    return _ItemBalance = _setField(_ItemBalance, 'ItemBalance', DbType.text);
  }

  /// Deletes List<InventoryMainTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInventoryMainTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInventoryMainTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InventoryID IN (SELECT InventoryID from InventoryMainTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInventoryMainTable!.updateBatch(qparams, values);
  }

  /// This method always returns [InventoryMainTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryMainTable?
  @override
  Future<InventoryMainTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInventoryMainTable!.toList(qparams);
    final data = await objFuture;
    InventoryMainTable? obj;
    if (data.isNotEmpty) {
      obj = InventoryMainTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [InventoryMainTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryMainTable?
  @override
  Future<InventoryMainTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        InventoryMainTable();
  }

  /// This method returns int. [InventoryMainTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? inventorymaintableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final inventorymaintablesFuture =
        await _mnInventoryMainTable!.toList(qparams);
    final int count = inventorymaintablesFuture[0]['CNT'] as int;
    if (inventorymaintableCount != null) {
      inventorymaintableCount(count);
    }
    return count;
  }

  /// This method returns List<InventoryMainTable> [InventoryMainTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<InventoryMainTable>
  @override
  Future<List<InventoryMainTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InventoryMainTable> inventorymaintablesData =
        await InventoryMainTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return inventorymaintablesData;
  }

  /// This method returns Json String [InventoryMainTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InventoryMainTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InventoryMainTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInventoryMainTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InventoryMainTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InventoryID` FROM InventoryMainTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> InventoryIDData = <String>[];
    qparams.selectColumns = ['InventoryID'];
    final InventoryIDFuture = await _mnInventoryMainTable!.toList(qparams);

    final int count = InventoryIDFuture.length;
    for (int i = 0; i < count; i++) {
      InventoryIDData.add(InventoryIDFuture[i]['InventoryID'] as String);
    }
    return InventoryIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InventoryMainTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInventoryMainTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await InventoryMainTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInventoryMainTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InventoryMainTableFilterBuilder

// region InventoryMainTableFields
class InventoryMainTableFields {
  static TableField? _fInventoryID;
  static TableField get InventoryID {
    return _fInventoryID = _fInventoryID ??
        SqlSyntax.setField(_fInventoryID, 'inventoryid', DbType.integer);
  }

  static TableField? _fItemCode;
  static TableField get ItemCode {
    return _fItemCode =
        _fItemCode ?? SqlSyntax.setField(_fItemCode, 'ItemCode', DbType.text);
  }

  static TableField? _fItemName;
  static TableField get ItemName {
    return _fItemName =
        _fItemName ?? SqlSyntax.setField(_fItemName, 'ItemName', DbType.text);
  }

  static TableField? _fItemDenomination;
  static TableField get ItemDenomination {
    return _fItemDenomination = _fItemDenomination ??
        SqlSyntax.setField(_fItemDenomination, 'ItemDenomination', DbType.text);
  }

  static TableField? _fItemBalance;
  static TableField get ItemBalance {
    return _fItemBalance = _fItemBalance ??
        SqlSyntax.setField(_fItemBalance, 'ItemBalance', DbType.text);
  }
}
// endregion InventoryMainTableFields

//region InventoryMainTableManager
class InventoryMainTableManager extends SqfEntityProvider {
  InventoryMainTableManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'InventoryMainTable';
  static const List<String> _primaryKeyList = ['InventoryID'];
  static const String _whereStr = 'InventoryID=?';
}

//endregion InventoryMainTableManager
// region InventoryReceiveTable
class InventoryReceiveTable extends TableBase {
  InventoryReceiveTable(
      {this.InventoryID,
      this.InventoryPrice,
      this.InventoryName,
      this.InventoryQuantity,
      this.InventoryOpeningDate,
      this.InventoryOpeningTime,
      this.InventoryClosingDate,
      this.InventoryClosingTime,
      this.InventoryOpeningBalance,
      this.InventoryClosingBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  InventoryReceiveTable.withFields(
      this.InventoryID,
      this.InventoryPrice,
      this.InventoryName,
      this.InventoryQuantity,
      this.InventoryOpeningDate,
      this.InventoryOpeningTime,
      this.InventoryClosingDate,
      this.InventoryClosingTime,
      this.InventoryOpeningBalance,
      this.InventoryClosingBalance) {
    _setDefaultValues();
  }
  InventoryReceiveTable.withId(
      this.InventoryID,
      this.InventoryPrice,
      this.InventoryName,
      this.InventoryQuantity,
      this.InventoryOpeningDate,
      this.InventoryOpeningTime,
      this.InventoryClosingDate,
      this.InventoryClosingTime,
      this.InventoryOpeningBalance,
      this.InventoryClosingBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InventoryReceiveTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InventoryID = o['InventoryID'].toString();
    if (o['InventoryPrice'] != null) {
      InventoryPrice = o['InventoryPrice'].toString();
    }
    if (o['InventoryName'] != null) {
      InventoryName = o['InventoryName'].toString();
    }
    if (o['InventoryQuantity'] != null) {
      InventoryQuantity = o['InventoryQuantity'].toString();
    }
    if (o['InventoryOpeningDate'] != null) {
      InventoryOpeningDate = o['InventoryOpeningDate'].toString();
    }
    if (o['InventoryOpeningTime'] != null) {
      InventoryOpeningTime = o['InventoryOpeningTime'].toString();
    }
    if (o['InventoryClosingDate'] != null) {
      InventoryClosingDate = o['InventoryClosingDate'].toString();
    }
    if (o['InventoryClosingTime'] != null) {
      InventoryClosingTime = o['InventoryClosingTime'].toString();
    }
    if (o['InventoryOpeningBalance'] != null) {
      InventoryOpeningBalance = o['InventoryOpeningBalance'].toString();
    }
    if (o['InventoryClosingBalance'] != null) {
      InventoryClosingBalance = o['InventoryClosingBalance'].toString();
    }

    isSaved = true;
  }
  // FIELDS (InventoryReceiveTable)
  String? InventoryID;
  String? InventoryPrice;
  String? InventoryName;
  String? InventoryQuantity;
  String? InventoryOpeningDate;
  String? InventoryOpeningTime;
  String? InventoryClosingDate;
  String? InventoryClosingTime;
  String? InventoryOpeningBalance;
  String? InventoryClosingBalance;
  bool? isSaved;
  // end FIELDS (InventoryReceiveTable)

  static const bool _softDeleteActivated = false;
  InventoryReceiveTableManager? __mnInventoryReceiveTable;

  InventoryReceiveTableManager get _mnInventoryReceiveTable {
    return __mnInventoryReceiveTable =
        __mnInventoryReceiveTable ?? InventoryReceiveTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }
    if (InventoryOpeningDate != null || !forView) {
      map['InventoryOpeningDate'] = InventoryOpeningDate;
    }
    if (InventoryOpeningTime != null || !forView) {
      map['InventoryOpeningTime'] = InventoryOpeningTime;
    }
    if (InventoryClosingDate != null || !forView) {
      map['InventoryClosingDate'] = InventoryClosingDate;
    }
    if (InventoryClosingTime != null || !forView) {
      map['InventoryClosingTime'] = InventoryClosingTime;
    }
    if (InventoryOpeningBalance != null || !forView) {
      map['InventoryOpeningBalance'] = InventoryOpeningBalance;
    }
    if (InventoryClosingBalance != null || !forView) {
      map['InventoryClosingBalance'] = InventoryClosingBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }
    if (InventoryOpeningDate != null || !forView) {
      map['InventoryOpeningDate'] = InventoryOpeningDate;
    }
    if (InventoryOpeningTime != null || !forView) {
      map['InventoryOpeningTime'] = InventoryOpeningTime;
    }
    if (InventoryClosingDate != null || !forView) {
      map['InventoryClosingDate'] = InventoryClosingDate;
    }
    if (InventoryClosingTime != null || !forView) {
      map['InventoryClosingTime'] = InventoryClosingTime;
    }
    if (InventoryOpeningBalance != null || !forView) {
      map['InventoryOpeningBalance'] = InventoryOpeningBalance;
    }
    if (InventoryClosingBalance != null || !forView) {
      map['InventoryClosingBalance'] = InventoryClosingBalance;
    }

    return map;
  }

  /// This method returns Json String [InventoryReceiveTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InventoryReceiveTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      InventoryID,
      InventoryPrice,
      InventoryName,
      InventoryQuantity,
      InventoryOpeningDate,
      InventoryOpeningTime,
      InventoryClosingDate,
      InventoryClosingTime,
      InventoryOpeningBalance,
      InventoryClosingBalance
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      InventoryID,
      InventoryPrice,
      InventoryName,
      InventoryQuantity,
      InventoryOpeningDate,
      InventoryOpeningTime,
      InventoryClosingDate,
      InventoryClosingTime,
      InventoryOpeningBalance,
      InventoryClosingBalance
    ];
  }

  static Future<List<InventoryReceiveTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryReceiveTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InventoryReceiveTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InventoryReceiveTable>[];
    try {
      objList = list
          .map((inventoryreceivetable) => InventoryReceiveTable.fromMap(
              inventoryreceivetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryReceiveTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InventoryReceiveTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InventoryReceiveTable> objList = <InventoryReceiveTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InventoryReceiveTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns InventoryReceiveTable by ID if exist, otherwise returns null
  /// Primary Keys: String? InventoryID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [InventoryReceiveTable] if exist, otherwise returns null
  Future<InventoryReceiveTable?> getById(String? InventoryID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InventoryID == null) {
      return null;
    }
    InventoryReceiveTable? obj;
    final data = await _mnInventoryReceiveTable.getById([InventoryID]);
    if (data.length != 0) {
      obj = InventoryReceiveTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InventoryReceiveTable) object. If the Primary Key (InventoryID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same InventoryID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnInventoryReceiveTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO InventoryReceiveTable (InventoryID, InventoryPrice, InventoryName, InventoryQuantity, InventoryOpeningDate, InventoryOpeningTime, InventoryClosingDate, InventoryClosingTime, InventoryOpeningBalance, InventoryClosingBalance)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<InventoryReceiveTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<InventoryReceiveTable> inventoryreceivetables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in inventoryreceivetables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryReceiveTable.rawInsert(
          'INSERT OR REPLACE INTO InventoryReceiveTable (InventoryID, InventoryPrice, InventoryName, InventoryQuantity, InventoryOpeningDate, InventoryOpeningTime, InventoryClosingDate, InventoryClosingTime, InventoryOpeningBalance, InventoryClosingBalance)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            InventoryID,
            InventoryPrice,
            InventoryName,
            InventoryQuantity,
            InventoryOpeningDate,
            InventoryOpeningTime,
            InventoryClosingDate,
            InventoryClosingTime,
            InventoryOpeningBalance,
            InventoryClosingBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryReceiveTable InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryReceiveTable InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryReceiveTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryReceiveTable.rawInsert(
          'INSERT OR IGNORE INTO InventoryReceiveTable (InventoryID, InventoryPrice, InventoryName, InventoryQuantity, InventoryOpeningDate, InventoryOpeningTime, InventoryClosingDate, InventoryClosingTime, InventoryOpeningBalance, InventoryClosingBalance)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            InventoryID,
            InventoryPrice,
            InventoryName,
            InventoryQuantity,
            InventoryOpeningDate,
            InventoryOpeningTime,
            InventoryClosingDate,
            InventoryClosingTime,
            InventoryOpeningBalance,
            InventoryClosingBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryReceiveTable InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryReceiveTable InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryReceiveTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes InventoryReceiveTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete InventoryReceiveTable invoked (InventoryID=$InventoryID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInventoryReceiveTable.delete(QueryParams(
          whereString: 'InventoryID=?', whereArguments: [InventoryID]));
    } else {
      return _mnInventoryReceiveTable.updateBatch(
          QueryParams(
              whereString: 'InventoryID=?', whereArguments: [InventoryID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [InventoryReceiveTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InventoryReceiveTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryReceiveTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InventoryReceiveTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryReceiveTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InventoryID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion inventoryreceivetable

// region InventoryReceiveTableField
class InventoryReceiveTableField extends FilterBase {
  InventoryReceiveTableField(
      InventoryReceiveTableFilterBuilder inventoryreceivetableFB)
      : super(inventoryreceivetableFB);

  @override
  InventoryReceiveTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder isNull() {
    return super.isNull() as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InventoryReceiveTableFilterBuilder;
  }

  @override
  InventoryReceiveTableField get not {
    return super.not as InventoryReceiveTableField;
  }
}
// endregion InventoryReceiveTableField

// region InventoryReceiveTableFilterBuilder
class InventoryReceiveTableFilterBuilder extends ConjunctionBase {
  InventoryReceiveTableFilterBuilder(
      InventoryReceiveTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInventoryReceiveTable = obj._mnInventoryReceiveTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InventoryReceiveTableManager? _mnInventoryReceiveTable;

  /// put the sql keyword 'AND'
  @override
  InventoryReceiveTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InventoryReceiveTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InventoryReceiveTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InventoryReceiveTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InventoryReceiveTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InventoryReceiveTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InventoryReceiveTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryReceiveTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryReceiveTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryReceiveTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryReceiveTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InventoryReceiveTableField _setField(
      InventoryReceiveTableField? field, String colName, DbType dbtype) {
    return InventoryReceiveTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InventoryReceiveTableField? _InventoryID;
  InventoryReceiveTableField get InventoryID {
    return _InventoryID =
        _setField(_InventoryID, 'InventoryID', DbType.integer);
  }

  InventoryReceiveTableField? _InventoryPrice;
  InventoryReceiveTableField get InventoryPrice {
    return _InventoryPrice =
        _setField(_InventoryPrice, 'InventoryPrice', DbType.text);
  }

  InventoryReceiveTableField? _InventoryName;
  InventoryReceiveTableField get InventoryName {
    return _InventoryName =
        _setField(_InventoryName, 'InventoryName', DbType.text);
  }

  InventoryReceiveTableField? _InventoryQuantity;
  InventoryReceiveTableField get InventoryQuantity {
    return _InventoryQuantity =
        _setField(_InventoryQuantity, 'InventoryQuantity', DbType.text);
  }

  InventoryReceiveTableField? _InventoryOpeningDate;
  InventoryReceiveTableField get InventoryOpeningDate {
    return _InventoryOpeningDate =
        _setField(_InventoryOpeningDate, 'InventoryOpeningDate', DbType.text);
  }

  InventoryReceiveTableField? _InventoryOpeningTime;
  InventoryReceiveTableField get InventoryOpeningTime {
    return _InventoryOpeningTime =
        _setField(_InventoryOpeningTime, 'InventoryOpeningTime', DbType.text);
  }

  InventoryReceiveTableField? _InventoryClosingDate;
  InventoryReceiveTableField get InventoryClosingDate {
    return _InventoryClosingDate =
        _setField(_InventoryClosingDate, 'InventoryClosingDate', DbType.text);
  }

  InventoryReceiveTableField? _InventoryClosingTime;
  InventoryReceiveTableField get InventoryClosingTime {
    return _InventoryClosingTime =
        _setField(_InventoryClosingTime, 'InventoryClosingTime', DbType.text);
  }

  InventoryReceiveTableField? _InventoryOpeningBalance;
  InventoryReceiveTableField get InventoryOpeningBalance {
    return _InventoryOpeningBalance = _setField(
        _InventoryOpeningBalance, 'InventoryOpeningBalance', DbType.text);
  }

  InventoryReceiveTableField? _InventoryClosingBalance;
  InventoryReceiveTableField get InventoryClosingBalance {
    return _InventoryClosingBalance = _setField(
        _InventoryClosingBalance, 'InventoryClosingBalance', DbType.text);
  }

  /// Deletes List<InventoryReceiveTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInventoryReceiveTable!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInventoryReceiveTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InventoryID IN (SELECT InventoryID from InventoryReceiveTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInventoryReceiveTable!.updateBatch(qparams, values);
  }

  /// This method always returns [InventoryReceiveTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryReceiveTable?
  @override
  Future<InventoryReceiveTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInventoryReceiveTable!.toList(qparams);
    final data = await objFuture;
    InventoryReceiveTable? obj;
    if (data.isNotEmpty) {
      obj = InventoryReceiveTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [InventoryReceiveTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryReceiveTable?
  @override
  Future<InventoryReceiveTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        InventoryReceiveTable();
  }

  /// This method returns int. [InventoryReceiveTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? inventoryreceivetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final inventoryreceivetablesFuture =
        await _mnInventoryReceiveTable!.toList(qparams);
    final int count = inventoryreceivetablesFuture[0]['CNT'] as int;
    if (inventoryreceivetableCount != null) {
      inventoryreceivetableCount(count);
    }
    return count;
  }

  /// This method returns List<InventoryReceiveTable> [InventoryReceiveTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<InventoryReceiveTable>
  @override
  Future<List<InventoryReceiveTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InventoryReceiveTable> inventoryreceivetablesData =
        await InventoryReceiveTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return inventoryreceivetablesData;
  }

  /// This method returns Json String [InventoryReceiveTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InventoryReceiveTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InventoryReceiveTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInventoryReceiveTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InventoryReceiveTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InventoryID` FROM InventoryReceiveTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> InventoryIDData = <String>[];
    qparams.selectColumns = ['InventoryID'];
    final InventoryIDFuture = await _mnInventoryReceiveTable!.toList(qparams);

    final int count = InventoryIDFuture.length;
    for (int i = 0; i < count; i++) {
      InventoryIDData.add(InventoryIDFuture[i]['InventoryID'] as String);
    }
    return InventoryIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InventoryReceiveTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInventoryReceiveTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await InventoryReceiveTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInventoryReceiveTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InventoryReceiveTableFilterBuilder

// region InventoryReceiveTableFields
class InventoryReceiveTableFields {
  static TableField? _fInventoryID;
  static TableField get InventoryID {
    return _fInventoryID = _fInventoryID ??
        SqlSyntax.setField(_fInventoryID, 'inventoryid', DbType.integer);
  }

  static TableField? _fInventoryPrice;
  static TableField get InventoryPrice {
    return _fInventoryPrice = _fInventoryPrice ??
        SqlSyntax.setField(_fInventoryPrice, 'InventoryPrice', DbType.text);
  }

  static TableField? _fInventoryName;
  static TableField get InventoryName {
    return _fInventoryName = _fInventoryName ??
        SqlSyntax.setField(_fInventoryName, 'InventoryName', DbType.text);
  }

  static TableField? _fInventoryQuantity;
  static TableField get InventoryQuantity {
    return _fInventoryQuantity = _fInventoryQuantity ??
        SqlSyntax.setField(
            _fInventoryQuantity, 'InventoryQuantity', DbType.text);
  }

  static TableField? _fInventoryOpeningDate;
  static TableField get InventoryOpeningDate {
    return _fInventoryOpeningDate = _fInventoryOpeningDate ??
        SqlSyntax.setField(
            _fInventoryOpeningDate, 'InventoryOpeningDate', DbType.text);
  }

  static TableField? _fInventoryOpeningTime;
  static TableField get InventoryOpeningTime {
    return _fInventoryOpeningTime = _fInventoryOpeningTime ??
        SqlSyntax.setField(
            _fInventoryOpeningTime, 'InventoryOpeningTime', DbType.text);
  }

  static TableField? _fInventoryClosingDate;
  static TableField get InventoryClosingDate {
    return _fInventoryClosingDate = _fInventoryClosingDate ??
        SqlSyntax.setField(
            _fInventoryClosingDate, 'InventoryClosingDate', DbType.text);
  }

  static TableField? _fInventoryClosingTime;
  static TableField get InventoryClosingTime {
    return _fInventoryClosingTime = _fInventoryClosingTime ??
        SqlSyntax.setField(
            _fInventoryClosingTime, 'InventoryClosingTime', DbType.text);
  }

  static TableField? _fInventoryOpeningBalance;
  static TableField get InventoryOpeningBalance {
    return _fInventoryOpeningBalance = _fInventoryOpeningBalance ??
        SqlSyntax.setField(
            _fInventoryOpeningBalance, 'InventoryOpeningBalance', DbType.text);
  }

  static TableField? _fInventoryClosingBalance;
  static TableField get InventoryClosingBalance {
    return _fInventoryClosingBalance = _fInventoryClosingBalance ??
        SqlSyntax.setField(
            _fInventoryClosingBalance, 'InventoryClosingBalance', DbType.text);
  }
}
// endregion InventoryReceiveTableFields

//region InventoryReceiveTableManager
class InventoryReceiveTableManager extends SqfEntityProvider {
  InventoryReceiveTableManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'InventoryReceiveTable';
  static const List<String> _primaryKeyList = ['InventoryID'];
  static const String _whereStr = 'InventoryID=?';
}

//endregion InventoryReceiveTableManager
// region CashReceiveTable
class CashReceiveTable extends TableBase {
  CashReceiveTable(
      {this.CashID,
      this.CashOpeningDate,
      this.CashOpeningTime,
      this.CashOpeningBalance,
      this.CashClosingDate,
      this.CashClosingTime,
      this.CashClosingBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CashReceiveTable.withFields(
      this.CashID,
      this.CashOpeningDate,
      this.CashOpeningTime,
      this.CashOpeningBalance,
      this.CashClosingDate,
      this.CashClosingTime,
      this.CashClosingBalance) {
    _setDefaultValues();
  }
  CashReceiveTable.withId(
      this.CashID,
      this.CashOpeningDate,
      this.CashOpeningTime,
      this.CashOpeningBalance,
      this.CashClosingDate,
      this.CashClosingTime,
      this.CashClosingBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CashReceiveTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CashID = o['CashID'].toString();
    if (o['CashOpeningDate'] != null) {
      CashOpeningDate = o['CashOpeningDate'].toString();
    }
    if (o['CashOpeningTime'] != null) {
      CashOpeningTime = o['CashOpeningTime'].toString();
    }
    if (o['CashOpeningBalance'] != null) {
      CashOpeningBalance = o['CashOpeningBalance'].toString();
    }
    if (o['CashClosingDate'] != null) {
      CashClosingDate = o['CashClosingDate'].toString();
    }
    if (o['CashClosingTime'] != null) {
      CashClosingTime = o['CashClosingTime'].toString();
    }
    if (o['CashClosingBalance'] != null) {
      CashClosingBalance = o['CashClosingBalance'].toString();
    }

    isSaved = true;
  }
  // FIELDS (CashReceiveTable)
  String? CashID;
  String? CashOpeningDate;
  String? CashOpeningTime;
  String? CashOpeningBalance;
  String? CashClosingDate;
  String? CashClosingTime;
  String? CashClosingBalance;
  bool? isSaved;
  // end FIELDS (CashReceiveTable)

  static const bool _softDeleteActivated = false;
  CashReceiveTableManager? __mnCashReceiveTable;

  CashReceiveTableManager get _mnCashReceiveTable {
    return __mnCashReceiveTable =
        __mnCashReceiveTable ?? CashReceiveTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['CashID'] = CashID;
    if (CashOpeningDate != null || !forView) {
      map['CashOpeningDate'] = CashOpeningDate;
    }
    if (CashOpeningTime != null || !forView) {
      map['CashOpeningTime'] = CashOpeningTime;
    }
    if (CashOpeningBalance != null || !forView) {
      map['CashOpeningBalance'] = CashOpeningBalance;
    }
    if (CashClosingDate != null || !forView) {
      map['CashClosingDate'] = CashClosingDate;
    }
    if (CashClosingTime != null || !forView) {
      map['CashClosingTime'] = CashClosingTime;
    }
    if (CashClosingBalance != null || !forView) {
      map['CashClosingBalance'] = CashClosingBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['CashID'] = CashID;
    if (CashOpeningDate != null || !forView) {
      map['CashOpeningDate'] = CashOpeningDate;
    }
    if (CashOpeningTime != null || !forView) {
      map['CashOpeningTime'] = CashOpeningTime;
    }
    if (CashOpeningBalance != null || !forView) {
      map['CashOpeningBalance'] = CashOpeningBalance;
    }
    if (CashClosingDate != null || !forView) {
      map['CashClosingDate'] = CashClosingDate;
    }
    if (CashClosingTime != null || !forView) {
      map['CashClosingTime'] = CashClosingTime;
    }
    if (CashClosingBalance != null || !forView) {
      map['CashClosingBalance'] = CashClosingBalance;
    }

    return map;
  }

  /// This method returns Json String [CashReceiveTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CashReceiveTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      CashID,
      CashOpeningDate,
      CashOpeningTime,
      CashOpeningBalance,
      CashClosingDate,
      CashClosingTime,
      CashClosingBalance
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      CashID,
      CashOpeningDate,
      CashOpeningTime,
      CashOpeningBalance,
      CashClosingDate,
      CashClosingTime,
      CashClosingBalance
    ];
  }

  static Future<List<CashReceiveTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashReceiveTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CashReceiveTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CashReceiveTable>[];
    try {
      objList = list
          .map((cashreceivetable) => CashReceiveTable.fromMap(
              cashreceivetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashReceiveTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CashReceiveTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CashReceiveTable> objList = <CashReceiveTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CashReceiveTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CashReceiveTable by ID if exist, otherwise returns null
  /// Primary Keys: String? CashID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CashReceiveTable] if exist, otherwise returns null
  Future<CashReceiveTable?> getById(String? CashID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (CashID == null) {
      return null;
    }
    CashReceiveTable? obj;
    final data = await _mnCashReceiveTable.getById([CashID]);
    if (data.length != 0) {
      obj = CashReceiveTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CashReceiveTable) object. If the Primary Key (CashID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same CashID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashReceiveTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO CashReceiveTable (CashID, CashOpeningDate, CashOpeningTime, CashOpeningBalance, CashClosingDate, CashClosingTime, CashClosingBalance)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<CashReceiveTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CashReceiveTable> cashreceivetables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in cashreceivetables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashReceiveTable.rawInsert(
          'INSERT OR REPLACE INTO CashReceiveTable (CashID, CashOpeningDate, CashOpeningTime, CashOpeningBalance, CashClosingDate, CashClosingTime, CashClosingBalance)  VALUES (?,?,?,?,?,?,?)',
          [
            CashID,
            CashOpeningDate,
            CashOpeningTime,
            CashOpeningBalance,
            CashClosingDate,
            CashClosingTime,
            CashClosingBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CashReceiveTable CashID=$CashID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashReceiveTable CashID=$CashID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashReceiveTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashReceiveTable.rawInsert(
          'INSERT OR IGNORE INTO CashReceiveTable (CashID, CashOpeningDate, CashOpeningTime, CashOpeningBalance, CashClosingDate, CashClosingTime, CashClosingBalance)  VALUES (?,?,?,?,?,?,?)',
          [
            CashID,
            CashOpeningDate,
            CashOpeningTime,
            CashOpeningBalance,
            CashClosingDate,
            CashClosingTime,
            CashClosingBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CashReceiveTable CashID=$CashID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashReceiveTable CashID=$CashID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashReceiveTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes CashReceiveTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CashReceiveTable invoked (CashID=$CashID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCashReceiveTable.delete(
          QueryParams(whereString: 'CashID=?', whereArguments: [CashID]));
    } else {
      return _mnCashReceiveTable.updateBatch(
          QueryParams(whereString: 'CashID=?', whereArguments: [CashID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CashReceiveTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CashReceiveTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashReceiveTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CashReceiveTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashReceiveTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      CashID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cashreceivetable

// region CashReceiveTableField
class CashReceiveTableField extends FilterBase {
  CashReceiveTableField(CashReceiveTableFilterBuilder cashreceivetableFB)
      : super(cashreceivetableFB);

  @override
  CashReceiveTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder isNull() {
    return super.isNull() as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CashReceiveTableFilterBuilder;
  }

  @override
  CashReceiveTableField get not {
    return super.not as CashReceiveTableField;
  }
}
// endregion CashReceiveTableField

// region CashReceiveTableFilterBuilder
class CashReceiveTableFilterBuilder extends ConjunctionBase {
  CashReceiveTableFilterBuilder(CashReceiveTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCashReceiveTable = obj._mnCashReceiveTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CashReceiveTableManager? _mnCashReceiveTable;

  /// put the sql keyword 'AND'
  @override
  CashReceiveTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CashReceiveTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CashReceiveTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CashReceiveTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CashReceiveTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CashReceiveTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CashReceiveTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashReceiveTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashReceiveTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashReceiveTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashReceiveTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CashReceiveTableField _setField(
      CashReceiveTableField? field, String colName, DbType dbtype) {
    return CashReceiveTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CashReceiveTableField? _CashID;
  CashReceiveTableField get CashID {
    return _CashID = _setField(_CashID, 'CashID', DbType.integer);
  }

  CashReceiveTableField? _CashOpeningDate;
  CashReceiveTableField get CashOpeningDate {
    return _CashOpeningDate =
        _setField(_CashOpeningDate, 'CashOpeningDate', DbType.text);
  }

  CashReceiveTableField? _CashOpeningTime;
  CashReceiveTableField get CashOpeningTime {
    return _CashOpeningTime =
        _setField(_CashOpeningTime, 'CashOpeningTime', DbType.text);
  }

  CashReceiveTableField? _CashOpeningBalance;
  CashReceiveTableField get CashOpeningBalance {
    return _CashOpeningBalance =
        _setField(_CashOpeningBalance, 'CashOpeningBalance', DbType.text);
  }

  CashReceiveTableField? _CashClosingDate;
  CashReceiveTableField get CashClosingDate {
    return _CashClosingDate =
        _setField(_CashClosingDate, 'CashClosingDate', DbType.text);
  }

  CashReceiveTableField? _CashClosingTime;
  CashReceiveTableField get CashClosingTime {
    return _CashClosingTime =
        _setField(_CashClosingTime, 'CashClosingTime', DbType.text);
  }

  CashReceiveTableField? _CashClosingBalance;
  CashReceiveTableField get CashClosingBalance {
    return _CashClosingBalance =
        _setField(_CashClosingBalance, 'CashClosingBalance', DbType.text);
  }

  /// Deletes List<CashReceiveTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCashReceiveTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCashReceiveTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'CashID IN (SELECT CashID from CashReceiveTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCashReceiveTable!.updateBatch(qparams, values);
  }

  /// This method always returns [CashReceiveTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashReceiveTable?
  @override
  Future<CashReceiveTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCashReceiveTable!.toList(qparams);
    final data = await objFuture;
    CashReceiveTable? obj;
    if (data.isNotEmpty) {
      obj = CashReceiveTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CashReceiveTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashReceiveTable?
  @override
  Future<CashReceiveTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CashReceiveTable();
  }

  /// This method returns int. [CashReceiveTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cashreceivetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cashreceivetablesFuture = await _mnCashReceiveTable!.toList(qparams);
    final int count = cashreceivetablesFuture[0]['CNT'] as int;
    if (cashreceivetableCount != null) {
      cashreceivetableCount(count);
    }
    return count;
  }

  /// This method returns List<CashReceiveTable> [CashReceiveTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CashReceiveTable>
  @override
  Future<List<CashReceiveTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CashReceiveTable> cashreceivetablesData =
        await CashReceiveTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cashreceivetablesData;
  }

  /// This method returns Json String [CashReceiveTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CashReceiveTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CashReceiveTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCashReceiveTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CashReceiveTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CashID` FROM CashReceiveTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> CashIDData = <String>[];
    qparams.selectColumns = ['CashID'];
    final CashIDFuture = await _mnCashReceiveTable!.toList(qparams);

    final int count = CashIDFuture.length;
    for (int i = 0; i < count; i++) {
      CashIDData.add(CashIDFuture[i]['CashID'] as String);
    }
    return CashIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CashReceiveTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCashReceiveTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CashReceiveTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCashReceiveTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CashReceiveTableFilterBuilder

// region CashReceiveTableFields
class CashReceiveTableFields {
  static TableField? _fCashID;
  static TableField get CashID {
    return _fCashID =
        _fCashID ?? SqlSyntax.setField(_fCashID, 'cashid', DbType.integer);
  }

  static TableField? _fCashOpeningDate;
  static TableField get CashOpeningDate {
    return _fCashOpeningDate = _fCashOpeningDate ??
        SqlSyntax.setField(_fCashOpeningDate, 'CashOpeningDate', DbType.text);
  }

  static TableField? _fCashOpeningTime;
  static TableField get CashOpeningTime {
    return _fCashOpeningTime = _fCashOpeningTime ??
        SqlSyntax.setField(_fCashOpeningTime, 'CashOpeningTime', DbType.text);
  }

  static TableField? _fCashOpeningBalance;
  static TableField get CashOpeningBalance {
    return _fCashOpeningBalance = _fCashOpeningBalance ??
        SqlSyntax.setField(
            _fCashOpeningBalance, 'CashOpeningBalance', DbType.text);
  }

  static TableField? _fCashClosingDate;
  static TableField get CashClosingDate {
    return _fCashClosingDate = _fCashClosingDate ??
        SqlSyntax.setField(_fCashClosingDate, 'CashClosingDate', DbType.text);
  }

  static TableField? _fCashClosingTime;
  static TableField get CashClosingTime {
    return _fCashClosingTime = _fCashClosingTime ??
        SqlSyntax.setField(_fCashClosingTime, 'CashClosingTime', DbType.text);
  }

  static TableField? _fCashClosingBalance;
  static TableField get CashClosingBalance {
    return _fCashClosingBalance = _fCashClosingBalance ??
        SqlSyntax.setField(
            _fCashClosingBalance, 'CashClosingBalance', DbType.text);
  }
}
// endregion CashReceiveTableFields

//region CashReceiveTableManager
class CashReceiveTableManager extends SqfEntityProvider {
  CashReceiveTableManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CashReceiveTable';
  static const List<String> _primaryKeyList = ['CashID'];
  static const String _whereStr = 'CashID=?';
}

//endregion CashReceiveTableManager
// region FileSyncDetail
class FileSyncDetail extends TableBase {
  FileSyncDetail(
      {this.ClientTransactionId,
      this.FileName,
      this.FilePath,
      this.ServiceText,
      this.Status,
      this.UpdatedAt,
      this.Processed}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  FileSyncDetail.withFields(this.FileName, this.FilePath, this.ServiceText,
      this.Status, this.UpdatedAt, this.Processed) {
    _setDefaultValues();
  }
  FileSyncDetail.withId(this.ClientTransactionId, this.FileName, this.FilePath,
      this.ServiceText, this.Status, this.UpdatedAt, this.Processed) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FileSyncDetail.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ClientTransactionId = int.tryParse(o['ClientTransactionId'].toString());
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FilePath'] != null) {
      FilePath = o['FilePath'].toString();
    }
    if (o['ServiceText'] != null) {
      ServiceText = o['ServiceText'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['UpdatedAt'] != null) {
      UpdatedAt = o['UpdatedAt'].toString();
    }
    if (o['Processed'] != null) {
      Processed = o['Processed'].toString();
    }
  }
  // FIELDS (FileSyncDetail)
  int? ClientTransactionId;
  String? FileName;
  String? FilePath;
  String? ServiceText;
  String? Status;
  String? UpdatedAt;
  String? Processed;

  // end FIELDS (FileSyncDetail)

  static const bool _softDeleteActivated = false;
  FileSyncDetailManager? __mnFileSyncDetail;

  FileSyncDetailManager get _mnFileSyncDetail {
    return __mnFileSyncDetail = __mnFileSyncDetail ?? FileSyncDetailManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ClientTransactionId'] = ClientTransactionId;
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FilePath != null || !forView) {
      map['FilePath'] = FilePath;
    }
    if (ServiceText != null || !forView) {
      map['ServiceText'] = ServiceText;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (UpdatedAt != null || !forView) {
      map['UpdatedAt'] = UpdatedAt;
    }
    if (Processed != null || !forView) {
      map['Processed'] = Processed;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ClientTransactionId'] = ClientTransactionId;
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FilePath != null || !forView) {
      map['FilePath'] = FilePath;
    }
    if (ServiceText != null || !forView) {
      map['ServiceText'] = ServiceText;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (UpdatedAt != null || !forView) {
      map['UpdatedAt'] = UpdatedAt;
    }
    if (Processed != null || !forView) {
      map['Processed'] = Processed;
    }

    return map;
  }

  /// This method returns Json String [FileSyncDetail]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FileSyncDetail]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [FileName, FilePath, ServiceText, Status, UpdatedAt, Processed];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ClientTransactionId,
      FileName,
      FilePath,
      ServiceText,
      Status,
      UpdatedAt,
      Processed
    ];
  }

  static Future<List<FileSyncDetail>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FileSyncDetail.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FileSyncDetail>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FileSyncDetail>[];
    try {
      objList = list
          .map((filesyncdetail) =>
              FileSyncDetail.fromMap(filesyncdetail as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FileSyncDetail.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FileSyncDetail>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FileSyncDetail> objList = <FileSyncDetail>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FileSyncDetail.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns FileSyncDetail by ID if exist, otherwise returns null
  /// Primary Keys: int? ClientTransactionId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [FileSyncDetail] if exist, otherwise returns null
  Future<FileSyncDetail?> getById(int? ClientTransactionId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ClientTransactionId == null) {
      return null;
    }
    FileSyncDetail? obj;
    final data = await _mnFileSyncDetail.getById([ClientTransactionId]);
    if (data.length != 0) {
      obj = FileSyncDetail.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FileSyncDetail) object. If the ClientTransactionId field is null, saves as a new record and returns new ClientTransactionId, if ClientTransactionId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns ClientTransactionId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (ClientTransactionId == null || ClientTransactionId == 0) {
      ClientTransactionId = await _mnFileSyncDetail.insert(this, ignoreBatch);
    } else {
      await _mnFileSyncDetail.update(this);
    }

    return ClientTransactionId;
  }

  /// Saves the (FileSyncDetail) object. If the ClientTransactionId field is null, saves as a new record and returns new ClientTransactionId, if ClientTransactionId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns ClientTransactionId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (ClientTransactionId == null || ClientTransactionId == 0) {
      ClientTransactionId =
          await _mnFileSyncDetail.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // ClientTransactionId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnFileSyncDetail.updateOrThrow(this);
    }

    return ClientTransactionId;
  }

  /// saveAs FileSyncDetail. Returns a new Primary Key value of FileSyncDetail

  /// <returns>Returns a new Primary Key value of FileSyncDetail
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    ClientTransactionId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<FileSyncDetail> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FileSyncDetail> filesyncdetails,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in filesyncdetails) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < filesyncdetails.length; i++) {
        if (filesyncdetails[i].ClientTransactionId == null) {
          filesyncdetails[i].ClientTransactionId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns ClientTransactionId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFileSyncDetail.rawInsert(
          'INSERT OR REPLACE INTO FileSyncDetails (ClientTransactionId, FileName, FilePath, ServiceText, Status, UpdatedAt, Processed)  VALUES (?,?,?,?,?,?,?)',
          [
            ClientTransactionId,
            FileName,
            FilePath,
            ServiceText,
            Status,
            UpdatedAt,
            Processed
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FileSyncDetail ClientTransactionId=$ClientTransactionId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FileSyncDetail ClientTransactionId=$ClientTransactionId did not update');
      }
      return ClientTransactionId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FileSyncDetail Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns ClientTransactionId
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFileSyncDetail.rawInsert(
          'INSERT OR IGNORE INTO FileSyncDetails (ClientTransactionId, FileName, FilePath, ServiceText, Status, UpdatedAt, Processed)  VALUES (?,?,?,?,?,?,?)',
          [
            ClientTransactionId,
            FileName,
            FilePath,
            ServiceText,
            Status,
            UpdatedAt,
            Processed
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FileSyncDetail ClientTransactionId=$ClientTransactionId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FileSyncDetail ClientTransactionId=$ClientTransactionId did not update');
      }
      return ClientTransactionId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FileSyncDetail Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<FileSyncDetail>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<FileSyncDetail> filesyncdetails,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnFileSyncDetail.rawInsertAll(
        'INSERT OR REPLACE INTO FileSyncDetails (ClientTransactionId, FileName, FilePath, ServiceText, Status, UpdatedAt, Processed)  VALUES (?,?,?,?,?,?,?)',
        filesyncdetails,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes FileSyncDetail

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete FileSyncDetail invoked (ClientTransactionId=$ClientTransactionId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnFileSyncDetail.delete(QueryParams(
          whereString: 'ClientTransactionId=?',
          whereArguments: [ClientTransactionId]));
    } else {
      return _mnFileSyncDetail.updateBatch(
          QueryParams(
              whereString: 'ClientTransactionId=?',
              whereArguments: [ClientTransactionId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [FileSyncDetail] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  FileSyncDetailFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FileSyncDetailFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  FileSyncDetailFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FileSyncDetailFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ClientTransactionId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion filesyncdetail

// region FileSyncDetailField
class FileSyncDetailField extends FilterBase {
  FileSyncDetailField(FileSyncDetailFilterBuilder filesyncdetailFB)
      : super(filesyncdetailFB);

  @override
  FileSyncDetailFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder isNull() {
    return super.isNull() as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as FileSyncDetailFilterBuilder;
  }

  @override
  FileSyncDetailField get not {
    return super.not as FileSyncDetailField;
  }
}
// endregion FileSyncDetailField

// region FileSyncDetailFilterBuilder
class FileSyncDetailFilterBuilder extends ConjunctionBase {
  FileSyncDetailFilterBuilder(FileSyncDetail obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnFileSyncDetail = obj._mnFileSyncDetail;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  FileSyncDetailManager? _mnFileSyncDetail;

  /// put the sql keyword 'AND'
  @override
  FileSyncDetailFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  FileSyncDetailFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  FileSyncDetailFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  FileSyncDetailFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  FileSyncDetailFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  FileSyncDetailFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  FileSyncDetailFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FileSyncDetailFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FileSyncDetailFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FileSyncDetailFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FileSyncDetailFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  FileSyncDetailField _setField(
      FileSyncDetailField? field, String colName, DbType dbtype) {
    return FileSyncDetailField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  FileSyncDetailField? _ClientTransactionId;
  FileSyncDetailField get ClientTransactionId {
    return _ClientTransactionId =
        _setField(_ClientTransactionId, 'ClientTransactionId', DbType.integer);
  }

  FileSyncDetailField? _FileName;
  FileSyncDetailField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  FileSyncDetailField? _FilePath;
  FileSyncDetailField get FilePath {
    return _FilePath = _setField(_FilePath, 'FilePath', DbType.text);
  }

  FileSyncDetailField? _ServiceText;
  FileSyncDetailField get ServiceText {
    return _ServiceText = _setField(_ServiceText, 'ServiceText', DbType.text);
  }

  FileSyncDetailField? _Status;
  FileSyncDetailField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  FileSyncDetailField? _UpdatedAt;
  FileSyncDetailField get UpdatedAt {
    return _UpdatedAt = _setField(_UpdatedAt, 'UpdatedAt', DbType.text);
  }

  FileSyncDetailField? _Processed;
  FileSyncDetailField get Processed {
    return _Processed = _setField(_Processed, 'Processed', DbType.text);
  }

  /// Deletes List<FileSyncDetail> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnFileSyncDetail!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnFileSyncDetail!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ClientTransactionId IN (SELECT ClientTransactionId from FileSyncDetails ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnFileSyncDetail!.updateBatch(qparams, values);
  }

  /// This method always returns [FileSyncDetail] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FileSyncDetail?
  @override
  Future<FileSyncDetail?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnFileSyncDetail!.toList(qparams);
    final data = await objFuture;
    FileSyncDetail? obj;
    if (data.isNotEmpty) {
      obj = FileSyncDetail.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FileSyncDetail]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FileSyncDetail?
  @override
  Future<FileSyncDetail> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FileSyncDetail();
  }

  /// This method returns int. [FileSyncDetail]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? filesyncdetailCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final filesyncdetailsFuture = await _mnFileSyncDetail!.toList(qparams);
    final int count = filesyncdetailsFuture[0]['CNT'] as int;
    if (filesyncdetailCount != null) {
      filesyncdetailCount(count);
    }
    return count;
  }

  /// This method returns List<FileSyncDetail> [FileSyncDetail]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<FileSyncDetail>
  @override
  Future<List<FileSyncDetail>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FileSyncDetail> filesyncdetailsData =
        await FileSyncDetail.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return filesyncdetailsData;
  }

  /// This method returns Json String [FileSyncDetail]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FileSyncDetail]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FileSyncDetail]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnFileSyncDetail!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FileSyncDetail]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ClientTransactionId` FROM FileSyncDetails WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> ClientTransactionIdData = <int>[];
    qparams.selectColumns = ['ClientTransactionId'];
    final ClientTransactionIdFuture = await _mnFileSyncDetail!.toList(qparams);

    final int count = ClientTransactionIdFuture.length;
    for (int i = 0; i < count; i++) {
      ClientTransactionIdData.add(
          ClientTransactionIdFuture[i]['ClientTransactionId'] as int);
    }
    return ClientTransactionIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FileSyncDetail]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnFileSyncDetail!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await FileSyncDetail.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnFileSyncDetail!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FileSyncDetailFilterBuilder

// region FileSyncDetailFields
class FileSyncDetailFields {
  static TableField? _fClientTransactionId;
  static TableField get ClientTransactionId {
    return _fClientTransactionId = _fClientTransactionId ??
        SqlSyntax.setField(
            _fClientTransactionId, 'clienttransactionid', DbType.integer);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFilePath;
  static TableField get FilePath {
    return _fFilePath =
        _fFilePath ?? SqlSyntax.setField(_fFilePath, 'FilePath', DbType.text);
  }

  static TableField? _fServiceText;
  static TableField get ServiceText {
    return _fServiceText = _fServiceText ??
        SqlSyntax.setField(_fServiceText, 'ServiceText', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fUpdatedAt;
  static TableField get UpdatedAt {
    return _fUpdatedAt = _fUpdatedAt ??
        SqlSyntax.setField(_fUpdatedAt, 'UpdatedAt', DbType.text);
  }

  static TableField? _fProcessed;
  static TableField get Processed {
    return _fProcessed = _fProcessed ??
        SqlSyntax.setField(_fProcessed, 'Processed', DbType.text);
  }
}
// endregion FileSyncDetailFields

//region FileSyncDetailManager
class FileSyncDetailManager extends SqfEntityProvider {
  FileSyncDetailManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'FileSyncDetails';
  static const List<String> _primaryKeyList = ['ClientTransactionId'];
  static const String _whereStr = 'ClientTransactionId=?';
}

//endregion FileSyncDetailManager
// region CashTableBackup
class CashTableBackup extends TableBase {
  CashTableBackup(
      {this.Sl,
      this.Cash_ID,
      this.Cash_Amount,
      this.Cash_Description,
      this.Cash_Type,
      this.Cash_Date,
      this.Cash_Time}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CashTableBackup.withFields(this.Cash_ID, this.Cash_Amount,
      this.Cash_Description, this.Cash_Type, this.Cash_Date, this.Cash_Time) {
    _setDefaultValues();
  }
  CashTableBackup.withId(this.Sl, this.Cash_ID, this.Cash_Amount,
      this.Cash_Description, this.Cash_Type, this.Cash_Date, this.Cash_Time) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CashTableBackup.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['Cash_ID'] != null) {
      Cash_ID = o['Cash_ID'].toString();
    }
    if (o['Cash_Amount'] != null) {
      Cash_Amount = double.tryParse(o['Cash_Amount'].toString());
    }
    if (o['Cash_Description'] != null) {
      Cash_Description = o['Cash_Description'].toString();
    }
    if (o['Cash_Type'] != null) {
      Cash_Type = o['Cash_Type'].toString();
    }
    if (o['Cash_Date'] != null) {
      Cash_Date = o['Cash_Date'].toString();
    }
    if (o['Cash_Time'] != null) {
      Cash_Time = o['Cash_Time'].toString();
    }
  }
  // FIELDS (CashTableBackup)
  int? Sl;
  String? Cash_ID;
  double? Cash_Amount;
  String? Cash_Description;
  String? Cash_Type;
  String? Cash_Date;
  String? Cash_Time;

  // end FIELDS (CashTableBackup)

  static const bool _softDeleteActivated = false;
  CashTableBackupManager? __mnCashTableBackup;

  CashTableBackupManager get _mnCashTableBackup {
    return __mnCashTableBackup =
        __mnCashTableBackup ?? CashTableBackupManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (Cash_ID != null || !forView) {
      map['Cash_ID'] = Cash_ID;
    }
    if (Cash_Amount != null || !forView) {
      map['Cash_Amount'] = Cash_Amount;
    }
    if (Cash_Description != null || !forView) {
      map['Cash_Description'] = Cash_Description;
    }
    if (Cash_Type != null || !forView) {
      map['Cash_Type'] = Cash_Type;
    }
    if (Cash_Date != null || !forView) {
      map['Cash_Date'] = Cash_Date;
    }
    if (Cash_Time != null || !forView) {
      map['Cash_Time'] = Cash_Time;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (Cash_ID != null || !forView) {
      map['Cash_ID'] = Cash_ID;
    }
    if (Cash_Amount != null || !forView) {
      map['Cash_Amount'] = Cash_Amount;
    }
    if (Cash_Description != null || !forView) {
      map['Cash_Description'] = Cash_Description;
    }
    if (Cash_Type != null || !forView) {
      map['Cash_Type'] = Cash_Type;
    }
    if (Cash_Date != null || !forView) {
      map['Cash_Date'] = Cash_Date;
    }
    if (Cash_Time != null || !forView) {
      map['Cash_Time'] = Cash_Time;
    }

    return map;
  }

  /// This method returns Json String [CashTableBackup]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CashTableBackup]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Cash_ID,
      Cash_Amount,
      Cash_Description,
      Cash_Type,
      Cash_Date,
      Cash_Time
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      Cash_ID,
      Cash_Amount,
      Cash_Description,
      Cash_Type,
      Cash_Date,
      Cash_Time
    ];
  }

  static Future<List<CashTableBackup>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashTableBackup.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CashTableBackup>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CashTableBackup>[];
    try {
      objList = list
          .map((cashtablebackup) =>
              CashTableBackup.fromMap(cashtablebackup as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashTableBackup.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CashTableBackup>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CashTableBackup> objList = <CashTableBackup>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CashTableBackup.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CashTableBackup by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? Cash_Date, String? Cash_Time
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CashTableBackup] if exist, otherwise returns null
  Future<CashTableBackup?> getById(
      int? Sl, String? Cash_Date, String? Cash_Time,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    CashTableBackup? obj;
    final data = await _mnCashTableBackup.getById([Sl, Cash_Date, Cash_Time]);
    if (data.length != 0) {
      obj = CashTableBackup.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CashTableBackup) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashTableBackup.rawInsert(
          'INSERT OR REPLACE INTO CashTableBackup (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs CashTableBackup
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashTableBackup.rawInsert(
          'INSERT INTO CashTableBackup ( Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?)',
          [
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<CashTableBackup> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CashTableBackup> cashtablebackups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in cashtablebackups) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < cashtablebackups.length; i++) {
        if (cashtablebackups[i].Sl == null) {
          cashtablebackups[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashTableBackup.rawInsert(
          'INSERT OR REPLACE INTO CashTableBackup (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashTableBackup Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashTableBackup Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashTableBackup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashTableBackup.rawInsert(
          'INSERT OR IGNORE INTO CashTableBackup (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashTableBackup Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashTableBackup Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashTableBackup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CashTableBackup>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<CashTableBackup> cashtablebackups,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCashTableBackup.rawInsertAll(
        'INSERT OR REPLACE INTO CashTableBackup (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
        cashtablebackups,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CashTableBackup

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CashTableBackup invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCashTableBackup.delete(QueryParams(
          whereString: 'Sl=? AND Cash_Date=? AND Cash_Time=?',
          whereArguments: [Sl, Cash_Date, Cash_Time]));
    } else {
      return _mnCashTableBackup.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND Cash_Date=? AND Cash_Time=?',
              whereArguments: [Sl, Cash_Date, Cash_Time]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CashTableBackup] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CashTableBackupFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashTableBackupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CashTableBackupFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashTableBackupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      Cash_Date = null;
      Cash_Time = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cashtablebackup

// region CashTableBackupField
class CashTableBackupField extends FilterBase {
  CashTableBackupField(CashTableBackupFilterBuilder cashtablebackupFB)
      : super(cashtablebackupFB);

  @override
  CashTableBackupFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder isNull() {
    return super.isNull() as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CashTableBackupFilterBuilder;
  }

  @override
  CashTableBackupField get not {
    return super.not as CashTableBackupField;
  }
}
// endregion CashTableBackupField

// region CashTableBackupFilterBuilder
class CashTableBackupFilterBuilder extends ConjunctionBase {
  CashTableBackupFilterBuilder(CashTableBackup obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCashTableBackup = obj._mnCashTableBackup;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CashTableBackupManager? _mnCashTableBackup;

  /// put the sql keyword 'AND'
  @override
  CashTableBackupFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CashTableBackupFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CashTableBackupFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CashTableBackupFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CashTableBackupFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CashTableBackupFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CashTableBackupFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashTableBackupFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashTableBackupFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashTableBackupFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashTableBackupFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CashTableBackupField _setField(
      CashTableBackupField? field, String colName, DbType dbtype) {
    return CashTableBackupField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CashTableBackupField? _Sl;
  CashTableBackupField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  CashTableBackupField? _Cash_ID;
  CashTableBackupField get Cash_ID {
    return _Cash_ID = _setField(_Cash_ID, 'Cash_ID', DbType.text);
  }

  CashTableBackupField? _Cash_Amount;
  CashTableBackupField get Cash_Amount {
    return _Cash_Amount = _setField(_Cash_Amount, 'Cash_Amount', DbType.real);
  }

  CashTableBackupField? _Cash_Description;
  CashTableBackupField get Cash_Description {
    return _Cash_Description =
        _setField(_Cash_Description, 'Cash_Description', DbType.text);
  }

  CashTableBackupField? _Cash_Type;
  CashTableBackupField get Cash_Type {
    return _Cash_Type = _setField(_Cash_Type, 'Cash_Type', DbType.text);
  }

  CashTableBackupField? _Cash_Date;
  CashTableBackupField get Cash_Date {
    return _Cash_Date = _setField(_Cash_Date, 'Cash_Date', DbType.text);
  }

  CashTableBackupField? _Cash_Time;
  CashTableBackupField get Cash_Time {
    return _Cash_Time = _setField(_Cash_Time, 'Cash_Time', DbType.text);
  }

  /// Deletes List<CashTableBackup> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCashTableBackup!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCashTableBackup!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from CashTableBackup ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCashTableBackup!.updateBatch(qparams, values);
  }

  /// This method always returns [CashTableBackup] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashTableBackup?
  @override
  Future<CashTableBackup?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCashTableBackup!.toList(qparams);
    final data = await objFuture;
    CashTableBackup? obj;
    if (data.isNotEmpty) {
      obj = CashTableBackup.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CashTableBackup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashTableBackup?
  @override
  Future<CashTableBackup> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CashTableBackup();
  }

  /// This method returns int. [CashTableBackup]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cashtablebackupCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cashtablebackupsFuture = await _mnCashTableBackup!.toList(qparams);
    final int count = cashtablebackupsFuture[0]['CNT'] as int;
    if (cashtablebackupCount != null) {
      cashtablebackupCount(count);
    }
    return count;
  }

  /// This method returns List<CashTableBackup> [CashTableBackup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CashTableBackup>
  @override
  Future<List<CashTableBackup>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CashTableBackup> cashtablebackupsData =
        await CashTableBackup.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cashtablebackupsData;
  }

  /// This method returns Json String [CashTableBackup]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CashTableBackup]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CashTableBackup]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCashTableBackup!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CashTableBackup]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`Cash_Date`Cash_Time` FROM CashTableBackup WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,Cash_Date,Cash_Time> [CashTableBackup]
  /// <returns>List<Sl,Cash_Date,Cash_Time>
  @override
  Future<List<CashTableBackup>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'Cash_Date', 'Cash_Time'];
    final cashtablebackupFuture = await _mnCashTableBackup!.toList(qparams);
    return await CashTableBackup.fromMapList(cashtablebackupFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CashTableBackup]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCashTableBackup!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CashTableBackup.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCashTableBackup!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CashTableBackupFilterBuilder

// region CashTableBackupFields
class CashTableBackupFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fCash_ID;
  static TableField get Cash_ID {
    return _fCash_ID =
        _fCash_ID ?? SqlSyntax.setField(_fCash_ID, 'Cash_ID', DbType.text);
  }

  static TableField? _fCash_Amount;
  static TableField get Cash_Amount {
    return _fCash_Amount = _fCash_Amount ??
        SqlSyntax.setField(_fCash_Amount, 'Cash_Amount', DbType.real);
  }

  static TableField? _fCash_Description;
  static TableField get Cash_Description {
    return _fCash_Description = _fCash_Description ??
        SqlSyntax.setField(_fCash_Description, 'Cash_Description', DbType.text);
  }

  static TableField? _fCash_Type;
  static TableField get Cash_Type {
    return _fCash_Type = _fCash_Type ??
        SqlSyntax.setField(_fCash_Type, 'Cash_Type', DbType.text);
  }

  static TableField? _fCash_Date;
  static TableField get Cash_Date {
    return _fCash_Date = _fCash_Date ??
        SqlSyntax.setField(_fCash_Date, 'Cash_Date', DbType.text);
  }

  static TableField? _fCash_Time;
  static TableField get Cash_Time {
    return _fCash_Time = _fCash_Time ??
        SqlSyntax.setField(_fCash_Time, 'Cash_Time', DbType.text);
  }
}
// endregion CashTableBackupFields

//region CashTableBackupManager
class CashTableBackupManager extends SqfEntityProvider {
  CashTableBackupManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CashTableBackup';
  static const List<String> _primaryKeyList = ['Sl', 'Cash_Date', 'Cash_Time'];
  static const String _whereStr = 'Sl=? AND Cash_Date=? AND Cash_Time=?';
}

//endregion CashTableBackupManager
// region TransactionTableBackup
class TransactionTableBackup extends TableBase {
  TransactionTableBackup(
      {this.Sl,
      this.tranid,
      this.tranType,
      this.tranDescription,
      this.tranDate,
      this.tranTime,
      this.tranAmount,
      this.valuation}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TransactionTableBackup.withFields(
      this.tranid,
      this.tranType,
      this.tranDescription,
      this.tranDate,
      this.tranTime,
      this.tranAmount,
      this.valuation) {
    _setDefaultValues();
  }
  TransactionTableBackup.withId(
      this.Sl,
      this.tranid,
      this.tranType,
      this.tranDescription,
      this.tranDate,
      this.tranTime,
      this.tranAmount,
      this.valuation) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TransactionTableBackup.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['tranid'] != null) {
      tranid = o['tranid'].toString();
    }
    if (o['tranType'] != null) {
      tranType = o['tranType'].toString();
    }
    if (o['tranDescription'] != null) {
      tranDescription = o['tranDescription'].toString();
    }
    if (o['tranDate'] != null) {
      tranDate = o['tranDate'].toString();
    }
    if (o['tranTime'] != null) {
      tranTime = o['tranTime'].toString();
    }
    if (o['tranAmount'] != null) {
      tranAmount = double.tryParse(o['tranAmount'].toString());
    }
    if (o['valuation'] != null) {
      valuation = o['valuation'].toString();
    }
  }
  // FIELDS (TransactionTableBackup)
  int? Sl;
  String? tranid;
  String? tranType;
  String? tranDescription;
  String? tranDate;
  String? tranTime;
  double? tranAmount;
  String? valuation;

  // end FIELDS (TransactionTableBackup)

  static const bool _softDeleteActivated = false;
  TransactionTableBackupManager? __mnTransactionTableBackup;

  TransactionTableBackupManager get _mnTransactionTableBackup {
    return __mnTransactionTableBackup =
        __mnTransactionTableBackup ?? TransactionTableBackupManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (tranid != null || !forView) {
      map['tranid'] = tranid;
    }
    if (tranType != null || !forView) {
      map['tranType'] = tranType;
    }
    if (tranDescription != null || !forView) {
      map['tranDescription'] = tranDescription;
    }
    if (tranDate != null || !forView) {
      map['tranDate'] = tranDate;
    }
    if (tranTime != null || !forView) {
      map['tranTime'] = tranTime;
    }
    if (tranAmount != null || !forView) {
      map['tranAmount'] = tranAmount;
    }
    if (valuation != null || !forView) {
      map['valuation'] = valuation;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (tranid != null || !forView) {
      map['tranid'] = tranid;
    }
    if (tranType != null || !forView) {
      map['tranType'] = tranType;
    }
    if (tranDescription != null || !forView) {
      map['tranDescription'] = tranDescription;
    }
    if (tranDate != null || !forView) {
      map['tranDate'] = tranDate;
    }
    if (tranTime != null || !forView) {
      map['tranTime'] = tranTime;
    }
    if (tranAmount != null || !forView) {
      map['tranAmount'] = tranAmount;
    }
    if (valuation != null || !forView) {
      map['valuation'] = valuation;
    }

    return map;
  }

  /// This method returns Json String [TransactionTableBackup]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TransactionTableBackup]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      tranid,
      tranType,
      tranDescription,
      tranDate,
      tranTime,
      tranAmount,
      valuation
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      tranid,
      tranType,
      tranDescription,
      tranDate,
      tranTime,
      tranAmount,
      valuation
    ];
  }

  static Future<List<TransactionTableBackup>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TransactionTableBackup.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TransactionTableBackup>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TransactionTableBackup>[];
    try {
      objList = list
          .map((transactiontablebackup) => TransactionTableBackup.fromMap(
              transactiontablebackup as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TransactionTableBackup.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TransactionTableBackup>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TransactionTableBackup> objList = <TransactionTableBackup>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TransactionTableBackup.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TransactionTableBackup by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? tranDate, String? tranTime
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TransactionTableBackup] if exist, otherwise returns null
  Future<TransactionTableBackup?> getById(
      int? Sl, String? tranDate, String? tranTime,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    TransactionTableBackup? obj;
    final data =
        await _mnTransactionTableBackup.getById([Sl, tranDate, tranTime]);
    if (data.length != 0) {
      obj = TransactionTableBackup.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TransactionTableBackup) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTransactionTableBackup.rawInsert(
          'INSERT OR REPLACE INTO TransactionTableBackup (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs TransactionTableBackup
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTransactionTableBackup.rawInsert(
          'INSERT INTO TransactionTableBackup ( tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?)',
          [
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<TransactionTableBackup> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TransactionTableBackup> transactiontablebackups,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in transactiontablebackups) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < transactiontablebackups.length; i++) {
        if (transactiontablebackups[i].Sl == null) {
          transactiontablebackups[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTransactionTableBackup.rawInsert(
          'INSERT OR REPLACE INTO TransactionTableBackup (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TransactionTableBackup Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TransactionTableBackup Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TransactionTableBackup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTransactionTableBackup.rawInsert(
          'INSERT OR IGNORE INTO TransactionTableBackup (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TransactionTableBackup Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TransactionTableBackup Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TransactionTableBackup Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<TransactionTableBackup>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<TransactionTableBackup> transactiontablebackups,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnTransactionTableBackup.rawInsertAll(
        'INSERT OR REPLACE INTO TransactionTableBackup (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
        transactiontablebackups,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes TransactionTableBackup

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TransactionTableBackup invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTransactionTableBackup.delete(QueryParams(
          whereString: 'Sl=? AND tranDate=? AND tranTime=?',
          whereArguments: [Sl, tranDate, tranTime]));
    } else {
      return _mnTransactionTableBackup.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND tranDate=? AND tranTime=?',
              whereArguments: [Sl, tranDate, tranTime]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TransactionTableBackup] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TransactionTableBackupFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TransactionTableBackupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TransactionTableBackupFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TransactionTableBackupFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      tranDate = null;
      tranTime = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion transactiontablebackup

// region TransactionTableBackupField
class TransactionTableBackupField extends FilterBase {
  TransactionTableBackupField(
      TransactionTableBackupFilterBuilder transactiontablebackupFB)
      : super(transactiontablebackupFB);

  @override
  TransactionTableBackupFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder isNull() {
    return super.isNull() as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TransactionTableBackupFilterBuilder;
  }

  @override
  TransactionTableBackupField get not {
    return super.not as TransactionTableBackupField;
  }
}
// endregion TransactionTableBackupField

// region TransactionTableBackupFilterBuilder
class TransactionTableBackupFilterBuilder extends ConjunctionBase {
  TransactionTableBackupFilterBuilder(
      TransactionTableBackup obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTransactionTableBackup = obj._mnTransactionTableBackup;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TransactionTableBackupManager? _mnTransactionTableBackup;

  /// put the sql keyword 'AND'
  @override
  TransactionTableBackupFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TransactionTableBackupFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TransactionTableBackupFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TransactionTableBackupFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TransactionTableBackupFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TransactionTableBackupFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TransactionTableBackupFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TransactionTableBackupFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TransactionTableBackupFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TransactionTableBackupFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TransactionTableBackupFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TransactionTableBackupField _setField(
      TransactionTableBackupField? field, String colName, DbType dbtype) {
    return TransactionTableBackupField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TransactionTableBackupField? _Sl;
  TransactionTableBackupField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  TransactionTableBackupField? _tranid;
  TransactionTableBackupField get tranid {
    return _tranid = _setField(_tranid, 'tranid', DbType.text);
  }

  TransactionTableBackupField? _tranType;
  TransactionTableBackupField get tranType {
    return _tranType = _setField(_tranType, 'tranType', DbType.text);
  }

  TransactionTableBackupField? _tranDescription;
  TransactionTableBackupField get tranDescription {
    return _tranDescription =
        _setField(_tranDescription, 'tranDescription', DbType.text);
  }

  TransactionTableBackupField? _tranDate;
  TransactionTableBackupField get tranDate {
    return _tranDate = _setField(_tranDate, 'tranDate', DbType.text);
  }

  TransactionTableBackupField? _tranTime;
  TransactionTableBackupField get tranTime {
    return _tranTime = _setField(_tranTime, 'tranTime', DbType.text);
  }

  TransactionTableBackupField? _tranAmount;
  TransactionTableBackupField get tranAmount {
    return _tranAmount = _setField(_tranAmount, 'tranAmount', DbType.real);
  }

  TransactionTableBackupField? _valuation;
  TransactionTableBackupField get valuation {
    return _valuation = _setField(_valuation, 'valuation', DbType.text);
  }

  /// Deletes List<TransactionTableBackup> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTransactionTableBackup!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTransactionTableBackup!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from TransactionTableBackup ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTransactionTableBackup!.updateBatch(qparams, values);
  }

  /// This method always returns [TransactionTableBackup] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TransactionTableBackup?
  @override
  Future<TransactionTableBackup?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTransactionTableBackup!.toList(qparams);
    final data = await objFuture;
    TransactionTableBackup? obj;
    if (data.isNotEmpty) {
      obj = TransactionTableBackup.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TransactionTableBackup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TransactionTableBackup?
  @override
  Future<TransactionTableBackup> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TransactionTableBackup();
  }

  /// This method returns int. [TransactionTableBackup]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? transactiontablebackupCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final transactiontablebackupsFuture =
        await _mnTransactionTableBackup!.toList(qparams);
    final int count = transactiontablebackupsFuture[0]['CNT'] as int;
    if (transactiontablebackupCount != null) {
      transactiontablebackupCount(count);
    }
    return count;
  }

  /// This method returns List<TransactionTableBackup> [TransactionTableBackup]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TransactionTableBackup>
  @override
  Future<List<TransactionTableBackup>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TransactionTableBackup> transactiontablebackupsData =
        await TransactionTableBackup.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return transactiontablebackupsData;
  }

  /// This method returns Json String [TransactionTableBackup]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TransactionTableBackup]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TransactionTableBackup]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTransactionTableBackup!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TransactionTableBackup]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`tranDate`tranTime` FROM TransactionTableBackup WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,tranDate,tranTime> [TransactionTableBackup]
  /// <returns>List<Sl,tranDate,tranTime>
  @override
  Future<List<TransactionTableBackup>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'tranDate', 'tranTime'];
    final transactiontablebackupFuture =
        await _mnTransactionTableBackup!.toList(qparams);
    return await TransactionTableBackup.fromMapList(
        transactiontablebackupFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TransactionTableBackup]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTransactionTableBackup!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TransactionTableBackup.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTransactionTableBackup!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TransactionTableBackupFilterBuilder

// region TransactionTableBackupFields
class TransactionTableBackupFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fTranid;
  static TableField get tranid {
    return _fTranid =
        _fTranid ?? SqlSyntax.setField(_fTranid, 'tranid', DbType.text);
  }

  static TableField? _fTranType;
  static TableField get tranType {
    return _fTranType =
        _fTranType ?? SqlSyntax.setField(_fTranType, 'tranType', DbType.text);
  }

  static TableField? _fTranDescription;
  static TableField get tranDescription {
    return _fTranDescription = _fTranDescription ??
        SqlSyntax.setField(_fTranDescription, 'tranDescription', DbType.text);
  }

  static TableField? _fTranDate;
  static TableField get tranDate {
    return _fTranDate =
        _fTranDate ?? SqlSyntax.setField(_fTranDate, 'tranDate', DbType.text);
  }

  static TableField? _fTranTime;
  static TableField get tranTime {
    return _fTranTime =
        _fTranTime ?? SqlSyntax.setField(_fTranTime, 'tranTime', DbType.text);
  }

  static TableField? _fTranAmount;
  static TableField get tranAmount {
    return _fTranAmount = _fTranAmount ??
        SqlSyntax.setField(_fTranAmount, 'tranAmount', DbType.real);
  }

  static TableField? _fValuation;
  static TableField get valuation {
    return _fValuation = _fValuation ??
        SqlSyntax.setField(_fValuation, 'valuation', DbType.text);
  }
}
// endregion TransactionTableBackupFields

//region TransactionTableBackupManager
class TransactionTableBackupManager extends SqfEntityProvider {
  TransactionTableBackupManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TransactionTableBackup';
  static const List<String> _primaryKeyList = ['Sl', 'tranDate', 'tranTime'];
  static const String _whereStr = 'Sl=? AND tranDate=? AND tranTime=?';
}

//endregion TransactionTableBackupManager
// region PincodeUpdateTable
class PincodeUpdateTable extends TableBase {
  PincodeUpdateTable(
      {this.appversion, this.versiondate, this.pincodecount, this.status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  PincodeUpdateTable.withFields(
      this.appversion, this.versiondate, this.pincodecount, this.status) {
    _setDefaultValues();
  }
  PincodeUpdateTable.withId(
      this.appversion, this.versiondate, this.pincodecount, this.status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PincodeUpdateTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    appversion = o['appversion'].toString();
    if (o['versiondate'] != null) {
      versiondate = o['versiondate'].toString();
    }
    if (o['pincodecount'] != null) {
      pincodecount = o['pincodecount'].toString();
    }
    if (o['status'] != null) {
      status = o['status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (PincodeUpdateTable)
  String? appversion;
  String? versiondate;
  String? pincodecount;
  String? status;
  bool? isSaved;
  // end FIELDS (PincodeUpdateTable)

  static const bool _softDeleteActivated = false;
  PincodeUpdateTableManager? __mnPincodeUpdateTable;

  PincodeUpdateTableManager get _mnPincodeUpdateTable {
    return __mnPincodeUpdateTable =
        __mnPincodeUpdateTable ?? PincodeUpdateTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['appversion'] = appversion;
    if (versiondate != null || !forView) {
      map['versiondate'] = versiondate;
    }
    if (pincodecount != null || !forView) {
      map['pincodecount'] = pincodecount;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['appversion'] = appversion;
    if (versiondate != null || !forView) {
      map['versiondate'] = versiondate;
    }
    if (pincodecount != null || !forView) {
      map['pincodecount'] = pincodecount;
    }
    if (status != null || !forView) {
      map['status'] = status;
    }

    return map;
  }

  /// This method returns Json String [PincodeUpdateTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PincodeUpdateTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [appversion, versiondate, pincodecount, status];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [appversion, versiondate, pincodecount, status];
  }

  static Future<List<PincodeUpdateTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PincodeUpdateTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PincodeUpdateTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PincodeUpdateTable>[];
    try {
      objList = list
          .map((pincodeupdatetable) => PincodeUpdateTable.fromMap(
              pincodeupdatetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PincodeUpdateTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PincodeUpdateTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PincodeUpdateTable> objList = <PincodeUpdateTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PincodeUpdateTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns PincodeUpdateTable by ID if exist, otherwise returns null
  /// Primary Keys: String? appversion
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PincodeUpdateTable] if exist, otherwise returns null
  Future<PincodeUpdateTable?> getById(String? appversion,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (appversion == null) {
      return null;
    }
    PincodeUpdateTable? obj;
    final data = await _mnPincodeUpdateTable.getById([appversion]);
    if (data.length != 0) {
      obj = PincodeUpdateTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PincodeUpdateTable) object. If the Primary Key (appversion) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same appversion
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPincodeUpdateTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO PincodeUpdateTable (appversion, versiondate, pincodecount, status)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<PincodeUpdateTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<PincodeUpdateTable> pincodeupdatetables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ReportModel().batchStart();
    for (final obj in pincodeupdatetables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ReportModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPincodeUpdateTable.rawInsert(
          'INSERT OR REPLACE INTO PincodeUpdateTable (appversion, versiondate, pincodecount, status)  VALUES (?,?,?,?)',
          [appversion, versiondate, pincodecount, status],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PincodeUpdateTable appversion=$appversion updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'PincodeUpdateTable appversion=$appversion did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'PincodeUpdateTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPincodeUpdateTable.rawInsert(
          'INSERT OR IGNORE INTO PincodeUpdateTable (appversion, versiondate, pincodecount, status)  VALUES (?,?,?,?)',
          [appversion, versiondate, pincodecount, status],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PincodeUpdateTable appversion=$appversion updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'PincodeUpdateTable appversion=$appversion did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'PincodeUpdateTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes PincodeUpdateTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete PincodeUpdateTable invoked (appversion=$appversion)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPincodeUpdateTable.delete(QueryParams(
          whereString: 'appversion=?', whereArguments: [appversion]));
    } else {
      return _mnPincodeUpdateTable.updateBatch(
          QueryParams(
              whereString: 'appversion=?', whereArguments: [appversion]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [PincodeUpdateTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PincodeUpdateTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PincodeUpdateTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PincodeUpdateTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PincodeUpdateTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    status = status ?? 'N';
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      appversion = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion pincodeupdatetable

// region PincodeUpdateTableField
class PincodeUpdateTableField extends FilterBase {
  PincodeUpdateTableField(PincodeUpdateTableFilterBuilder pincodeupdatetableFB)
      : super(pincodeupdatetableFB);

  @override
  PincodeUpdateTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder isNull() {
    return super.isNull() as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PincodeUpdateTableFilterBuilder;
  }

  @override
  PincodeUpdateTableField get not {
    return super.not as PincodeUpdateTableField;
  }
}
// endregion PincodeUpdateTableField

// region PincodeUpdateTableFilterBuilder
class PincodeUpdateTableFilterBuilder extends ConjunctionBase {
  PincodeUpdateTableFilterBuilder(PincodeUpdateTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPincodeUpdateTable = obj._mnPincodeUpdateTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PincodeUpdateTableManager? _mnPincodeUpdateTable;

  /// put the sql keyword 'AND'
  @override
  PincodeUpdateTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PincodeUpdateTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PincodeUpdateTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PincodeUpdateTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PincodeUpdateTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PincodeUpdateTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PincodeUpdateTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PincodeUpdateTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PincodeUpdateTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PincodeUpdateTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PincodeUpdateTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PincodeUpdateTableField _setField(
      PincodeUpdateTableField? field, String colName, DbType dbtype) {
    return PincodeUpdateTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PincodeUpdateTableField? _appversion;
  PincodeUpdateTableField get appversion {
    return _appversion = _setField(_appversion, 'appversion', DbType.integer);
  }

  PincodeUpdateTableField? _versiondate;
  PincodeUpdateTableField get versiondate {
    return _versiondate = _setField(_versiondate, 'versiondate', DbType.text);
  }

  PincodeUpdateTableField? _pincodecount;
  PincodeUpdateTableField get pincodecount {
    return _pincodecount =
        _setField(_pincodecount, 'pincodecount', DbType.text);
  }

  PincodeUpdateTableField? _status;
  PincodeUpdateTableField get status {
    return _status = _setField(_status, 'status', DbType.text);
  }

  /// Deletes List<PincodeUpdateTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPincodeUpdateTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPincodeUpdateTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'appversion IN (SELECT appversion from PincodeUpdateTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPincodeUpdateTable!.updateBatch(qparams, values);
  }

  /// This method always returns [PincodeUpdateTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PincodeUpdateTable?
  @override
  Future<PincodeUpdateTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPincodeUpdateTable!.toList(qparams);
    final data = await objFuture;
    PincodeUpdateTable? obj;
    if (data.isNotEmpty) {
      obj = PincodeUpdateTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PincodeUpdateTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PincodeUpdateTable?
  @override
  Future<PincodeUpdateTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PincodeUpdateTable();
  }

  /// This method returns int. [PincodeUpdateTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? pincodeupdatetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final pincodeupdatetablesFuture =
        await _mnPincodeUpdateTable!.toList(qparams);
    final int count = pincodeupdatetablesFuture[0]['CNT'] as int;
    if (pincodeupdatetableCount != null) {
      pincodeupdatetableCount(count);
    }
    return count;
  }

  /// This method returns List<PincodeUpdateTable> [PincodeUpdateTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PincodeUpdateTable>
  @override
  Future<List<PincodeUpdateTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PincodeUpdateTable> pincodeupdatetablesData =
        await PincodeUpdateTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return pincodeupdatetablesData;
  }

  /// This method returns Json String [PincodeUpdateTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PincodeUpdateTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PincodeUpdateTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPincodeUpdateTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PincodeUpdateTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `appversion` FROM PincodeUpdateTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> appversionData = <String>[];
    qparams.selectColumns = ['appversion'];
    final appversionFuture = await _mnPincodeUpdateTable!.toList(qparams);

    final int count = appversionFuture.length;
    for (int i = 0; i < count; i++) {
      appversionData.add(appversionFuture[i]['appversion'] as String);
    }
    return appversionData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PincodeUpdateTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPincodeUpdateTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PincodeUpdateTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPincodeUpdateTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PincodeUpdateTableFilterBuilder

// region PincodeUpdateTableFields
class PincodeUpdateTableFields {
  static TableField? _fAppversion;
  static TableField get appversion {
    return _fAppversion = _fAppversion ??
        SqlSyntax.setField(_fAppversion, 'appversion', DbType.integer);
  }

  static TableField? _fVersiondate;
  static TableField get versiondate {
    return _fVersiondate = _fVersiondate ??
        SqlSyntax.setField(_fVersiondate, 'versiondate', DbType.text);
  }

  static TableField? _fPincodecount;
  static TableField get pincodecount {
    return _fPincodecount = _fPincodecount ??
        SqlSyntax.setField(_fPincodecount, 'pincodecount', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'status', DbType.text);
  }
}
// endregion PincodeUpdateTableFields

//region PincodeUpdateTableManager
class PincodeUpdateTableManager extends SqfEntityProvider {
  PincodeUpdateTableManager()
      : super(ReportModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'PincodeUpdateTable';
  static const List<String> _primaryKeyList = ['appversion'];
  static const String _whereStr = 'appversion=?';
}

//endregion PincodeUpdateTableManager
class ReportModelSequenceManager extends SqfEntityProvider {
  ReportModelSequenceManager() : super(ReportModel());
}
// END OF ENTITIES
