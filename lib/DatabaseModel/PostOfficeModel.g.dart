// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'PostOfficeModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Base_Tariff_BP.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Base_Tariff_BP TABLE
class TableBase_Tariff_BP extends SqfEntityTableBase {
  TableBase_Tariff_BP() {
    // declare properties of EntityTable
    tableName = 'Base_Tariff_BP';
    primaryKeyName = 'Productcode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ValidTo', DbType.real),
      SqfEntityFieldBase('ProductDescription', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('DistanceDescription', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('WeightDescriptionStart', DbType.integer),
      SqfEntityFieldBase('WeightDescriptionEnd', DbType.integer),
      SqfEntityFieldBase('Conditionrate', DbType.real),
      SqfEntityFieldBase('ServiceTax', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBase_Tariff_BP();
  }
}

// Base_Tariff_SP TABLE
class TableBase_Tariff_SP extends SqfEntityTableBase {
  TableBase_Tariff_SP() {
    // declare properties of EntityTable
    tableName = 'Base_Tariff_SP';
    primaryKeyName = 'Productcode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ValidTo', DbType.text),
      SqfEntityFieldBase('ProductDescription', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('DistanceDescriptionStart', DbType.integer),
      SqfEntityFieldBase('DistanceDescriptionEnd', DbType.integer),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('WeightDescriptionStart', DbType.integer),
      SqfEntityFieldBase('WeightDescriptionEnd', DbType.integer),
      SqfEntityFieldBase('Conditionrate', DbType.real),
      SqfEntityFieldBase('ServiceTax', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBase_Tariff_SP();
  }
}

// Book_State_Neighbour TABLE
class TableBook_State_Neighbour extends SqfEntityTableBase {
  TableBook_State_Neighbour() {
    // declare properties of EntityTable
    tableName = 'Book_State_Neighbour';
    primaryKeyName = 'BookingStatecode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Bookingstatename', DbType.text),
      SqfEntityFieldBase('NeighbouringStatecode', DbType.integer),
      SqfEntityFieldBase('NeighbouringState', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBook_State_Neighbour();
  }
}

// City_state TABLE
class TableCity_state extends SqfEntityTableBase {
  TableCity_state() {
    // declare properties of EntityTable
    tableName = 'city_state';
    primaryKeyName = 'city';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('citycode', DbType.integer),
      SqfEntityFieldBase('statecode', DbType.integer),
      SqfEntityFieldBase('capital', DbType.text),
      SqfEntityFieldBase('metro_indicator', DbType.text),
      SqfEntityFieldBase('ncr_indicator', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCity_state();
  }
}

// Insurance TABLE
class TableInsurance extends SqfEntityTableBase {
  TableInsurance() {
    // declare properties of EntityTable
    tableName = 'Insurance';
    primaryKeyName = 'ServiceID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MinAmount', DbType.real),
      SqfEntityFieldBase('MaxAmount', DbType.real),
      SqfEntityFieldBase('Commission', DbType.real),
      SqfEntityFieldBase('ActivationDate', DbType.real),
      SqfEntityFieldBase('ExpiryDate', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInsurance();
  }
}

// Local_pin TABLE
class TableLocal_pin extends SqfEntityTableBase {
  TableLocal_pin() {
    // declare properties of EntityTable
    tableName = 'Local_pin';
    primaryKeyName = 'SourcePinCode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('LocalPinCode', DbType.text),
      SqfEntityFieldBase('Var1', DbType.text),
      SqfEntityFieldBase('ValidTo', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLocal_pin();
  }
}

// OfficeMaster_Pincode TABLE
class TableOfficeMaster_Pincode extends SqfEntityTableBase {
  TableOfficeMaster_Pincode() {
    // declare properties of EntityTable
    tableName = 'OfficeMaster_Pincodes';
    primaryKeyName = 'FacilityID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('OfficeType', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.integer),
      SqfEntityFieldBase('Delivery', DbType.text),
      SqfEntityFieldBase('Latitude', DbType.real),
      SqfEntityFieldBase('Longitude', DbType.real),
      SqfEntityFieldBase('SOName', DbType.text),
      SqfEntityFieldBase('HOName', DbType.text),
      SqfEntityFieldBase('DOName', DbType.text),
      SqfEntityFieldBase('ROName', DbType.text),
      SqfEntityFieldBase('COName', DbType.text),
      SqfEntityFieldBase('ContactNumber', DbType.integer),
      SqfEntityFieldBase('EndDate', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('ModifiedDate', DbType.text),
      SqfEntityFieldBase('field16', DbType.text),
      SqfEntityFieldBase('field17', DbType.text),
      SqfEntityFieldBase('Region', DbType.integer),
      SqfEntityFieldBase('ReceiverCityDistrict', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableOfficeMaster_Pincode();
  }
}

// PeriodicalWeight TABLE
class TablePeriodicalWeight extends SqfEntityTableBase {
  TablePeriodicalWeight() {
    // declare properties of EntityTable
    tableName = 'PeriodicalWeight';
    primaryKeyName = 'Weight';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('WeightDescriptionStart', DbType.real),
      SqfEntityFieldBase('WeightDescriptionEnd', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePeriodicalWeight();
  }
}

// Periodical TABLE
class TablePeriodical extends SqfEntityTableBase {
  TablePeriodical() {
    // declare properties of EntityTable
    tableName = 'Periodicals';
    primaryKeyName = 'PeriodicalVariant';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('PeriodicalValueMin', DbType.real),
      SqfEntityFieldBase('PeriodicalValueMax', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePeriodical();
  }
}

// Price TABLE
class TablePrice extends SqfEntityTableBase {
  TablePrice() {
    // declare properties of EntityTable
    tableName = 'Price';
    primaryKeyName = 'Productcode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('DestinationCountry', DbType.text),
      SqfEntityFieldBase('Pricingunit', DbType.integer),
      SqfEntityFieldBase('LocalNonLocal', DbType.text),
      SqfEntityFieldBase('Variant', DbType.text),
      SqfEntityFieldBase('ValidTo', DbType.real),
      SqfEntityFieldBase('ProductDescription', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('DistanceDescription', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('WeightDescriptionStart', DbType.integer),
      SqfEntityFieldBase('WeightDescriptionEnd', DbType.integer),
      SqfEntityFieldBase('Conditionrate', DbType.real),
      SqfEntityFieldBase('ServiceTax', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePrice();
  }
}

// Productmaster TABLE
class TableProductmaster extends SqfEntityTableBase {
  TableProductmaster() {
    // declare properties of EntityTable
    tableName = 'Productmaster';
    primaryKeyName = 'Productcode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MaterialDescription', DbType.text),
      SqfEntityFieldBase('Country', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProductmaster();
  }
}

// RegionState TABLE
class TableRegionState extends SqfEntityTableBase {
  TableRegionState() {
    // declare properties of EntityTable
    tableName = 'RegionState';
    primaryKeyName = 'RegionCode';
    primaryKeyType = PrimaryKeyType.integer_unique;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('StateName', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRegionState();
  }
}

// TariffInfo TABLE
class TableTariffInfo extends SqfEntityTableBase {
  TableTariffInfo() {
    // declare properties of EntityTable
    tableName = 'TariffInfo';
    primaryKeyName = 'Product';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ProductDesc', DbType.text),
      SqfEntityFieldBase('Price', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTariffInfo();
  }
}

// Tariff_Info_mod TABLE
class TableTariff_Info_mod extends SqfEntityTableBase {
  TableTariff_Info_mod() {
    // declare properties of EntityTable
    tableName = 'Tariff_Info_mod';
    primaryKeyName = 'Product';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ProductDesc', DbType.text),
      SqfEntityFieldBase('Price', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTariff_Info_mod();
  }
}

// Vpp TABLE
class TableVpp extends SqfEntityTableBase {
  TableVpp() {
    // declare properties of EntityTable
    tableName = 'Vpp';
    primaryKeyName = 'ServiceID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MinAmount', DbType.real),
      SqfEntityFieldBase('MaxAmount', DbType.real),
      SqfEntityFieldBase('Commission', DbType.real),
      SqfEntityFieldBase('ActivationDate', DbType.real),
      SqfEntityFieldBase('ExpiryDate', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVpp();
  }
}

// WeightValidation TABLE
class TableWeightValidation extends SqfEntityTableBase {
  TableWeightValidation() {
    // declare properties of EntityTable
    tableName = 'WeightValidations';
    primaryKeyName = 'Product';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('WeightMin', DbType.real),
      SqfEntityFieldBase('WeightMax', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableWeightValidation();
  }
}

// Vaservice TABLE
class TableVaservice extends SqfEntityTableBase {
  TableVaservice() {
    // declare properties of EntityTable
    tableName = 'Vaservices';
    primaryKeyName = 'Productcode';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ServiceType', DbType.text),
      SqfEntityFieldBase('VASdescription', DbType.text),
      SqfEntityFieldBase('VASPrice', DbType.real),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVaservice();
  }
}

// OfficeMasterPinCode TABLE
class TableOfficeMasterPinCode extends SqfEntityTableBase {
  TableOfficeMasterPinCode() {
    // declare properties of EntityTable
    tableName = 'OfficeMasterPinCode';
    primaryKeyName = 'FacilityID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('OfficeType', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.integer),
      SqfEntityFieldBase('Delivery', DbType.text),
      SqfEntityFieldBase('Latitude', DbType.real),
      SqfEntityFieldBase('Longitude', DbType.real),
      SqfEntityFieldBase('SOName', DbType.text),
      SqfEntityFieldBase('HOName', DbType.text),
      SqfEntityFieldBase('DOName', DbType.text),
      SqfEntityFieldBase('ROName', DbType.text),
      SqfEntityFieldBase('COName', DbType.text),
      SqfEntityFieldBase('ContactNumber', DbType.integer),
      SqfEntityFieldBase('EndDate', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('ModifiedDate', DbType.text),
      SqfEntityFieldBase('Priority', DbType.integer),
      SqfEntityFieldBase('State', DbType.text),
      SqfEntityFieldBase('Region', DbType.integer),
      SqfEntityFieldBase('ReceiverCityDistrict', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableOfficeMasterPinCode();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class Tariffdb extends SqfEntityModelProvider {
  Tariffdb() {
    databaseName = tariffdb.databaseName;
    password = tariffdb.password;
    dbVersion = tariffdb.dbVersion;
    preSaveAction = tariffdb.preSaveAction;
    logFunction = tariffdb.logFunction;
    databaseTables = [
      TableBase_Tariff_BP.getInstance,
      TableBase_Tariff_SP.getInstance,
      TableBook_State_Neighbour.getInstance,
      TableCity_state.getInstance,
      TableInsurance.getInstance,
      TableLocal_pin.getInstance,
      TableOfficeMaster_Pincode.getInstance,
      TablePeriodicalWeight.getInstance,
      TablePeriodical.getInstance,
      TablePrice.getInstance,
      TableProductmaster.getInstance,
      TableRegionState.getInstance,
      TableTariffInfo.getInstance,
      TableTariff_Info_mod.getInstance,
      TableVpp.getInstance,
      TableWeightValidation.getInstance,
      TableVaservice.getInstance,
      TableOfficeMasterPinCode.getInstance,
    ];

    bundledDatabasePath = tariffdb
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = tariffdb.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Base_Tariff_BP
class Base_Tariff_BP extends TableBase {
  Base_Tariff_BP(
      {this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Base_Tariff_BP.withFields(
      this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  Base_Tariff_BP.withId(
      this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Base_Tariff_BP.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Productcode = o['Productcode'].toString();
    if (o['ValidTo'] != null) {
      ValidTo = double.tryParse(o['ValidTo'].toString());
    }
    if (o['ProductDescription'] != null) {
      ProductDescription = o['ProductDescription'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['DistanceDescription'] != null) {
      DistanceDescription = o['DistanceDescription'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['WeightDescriptionStart'] != null) {
      WeightDescriptionStart =
          int.tryParse(o['WeightDescriptionStart'].toString());
    }
    if (o['WeightDescriptionEnd'] != null) {
      WeightDescriptionEnd = int.tryParse(o['WeightDescriptionEnd'].toString());
    }
    if (o['Conditionrate'] != null) {
      Conditionrate = double.tryParse(o['Conditionrate'].toString());
    }
    if (o['ServiceTax'] != null) {
      ServiceTax = double.tryParse(o['ServiceTax'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Base_Tariff_BP)
  String? Productcode;
  double? ValidTo;
  String? ProductDescription;
  String? Distance;
  String? DistanceDescription;
  String? Weight;
  int? WeightDescriptionStart;
  int? WeightDescriptionEnd;
  double? Conditionrate;
  double? ServiceTax;
  bool? isSaved;
  // end FIELDS (Base_Tariff_BP)

  static const bool _softDeleteActivated = false;
  Base_Tariff_BPManager? __mnBase_Tariff_BP;

  Base_Tariff_BPManager get _mnBase_Tariff_BP {
    return __mnBase_Tariff_BP = __mnBase_Tariff_BP ?? Base_Tariff_BPManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescription != null || !forView) {
      map['DistanceDescription'] = DistanceDescription;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescription != null || !forView) {
      map['DistanceDescription'] = DistanceDescription;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  /// This method returns Json String [Base_Tariff_BP]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Base_Tariff_BP]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Productcode,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescription,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Productcode,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescription,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  static Future<List<Base_Tariff_BP>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Base_Tariff_BP.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Base_Tariff_BP>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Base_Tariff_BP>[];
    try {
      objList = list
          .map((base_tariff_bp) =>
              Base_Tariff_BP.fromMap(base_tariff_bp as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Base_Tariff_BP.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Base_Tariff_BP>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Base_Tariff_BP> objList = <Base_Tariff_BP>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Base_Tariff_BP.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Base_Tariff_BP by ID if exist, otherwise returns null
  /// Primary Keys: String? Productcode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Base_Tariff_BP] if exist, otherwise returns null
  Future<Base_Tariff_BP?> getById(String? Productcode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Productcode == null) {
      return null;
    }
    Base_Tariff_BP? obj;
    final data = await _mnBase_Tariff_BP.getById([Productcode]);
    if (data.length != 0) {
      obj = Base_Tariff_BP.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Base_Tariff_BP) object. If the Primary Key (Productcode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Productcode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBase_Tariff_BP.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Base_Tariff_BP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Base_Tariff_BP> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Base_Tariff_BP> base_tariff_bps,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in base_tariff_bps) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBase_Tariff_BP.rawInsert(
          'INSERT OR REPLACE INTO Base_Tariff_BP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescription,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Base_Tariff_BP Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Base_Tariff_BP Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Base_Tariff_BP Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBase_Tariff_BP.rawInsert(
          'INSERT OR IGNORE INTO Base_Tariff_BP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescription,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Base_Tariff_BP Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Base_Tariff_BP Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Base_Tariff_BP Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Base_Tariff_BP

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Base_Tariff_BP invoked (Productcode=$Productcode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBase_Tariff_BP.delete(QueryParams(
          whereString: 'Productcode=?', whereArguments: [Productcode]));
    } else {
      return _mnBase_Tariff_BP.updateBatch(
          QueryParams(
              whereString: 'Productcode=?', whereArguments: [Productcode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Base_Tariff_BP] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Base_Tariff_BPFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Base_Tariff_BPFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Base_Tariff_BPFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Base_Tariff_BPFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Productcode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion base_tariff_bp

// region Base_Tariff_BPField
class Base_Tariff_BPField extends FilterBase {
  Base_Tariff_BPField(Base_Tariff_BPFilterBuilder base_tariff_bpFB)
      : super(base_tariff_bpFB);

  @override
  Base_Tariff_BPFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder isNull() {
    return super.isNull() as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Base_Tariff_BPFilterBuilder;
  }

  @override
  Base_Tariff_BPField get not {
    return super.not as Base_Tariff_BPField;
  }
}
// endregion Base_Tariff_BPField

// region Base_Tariff_BPFilterBuilder
class Base_Tariff_BPFilterBuilder extends ConjunctionBase {
  Base_Tariff_BPFilterBuilder(Base_Tariff_BP obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBase_Tariff_BP = obj._mnBase_Tariff_BP;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Base_Tariff_BPManager? _mnBase_Tariff_BP;

  /// put the sql keyword 'AND'
  @override
  Base_Tariff_BPFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Base_Tariff_BPFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Base_Tariff_BPFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Base_Tariff_BPFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Base_Tariff_BPFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Base_Tariff_BPFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Base_Tariff_BPFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Base_Tariff_BPFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Base_Tariff_BPFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Base_Tariff_BPFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Base_Tariff_BPFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Base_Tariff_BPField _setField(
      Base_Tariff_BPField? field, String colName, DbType dbtype) {
    return Base_Tariff_BPField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Base_Tariff_BPField? _Productcode;
  Base_Tariff_BPField get Productcode {
    return _Productcode =
        _setField(_Productcode, 'Productcode', DbType.integer);
  }

  Base_Tariff_BPField? _ValidTo;
  Base_Tariff_BPField get ValidTo {
    return _ValidTo = _setField(_ValidTo, 'ValidTo', DbType.real);
  }

  Base_Tariff_BPField? _ProductDescription;
  Base_Tariff_BPField get ProductDescription {
    return _ProductDescription =
        _setField(_ProductDescription, 'ProductDescription', DbType.text);
  }

  Base_Tariff_BPField? _Distance;
  Base_Tariff_BPField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  Base_Tariff_BPField? _DistanceDescription;
  Base_Tariff_BPField get DistanceDescription {
    return _DistanceDescription =
        _setField(_DistanceDescription, 'DistanceDescription', DbType.text);
  }

  Base_Tariff_BPField? _Weight;
  Base_Tariff_BPField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  Base_Tariff_BPField? _WeightDescriptionStart;
  Base_Tariff_BPField get WeightDescriptionStart {
    return _WeightDescriptionStart = _setField(
        _WeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  Base_Tariff_BPField? _WeightDescriptionEnd;
  Base_Tariff_BPField get WeightDescriptionEnd {
    return _WeightDescriptionEnd = _setField(
        _WeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  Base_Tariff_BPField? _Conditionrate;
  Base_Tariff_BPField get Conditionrate {
    return _Conditionrate =
        _setField(_Conditionrate, 'Conditionrate', DbType.real);
  }

  Base_Tariff_BPField? _ServiceTax;
  Base_Tariff_BPField get ServiceTax {
    return _ServiceTax = _setField(_ServiceTax, 'ServiceTax', DbType.real);
  }

  /// Deletes List<Base_Tariff_BP> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBase_Tariff_BP!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBase_Tariff_BP!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Productcode IN (SELECT Productcode from Base_Tariff_BP ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBase_Tariff_BP!.updateBatch(qparams, values);
  }

  /// This method always returns [Base_Tariff_BP] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Base_Tariff_BP?
  @override
  Future<Base_Tariff_BP?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBase_Tariff_BP!.toList(qparams);
    final data = await objFuture;
    Base_Tariff_BP? obj;
    if (data.isNotEmpty) {
      obj = Base_Tariff_BP.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Base_Tariff_BP]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Base_Tariff_BP?
  @override
  Future<Base_Tariff_BP> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Base_Tariff_BP();
  }

  /// This method returns int. [Base_Tariff_BP]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? base_tariff_bpCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final base_tariff_bpsFuture = await _mnBase_Tariff_BP!.toList(qparams);
    final int count = base_tariff_bpsFuture[0]['CNT'] as int;
    if (base_tariff_bpCount != null) {
      base_tariff_bpCount(count);
    }
    return count;
  }

  /// This method returns List<Base_Tariff_BP> [Base_Tariff_BP]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Base_Tariff_BP>
  @override
  Future<List<Base_Tariff_BP>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Base_Tariff_BP> base_tariff_bpsData =
        await Base_Tariff_BP.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return base_tariff_bpsData;
  }

  /// This method returns Json String [Base_Tariff_BP]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Base_Tariff_BP]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Base_Tariff_BP]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBase_Tariff_BP!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Base_Tariff_BP]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Productcode` FROM Base_Tariff_BP WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductcodeData = <String>[];
    qparams.selectColumns = ['Productcode'];
    final ProductcodeFuture = await _mnBase_Tariff_BP!.toList(qparams);

    final int count = ProductcodeFuture.length;
    for (int i = 0; i < count; i++) {
      ProductcodeData.add(ProductcodeFuture[i]['Productcode'] as String);
    }
    return ProductcodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Base_Tariff_BP]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBase_Tariff_BP!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Base_Tariff_BP.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBase_Tariff_BP!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Base_Tariff_BPFilterBuilder

// region Base_Tariff_BPFields
class Base_Tariff_BPFields {
  static TableField? _fProductcode;
  static TableField get Productcode {
    return _fProductcode = _fProductcode ??
        SqlSyntax.setField(_fProductcode, 'productcode', DbType.integer);
  }

  static TableField? _fValidTo;
  static TableField get ValidTo {
    return _fValidTo =
        _fValidTo ?? SqlSyntax.setField(_fValidTo, 'ValidTo', DbType.real);
  }

  static TableField? _fProductDescription;
  static TableField get ProductDescription {
    return _fProductDescription = _fProductDescription ??
        SqlSyntax.setField(
            _fProductDescription, 'ProductDescription', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fDistanceDescription;
  static TableField get DistanceDescription {
    return _fDistanceDescription = _fDistanceDescription ??
        SqlSyntax.setField(
            _fDistanceDescription, 'DistanceDescription', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fWeightDescriptionStart;
  static TableField get WeightDescriptionStart {
    return _fWeightDescriptionStart = _fWeightDescriptionStart ??
        SqlSyntax.setField(
            _fWeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  static TableField? _fWeightDescriptionEnd;
  static TableField get WeightDescriptionEnd {
    return _fWeightDescriptionEnd = _fWeightDescriptionEnd ??
        SqlSyntax.setField(
            _fWeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  static TableField? _fConditionrate;
  static TableField get Conditionrate {
    return _fConditionrate = _fConditionrate ??
        SqlSyntax.setField(_fConditionrate, 'Conditionrate', DbType.real);
  }

  static TableField? _fServiceTax;
  static TableField get ServiceTax {
    return _fServiceTax = _fServiceTax ??
        SqlSyntax.setField(_fServiceTax, 'ServiceTax', DbType.real);
  }
}
// endregion Base_Tariff_BPFields

//region Base_Tariff_BPManager
class Base_Tariff_BPManager extends SqfEntityProvider {
  Base_Tariff_BPManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Base_Tariff_BP';
  static const List<String> _primaryKeyList = ['Productcode'];
  static const String _whereStr = 'Productcode=?';
}

//endregion Base_Tariff_BPManager
// region Base_Tariff_SP
class Base_Tariff_SP extends TableBase {
  Base_Tariff_SP(
      {this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescriptionStart,
      this.DistanceDescriptionEnd,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Base_Tariff_SP.withFields(
      this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescriptionStart,
      this.DistanceDescriptionEnd,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  Base_Tariff_SP.withId(
      this.Productcode,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescriptionStart,
      this.DistanceDescriptionEnd,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Base_Tariff_SP.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Productcode = o['Productcode'].toString();
    if (o['ValidTo'] != null) {
      ValidTo = o['ValidTo'].toString();
    }
    if (o['ProductDescription'] != null) {
      ProductDescription = o['ProductDescription'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['DistanceDescriptionStart'] != null) {
      DistanceDescriptionStart =
          int.tryParse(o['DistanceDescriptionStart'].toString());
    }
    if (o['DistanceDescriptionEnd'] != null) {
      DistanceDescriptionEnd =
          int.tryParse(o['DistanceDescriptionEnd'].toString());
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['WeightDescriptionStart'] != null) {
      WeightDescriptionStart =
          int.tryParse(o['WeightDescriptionStart'].toString());
    }
    if (o['WeightDescriptionEnd'] != null) {
      WeightDescriptionEnd = int.tryParse(o['WeightDescriptionEnd'].toString());
    }
    if (o['Conditionrate'] != null) {
      Conditionrate = double.tryParse(o['Conditionrate'].toString());
    }
    if (o['ServiceTax'] != null) {
      ServiceTax = double.tryParse(o['ServiceTax'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Base_Tariff_SP)
  String? Productcode;
  String? ValidTo;
  String? ProductDescription;
  String? Distance;
  int? DistanceDescriptionStart;
  int? DistanceDescriptionEnd;
  String? Weight;
  int? WeightDescriptionStart;
  int? WeightDescriptionEnd;
  double? Conditionrate;
  double? ServiceTax;
  bool? isSaved;
  // end FIELDS (Base_Tariff_SP)

  static const bool _softDeleteActivated = false;
  Base_Tariff_SPManager? __mnBase_Tariff_SP;

  Base_Tariff_SPManager get _mnBase_Tariff_SP {
    return __mnBase_Tariff_SP = __mnBase_Tariff_SP ?? Base_Tariff_SPManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescriptionStart != null || !forView) {
      map['DistanceDescriptionStart'] = DistanceDescriptionStart;
    }
    if (DistanceDescriptionEnd != null || !forView) {
      map['DistanceDescriptionEnd'] = DistanceDescriptionEnd;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescriptionStart != null || !forView) {
      map['DistanceDescriptionStart'] = DistanceDescriptionStart;
    }
    if (DistanceDescriptionEnd != null || !forView) {
      map['DistanceDescriptionEnd'] = DistanceDescriptionEnd;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  /// This method returns Json String [Base_Tariff_SP]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Base_Tariff_SP]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Productcode,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescriptionStart,
      DistanceDescriptionEnd,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Productcode,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescriptionStart,
      DistanceDescriptionEnd,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  static Future<List<Base_Tariff_SP>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Base_Tariff_SP.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Base_Tariff_SP>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Base_Tariff_SP>[];
    try {
      objList = list
          .map((base_tariff_sp) =>
              Base_Tariff_SP.fromMap(base_tariff_sp as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Base_Tariff_SP.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Base_Tariff_SP>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Base_Tariff_SP> objList = <Base_Tariff_SP>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Base_Tariff_SP.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Base_Tariff_SP by ID if exist, otherwise returns null
  /// Primary Keys: String? Productcode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Base_Tariff_SP] if exist, otherwise returns null
  Future<Base_Tariff_SP?> getById(String? Productcode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Productcode == null) {
      return null;
    }
    Base_Tariff_SP? obj;
    final data = await _mnBase_Tariff_SP.getById([Productcode]);
    if (data.length != 0) {
      obj = Base_Tariff_SP.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Base_Tariff_SP) object. If the Primary Key (Productcode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Productcode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBase_Tariff_SP.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Base_Tariff_SP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescriptionStart, DistanceDescriptionEnd, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Base_Tariff_SP> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Base_Tariff_SP> base_tariff_sps,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in base_tariff_sps) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBase_Tariff_SP.rawInsert(
          'INSERT OR REPLACE INTO Base_Tariff_SP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescriptionStart, DistanceDescriptionEnd, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescriptionStart,
            DistanceDescriptionEnd,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Base_Tariff_SP Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Base_Tariff_SP Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Base_Tariff_SP Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBase_Tariff_SP.rawInsert(
          'INSERT OR IGNORE INTO Base_Tariff_SP (Productcode, ValidTo, ProductDescription, Distance, DistanceDescriptionStart, DistanceDescriptionEnd, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescriptionStart,
            DistanceDescriptionEnd,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Base_Tariff_SP Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Base_Tariff_SP Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Base_Tariff_SP Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Base_Tariff_SP

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Base_Tariff_SP invoked (Productcode=$Productcode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBase_Tariff_SP.delete(QueryParams(
          whereString: 'Productcode=?', whereArguments: [Productcode]));
    } else {
      return _mnBase_Tariff_SP.updateBatch(
          QueryParams(
              whereString: 'Productcode=?', whereArguments: [Productcode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Base_Tariff_SP] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Base_Tariff_SPFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Base_Tariff_SPFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Base_Tariff_SPFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Base_Tariff_SPFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Productcode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion base_tariff_sp

// region Base_Tariff_SPField
class Base_Tariff_SPField extends FilterBase {
  Base_Tariff_SPField(Base_Tariff_SPFilterBuilder base_tariff_spFB)
      : super(base_tariff_spFB);

  @override
  Base_Tariff_SPFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder isNull() {
    return super.isNull() as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Base_Tariff_SPFilterBuilder;
  }

  @override
  Base_Tariff_SPField get not {
    return super.not as Base_Tariff_SPField;
  }
}
// endregion Base_Tariff_SPField

// region Base_Tariff_SPFilterBuilder
class Base_Tariff_SPFilterBuilder extends ConjunctionBase {
  Base_Tariff_SPFilterBuilder(Base_Tariff_SP obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBase_Tariff_SP = obj._mnBase_Tariff_SP;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Base_Tariff_SPManager? _mnBase_Tariff_SP;

  /// put the sql keyword 'AND'
  @override
  Base_Tariff_SPFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Base_Tariff_SPFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Base_Tariff_SPFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Base_Tariff_SPFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Base_Tariff_SPFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Base_Tariff_SPFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Base_Tariff_SPFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Base_Tariff_SPFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Base_Tariff_SPFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Base_Tariff_SPFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Base_Tariff_SPFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Base_Tariff_SPField _setField(
      Base_Tariff_SPField? field, String colName, DbType dbtype) {
    return Base_Tariff_SPField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Base_Tariff_SPField? _Productcode;
  Base_Tariff_SPField get Productcode {
    return _Productcode =
        _setField(_Productcode, 'Productcode', DbType.integer);
  }

  Base_Tariff_SPField? _ValidTo;
  Base_Tariff_SPField get ValidTo {
    return _ValidTo = _setField(_ValidTo, 'ValidTo', DbType.text);
  }

  Base_Tariff_SPField? _ProductDescription;
  Base_Tariff_SPField get ProductDescription {
    return _ProductDescription =
        _setField(_ProductDescription, 'ProductDescription', DbType.text);
  }

  Base_Tariff_SPField? _Distance;
  Base_Tariff_SPField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  Base_Tariff_SPField? _DistanceDescriptionStart;
  Base_Tariff_SPField get DistanceDescriptionStart {
    return _DistanceDescriptionStart = _setField(
        _DistanceDescriptionStart, 'DistanceDescriptionStart', DbType.integer);
  }

  Base_Tariff_SPField? _DistanceDescriptionEnd;
  Base_Tariff_SPField get DistanceDescriptionEnd {
    return _DistanceDescriptionEnd = _setField(
        _DistanceDescriptionEnd, 'DistanceDescriptionEnd', DbType.integer);
  }

  Base_Tariff_SPField? _Weight;
  Base_Tariff_SPField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  Base_Tariff_SPField? _WeightDescriptionStart;
  Base_Tariff_SPField get WeightDescriptionStart {
    return _WeightDescriptionStart = _setField(
        _WeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  Base_Tariff_SPField? _WeightDescriptionEnd;
  Base_Tariff_SPField get WeightDescriptionEnd {
    return _WeightDescriptionEnd = _setField(
        _WeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  Base_Tariff_SPField? _Conditionrate;
  Base_Tariff_SPField get Conditionrate {
    return _Conditionrate =
        _setField(_Conditionrate, 'Conditionrate', DbType.real);
  }

  Base_Tariff_SPField? _ServiceTax;
  Base_Tariff_SPField get ServiceTax {
    return _ServiceTax = _setField(_ServiceTax, 'ServiceTax', DbType.real);
  }

  /// Deletes List<Base_Tariff_SP> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBase_Tariff_SP!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBase_Tariff_SP!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Productcode IN (SELECT Productcode from Base_Tariff_SP ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBase_Tariff_SP!.updateBatch(qparams, values);
  }

  /// This method always returns [Base_Tariff_SP] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Base_Tariff_SP?
  @override
  Future<Base_Tariff_SP?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBase_Tariff_SP!.toList(qparams);
    final data = await objFuture;
    Base_Tariff_SP? obj;
    if (data.isNotEmpty) {
      obj = Base_Tariff_SP.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Base_Tariff_SP]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Base_Tariff_SP?
  @override
  Future<Base_Tariff_SP> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Base_Tariff_SP();
  }

  /// This method returns int. [Base_Tariff_SP]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? base_tariff_spCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final base_tariff_spsFuture = await _mnBase_Tariff_SP!.toList(qparams);
    final int count = base_tariff_spsFuture[0]['CNT'] as int;
    if (base_tariff_spCount != null) {
      base_tariff_spCount(count);
    }
    return count;
  }

  /// This method returns List<Base_Tariff_SP> [Base_Tariff_SP]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Base_Tariff_SP>
  @override
  Future<List<Base_Tariff_SP>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Base_Tariff_SP> base_tariff_spsData =
        await Base_Tariff_SP.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return base_tariff_spsData;
  }

  /// This method returns Json String [Base_Tariff_SP]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Base_Tariff_SP]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Base_Tariff_SP]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBase_Tariff_SP!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Base_Tariff_SP]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Productcode` FROM Base_Tariff_SP WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductcodeData = <String>[];
    qparams.selectColumns = ['Productcode'];
    final ProductcodeFuture = await _mnBase_Tariff_SP!.toList(qparams);

    final int count = ProductcodeFuture.length;
    for (int i = 0; i < count; i++) {
      ProductcodeData.add(ProductcodeFuture[i]['Productcode'] as String);
    }
    return ProductcodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Base_Tariff_SP]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBase_Tariff_SP!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Base_Tariff_SP.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBase_Tariff_SP!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Base_Tariff_SPFilterBuilder

// region Base_Tariff_SPFields
class Base_Tariff_SPFields {
  static TableField? _fProductcode;
  static TableField get Productcode {
    return _fProductcode = _fProductcode ??
        SqlSyntax.setField(_fProductcode, 'productcode', DbType.integer);
  }

  static TableField? _fValidTo;
  static TableField get ValidTo {
    return _fValidTo =
        _fValidTo ?? SqlSyntax.setField(_fValidTo, 'ValidTo', DbType.text);
  }

  static TableField? _fProductDescription;
  static TableField get ProductDescription {
    return _fProductDescription = _fProductDescription ??
        SqlSyntax.setField(
            _fProductDescription, 'ProductDescription', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fDistanceDescriptionStart;
  static TableField get DistanceDescriptionStart {
    return _fDistanceDescriptionStart = _fDistanceDescriptionStart ??
        SqlSyntax.setField(_fDistanceDescriptionStart,
            'DistanceDescriptionStart', DbType.integer);
  }

  static TableField? _fDistanceDescriptionEnd;
  static TableField get DistanceDescriptionEnd {
    return _fDistanceDescriptionEnd = _fDistanceDescriptionEnd ??
        SqlSyntax.setField(
            _fDistanceDescriptionEnd, 'DistanceDescriptionEnd', DbType.integer);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fWeightDescriptionStart;
  static TableField get WeightDescriptionStart {
    return _fWeightDescriptionStart = _fWeightDescriptionStart ??
        SqlSyntax.setField(
            _fWeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  static TableField? _fWeightDescriptionEnd;
  static TableField get WeightDescriptionEnd {
    return _fWeightDescriptionEnd = _fWeightDescriptionEnd ??
        SqlSyntax.setField(
            _fWeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  static TableField? _fConditionrate;
  static TableField get Conditionrate {
    return _fConditionrate = _fConditionrate ??
        SqlSyntax.setField(_fConditionrate, 'Conditionrate', DbType.real);
  }

  static TableField? _fServiceTax;
  static TableField get ServiceTax {
    return _fServiceTax = _fServiceTax ??
        SqlSyntax.setField(_fServiceTax, 'ServiceTax', DbType.real);
  }
}
// endregion Base_Tariff_SPFields

//region Base_Tariff_SPManager
class Base_Tariff_SPManager extends SqfEntityProvider {
  Base_Tariff_SPManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Base_Tariff_SP';
  static const List<String> _primaryKeyList = ['Productcode'];
  static const String _whereStr = 'Productcode=?';
}

//endregion Base_Tariff_SPManager
// region Book_State_Neighbour
class Book_State_Neighbour extends TableBase {
  Book_State_Neighbour(
      {this.BookingStatecode,
      this.Bookingstatename,
      this.NeighbouringStatecode,
      this.NeighbouringState}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Book_State_Neighbour.withFields(this.BookingStatecode, this.Bookingstatename,
      this.NeighbouringStatecode, this.NeighbouringState) {
    _setDefaultValues();
  }
  Book_State_Neighbour.withId(this.BookingStatecode, this.Bookingstatename,
      this.NeighbouringStatecode, this.NeighbouringState) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Book_State_Neighbour.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BookingStatecode = o['BookingStatecode'].toString();
    if (o['Bookingstatename'] != null) {
      Bookingstatename = o['Bookingstatename'].toString();
    }
    if (o['NeighbouringStatecode'] != null) {
      NeighbouringStatecode =
          int.tryParse(o['NeighbouringStatecode'].toString());
    }
    if (o['NeighbouringState'] != null) {
      NeighbouringState = o['NeighbouringState'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Book_State_Neighbour)
  String? BookingStatecode;
  String? Bookingstatename;
  int? NeighbouringStatecode;
  String? NeighbouringState;
  bool? isSaved;
  // end FIELDS (Book_State_Neighbour)

  static const bool _softDeleteActivated = false;
  Book_State_NeighbourManager? __mnBook_State_Neighbour;

  Book_State_NeighbourManager get _mnBook_State_Neighbour {
    return __mnBook_State_Neighbour =
        __mnBook_State_Neighbour ?? Book_State_NeighbourManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BookingStatecode'] = BookingStatecode;
    if (Bookingstatename != null || !forView) {
      map['Bookingstatename'] = Bookingstatename;
    }
    if (NeighbouringStatecode != null || !forView) {
      map['NeighbouringStatecode'] = NeighbouringStatecode;
    }
    if (NeighbouringState != null || !forView) {
      map['NeighbouringState'] = NeighbouringState;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BookingStatecode'] = BookingStatecode;
    if (Bookingstatename != null || !forView) {
      map['Bookingstatename'] = Bookingstatename;
    }
    if (NeighbouringStatecode != null || !forView) {
      map['NeighbouringStatecode'] = NeighbouringStatecode;
    }
    if (NeighbouringState != null || !forView) {
      map['NeighbouringState'] = NeighbouringState;
    }

    return map;
  }

  /// This method returns Json String [Book_State_Neighbour]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Book_State_Neighbour]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BookingStatecode,
      Bookingstatename,
      NeighbouringStatecode,
      NeighbouringState
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BookingStatecode,
      Bookingstatename,
      NeighbouringStatecode,
      NeighbouringState
    ];
  }

  static Future<List<Book_State_Neighbour>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Book_State_Neighbour.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Book_State_Neighbour>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Book_State_Neighbour>[];
    try {
      objList = list
          .map((book_state_neighbour) => Book_State_Neighbour.fromMap(
              book_state_neighbour as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Book_State_Neighbour.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Book_State_Neighbour>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Book_State_Neighbour> objList = <Book_State_Neighbour>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Book_State_Neighbour.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Book_State_Neighbour by ID if exist, otherwise returns null
  /// Primary Keys: String? BookingStatecode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Book_State_Neighbour] if exist, otherwise returns null
  Future<Book_State_Neighbour?> getById(String? BookingStatecode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BookingStatecode == null) {
      return null;
    }
    Book_State_Neighbour? obj;
    final data = await _mnBook_State_Neighbour.getById([BookingStatecode]);
    if (data.length != 0) {
      obj = Book_State_Neighbour.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Book_State_Neighbour) object. If the Primary Key (BookingStatecode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BookingStatecode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBook_State_Neighbour.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Book_State_Neighbour (BookingStatecode, Bookingstatename, NeighbouringStatecode, NeighbouringState)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Book_State_Neighbour> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<Book_State_Neighbour> book_state_neighbours,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in book_state_neighbours) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBook_State_Neighbour.rawInsert(
          'INSERT OR REPLACE INTO Book_State_Neighbour (BookingStatecode, Bookingstatename, NeighbouringStatecode, NeighbouringState)  VALUES (?,?,?,?)',
          [
            BookingStatecode,
            Bookingstatename,
            NeighbouringStatecode,
            NeighbouringState
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Book_State_Neighbour BookingStatecode=$BookingStatecode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Book_State_Neighbour BookingStatecode=$BookingStatecode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Book_State_Neighbour Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBook_State_Neighbour.rawInsert(
          'INSERT OR IGNORE INTO Book_State_Neighbour (BookingStatecode, Bookingstatename, NeighbouringStatecode, NeighbouringState)  VALUES (?,?,?,?)',
          [
            BookingStatecode,
            Bookingstatename,
            NeighbouringStatecode,
            NeighbouringState
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Book_State_Neighbour BookingStatecode=$BookingStatecode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Book_State_Neighbour BookingStatecode=$BookingStatecode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'Book_State_Neighbour Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Book_State_Neighbour

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Book_State_Neighbour invoked (BookingStatecode=$BookingStatecode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBook_State_Neighbour.delete(QueryParams(
          whereString: 'BookingStatecode=?',
          whereArguments: [BookingStatecode]));
    } else {
      return _mnBook_State_Neighbour.updateBatch(
          QueryParams(
              whereString: 'BookingStatecode=?',
              whereArguments: [BookingStatecode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Book_State_Neighbour] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Book_State_NeighbourFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Book_State_NeighbourFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Book_State_NeighbourFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Book_State_NeighbourFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BookingStatecode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion book_state_neighbour

// region Book_State_NeighbourField
class Book_State_NeighbourField extends FilterBase {
  Book_State_NeighbourField(
      Book_State_NeighbourFilterBuilder book_state_neighbourFB)
      : super(book_state_neighbourFB);

  @override
  Book_State_NeighbourFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder isNull() {
    return super.isNull() as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Book_State_NeighbourFilterBuilder;
  }

  @override
  Book_State_NeighbourField get not {
    return super.not as Book_State_NeighbourField;
  }
}
// endregion Book_State_NeighbourField

// region Book_State_NeighbourFilterBuilder
class Book_State_NeighbourFilterBuilder extends ConjunctionBase {
  Book_State_NeighbourFilterBuilder(
      Book_State_Neighbour obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBook_State_Neighbour = obj._mnBook_State_Neighbour;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Book_State_NeighbourManager? _mnBook_State_Neighbour;

  /// put the sql keyword 'AND'
  @override
  Book_State_NeighbourFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Book_State_NeighbourFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Book_State_NeighbourFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Book_State_NeighbourFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Book_State_NeighbourFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Book_State_NeighbourFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Book_State_NeighbourFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Book_State_NeighbourFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Book_State_NeighbourFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Book_State_NeighbourFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Book_State_NeighbourFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Book_State_NeighbourField _setField(
      Book_State_NeighbourField? field, String colName, DbType dbtype) {
    return Book_State_NeighbourField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Book_State_NeighbourField? _BookingStatecode;
  Book_State_NeighbourField get BookingStatecode {
    return _BookingStatecode =
        _setField(_BookingStatecode, 'BookingStatecode', DbType.integer);
  }

  Book_State_NeighbourField? _Bookingstatename;
  Book_State_NeighbourField get Bookingstatename {
    return _Bookingstatename =
        _setField(_Bookingstatename, 'Bookingstatename', DbType.text);
  }

  Book_State_NeighbourField? _NeighbouringStatecode;
  Book_State_NeighbourField get NeighbouringStatecode {
    return _NeighbouringStatecode = _setField(
        _NeighbouringStatecode, 'NeighbouringStatecode', DbType.integer);
  }

  Book_State_NeighbourField? _NeighbouringState;
  Book_State_NeighbourField get NeighbouringState {
    return _NeighbouringState =
        _setField(_NeighbouringState, 'NeighbouringState', DbType.text);
  }

  /// Deletes List<Book_State_Neighbour> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBook_State_Neighbour!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBook_State_Neighbour!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BookingStatecode IN (SELECT BookingStatecode from Book_State_Neighbour ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBook_State_Neighbour!.updateBatch(qparams, values);
  }

  /// This method always returns [Book_State_Neighbour] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Book_State_Neighbour?
  @override
  Future<Book_State_Neighbour?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBook_State_Neighbour!.toList(qparams);
    final data = await objFuture;
    Book_State_Neighbour? obj;
    if (data.isNotEmpty) {
      obj = Book_State_Neighbour.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Book_State_Neighbour]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Book_State_Neighbour?
  @override
  Future<Book_State_Neighbour> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Book_State_Neighbour();
  }

  /// This method returns int. [Book_State_Neighbour]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? book_state_neighbourCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final book_state_neighboursFuture =
        await _mnBook_State_Neighbour!.toList(qparams);
    final int count = book_state_neighboursFuture[0]['CNT'] as int;
    if (book_state_neighbourCount != null) {
      book_state_neighbourCount(count);
    }
    return count;
  }

  /// This method returns List<Book_State_Neighbour> [Book_State_Neighbour]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Book_State_Neighbour>
  @override
  Future<List<Book_State_Neighbour>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Book_State_Neighbour> book_state_neighboursData =
        await Book_State_Neighbour.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return book_state_neighboursData;
  }

  /// This method returns Json String [Book_State_Neighbour]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Book_State_Neighbour]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Book_State_Neighbour]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBook_State_Neighbour!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Book_State_Neighbour]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BookingStatecode` FROM Book_State_Neighbour WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BookingStatecodeData = <String>[];
    qparams.selectColumns = ['BookingStatecode'];
    final BookingStatecodeFuture =
        await _mnBook_State_Neighbour!.toList(qparams);

    final int count = BookingStatecodeFuture.length;
    for (int i = 0; i < count; i++) {
      BookingStatecodeData.add(
          BookingStatecodeFuture[i]['BookingStatecode'] as String);
    }
    return BookingStatecodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Book_State_Neighbour]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBook_State_Neighbour!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Book_State_Neighbour.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBook_State_Neighbour!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Book_State_NeighbourFilterBuilder

// region Book_State_NeighbourFields
class Book_State_NeighbourFields {
  static TableField? _fBookingStatecode;
  static TableField get BookingStatecode {
    return _fBookingStatecode = _fBookingStatecode ??
        SqlSyntax.setField(
            _fBookingStatecode, 'bookingstatecode', DbType.integer);
  }

  static TableField? _fBookingstatename;
  static TableField get Bookingstatename {
    return _fBookingstatename = _fBookingstatename ??
        SqlSyntax.setField(_fBookingstatename, 'Bookingstatename', DbType.text);
  }

  static TableField? _fNeighbouringStatecode;
  static TableField get NeighbouringStatecode {
    return _fNeighbouringStatecode = _fNeighbouringStatecode ??
        SqlSyntax.setField(
            _fNeighbouringStatecode, 'NeighbouringStatecode', DbType.integer);
  }

  static TableField? _fNeighbouringState;
  static TableField get NeighbouringState {
    return _fNeighbouringState = _fNeighbouringState ??
        SqlSyntax.setField(
            _fNeighbouringState, 'NeighbouringState', DbType.text);
  }
}
// endregion Book_State_NeighbourFields

//region Book_State_NeighbourManager
class Book_State_NeighbourManager extends SqfEntityProvider {
  Book_State_NeighbourManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Book_State_Neighbour';
  static const List<String> _primaryKeyList = ['BookingStatecode'];
  static const String _whereStr = 'BookingStatecode=?';
}

//endregion Book_State_NeighbourManager
// region City_state
class City_state extends TableBase {
  City_state(
      {this.city,
      this.citycode,
      this.statecode,
      this.capital,
      this.metro_indicator,
      this.ncr_indicator}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  City_state.withFields(this.city, this.citycode, this.statecode, this.capital,
      this.metro_indicator, this.ncr_indicator) {
    _setDefaultValues();
  }
  City_state.withId(this.city, this.citycode, this.statecode, this.capital,
      this.metro_indicator, this.ncr_indicator) {
    _setDefaultValues();
  }
  // fromMap v2.0
  City_state.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    city = o['city'].toString();
    if (o['citycode'] != null) {
      citycode = int.tryParse(o['citycode'].toString());
    }
    if (o['statecode'] != null) {
      statecode = int.tryParse(o['statecode'].toString());
    }
    if (o['capital'] != null) {
      capital = o['capital'].toString();
    }
    if (o['metro_indicator'] != null) {
      metro_indicator = o['metro_indicator'].toString();
    }
    if (o['ncr_indicator'] != null) {
      ncr_indicator = o['ncr_indicator'].toString();
    }

    isSaved = true;
  }
  // FIELDS (City_state)
  String? city;
  int? citycode;
  int? statecode;
  String? capital;
  String? metro_indicator;
  String? ncr_indicator;
  bool? isSaved;
  // end FIELDS (City_state)

  static const bool _softDeleteActivated = false;
  City_stateManager? __mnCity_state;

  City_stateManager get _mnCity_state {
    return __mnCity_state = __mnCity_state ?? City_stateManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['city'] = city;
    if (citycode != null || !forView) {
      map['citycode'] = citycode;
    }
    if (statecode != null || !forView) {
      map['statecode'] = statecode;
    }
    if (capital != null || !forView) {
      map['capital'] = capital;
    }
    if (metro_indicator != null || !forView) {
      map['metro_indicator'] = metro_indicator;
    }
    if (ncr_indicator != null || !forView) {
      map['ncr_indicator'] = ncr_indicator;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['city'] = city;
    if (citycode != null || !forView) {
      map['citycode'] = citycode;
    }
    if (statecode != null || !forView) {
      map['statecode'] = statecode;
    }
    if (capital != null || !forView) {
      map['capital'] = capital;
    }
    if (metro_indicator != null || !forView) {
      map['metro_indicator'] = metro_indicator;
    }
    if (ncr_indicator != null || !forView) {
      map['ncr_indicator'] = ncr_indicator;
    }

    return map;
  }

  /// This method returns Json String [City_state]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [City_state]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [city, citycode, statecode, capital, metro_indicator, ncr_indicator];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [city, citycode, statecode, capital, metro_indicator, ncr_indicator];
  }

  static Future<List<City_state>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR City_state.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<City_state>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <City_state>[];
    try {
      objList = list
          .map((city_state) =>
              City_state.fromMap(city_state as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR City_state.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<City_state>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<City_state> objList = <City_state>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = City_state.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns City_state by ID if exist, otherwise returns null
  /// Primary Keys: String? city
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [City_state] if exist, otherwise returns null
  Future<City_state?> getById(String? city,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (city == null) {
      return null;
    }
    City_state? obj;
    final data = await _mnCity_state.getById([city]);
    if (data.length != 0) {
      obj = City_state.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (City_state) object. If the Primary Key (city) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same city
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCity_state.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO city_state (city, citycode, statecode, capital, metro_indicator, ncr_indicator)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<City_state> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<City_state> city_states,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in city_states) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCity_state.rawInsert(
          'INSERT OR REPLACE INTO city_state (city, citycode, statecode, capital, metro_indicator, ncr_indicator)  VALUES (?,?,?,?,?,?)',
          [city, citycode, statecode, capital, metro_indicator, ncr_indicator],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'City_state city=$city updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'City_state city=$city did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'City_state Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCity_state.rawInsert(
          'INSERT OR IGNORE INTO city_state (city, citycode, statecode, capital, metro_indicator, ncr_indicator)  VALUES (?,?,?,?,?,?)',
          [city, citycode, statecode, capital, metro_indicator, ncr_indicator],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'City_state city=$city updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'City_state city=$city did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'City_state Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes City_state

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete City_state invoked (city=$city)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCity_state
          .delete(QueryParams(whereString: 'city=?', whereArguments: [city]));
    } else {
      return _mnCity_state.updateBatch(
          QueryParams(whereString: 'city=?', whereArguments: [city]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [City_state] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  City_stateFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return City_stateFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  City_stateFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return City_stateFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      city = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion city_state

// region City_stateField
class City_stateField extends FilterBase {
  City_stateField(City_stateFilterBuilder city_stateFB) : super(city_stateFB);

  @override
  City_stateFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder isNull() {
    return super.isNull() as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as City_stateFilterBuilder;
  }

  @override
  City_stateField get not {
    return super.not as City_stateField;
  }
}
// endregion City_stateField

// region City_stateFilterBuilder
class City_stateFilterBuilder extends ConjunctionBase {
  City_stateFilterBuilder(City_state obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCity_state = obj._mnCity_state;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  City_stateManager? _mnCity_state;

  /// put the sql keyword 'AND'
  @override
  City_stateFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  City_stateFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  City_stateFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  City_stateFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  City_stateFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  City_stateFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  City_stateFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  City_stateFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  City_stateFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  City_stateFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  City_stateFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  City_stateField _setField(
      City_stateField? field, String colName, DbType dbtype) {
    return City_stateField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  City_stateField? _city;
  City_stateField get city {
    return _city = _setField(_city, 'city', DbType.integer);
  }

  City_stateField? _citycode;
  City_stateField get citycode {
    return _citycode = _setField(_citycode, 'citycode', DbType.integer);
  }

  City_stateField? _statecode;
  City_stateField get statecode {
    return _statecode = _setField(_statecode, 'statecode', DbType.integer);
  }

  City_stateField? _capital;
  City_stateField get capital {
    return _capital = _setField(_capital, 'capital', DbType.text);
  }

  City_stateField? _metro_indicator;
  City_stateField get metro_indicator {
    return _metro_indicator =
        _setField(_metro_indicator, 'metro_indicator', DbType.text);
  }

  City_stateField? _ncr_indicator;
  City_stateField get ncr_indicator {
    return _ncr_indicator =
        _setField(_ncr_indicator, 'ncr_indicator', DbType.text);
  }

  /// Deletes List<City_state> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCity_state!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCity_state!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'city IN (SELECT city from city_state ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCity_state!.updateBatch(qparams, values);
  }

  /// This method always returns [City_state] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> City_state?
  @override
  Future<City_state?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCity_state!.toList(qparams);
    final data = await objFuture;
    City_state? obj;
    if (data.isNotEmpty) {
      obj = City_state.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [City_state]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> City_state?
  @override
  Future<City_state> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        City_state();
  }

  /// This method returns int. [City_state]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? city_stateCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final city_statesFuture = await _mnCity_state!.toList(qparams);
    final int count = city_statesFuture[0]['CNT'] as int;
    if (city_stateCount != null) {
      city_stateCount(count);
    }
    return count;
  }

  /// This method returns List<City_state> [City_state]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<City_state>
  @override
  Future<List<City_state>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<City_state> city_statesData = await City_state.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return city_statesData;
  }

  /// This method returns Json String [City_state]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [City_state]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [City_state]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCity_state!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [City_state]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `city` FROM city_state WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> cityData = <String>[];
    qparams.selectColumns = ['city'];
    final cityFuture = await _mnCity_state!.toList(qparams);

    final int count = cityFuture.length;
    for (int i = 0; i < count; i++) {
      cityData.add(cityFuture[i]['city'] as String);
    }
    return cityData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [City_state]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCity_state!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await City_state.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCity_state!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion City_stateFilterBuilder

// region City_stateFields
class City_stateFields {
  static TableField? _fCity;
  static TableField get city {
    return _fCity =
        _fCity ?? SqlSyntax.setField(_fCity, 'city', DbType.integer);
  }

  static TableField? _fCitycode;
  static TableField get citycode {
    return _fCitycode = _fCitycode ??
        SqlSyntax.setField(_fCitycode, 'citycode', DbType.integer);
  }

  static TableField? _fStatecode;
  static TableField get statecode {
    return _fStatecode = _fStatecode ??
        SqlSyntax.setField(_fStatecode, 'statecode', DbType.integer);
  }

  static TableField? _fCapital;
  static TableField get capital {
    return _fCapital =
        _fCapital ?? SqlSyntax.setField(_fCapital, 'capital', DbType.text);
  }

  static TableField? _fMetro_indicator;
  static TableField get metro_indicator {
    return _fMetro_indicator = _fMetro_indicator ??
        SqlSyntax.setField(_fMetro_indicator, 'metro_indicator', DbType.text);
  }

  static TableField? _fNcr_indicator;
  static TableField get ncr_indicator {
    return _fNcr_indicator = _fNcr_indicator ??
        SqlSyntax.setField(_fNcr_indicator, 'ncr_indicator', DbType.text);
  }
}
// endregion City_stateFields

//region City_stateManager
class City_stateManager extends SqfEntityProvider {
  City_stateManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'city_state';
  static const List<String> _primaryKeyList = ['city'];
  static const String _whereStr = 'city=?';
}

//endregion City_stateManager
// region Insurance
class Insurance extends TableBase {
  Insurance(
      {this.ServiceID,
      this.MinAmount,
      this.MaxAmount,
      this.Commission,
      this.ActivationDate,
      this.ExpiryDate}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Insurance.withFields(this.ServiceID, this.MinAmount, this.MaxAmount,
      this.Commission, this.ActivationDate, this.ExpiryDate) {
    _setDefaultValues();
  }
  Insurance.withId(this.ServiceID, this.MinAmount, this.MaxAmount,
      this.Commission, this.ActivationDate, this.ExpiryDate) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Insurance.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ServiceID = o['ServiceID'].toString();
    if (o['MinAmount'] != null) {
      MinAmount = double.tryParse(o['MinAmount'].toString());
    }
    if (o['MaxAmount'] != null) {
      MaxAmount = double.tryParse(o['MaxAmount'].toString());
    }
    if (o['Commission'] != null) {
      Commission = double.tryParse(o['Commission'].toString());
    }
    if (o['ActivationDate'] != null) {
      ActivationDate = double.tryParse(o['ActivationDate'].toString());
    }
    if (o['ExpiryDate'] != null) {
      ExpiryDate = double.tryParse(o['ExpiryDate'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Insurance)
  String? ServiceID;
  double? MinAmount;
  double? MaxAmount;
  double? Commission;
  double? ActivationDate;
  double? ExpiryDate;
  bool? isSaved;
  // end FIELDS (Insurance)

  static const bool _softDeleteActivated = false;
  InsuranceManager? __mnInsurance;

  InsuranceManager get _mnInsurance {
    return __mnInsurance = __mnInsurance ?? InsuranceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ServiceID'] = ServiceID;
    if (MinAmount != null || !forView) {
      map['MinAmount'] = MinAmount;
    }
    if (MaxAmount != null || !forView) {
      map['MaxAmount'] = MaxAmount;
    }
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (ActivationDate != null || !forView) {
      map['ActivationDate'] = ActivationDate;
    }
    if (ExpiryDate != null || !forView) {
      map['ExpiryDate'] = ExpiryDate;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ServiceID'] = ServiceID;
    if (MinAmount != null || !forView) {
      map['MinAmount'] = MinAmount;
    }
    if (MaxAmount != null || !forView) {
      map['MaxAmount'] = MaxAmount;
    }
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (ActivationDate != null || !forView) {
      map['ActivationDate'] = ActivationDate;
    }
    if (ExpiryDate != null || !forView) {
      map['ExpiryDate'] = ExpiryDate;
    }

    return map;
  }

  /// This method returns Json String [Insurance]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Insurance]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ServiceID,
      MinAmount,
      MaxAmount,
      Commission,
      ActivationDate,
      ExpiryDate
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ServiceID,
      MinAmount,
      MaxAmount,
      Commission,
      ActivationDate,
      ExpiryDate
    ];
  }

  static Future<List<Insurance>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Insurance.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Insurance>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Insurance>[];
    try {
      objList = list
          .map((insurance) =>
              Insurance.fromMap(insurance as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Insurance.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Insurance>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Insurance> objList = <Insurance>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Insurance.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Insurance by ID if exist, otherwise returns null
  /// Primary Keys: String? ServiceID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Insurance] if exist, otherwise returns null
  Future<Insurance?> getById(String? ServiceID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ServiceID == null) {
      return null;
    }
    Insurance? obj;
    final data = await _mnInsurance.getById([ServiceID]);
    if (data.length != 0) {
      obj = Insurance.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Insurance) object. If the Primary Key (ServiceID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ServiceID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnInsurance.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Insurance (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Insurance> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Insurance> insurances,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in insurances) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInsurance.rawInsert(
          'INSERT OR REPLACE INTO Insurance (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          [
            ServiceID,
            MinAmount,
            MaxAmount,
            Commission,
            ActivationDate,
            ExpiryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Insurance ServiceID=$ServiceID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Insurance ServiceID=$ServiceID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Insurance Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInsurance.rawInsert(
          'INSERT OR IGNORE INTO Insurance (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          [
            ServiceID,
            MinAmount,
            MaxAmount,
            Commission,
            ActivationDate,
            ExpiryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Insurance ServiceID=$ServiceID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Insurance ServiceID=$ServiceID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Insurance Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Insurance

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Insurance invoked (ServiceID=$ServiceID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInsurance.delete(
          QueryParams(whereString: 'ServiceID=?', whereArguments: [ServiceID]));
    } else {
      return _mnInsurance.updateBatch(
          QueryParams(whereString: 'ServiceID=?', whereArguments: [ServiceID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Insurance] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InsuranceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InsuranceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InsuranceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InsuranceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ServiceID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion insurance

// region InsuranceField
class InsuranceField extends FilterBase {
  InsuranceField(InsuranceFilterBuilder insuranceFB) : super(insuranceFB);

  @override
  InsuranceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder isNull() {
    return super.isNull() as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InsuranceFilterBuilder;
  }

  @override
  InsuranceField get not {
    return super.not as InsuranceField;
  }
}
// endregion InsuranceField

// region InsuranceFilterBuilder
class InsuranceFilterBuilder extends ConjunctionBase {
  InsuranceFilterBuilder(Insurance obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInsurance = obj._mnInsurance;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InsuranceManager? _mnInsurance;

  /// put the sql keyword 'AND'
  @override
  InsuranceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InsuranceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InsuranceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InsuranceFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InsuranceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InsuranceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InsuranceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InsuranceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InsuranceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InsuranceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InsuranceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InsuranceField _setField(
      InsuranceField? field, String colName, DbType dbtype) {
    return InsuranceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InsuranceField? _ServiceID;
  InsuranceField get ServiceID {
    return _ServiceID = _setField(_ServiceID, 'ServiceID', DbType.integer);
  }

  InsuranceField? _MinAmount;
  InsuranceField get MinAmount {
    return _MinAmount = _setField(_MinAmount, 'MinAmount', DbType.real);
  }

  InsuranceField? _MaxAmount;
  InsuranceField get MaxAmount {
    return _MaxAmount = _setField(_MaxAmount, 'MaxAmount', DbType.real);
  }

  InsuranceField? _Commission;
  InsuranceField get Commission {
    return _Commission = _setField(_Commission, 'Commission', DbType.real);
  }

  InsuranceField? _ActivationDate;
  InsuranceField get ActivationDate {
    return _ActivationDate =
        _setField(_ActivationDate, 'ActivationDate', DbType.real);
  }

  InsuranceField? _ExpiryDate;
  InsuranceField get ExpiryDate {
    return _ExpiryDate = _setField(_ExpiryDate, 'ExpiryDate', DbType.real);
  }

  /// Deletes List<Insurance> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInsurance!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInsurance!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ServiceID IN (SELECT ServiceID from Insurance ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInsurance!.updateBatch(qparams, values);
  }

  /// This method always returns [Insurance] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Insurance?
  @override
  Future<Insurance?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInsurance!.toList(qparams);
    final data = await objFuture;
    Insurance? obj;
    if (data.isNotEmpty) {
      obj = Insurance.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Insurance]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Insurance?
  @override
  Future<Insurance> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Insurance();
  }

  /// This method returns int. [Insurance]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? insuranceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final insurancesFuture = await _mnInsurance!.toList(qparams);
    final int count = insurancesFuture[0]['CNT'] as int;
    if (insuranceCount != null) {
      insuranceCount(count);
    }
    return count;
  }

  /// This method returns List<Insurance> [Insurance]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Insurance>
  @override
  Future<List<Insurance>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Insurance> insurancesData = await Insurance.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return insurancesData;
  }

  /// This method returns Json String [Insurance]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Insurance]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Insurance]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInsurance!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Insurance]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ServiceID` FROM Insurance WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ServiceIDData = <String>[];
    qparams.selectColumns = ['ServiceID'];
    final ServiceIDFuture = await _mnInsurance!.toList(qparams);

    final int count = ServiceIDFuture.length;
    for (int i = 0; i < count; i++) {
      ServiceIDData.add(ServiceIDFuture[i]['ServiceID'] as String);
    }
    return ServiceIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Insurance]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInsurance!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Insurance.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInsurance!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InsuranceFilterBuilder

// region InsuranceFields
class InsuranceFields {
  static TableField? _fServiceID;
  static TableField get ServiceID {
    return _fServiceID = _fServiceID ??
        SqlSyntax.setField(_fServiceID, 'serviceid', DbType.integer);
  }

  static TableField? _fMinAmount;
  static TableField get MinAmount {
    return _fMinAmount = _fMinAmount ??
        SqlSyntax.setField(_fMinAmount, 'MinAmount', DbType.real);
  }

  static TableField? _fMaxAmount;
  static TableField get MaxAmount {
    return _fMaxAmount = _fMaxAmount ??
        SqlSyntax.setField(_fMaxAmount, 'MaxAmount', DbType.real);
  }

  static TableField? _fCommission;
  static TableField get Commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'Commission', DbType.real);
  }

  static TableField? _fActivationDate;
  static TableField get ActivationDate {
    return _fActivationDate = _fActivationDate ??
        SqlSyntax.setField(_fActivationDate, 'ActivationDate', DbType.real);
  }

  static TableField? _fExpiryDate;
  static TableField get ExpiryDate {
    return _fExpiryDate = _fExpiryDate ??
        SqlSyntax.setField(_fExpiryDate, 'ExpiryDate', DbType.real);
  }
}
// endregion InsuranceFields

//region InsuranceManager
class InsuranceManager extends SqfEntityProvider {
  InsuranceManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Insurance';
  static const List<String> _primaryKeyList = ['ServiceID'];
  static const String _whereStr = 'ServiceID=?';
}

//endregion InsuranceManager
// region Local_pin
class Local_pin extends TableBase {
  Local_pin({this.SourcePinCode, this.LocalPinCode, this.Var1, this.ValidTo}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Local_pin.withFields(
      this.SourcePinCode, this.LocalPinCode, this.Var1, this.ValidTo) {
    _setDefaultValues();
  }
  Local_pin.withId(
      this.SourcePinCode, this.LocalPinCode, this.Var1, this.ValidTo) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Local_pin.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SourcePinCode = o['SourcePinCode'].toString();
    if (o['LocalPinCode'] != null) {
      LocalPinCode = o['LocalPinCode'].toString();
    }
    if (o['Var1'] != null) {
      Var1 = o['Var1'].toString();
    }
    if (o['ValidTo'] != null) {
      ValidTo = o['ValidTo'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Local_pin)
  String? SourcePinCode;
  String? LocalPinCode;
  String? Var1;
  String? ValidTo;
  bool? isSaved;
  // end FIELDS (Local_pin)

  static const bool _softDeleteActivated = false;
  Local_pinManager? __mnLocal_pin;

  Local_pinManager get _mnLocal_pin {
    return __mnLocal_pin = __mnLocal_pin ?? Local_pinManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SourcePinCode'] = SourcePinCode;
    if (LocalPinCode != null || !forView) {
      map['LocalPinCode'] = LocalPinCode;
    }
    if (Var1 != null || !forView) {
      map['Var1'] = Var1;
    }
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SourcePinCode'] = SourcePinCode;
    if (LocalPinCode != null || !forView) {
      map['LocalPinCode'] = LocalPinCode;
    }
    if (Var1 != null || !forView) {
      map['Var1'] = Var1;
    }
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }

    return map;
  }

  /// This method returns Json String [Local_pin]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Local_pin]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [SourcePinCode, LocalPinCode, Var1, ValidTo];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [SourcePinCode, LocalPinCode, Var1, ValidTo];
  }

  static Future<List<Local_pin>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Local_pin.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Local_pin>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Local_pin>[];
    try {
      objList = list
          .map((local_pin) =>
              Local_pin.fromMap(local_pin as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Local_pin.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Local_pin>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Local_pin> objList = <Local_pin>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Local_pin.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Local_pin by ID if exist, otherwise returns null
  /// Primary Keys: String? SourcePinCode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Local_pin] if exist, otherwise returns null
  Future<Local_pin?> getById(String? SourcePinCode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SourcePinCode == null) {
      return null;
    }
    Local_pin? obj;
    final data = await _mnLocal_pin.getById([SourcePinCode]);
    if (data.length != 0) {
      obj = Local_pin.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Local_pin) object. If the Primary Key (SourcePinCode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same SourcePinCode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnLocal_pin.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Local_pin (SourcePinCode, LocalPinCode, Var1, ValidTo)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Local_pin> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Local_pin> local_pins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in local_pins) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLocal_pin.rawInsert(
          'INSERT OR REPLACE INTO Local_pin (SourcePinCode, LocalPinCode, Var1, ValidTo)  VALUES (?,?,?,?)',
          [SourcePinCode, LocalPinCode, Var1, ValidTo],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Local_pin SourcePinCode=$SourcePinCode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Local_pin SourcePinCode=$SourcePinCode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Local_pin Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLocal_pin.rawInsert(
          'INSERT OR IGNORE INTO Local_pin (SourcePinCode, LocalPinCode, Var1, ValidTo)  VALUES (?,?,?,?)',
          [SourcePinCode, LocalPinCode, Var1, ValidTo],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Local_pin SourcePinCode=$SourcePinCode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Local_pin SourcePinCode=$SourcePinCode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Local_pin Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Local_pin

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Local_pin invoked (SourcePinCode=$SourcePinCode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLocal_pin.delete(QueryParams(
          whereString: 'SourcePinCode=?', whereArguments: [SourcePinCode]));
    } else {
      return _mnLocal_pin.updateBatch(
          QueryParams(
              whereString: 'SourcePinCode=?', whereArguments: [SourcePinCode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Local_pin] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Local_pinFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Local_pinFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Local_pinFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Local_pinFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SourcePinCode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion local_pin

// region Local_pinField
class Local_pinField extends FilterBase {
  Local_pinField(Local_pinFilterBuilder local_pinFB) : super(local_pinFB);

  @override
  Local_pinFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder isNull() {
    return super.isNull() as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Local_pinFilterBuilder;
  }

  @override
  Local_pinField get not {
    return super.not as Local_pinField;
  }
}
// endregion Local_pinField

// region Local_pinFilterBuilder
class Local_pinFilterBuilder extends ConjunctionBase {
  Local_pinFilterBuilder(Local_pin obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLocal_pin = obj._mnLocal_pin;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Local_pinManager? _mnLocal_pin;

  /// put the sql keyword 'AND'
  @override
  Local_pinFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Local_pinFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Local_pinFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Local_pinFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Local_pinFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Local_pinFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Local_pinFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Local_pinFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Local_pinFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Local_pinFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Local_pinFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Local_pinField _setField(
      Local_pinField? field, String colName, DbType dbtype) {
    return Local_pinField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Local_pinField? _SourcePinCode;
  Local_pinField get SourcePinCode {
    return _SourcePinCode =
        _setField(_SourcePinCode, 'SourcePinCode', DbType.integer);
  }

  Local_pinField? _LocalPinCode;
  Local_pinField get LocalPinCode {
    return _LocalPinCode =
        _setField(_LocalPinCode, 'LocalPinCode', DbType.text);
  }

  Local_pinField? _Var1;
  Local_pinField get Var1 {
    return _Var1 = _setField(_Var1, 'Var1', DbType.text);
  }

  Local_pinField? _ValidTo;
  Local_pinField get ValidTo {
    return _ValidTo = _setField(_ValidTo, 'ValidTo', DbType.text);
  }

  /// Deletes List<Local_pin> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLocal_pin!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLocal_pin!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SourcePinCode IN (SELECT SourcePinCode from Local_pin ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLocal_pin!.updateBatch(qparams, values);
  }

  /// This method always returns [Local_pin] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Local_pin?
  @override
  Future<Local_pin?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLocal_pin!.toList(qparams);
    final data = await objFuture;
    Local_pin? obj;
    if (data.isNotEmpty) {
      obj = Local_pin.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Local_pin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Local_pin?
  @override
  Future<Local_pin> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Local_pin();
  }

  /// This method returns int. [Local_pin]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? local_pinCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final local_pinsFuture = await _mnLocal_pin!.toList(qparams);
    final int count = local_pinsFuture[0]['CNT'] as int;
    if (local_pinCount != null) {
      local_pinCount(count);
    }
    return count;
  }

  /// This method returns List<Local_pin> [Local_pin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Local_pin>
  @override
  Future<List<Local_pin>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Local_pin> local_pinsData = await Local_pin.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return local_pinsData;
  }

  /// This method returns Json String [Local_pin]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Local_pin]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Local_pin]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLocal_pin!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Local_pin]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SourcePinCode` FROM Local_pin WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> SourcePinCodeData = <String>[];
    qparams.selectColumns = ['SourcePinCode'];
    final SourcePinCodeFuture = await _mnLocal_pin!.toList(qparams);

    final int count = SourcePinCodeFuture.length;
    for (int i = 0; i < count; i++) {
      SourcePinCodeData.add(SourcePinCodeFuture[i]['SourcePinCode'] as String);
    }
    return SourcePinCodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Local_pin]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLocal_pin!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Local_pin.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLocal_pin!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Local_pinFilterBuilder

// region Local_pinFields
class Local_pinFields {
  static TableField? _fSourcePinCode;
  static TableField get SourcePinCode {
    return _fSourcePinCode = _fSourcePinCode ??
        SqlSyntax.setField(_fSourcePinCode, 'sourcepincode', DbType.integer);
  }

  static TableField? _fLocalPinCode;
  static TableField get LocalPinCode {
    return _fLocalPinCode = _fLocalPinCode ??
        SqlSyntax.setField(_fLocalPinCode, 'LocalPinCode', DbType.text);
  }

  static TableField? _fVar1;
  static TableField get Var1 {
    return _fVar1 = _fVar1 ?? SqlSyntax.setField(_fVar1, 'Var1', DbType.text);
  }

  static TableField? _fValidTo;
  static TableField get ValidTo {
    return _fValidTo =
        _fValidTo ?? SqlSyntax.setField(_fValidTo, 'ValidTo', DbType.text);
  }
}
// endregion Local_pinFields

//region Local_pinManager
class Local_pinManager extends SqfEntityProvider {
  Local_pinManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Local_pin';
  static const List<String> _primaryKeyList = ['SourcePinCode'];
  static const String _whereStr = 'SourcePinCode=?';
}

//endregion Local_pinManager
// region OfficeMaster_Pincode
class OfficeMaster_Pincode extends TableBase {
  OfficeMaster_Pincode(
      {this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.field16,
      this.field17,
      this.Region,
      this.ReceiverCityDistrict}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  OfficeMaster_Pincode.withFields(
      this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.field16,
      this.field17,
      this.Region,
      this.ReceiverCityDistrict) {
    _setDefaultValues();
  }
  OfficeMaster_Pincode.withId(
      this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.field16,
      this.field17,
      this.Region,
      this.ReceiverCityDistrict) {
    _setDefaultValues();
  }
  // fromMap v2.0
  OfficeMaster_Pincode.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    FacilityID = o['FacilityID'].toString();
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['OfficeType'] != null) {
      OfficeType = o['OfficeType'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = int.tryParse(o['Pincode'].toString());
    }
    if (o['Delivery'] != null) {
      Delivery = o['Delivery'].toString();
    }
    if (o['Latitude'] != null) {
      Latitude = double.tryParse(o['Latitude'].toString());
    }
    if (o['Longitude'] != null) {
      Longitude = double.tryParse(o['Longitude'].toString());
    }
    if (o['SOName'] != null) {
      SOName = o['SOName'].toString();
    }
    if (o['HOName'] != null) {
      HOName = o['HOName'].toString();
    }
    if (o['DOName'] != null) {
      DOName = o['DOName'].toString();
    }
    if (o['ROName'] != null) {
      ROName = o['ROName'].toString();
    }
    if (o['COName'] != null) {
      COName = o['COName'].toString();
    }
    if (o['ContactNumber'] != null) {
      ContactNumber = int.tryParse(o['ContactNumber'].toString());
    }
    if (o['EndDate'] != null) {
      EndDate = int.tryParse(o['EndDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['EndDate'].toString())!)
          : DateTime.tryParse(o['EndDate'].toString());
    }
    if (o['ModifiedDate'] != null) {
      ModifiedDate = o['ModifiedDate'].toString();
    }
    if (o['field16'] != null) {
      field16 = o['field16'].toString();
    }
    if (o['field17'] != null) {
      field17 = o['field17'].toString();
    }
    if (o['Region'] != null) {
      Region = int.tryParse(o['Region'].toString());
    }
    if (o['ReceiverCityDistrict'] != null) {
      ReceiverCityDistrict = o['ReceiverCityDistrict'].toString();
    }

    isSaved = true;
  }
  // FIELDS (OfficeMaster_Pincode)
  String? FacilityID;
  String? OfficeName;
  String? OfficeType;
  int? Pincode;
  String? Delivery;
  double? Latitude;
  double? Longitude;
  String? SOName;
  String? HOName;
  String? DOName;
  String? ROName;
  String? COName;
  int? ContactNumber;
  DateTime? EndDate;
  String? ModifiedDate;
  String? field16;
  String? field17;
  int? Region;
  String? ReceiverCityDistrict;
  bool? isSaved;
  // end FIELDS (OfficeMaster_Pincode)

  static const bool _softDeleteActivated = false;
  OfficeMaster_PincodeManager? __mnOfficeMaster_Pincode;

  OfficeMaster_PincodeManager get _mnOfficeMaster_Pincode {
    return __mnOfficeMaster_Pincode =
        __mnOfficeMaster_Pincode ?? OfficeMaster_PincodeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['FacilityID'] = FacilityID;
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (OfficeType != null || !forView) {
      map['OfficeType'] = OfficeType;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (Delivery != null || !forView) {
      map['Delivery'] = Delivery;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (ROName != null || !forView) {
      map['ROName'] = ROName;
    }
    if (COName != null || !forView) {
      map['COName'] = COName;
    }
    if (ContactNumber != null || !forView) {
      map['ContactNumber'] = ContactNumber;
    }
    if (EndDate != null) {
      map['EndDate'] = forJson
          ? '$EndDate!.year-$EndDate!.month-$EndDate!.day'
          : forQuery
              ? DateTime(EndDate!.year, EndDate!.month, EndDate!.day)
                  .millisecondsSinceEpoch
              : EndDate;
    } else if (EndDate != null || !forView) {
      map['EndDate'] = null;
    }
    if (ModifiedDate != null || !forView) {
      map['ModifiedDate'] = ModifiedDate;
    }
    if (field16 != null || !forView) {
      map['field16'] = field16;
    }
    if (field17 != null || !forView) {
      map['field17'] = field17;
    }
    if (Region != null || !forView) {
      map['Region'] = Region;
    }
    if (ReceiverCityDistrict != null || !forView) {
      map['ReceiverCityDistrict'] = ReceiverCityDistrict;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['FacilityID'] = FacilityID;
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (OfficeType != null || !forView) {
      map['OfficeType'] = OfficeType;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (Delivery != null || !forView) {
      map['Delivery'] = Delivery;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (ROName != null || !forView) {
      map['ROName'] = ROName;
    }
    if (COName != null || !forView) {
      map['COName'] = COName;
    }
    if (ContactNumber != null || !forView) {
      map['ContactNumber'] = ContactNumber;
    }
    if (EndDate != null) {
      map['EndDate'] = forJson
          ? '$EndDate!.year-$EndDate!.month-$EndDate!.day'
          : forQuery
              ? DateTime(EndDate!.year, EndDate!.month, EndDate!.day)
                  .millisecondsSinceEpoch
              : EndDate;
    } else if (EndDate != null || !forView) {
      map['EndDate'] = null;
    }
    if (ModifiedDate != null || !forView) {
      map['ModifiedDate'] = ModifiedDate;
    }
    if (field16 != null || !forView) {
      map['field16'] = field16;
    }
    if (field17 != null || !forView) {
      map['field17'] = field17;
    }
    if (Region != null || !forView) {
      map['Region'] = Region;
    }
    if (ReceiverCityDistrict != null || !forView) {
      map['ReceiverCityDistrict'] = ReceiverCityDistrict;
    }

    return map;
  }

  /// This method returns Json String [OfficeMaster_Pincode]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [OfficeMaster_Pincode]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityID,
      OfficeName,
      OfficeType,
      Pincode,
      Delivery,
      Latitude,
      Longitude,
      SOName,
      HOName,
      DOName,
      ROName,
      COName,
      ContactNumber,
      EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
      ModifiedDate,
      field16,
      field17,
      Region,
      ReceiverCityDistrict
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      FacilityID,
      OfficeName,
      OfficeType,
      Pincode,
      Delivery,
      Latitude,
      Longitude,
      SOName,
      HOName,
      DOName,
      ROName,
      COName,
      ContactNumber,
      EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
      ModifiedDate,
      field16,
      field17,
      Region,
      ReceiverCityDistrict
    ];
  }

  static Future<List<OfficeMaster_Pincode>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OfficeMaster_Pincode.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<OfficeMaster_Pincode>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <OfficeMaster_Pincode>[];
    try {
      objList = list
          .map((officemaster_pincode) => OfficeMaster_Pincode.fromMap(
              officemaster_pincode as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OfficeMaster_Pincode.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<OfficeMaster_Pincode>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<OfficeMaster_Pincode> objList = <OfficeMaster_Pincode>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = OfficeMaster_Pincode.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns OfficeMaster_Pincode by ID if exist, otherwise returns null
  /// Primary Keys: String? FacilityID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [OfficeMaster_Pincode] if exist, otherwise returns null
  Future<OfficeMaster_Pincode?> getById(String? FacilityID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (FacilityID == null) {
      return null;
    }
    OfficeMaster_Pincode? obj;
    final data = await _mnOfficeMaster_Pincode.getById([FacilityID]);
    if (data.length != 0) {
      obj = OfficeMaster_Pincode.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (OfficeMaster_Pincode) object. If the Primary Key (FacilityID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same FacilityID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnOfficeMaster_Pincode.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO OfficeMaster_Pincodes (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, field16, field17, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<OfficeMaster_Pincode> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<OfficeMaster_Pincode> officemaster_pincodes,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in officemaster_pincodes) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOfficeMaster_Pincode.rawInsert(
          'INSERT OR REPLACE INTO OfficeMaster_Pincodes (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, field16, field17, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            FacilityID,
            OfficeName,
            OfficeType,
            Pincode,
            Delivery,
            Latitude,
            Longitude,
            SOName,
            HOName,
            DOName,
            ROName,
            COName,
            ContactNumber,
            EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
            ModifiedDate,
            field16,
            field17,
            Region,
            ReceiverCityDistrict
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'OfficeMaster_Pincode FacilityID=$FacilityID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'OfficeMaster_Pincode FacilityID=$FacilityID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'OfficeMaster_Pincode Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOfficeMaster_Pincode.rawInsert(
          'INSERT OR IGNORE INTO OfficeMaster_Pincodes (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, field16, field17, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            FacilityID,
            OfficeName,
            OfficeType,
            Pincode,
            Delivery,
            Latitude,
            Longitude,
            SOName,
            HOName,
            DOName,
            ROName,
            COName,
            ContactNumber,
            EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
            ModifiedDate,
            field16,
            field17,
            Region,
            ReceiverCityDistrict
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'OfficeMaster_Pincode FacilityID=$FacilityID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'OfficeMaster_Pincode FacilityID=$FacilityID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'OfficeMaster_Pincode Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes OfficeMaster_Pincode

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete OfficeMaster_Pincode invoked (FacilityID=$FacilityID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnOfficeMaster_Pincode.delete(QueryParams(
          whereString: 'FacilityID=?', whereArguments: [FacilityID]));
    } else {
      return _mnOfficeMaster_Pincode.updateBatch(
          QueryParams(
              whereString: 'FacilityID=?', whereArguments: [FacilityID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [OfficeMaster_Pincode] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  OfficeMaster_PincodeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OfficeMaster_PincodeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  OfficeMaster_PincodeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OfficeMaster_PincodeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      FacilityID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion officemaster_pincode

// region OfficeMaster_PincodeField
class OfficeMaster_PincodeField extends FilterBase {
  OfficeMaster_PincodeField(
      OfficeMaster_PincodeFilterBuilder officemaster_pincodeFB)
      : super(officemaster_pincodeFB);

  @override
  OfficeMaster_PincodeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder isNull() {
    return super.isNull() as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as OfficeMaster_PincodeFilterBuilder;
  }

  @override
  OfficeMaster_PincodeField get not {
    return super.not as OfficeMaster_PincodeField;
  }
}
// endregion OfficeMaster_PincodeField

// region OfficeMaster_PincodeFilterBuilder
class OfficeMaster_PincodeFilterBuilder extends ConjunctionBase {
  OfficeMaster_PincodeFilterBuilder(
      OfficeMaster_Pincode obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnOfficeMaster_Pincode = obj._mnOfficeMaster_Pincode;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  OfficeMaster_PincodeManager? _mnOfficeMaster_Pincode;

  /// put the sql keyword 'AND'
  @override
  OfficeMaster_PincodeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  OfficeMaster_PincodeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  OfficeMaster_PincodeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  OfficeMaster_PincodeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  OfficeMaster_PincodeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  OfficeMaster_PincodeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  OfficeMaster_PincodeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OfficeMaster_PincodeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OfficeMaster_PincodeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OfficeMaster_PincodeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OfficeMaster_PincodeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  OfficeMaster_PincodeField _setField(
      OfficeMaster_PincodeField? field, String colName, DbType dbtype) {
    return OfficeMaster_PincodeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  OfficeMaster_PincodeField? _FacilityID;
  OfficeMaster_PincodeField get FacilityID {
    return _FacilityID = _setField(_FacilityID, 'FacilityID', DbType.integer);
  }

  OfficeMaster_PincodeField? _OfficeName;
  OfficeMaster_PincodeField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  OfficeMaster_PincodeField? _OfficeType;
  OfficeMaster_PincodeField get OfficeType {
    return _OfficeType = _setField(_OfficeType, 'OfficeType', DbType.text);
  }

  OfficeMaster_PincodeField? _Pincode;
  OfficeMaster_PincodeField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.integer);
  }

  OfficeMaster_PincodeField? _Delivery;
  OfficeMaster_PincodeField get Delivery {
    return _Delivery = _setField(_Delivery, 'Delivery', DbType.text);
  }

  OfficeMaster_PincodeField? _Latitude;
  OfficeMaster_PincodeField get Latitude {
    return _Latitude = _setField(_Latitude, 'Latitude', DbType.real);
  }

  OfficeMaster_PincodeField? _Longitude;
  OfficeMaster_PincodeField get Longitude {
    return _Longitude = _setField(_Longitude, 'Longitude', DbType.real);
  }

  OfficeMaster_PincodeField? _SOName;
  OfficeMaster_PincodeField get SOName {
    return _SOName = _setField(_SOName, 'SOName', DbType.text);
  }

  OfficeMaster_PincodeField? _HOName;
  OfficeMaster_PincodeField get HOName {
    return _HOName = _setField(_HOName, 'HOName', DbType.text);
  }

  OfficeMaster_PincodeField? _DOName;
  OfficeMaster_PincodeField get DOName {
    return _DOName = _setField(_DOName, 'DOName', DbType.text);
  }

  OfficeMaster_PincodeField? _ROName;
  OfficeMaster_PincodeField get ROName {
    return _ROName = _setField(_ROName, 'ROName', DbType.text);
  }

  OfficeMaster_PincodeField? _COName;
  OfficeMaster_PincodeField get COName {
    return _COName = _setField(_COName, 'COName', DbType.text);
  }

  OfficeMaster_PincodeField? _ContactNumber;
  OfficeMaster_PincodeField get ContactNumber {
    return _ContactNumber =
        _setField(_ContactNumber, 'ContactNumber', DbType.integer);
  }

  OfficeMaster_PincodeField? _EndDate;
  OfficeMaster_PincodeField get EndDate {
    return _EndDate = _setField(_EndDate, 'EndDate', DbType.date);
  }

  OfficeMaster_PincodeField? _ModifiedDate;
  OfficeMaster_PincodeField get ModifiedDate {
    return _ModifiedDate =
        _setField(_ModifiedDate, 'ModifiedDate', DbType.text);
  }

  OfficeMaster_PincodeField? _field16;
  OfficeMaster_PincodeField get field16 {
    return _field16 = _setField(_field16, 'field16', DbType.text);
  }

  OfficeMaster_PincodeField? _field17;
  OfficeMaster_PincodeField get field17 {
    return _field17 = _setField(_field17, 'field17', DbType.text);
  }

  OfficeMaster_PincodeField? _Region;
  OfficeMaster_PincodeField get Region {
    return _Region = _setField(_Region, 'Region', DbType.integer);
  }

  OfficeMaster_PincodeField? _ReceiverCityDistrict;
  OfficeMaster_PincodeField get ReceiverCityDistrict {
    return _ReceiverCityDistrict =
        _setField(_ReceiverCityDistrict, 'ReceiverCityDistrict', DbType.text);
  }

  /// Deletes List<OfficeMaster_Pincode> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnOfficeMaster_Pincode!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnOfficeMaster_Pincode!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'FacilityID IN (SELECT FacilityID from OfficeMaster_Pincodes ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnOfficeMaster_Pincode!.updateBatch(qparams, values);
  }

  /// This method always returns [OfficeMaster_Pincode] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OfficeMaster_Pincode?
  @override
  Future<OfficeMaster_Pincode?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnOfficeMaster_Pincode!.toList(qparams);
    final data = await objFuture;
    OfficeMaster_Pincode? obj;
    if (data.isNotEmpty) {
      obj = OfficeMaster_Pincode.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [OfficeMaster_Pincode]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OfficeMaster_Pincode?
  @override
  Future<OfficeMaster_Pincode> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        OfficeMaster_Pincode();
  }

  /// This method returns int. [OfficeMaster_Pincode]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? officemaster_pincodeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final officemaster_pincodesFuture =
        await _mnOfficeMaster_Pincode!.toList(qparams);
    final int count = officemaster_pincodesFuture[0]['CNT'] as int;
    if (officemaster_pincodeCount != null) {
      officemaster_pincodeCount(count);
    }
    return count;
  }

  /// This method returns List<OfficeMaster_Pincode> [OfficeMaster_Pincode]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<OfficeMaster_Pincode>
  @override
  Future<List<OfficeMaster_Pincode>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<OfficeMaster_Pincode> officemaster_pincodesData =
        await OfficeMaster_Pincode.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return officemaster_pincodesData;
  }

  /// This method returns Json String [OfficeMaster_Pincode]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [OfficeMaster_Pincode]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [OfficeMaster_Pincode]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnOfficeMaster_Pincode!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [OfficeMaster_Pincode]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `FacilityID` FROM OfficeMaster_Pincodes WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> FacilityIDData = <String>[];
    qparams.selectColumns = ['FacilityID'];
    final FacilityIDFuture = await _mnOfficeMaster_Pincode!.toList(qparams);

    final int count = FacilityIDFuture.length;
    for (int i = 0; i < count; i++) {
      FacilityIDData.add(FacilityIDFuture[i]['FacilityID'] as String);
    }
    return FacilityIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [OfficeMaster_Pincode]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnOfficeMaster_Pincode!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await OfficeMaster_Pincode.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnOfficeMaster_Pincode!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion OfficeMaster_PincodeFilterBuilder

// region OfficeMaster_PincodeFields
class OfficeMaster_PincodeFields {
  static TableField? _fFacilityID;
  static TableField get FacilityID {
    return _fFacilityID = _fFacilityID ??
        SqlSyntax.setField(_fFacilityID, 'facilityid', DbType.integer);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fOfficeType;
  static TableField get OfficeType {
    return _fOfficeType = _fOfficeType ??
        SqlSyntax.setField(_fOfficeType, 'OfficeType', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.integer);
  }

  static TableField? _fDelivery;
  static TableField get Delivery {
    return _fDelivery =
        _fDelivery ?? SqlSyntax.setField(_fDelivery, 'Delivery', DbType.text);
  }

  static TableField? _fLatitude;
  static TableField get Latitude {
    return _fLatitude =
        _fLatitude ?? SqlSyntax.setField(_fLatitude, 'Latitude', DbType.real);
  }

  static TableField? _fLongitude;
  static TableField get Longitude {
    return _fLongitude = _fLongitude ??
        SqlSyntax.setField(_fLongitude, 'Longitude', DbType.real);
  }

  static TableField? _fSOName;
  static TableField get SOName {
    return _fSOName =
        _fSOName ?? SqlSyntax.setField(_fSOName, 'SOName', DbType.text);
  }

  static TableField? _fHOName;
  static TableField get HOName {
    return _fHOName =
        _fHOName ?? SqlSyntax.setField(_fHOName, 'HOName', DbType.text);
  }

  static TableField? _fDOName;
  static TableField get DOName {
    return _fDOName =
        _fDOName ?? SqlSyntax.setField(_fDOName, 'DOName', DbType.text);
  }

  static TableField? _fROName;
  static TableField get ROName {
    return _fROName =
        _fROName ?? SqlSyntax.setField(_fROName, 'ROName', DbType.text);
  }

  static TableField? _fCOName;
  static TableField get COName {
    return _fCOName =
        _fCOName ?? SqlSyntax.setField(_fCOName, 'COName', DbType.text);
  }

  static TableField? _fContactNumber;
  static TableField get ContactNumber {
    return _fContactNumber = _fContactNumber ??
        SqlSyntax.setField(_fContactNumber, 'ContactNumber', DbType.integer);
  }

  static TableField? _fEndDate;
  static TableField get EndDate {
    return _fEndDate =
        _fEndDate ?? SqlSyntax.setField(_fEndDate, 'EndDate', DbType.date);
  }

  static TableField? _fModifiedDate;
  static TableField get ModifiedDate {
    return _fModifiedDate = _fModifiedDate ??
        SqlSyntax.setField(_fModifiedDate, 'ModifiedDate', DbType.text);
  }

  static TableField? _fField16;
  static TableField get field16 {
    return _fField16 =
        _fField16 ?? SqlSyntax.setField(_fField16, 'field16', DbType.text);
  }

  static TableField? _fField17;
  static TableField get field17 {
    return _fField17 =
        _fField17 ?? SqlSyntax.setField(_fField17, 'field17', DbType.text);
  }

  static TableField? _fRegion;
  static TableField get Region {
    return _fRegion =
        _fRegion ?? SqlSyntax.setField(_fRegion, 'Region', DbType.integer);
  }

  static TableField? _fReceiverCityDistrict;
  static TableField get ReceiverCityDistrict {
    return _fReceiverCityDistrict = _fReceiverCityDistrict ??
        SqlSyntax.setField(
            _fReceiverCityDistrict, 'ReceiverCityDistrict', DbType.text);
  }
}
// endregion OfficeMaster_PincodeFields

//region OfficeMaster_PincodeManager
class OfficeMaster_PincodeManager extends SqfEntityProvider {
  OfficeMaster_PincodeManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'OfficeMaster_Pincodes';
  static const List<String> _primaryKeyList = ['FacilityID'];
  static const String _whereStr = 'FacilityID=?';
}

//endregion OfficeMaster_PincodeManager
// region PeriodicalWeight
class PeriodicalWeight extends TableBase {
  PeriodicalWeight(
      {this.Weight, this.WeightDescriptionStart, this.WeightDescriptionEnd}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  PeriodicalWeight.withFields(
      this.Weight, this.WeightDescriptionStart, this.WeightDescriptionEnd) {
    _setDefaultValues();
  }
  PeriodicalWeight.withId(
      this.Weight, this.WeightDescriptionStart, this.WeightDescriptionEnd) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PeriodicalWeight.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Weight = o['Weight'].toString();
    if (o['WeightDescriptionStart'] != null) {
      WeightDescriptionStart =
          double.tryParse(o['WeightDescriptionStart'].toString());
    }
    if (o['WeightDescriptionEnd'] != null) {
      WeightDescriptionEnd =
          double.tryParse(o['WeightDescriptionEnd'].toString());
    }

    isSaved = true;
  }
  // FIELDS (PeriodicalWeight)
  String? Weight;
  double? WeightDescriptionStart;
  double? WeightDescriptionEnd;
  bool? isSaved;
  // end FIELDS (PeriodicalWeight)

  static const bool _softDeleteActivated = false;
  PeriodicalWeightManager? __mnPeriodicalWeight;

  PeriodicalWeightManager get _mnPeriodicalWeight {
    return __mnPeriodicalWeight =
        __mnPeriodicalWeight ?? PeriodicalWeightManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Weight'] = Weight;
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Weight'] = Weight;
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }

    return map;
  }

  /// This method returns Json String [PeriodicalWeight]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PeriodicalWeight]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Weight, WeightDescriptionStart, WeightDescriptionEnd];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Weight, WeightDescriptionStart, WeightDescriptionEnd];
  }

  static Future<List<PeriodicalWeight>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PeriodicalWeight.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PeriodicalWeight>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PeriodicalWeight>[];
    try {
      objList = list
          .map((periodicalweight) => PeriodicalWeight.fromMap(
              periodicalweight as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PeriodicalWeight.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PeriodicalWeight>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PeriodicalWeight> objList = <PeriodicalWeight>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PeriodicalWeight.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns PeriodicalWeight by ID if exist, otherwise returns null
  /// Primary Keys: String? Weight
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PeriodicalWeight] if exist, otherwise returns null
  Future<PeriodicalWeight?> getById(String? Weight,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Weight == null) {
      return null;
    }
    PeriodicalWeight? obj;
    final data = await _mnPeriodicalWeight.getById([Weight]);
    if (data.length != 0) {
      obj = PeriodicalWeight.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PeriodicalWeight) object. If the Primary Key (Weight) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Weight
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPeriodicalWeight.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO PeriodicalWeight (Weight, WeightDescriptionStart, WeightDescriptionEnd)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<PeriodicalWeight> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<PeriodicalWeight> periodicalweights,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in periodicalweights) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPeriodicalWeight.rawInsert(
          'INSERT OR REPLACE INTO PeriodicalWeight (Weight, WeightDescriptionStart, WeightDescriptionEnd)  VALUES (?,?,?)',
          [Weight, WeightDescriptionStart, WeightDescriptionEnd],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PeriodicalWeight Weight=$Weight updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PeriodicalWeight Weight=$Weight did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PeriodicalWeight Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPeriodicalWeight.rawInsert(
          'INSERT OR IGNORE INTO PeriodicalWeight (Weight, WeightDescriptionStart, WeightDescriptionEnd)  VALUES (?,?,?)',
          [Weight, WeightDescriptionStart, WeightDescriptionEnd],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PeriodicalWeight Weight=$Weight updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'PeriodicalWeight Weight=$Weight did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PeriodicalWeight Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes PeriodicalWeight

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete PeriodicalWeight invoked (Weight=$Weight)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPeriodicalWeight.delete(
          QueryParams(whereString: 'Weight=?', whereArguments: [Weight]));
    } else {
      return _mnPeriodicalWeight.updateBatch(
          QueryParams(whereString: 'Weight=?', whereArguments: [Weight]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [PeriodicalWeight] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PeriodicalWeightFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodicalWeightFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PeriodicalWeightFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodicalWeightFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Weight = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion periodicalweight

// region PeriodicalWeightField
class PeriodicalWeightField extends FilterBase {
  PeriodicalWeightField(PeriodicalWeightFilterBuilder periodicalweightFB)
      : super(periodicalweightFB);

  @override
  PeriodicalWeightFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder isNull() {
    return super.isNull() as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PeriodicalWeightFilterBuilder;
  }

  @override
  PeriodicalWeightField get not {
    return super.not as PeriodicalWeightField;
  }
}
// endregion PeriodicalWeightField

// region PeriodicalWeightFilterBuilder
class PeriodicalWeightFilterBuilder extends ConjunctionBase {
  PeriodicalWeightFilterBuilder(PeriodicalWeight obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPeriodicalWeight = obj._mnPeriodicalWeight;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PeriodicalWeightManager? _mnPeriodicalWeight;

  /// put the sql keyword 'AND'
  @override
  PeriodicalWeightFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PeriodicalWeightFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PeriodicalWeightFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PeriodicalWeightFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PeriodicalWeightFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PeriodicalWeightFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PeriodicalWeightFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodicalWeightFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodicalWeightFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodicalWeightFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodicalWeightFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PeriodicalWeightField _setField(
      PeriodicalWeightField? field, String colName, DbType dbtype) {
    return PeriodicalWeightField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PeriodicalWeightField? _Weight;
  PeriodicalWeightField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.integer);
  }

  PeriodicalWeightField? _WeightDescriptionStart;
  PeriodicalWeightField get WeightDescriptionStart {
    return _WeightDescriptionStart = _setField(
        _WeightDescriptionStart, 'WeightDescriptionStart', DbType.real);
  }

  PeriodicalWeightField? _WeightDescriptionEnd;
  PeriodicalWeightField get WeightDescriptionEnd {
    return _WeightDescriptionEnd =
        _setField(_WeightDescriptionEnd, 'WeightDescriptionEnd', DbType.real);
  }

  /// Deletes List<PeriodicalWeight> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPeriodicalWeight!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPeriodicalWeight!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Weight IN (SELECT Weight from PeriodicalWeight ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPeriodicalWeight!.updateBatch(qparams, values);
  }

  /// This method always returns [PeriodicalWeight] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PeriodicalWeight?
  @override
  Future<PeriodicalWeight?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPeriodicalWeight!.toList(qparams);
    final data = await objFuture;
    PeriodicalWeight? obj;
    if (data.isNotEmpty) {
      obj = PeriodicalWeight.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PeriodicalWeight]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PeriodicalWeight?
  @override
  Future<PeriodicalWeight> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PeriodicalWeight();
  }

  /// This method returns int. [PeriodicalWeight]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? periodicalweightCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final periodicalweightsFuture = await _mnPeriodicalWeight!.toList(qparams);
    final int count = periodicalweightsFuture[0]['CNT'] as int;
    if (periodicalweightCount != null) {
      periodicalweightCount(count);
    }
    return count;
  }

  /// This method returns List<PeriodicalWeight> [PeriodicalWeight]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PeriodicalWeight>
  @override
  Future<List<PeriodicalWeight>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PeriodicalWeight> periodicalweightsData =
        await PeriodicalWeight.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return periodicalweightsData;
  }

  /// This method returns Json String [PeriodicalWeight]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PeriodicalWeight]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PeriodicalWeight]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPeriodicalWeight!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PeriodicalWeight]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Weight` FROM PeriodicalWeight WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> WeightData = <String>[];
    qparams.selectColumns = ['Weight'];
    final WeightFuture = await _mnPeriodicalWeight!.toList(qparams);

    final int count = WeightFuture.length;
    for (int i = 0; i < count; i++) {
      WeightData.add(WeightFuture[i]['Weight'] as String);
    }
    return WeightData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PeriodicalWeight]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPeriodicalWeight!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PeriodicalWeight.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPeriodicalWeight!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PeriodicalWeightFilterBuilder

// region PeriodicalWeightFields
class PeriodicalWeightFields {
  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'weight', DbType.integer);
  }

  static TableField? _fWeightDescriptionStart;
  static TableField get WeightDescriptionStart {
    return _fWeightDescriptionStart = _fWeightDescriptionStart ??
        SqlSyntax.setField(
            _fWeightDescriptionStart, 'WeightDescriptionStart', DbType.real);
  }

  static TableField? _fWeightDescriptionEnd;
  static TableField get WeightDescriptionEnd {
    return _fWeightDescriptionEnd = _fWeightDescriptionEnd ??
        SqlSyntax.setField(
            _fWeightDescriptionEnd, 'WeightDescriptionEnd', DbType.real);
  }
}
// endregion PeriodicalWeightFields

//region PeriodicalWeightManager
class PeriodicalWeightManager extends SqfEntityProvider {
  PeriodicalWeightManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'PeriodicalWeight';
  static const List<String> _primaryKeyList = ['Weight'];
  static const String _whereStr = 'Weight=?';
}

//endregion PeriodicalWeightManager
// region Periodical
class Periodical extends TableBase {
  Periodical(
      {this.PeriodicalVariant,
      this.PeriodicalValueMin,
      this.PeriodicalValueMax}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Periodical.withFields(this.PeriodicalVariant, this.PeriodicalValueMin,
      this.PeriodicalValueMax) {
    _setDefaultValues();
  }
  Periodical.withId(this.PeriodicalVariant, this.PeriodicalValueMin,
      this.PeriodicalValueMax) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Periodical.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    PeriodicalVariant = o['PeriodicalVariant'].toString();
    if (o['PeriodicalValueMin'] != null) {
      PeriodicalValueMin = double.tryParse(o['PeriodicalValueMin'].toString());
    }
    if (o['PeriodicalValueMax'] != null) {
      PeriodicalValueMax = double.tryParse(o['PeriodicalValueMax'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Periodical)
  String? PeriodicalVariant;
  double? PeriodicalValueMin;
  double? PeriodicalValueMax;
  bool? isSaved;
  // end FIELDS (Periodical)

  static const bool _softDeleteActivated = false;
  PeriodicalManager? __mnPeriodical;

  PeriodicalManager get _mnPeriodical {
    return __mnPeriodical = __mnPeriodical ?? PeriodicalManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['PeriodicalVariant'] = PeriodicalVariant;
    if (PeriodicalValueMin != null || !forView) {
      map['PeriodicalValueMin'] = PeriodicalValueMin;
    }
    if (PeriodicalValueMax != null || !forView) {
      map['PeriodicalValueMax'] = PeriodicalValueMax;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['PeriodicalVariant'] = PeriodicalVariant;
    if (PeriodicalValueMin != null || !forView) {
      map['PeriodicalValueMin'] = PeriodicalValueMin;
    }
    if (PeriodicalValueMax != null || !forView) {
      map['PeriodicalValueMax'] = PeriodicalValueMax;
    }

    return map;
  }

  /// This method returns Json String [Periodical]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Periodical]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax];
  }

  static Future<List<Periodical>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Periodical.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Periodical>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Periodical>[];
    try {
      objList = list
          .map((periodical) =>
              Periodical.fromMap(periodical as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Periodical.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Periodical>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Periodical> objList = <Periodical>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Periodical.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Periodical by ID if exist, otherwise returns null
  /// Primary Keys: String? PeriodicalVariant
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Periodical] if exist, otherwise returns null
  Future<Periodical?> getById(String? PeriodicalVariant,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (PeriodicalVariant == null) {
      return null;
    }
    Periodical? obj;
    final data = await _mnPeriodical.getById([PeriodicalVariant]);
    if (data.length != 0) {
      obj = Periodical.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Periodical) object. If the Primary Key (PeriodicalVariant) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same PeriodicalVariant
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPeriodical.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Periodicals (PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Periodical> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Periodical> periodicals,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in periodicals) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPeriodical.rawInsert(
          'INSERT OR REPLACE INTO Periodicals (PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax)  VALUES (?,?,?)',
          [PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Periodical PeriodicalVariant=$PeriodicalVariant updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Periodical PeriodicalVariant=$PeriodicalVariant did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Periodical Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPeriodical.rawInsert(
          'INSERT OR IGNORE INTO Periodicals (PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax)  VALUES (?,?,?)',
          [PeriodicalVariant, PeriodicalValueMin, PeriodicalValueMax],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Periodical PeriodicalVariant=$PeriodicalVariant updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Periodical PeriodicalVariant=$PeriodicalVariant did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Periodical Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Periodical

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Periodical invoked (PeriodicalVariant=$PeriodicalVariant)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPeriodical.delete(QueryParams(
          whereString: 'PeriodicalVariant=?',
          whereArguments: [PeriodicalVariant]));
    } else {
      return _mnPeriodical.updateBatch(
          QueryParams(
              whereString: 'PeriodicalVariant=?',
              whereArguments: [PeriodicalVariant]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Periodical] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PeriodicalFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodicalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PeriodicalFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PeriodicalFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      PeriodicalVariant = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion periodical

// region PeriodicalField
class PeriodicalField extends FilterBase {
  PeriodicalField(PeriodicalFilterBuilder periodicalFB) : super(periodicalFB);

  @override
  PeriodicalFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder isNull() {
    return super.isNull() as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PeriodicalFilterBuilder;
  }

  @override
  PeriodicalField get not {
    return super.not as PeriodicalField;
  }
}
// endregion PeriodicalField

// region PeriodicalFilterBuilder
class PeriodicalFilterBuilder extends ConjunctionBase {
  PeriodicalFilterBuilder(Periodical obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPeriodical = obj._mnPeriodical;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PeriodicalManager? _mnPeriodical;

  /// put the sql keyword 'AND'
  @override
  PeriodicalFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PeriodicalFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PeriodicalFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PeriodicalFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PeriodicalFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PeriodicalFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PeriodicalFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodicalFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodicalFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PeriodicalFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PeriodicalFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PeriodicalField _setField(
      PeriodicalField? field, String colName, DbType dbtype) {
    return PeriodicalField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PeriodicalField? _PeriodicalVariant;
  PeriodicalField get PeriodicalVariant {
    return _PeriodicalVariant =
        _setField(_PeriodicalVariant, 'PeriodicalVariant', DbType.integer);
  }

  PeriodicalField? _PeriodicalValueMin;
  PeriodicalField get PeriodicalValueMin {
    return _PeriodicalValueMin =
        _setField(_PeriodicalValueMin, 'PeriodicalValueMin', DbType.real);
  }

  PeriodicalField? _PeriodicalValueMax;
  PeriodicalField get PeriodicalValueMax {
    return _PeriodicalValueMax =
        _setField(_PeriodicalValueMax, 'PeriodicalValueMax', DbType.real);
  }

  /// Deletes List<Periodical> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPeriodical!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPeriodical!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'PeriodicalVariant IN (SELECT PeriodicalVariant from Periodicals ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPeriodical!.updateBatch(qparams, values);
  }

  /// This method always returns [Periodical] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Periodical?
  @override
  Future<Periodical?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPeriodical!.toList(qparams);
    final data = await objFuture;
    Periodical? obj;
    if (data.isNotEmpty) {
      obj = Periodical.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Periodical]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Periodical?
  @override
  Future<Periodical> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Periodical();
  }

  /// This method returns int. [Periodical]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? periodicalCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final periodicalsFuture = await _mnPeriodical!.toList(qparams);
    final int count = periodicalsFuture[0]['CNT'] as int;
    if (periodicalCount != null) {
      periodicalCount(count);
    }
    return count;
  }

  /// This method returns List<Periodical> [Periodical]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Periodical>
  @override
  Future<List<Periodical>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Periodical> periodicalsData = await Periodical.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return periodicalsData;
  }

  /// This method returns Json String [Periodical]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Periodical]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Periodical]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPeriodical!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Periodical]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `PeriodicalVariant` FROM Periodicals WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> PeriodicalVariantData = <String>[];
    qparams.selectColumns = ['PeriodicalVariant'];
    final PeriodicalVariantFuture = await _mnPeriodical!.toList(qparams);

    final int count = PeriodicalVariantFuture.length;
    for (int i = 0; i < count; i++) {
      PeriodicalVariantData.add(
          PeriodicalVariantFuture[i]['PeriodicalVariant'] as String);
    }
    return PeriodicalVariantData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Periodical]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPeriodical!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Periodical.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPeriodical!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PeriodicalFilterBuilder

// region PeriodicalFields
class PeriodicalFields {
  static TableField? _fPeriodicalVariant;
  static TableField get PeriodicalVariant {
    return _fPeriodicalVariant = _fPeriodicalVariant ??
        SqlSyntax.setField(
            _fPeriodicalVariant, 'periodicalvariant', DbType.integer);
  }

  static TableField? _fPeriodicalValueMin;
  static TableField get PeriodicalValueMin {
    return _fPeriodicalValueMin = _fPeriodicalValueMin ??
        SqlSyntax.setField(
            _fPeriodicalValueMin, 'PeriodicalValueMin', DbType.real);
  }

  static TableField? _fPeriodicalValueMax;
  static TableField get PeriodicalValueMax {
    return _fPeriodicalValueMax = _fPeriodicalValueMax ??
        SqlSyntax.setField(
            _fPeriodicalValueMax, 'PeriodicalValueMax', DbType.real);
  }
}
// endregion PeriodicalFields

//region PeriodicalManager
class PeriodicalManager extends SqfEntityProvider {
  PeriodicalManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Periodicals';
  static const List<String> _primaryKeyList = ['PeriodicalVariant'];
  static const String _whereStr = 'PeriodicalVariant=?';
}

//endregion PeriodicalManager
// region Price
class Price extends TableBase {
  Price(
      {this.Productcode,
      this.DestinationCountry,
      this.Pricingunit,
      this.LocalNonLocal,
      this.Variant,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Price.withFields(
      this.Productcode,
      this.DestinationCountry,
      this.Pricingunit,
      this.LocalNonLocal,
      this.Variant,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  Price.withId(
      this.Productcode,
      this.DestinationCountry,
      this.Pricingunit,
      this.LocalNonLocal,
      this.Variant,
      this.ValidTo,
      this.ProductDescription,
      this.Distance,
      this.DistanceDescription,
      this.Weight,
      this.WeightDescriptionStart,
      this.WeightDescriptionEnd,
      this.Conditionrate,
      this.ServiceTax) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Price.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Productcode = o['Productcode'].toString();
    if (o['DestinationCountry'] != null) {
      DestinationCountry = o['DestinationCountry'].toString();
    }
    if (o['Pricingunit'] != null) {
      Pricingunit = int.tryParse(o['Pricingunit'].toString());
    }
    if (o['LocalNonLocal'] != null) {
      LocalNonLocal = o['LocalNonLocal'].toString();
    }
    if (o['Variant'] != null) {
      Variant = o['Variant'].toString();
    }
    if (o['ValidTo'] != null) {
      ValidTo = double.tryParse(o['ValidTo'].toString());
    }
    if (o['ProductDescription'] != null) {
      ProductDescription = o['ProductDescription'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['DistanceDescription'] != null) {
      DistanceDescription = o['DistanceDescription'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['WeightDescriptionStart'] != null) {
      WeightDescriptionStart =
          int.tryParse(o['WeightDescriptionStart'].toString());
    }
    if (o['WeightDescriptionEnd'] != null) {
      WeightDescriptionEnd = int.tryParse(o['WeightDescriptionEnd'].toString());
    }
    if (o['Conditionrate'] != null) {
      Conditionrate = double.tryParse(o['Conditionrate'].toString());
    }
    if (o['ServiceTax'] != null) {
      ServiceTax = double.tryParse(o['ServiceTax'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Price)
  String? Productcode;
  String? DestinationCountry;
  int? Pricingunit;
  String? LocalNonLocal;
  String? Variant;
  double? ValidTo;
  String? ProductDescription;
  String? Distance;
  String? DistanceDescription;
  String? Weight;
  int? WeightDescriptionStart;
  int? WeightDescriptionEnd;
  double? Conditionrate;
  double? ServiceTax;
  bool? isSaved;
  // end FIELDS (Price)

  static const bool _softDeleteActivated = false;
  PriceManager? __mnPrice;

  PriceManager get _mnPrice {
    return __mnPrice = __mnPrice ?? PriceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (DestinationCountry != null || !forView) {
      map['DestinationCountry'] = DestinationCountry;
    }
    if (Pricingunit != null || !forView) {
      map['Pricingunit'] = Pricingunit;
    }
    if (LocalNonLocal != null || !forView) {
      map['LocalNonLocal'] = LocalNonLocal;
    }
    if (Variant != null || !forView) {
      map['Variant'] = Variant;
    }
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescription != null || !forView) {
      map['DistanceDescription'] = DistanceDescription;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (DestinationCountry != null || !forView) {
      map['DestinationCountry'] = DestinationCountry;
    }
    if (Pricingunit != null || !forView) {
      map['Pricingunit'] = Pricingunit;
    }
    if (LocalNonLocal != null || !forView) {
      map['LocalNonLocal'] = LocalNonLocal;
    }
    if (Variant != null || !forView) {
      map['Variant'] = Variant;
    }
    if (ValidTo != null || !forView) {
      map['ValidTo'] = ValidTo;
    }
    if (ProductDescription != null || !forView) {
      map['ProductDescription'] = ProductDescription;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (DistanceDescription != null || !forView) {
      map['DistanceDescription'] = DistanceDescription;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightDescriptionStart != null || !forView) {
      map['WeightDescriptionStart'] = WeightDescriptionStart;
    }
    if (WeightDescriptionEnd != null || !forView) {
      map['WeightDescriptionEnd'] = WeightDescriptionEnd;
    }
    if (Conditionrate != null || !forView) {
      map['Conditionrate'] = Conditionrate;
    }
    if (ServiceTax != null || !forView) {
      map['ServiceTax'] = ServiceTax;
    }

    return map;
  }

  /// This method returns Json String [Price]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Price]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Productcode,
      DestinationCountry,
      Pricingunit,
      LocalNonLocal,
      Variant,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescription,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Productcode,
      DestinationCountry,
      Pricingunit,
      LocalNonLocal,
      Variant,
      ValidTo,
      ProductDescription,
      Distance,
      DistanceDescription,
      Weight,
      WeightDescriptionStart,
      WeightDescriptionEnd,
      Conditionrate,
      ServiceTax
    ];
  }

  static Future<List<Price>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Price.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Price>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Price>[];
    try {
      objList = list
          .map((price) => Price.fromMap(price as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Price.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Price>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Price> objList = <Price>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Price.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Price by ID if exist, otherwise returns null
  /// Primary Keys: String? Productcode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Price] if exist, otherwise returns null
  Future<Price?> getById(String? Productcode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Productcode == null) {
      return null;
    }
    Price? obj;
    final data = await _mnPrice.getById([Productcode]);
    if (data.length != 0) {
      obj = Price.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Price) object. If the Primary Key (Productcode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Productcode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPrice.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Price (Productcode, DestinationCountry, Pricingunit, LocalNonLocal, Variant, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Price> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Price> prices,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in prices) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPrice.rawInsert(
          'INSERT OR REPLACE INTO Price (Productcode, DestinationCountry, Pricingunit, LocalNonLocal, Variant, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            DestinationCountry,
            Pricingunit,
            LocalNonLocal,
            Variant,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescription,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Price Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Price Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Price Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPrice.rawInsert(
          'INSERT OR IGNORE INTO Price (Productcode, DestinationCountry, Pricingunit, LocalNonLocal, Variant, ValidTo, ProductDescription, Distance, DistanceDescription, Weight, WeightDescriptionStart, WeightDescriptionEnd, Conditionrate, ServiceTax)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            Productcode,
            DestinationCountry,
            Pricingunit,
            LocalNonLocal,
            Variant,
            ValidTo,
            ProductDescription,
            Distance,
            DistanceDescription,
            Weight,
            WeightDescriptionStart,
            WeightDescriptionEnd,
            Conditionrate,
            ServiceTax
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Price Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Price Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Price Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Price

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Price invoked (Productcode=$Productcode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPrice.delete(QueryParams(
          whereString: 'Productcode=?', whereArguments: [Productcode]));
    } else {
      return _mnPrice.updateBatch(
          QueryParams(
              whereString: 'Productcode=?', whereArguments: [Productcode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Price] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PriceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PriceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PriceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PriceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Productcode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion price

// region PriceField
class PriceField extends FilterBase {
  PriceField(PriceFilterBuilder priceFB) : super(priceFB);

  @override
  PriceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder isNull() {
    return super.isNull() as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PriceFilterBuilder;
  }

  @override
  PriceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PriceFilterBuilder;
  }

  @override
  PriceField get not {
    return super.not as PriceField;
  }
}
// endregion PriceField

// region PriceFilterBuilder
class PriceFilterBuilder extends ConjunctionBase {
  PriceFilterBuilder(Price obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnPrice = obj._mnPrice;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PriceManager? _mnPrice;

  /// put the sql keyword 'AND'
  @override
  PriceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PriceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PriceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PriceFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PriceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PriceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PriceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PriceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PriceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PriceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PriceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PriceField _setField(PriceField? field, String colName, DbType dbtype) {
    return PriceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PriceField? _Productcode;
  PriceField get Productcode {
    return _Productcode =
        _setField(_Productcode, 'Productcode', DbType.integer);
  }

  PriceField? _DestinationCountry;
  PriceField get DestinationCountry {
    return _DestinationCountry =
        _setField(_DestinationCountry, 'DestinationCountry', DbType.text);
  }

  PriceField? _Pricingunit;
  PriceField get Pricingunit {
    return _Pricingunit =
        _setField(_Pricingunit, 'Pricingunit', DbType.integer);
  }

  PriceField? _LocalNonLocal;
  PriceField get LocalNonLocal {
    return _LocalNonLocal =
        _setField(_LocalNonLocal, 'LocalNonLocal', DbType.text);
  }

  PriceField? _Variant;
  PriceField get Variant {
    return _Variant = _setField(_Variant, 'Variant', DbType.text);
  }

  PriceField? _ValidTo;
  PriceField get ValidTo {
    return _ValidTo = _setField(_ValidTo, 'ValidTo', DbType.real);
  }

  PriceField? _ProductDescription;
  PriceField get ProductDescription {
    return _ProductDescription =
        _setField(_ProductDescription, 'ProductDescription', DbType.text);
  }

  PriceField? _Distance;
  PriceField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  PriceField? _DistanceDescription;
  PriceField get DistanceDescription {
    return _DistanceDescription =
        _setField(_DistanceDescription, 'DistanceDescription', DbType.text);
  }

  PriceField? _Weight;
  PriceField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  PriceField? _WeightDescriptionStart;
  PriceField get WeightDescriptionStart {
    return _WeightDescriptionStart = _setField(
        _WeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  PriceField? _WeightDescriptionEnd;
  PriceField get WeightDescriptionEnd {
    return _WeightDescriptionEnd = _setField(
        _WeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  PriceField? _Conditionrate;
  PriceField get Conditionrate {
    return _Conditionrate =
        _setField(_Conditionrate, 'Conditionrate', DbType.real);
  }

  PriceField? _ServiceTax;
  PriceField get ServiceTax {
    return _ServiceTax = _setField(_ServiceTax, 'ServiceTax', DbType.real);
  }

  /// Deletes List<Price> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPrice!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPrice!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Productcode IN (SELECT Productcode from Price ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPrice!.updateBatch(qparams, values);
  }

  /// This method always returns [Price] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Price?
  @override
  Future<Price?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPrice!.toList(qparams);
    final data = await objFuture;
    Price? obj;
    if (data.isNotEmpty) {
      obj = Price.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Price]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Price?
  @override
  Future<Price> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Price();
  }

  /// This method returns int. [Price]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? priceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final pricesFuture = await _mnPrice!.toList(qparams);
    final int count = pricesFuture[0]['CNT'] as int;
    if (priceCount != null) {
      priceCount(count);
    }
    return count;
  }

  /// This method returns List<Price> [Price]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Price>
  @override
  Future<List<Price>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Price> pricesData = await Price.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return pricesData;
  }

  /// This method returns Json String [Price]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Price]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Price]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPrice!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Price]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Productcode` FROM Price WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductcodeData = <String>[];
    qparams.selectColumns = ['Productcode'];
    final ProductcodeFuture = await _mnPrice!.toList(qparams);

    final int count = ProductcodeFuture.length;
    for (int i = 0; i < count; i++) {
      ProductcodeData.add(ProductcodeFuture[i]['Productcode'] as String);
    }
    return ProductcodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Price]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPrice!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Price.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPrice!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PriceFilterBuilder

// region PriceFields
class PriceFields {
  static TableField? _fProductcode;
  static TableField get Productcode {
    return _fProductcode = _fProductcode ??
        SqlSyntax.setField(_fProductcode, 'productcode', DbType.integer);
  }

  static TableField? _fDestinationCountry;
  static TableField get DestinationCountry {
    return _fDestinationCountry = _fDestinationCountry ??
        SqlSyntax.setField(
            _fDestinationCountry, 'DestinationCountry', DbType.text);
  }

  static TableField? _fPricingunit;
  static TableField get Pricingunit {
    return _fPricingunit = _fPricingunit ??
        SqlSyntax.setField(_fPricingunit, 'Pricingunit', DbType.integer);
  }

  static TableField? _fLocalNonLocal;
  static TableField get LocalNonLocal {
    return _fLocalNonLocal = _fLocalNonLocal ??
        SqlSyntax.setField(_fLocalNonLocal, 'LocalNonLocal', DbType.text);
  }

  static TableField? _fVariant;
  static TableField get Variant {
    return _fVariant =
        _fVariant ?? SqlSyntax.setField(_fVariant, 'Variant', DbType.text);
  }

  static TableField? _fValidTo;
  static TableField get ValidTo {
    return _fValidTo =
        _fValidTo ?? SqlSyntax.setField(_fValidTo, 'ValidTo', DbType.real);
  }

  static TableField? _fProductDescription;
  static TableField get ProductDescription {
    return _fProductDescription = _fProductDescription ??
        SqlSyntax.setField(
            _fProductDescription, 'ProductDescription', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fDistanceDescription;
  static TableField get DistanceDescription {
    return _fDistanceDescription = _fDistanceDescription ??
        SqlSyntax.setField(
            _fDistanceDescription, 'DistanceDescription', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fWeightDescriptionStart;
  static TableField get WeightDescriptionStart {
    return _fWeightDescriptionStart = _fWeightDescriptionStart ??
        SqlSyntax.setField(
            _fWeightDescriptionStart, 'WeightDescriptionStart', DbType.integer);
  }

  static TableField? _fWeightDescriptionEnd;
  static TableField get WeightDescriptionEnd {
    return _fWeightDescriptionEnd = _fWeightDescriptionEnd ??
        SqlSyntax.setField(
            _fWeightDescriptionEnd, 'WeightDescriptionEnd', DbType.integer);
  }

  static TableField? _fConditionrate;
  static TableField get Conditionrate {
    return _fConditionrate = _fConditionrate ??
        SqlSyntax.setField(_fConditionrate, 'Conditionrate', DbType.real);
  }

  static TableField? _fServiceTax;
  static TableField get ServiceTax {
    return _fServiceTax = _fServiceTax ??
        SqlSyntax.setField(_fServiceTax, 'ServiceTax', DbType.real);
  }
}
// endregion PriceFields

//region PriceManager
class PriceManager extends SqfEntityProvider {
  PriceManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Price';
  static const List<String> _primaryKeyList = ['Productcode'];
  static const String _whereStr = 'Productcode=?';
}

//endregion PriceManager
// region Productmaster
class Productmaster extends TableBase {
  Productmaster({this.Productcode, this.MaterialDescription, this.Country}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Productmaster.withFields(
      this.Productcode, this.MaterialDescription, this.Country) {
    _setDefaultValues();
  }
  Productmaster.withId(
      this.Productcode, this.MaterialDescription, this.Country) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Productmaster.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Productcode = o['Productcode'].toString();
    if (o['MaterialDescription'] != null) {
      MaterialDescription = o['MaterialDescription'].toString();
    }
    if (o['Country'] != null) {
      Country = o['Country'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Productmaster)
  String? Productcode;
  String? MaterialDescription;
  String? Country;
  bool? isSaved;
  // end FIELDS (Productmaster)

  static const bool _softDeleteActivated = false;
  ProductmasterManager? __mnProductmaster;

  ProductmasterManager get _mnProductmaster {
    return __mnProductmaster = __mnProductmaster ?? ProductmasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (MaterialDescription != null || !forView) {
      map['MaterialDescription'] = MaterialDescription;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (MaterialDescription != null || !forView) {
      map['MaterialDescription'] = MaterialDescription;
    }
    if (Country != null || !forView) {
      map['Country'] = Country;
    }

    return map;
  }

  /// This method returns Json String [Productmaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Productmaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Productcode, MaterialDescription, Country];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Productcode, MaterialDescription, Country];
  }

  static Future<List<Productmaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Productmaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Productmaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Productmaster>[];
    try {
      objList = list
          .map((productmaster) =>
              Productmaster.fromMap(productmaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Productmaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Productmaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Productmaster> objList = <Productmaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Productmaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Productmaster by ID if exist, otherwise returns null
  /// Primary Keys: String? Productcode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Productmaster] if exist, otherwise returns null
  Future<Productmaster?> getById(String? Productcode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Productcode == null) {
      return null;
    }
    Productmaster? obj;
    final data = await _mnProductmaster.getById([Productcode]);
    if (data.length != 0) {
      obj = Productmaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Productmaster) object. If the Primary Key (Productcode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Productcode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnProductmaster.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Productmaster (Productcode, MaterialDescription, Country)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Productmaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Productmaster> productmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in productmasters) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductmaster.rawInsert(
          'INSERT OR REPLACE INTO Productmaster (Productcode, MaterialDescription, Country)  VALUES (?,?,?)',
          [Productcode, MaterialDescription, Country],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Productmaster Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Productmaster Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Productmaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductmaster.rawInsert(
          'INSERT OR IGNORE INTO Productmaster (Productcode, MaterialDescription, Country)  VALUES (?,?,?)',
          [Productcode, MaterialDescription, Country],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Productmaster Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'Productmaster Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Productmaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Productmaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Productmaster invoked (Productcode=$Productcode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnProductmaster.delete(QueryParams(
          whereString: 'Productcode=?', whereArguments: [Productcode]));
    } else {
      return _mnProductmaster.updateBatch(
          QueryParams(
              whereString: 'Productcode=?', whereArguments: [Productcode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Productmaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ProductmasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductmasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProductmasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductmasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Productcode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion productmaster

// region ProductmasterField
class ProductmasterField extends FilterBase {
  ProductmasterField(ProductmasterFilterBuilder productmasterFB)
      : super(productmasterFB);

  @override
  ProductmasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder isNull() {
    return super.isNull() as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProductmasterFilterBuilder;
  }

  @override
  ProductmasterField get not {
    return super.not as ProductmasterField;
  }
}
// endregion ProductmasterField

// region ProductmasterFilterBuilder
class ProductmasterFilterBuilder extends ConjunctionBase {
  ProductmasterFilterBuilder(Productmaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProductmaster = obj._mnProductmaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProductmasterManager? _mnProductmaster;

  /// put the sql keyword 'AND'
  @override
  ProductmasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProductmasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProductmasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProductmasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProductmasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProductmasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProductmasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductmasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductmasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductmasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductmasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProductmasterField _setField(
      ProductmasterField? field, String colName, DbType dbtype) {
    return ProductmasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProductmasterField? _Productcode;
  ProductmasterField get Productcode {
    return _Productcode =
        _setField(_Productcode, 'Productcode', DbType.integer);
  }

  ProductmasterField? _MaterialDescription;
  ProductmasterField get MaterialDescription {
    return _MaterialDescription =
        _setField(_MaterialDescription, 'MaterialDescription', DbType.text);
  }

  ProductmasterField? _Country;
  ProductmasterField get Country {
    return _Country = _setField(_Country, 'Country', DbType.text);
  }

  /// Deletes List<Productmaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProductmaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProductmaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Productcode IN (SELECT Productcode from Productmaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProductmaster!.updateBatch(qparams, values);
  }

  /// This method always returns [Productmaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Productmaster?
  @override
  Future<Productmaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProductmaster!.toList(qparams);
    final data = await objFuture;
    Productmaster? obj;
    if (data.isNotEmpty) {
      obj = Productmaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Productmaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Productmaster?
  @override
  Future<Productmaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Productmaster();
  }

  /// This method returns int. [Productmaster]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? productmasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productmastersFuture = await _mnProductmaster!.toList(qparams);
    final int count = productmastersFuture[0]['CNT'] as int;
    if (productmasterCount != null) {
      productmasterCount(count);
    }
    return count;
  }

  /// This method returns List<Productmaster> [Productmaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Productmaster>
  @override
  Future<List<Productmaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Productmaster> productmastersData =
        await Productmaster.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return productmastersData;
  }

  /// This method returns Json String [Productmaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Productmaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Productmaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProductmaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Productmaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Productcode` FROM Productmaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductcodeData = <String>[];
    qparams.selectColumns = ['Productcode'];
    final ProductcodeFuture = await _mnProductmaster!.toList(qparams);

    final int count = ProductcodeFuture.length;
    for (int i = 0; i < count; i++) {
      ProductcodeData.add(ProductcodeFuture[i]['Productcode'] as String);
    }
    return ProductcodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Productmaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProductmaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Productmaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProductmaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductmasterFilterBuilder

// region ProductmasterFields
class ProductmasterFields {
  static TableField? _fProductcode;
  static TableField get Productcode {
    return _fProductcode = _fProductcode ??
        SqlSyntax.setField(_fProductcode, 'productcode', DbType.integer);
  }

  static TableField? _fMaterialDescription;
  static TableField get MaterialDescription {
    return _fMaterialDescription = _fMaterialDescription ??
        SqlSyntax.setField(
            _fMaterialDescription, 'MaterialDescription', DbType.text);
  }

  static TableField? _fCountry;
  static TableField get Country {
    return _fCountry =
        _fCountry ?? SqlSyntax.setField(_fCountry, 'Country', DbType.text);
  }
}
// endregion ProductmasterFields

//region ProductmasterManager
class ProductmasterManager extends SqfEntityProvider {
  ProductmasterManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Productmaster';
  static const List<String> _primaryKeyList = ['Productcode'];
  static const String _whereStr = 'Productcode=?';
}

//endregion ProductmasterManager
// region RegionState
class RegionState extends TableBase {
  RegionState({this.RegionCode, this.StateName}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  RegionState.withFields(this.RegionCode, this.StateName) {
    _setDefaultValues();
  }
  RegionState.withId(this.RegionCode, this.StateName) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RegionState.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    RegionCode = int.tryParse(o['RegionCode'].toString());
    if (o['StateName'] != null) {
      StateName = o['StateName'].toString();
    }

    isSaved = true;
  }
  // FIELDS (RegionState)
  int? RegionCode;
  String? StateName;
  bool? isSaved;
  // end FIELDS (RegionState)

  static const bool _softDeleteActivated = false;
  RegionStateManager? __mnRegionState;

  RegionStateManager get _mnRegionState {
    return __mnRegionState = __mnRegionState ?? RegionStateManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['RegionCode'] = RegionCode;
    if (StateName != null || !forView) {
      map['StateName'] = StateName;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['RegionCode'] = RegionCode;
    if (StateName != null || !forView) {
      map['StateName'] = StateName;
    }

    return map;
  }

  /// This method returns Json String [RegionState]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RegionState]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [RegionCode, StateName];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [RegionCode, StateName];
  }

  static Future<List<RegionState>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegionState.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RegionState>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RegionState>[];
    try {
      objList = list
          .map((regionstate) =>
              RegionState.fromMap(regionstate as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegionState.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RegionState>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RegionState> objList = <RegionState>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RegionState.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns RegionState by ID if exist, otherwise returns null
  /// Primary Keys: int? RegionCode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [RegionState] if exist, otherwise returns null
  Future<RegionState?> getById(int? RegionCode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (RegionCode == null) {
      return null;
    }
    RegionState? obj;
    final data = await _mnRegionState.getById([RegionCode]);
    if (data.length != 0) {
      obj = RegionState.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RegionState) object. If the RegionCode field is null, saves as a new record and returns new RegionCode, if RegionCode is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns RegionCode
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (RegionCode == null || RegionCode == 0 || !isSaved!) {
      await _mnRegionState.insert(this, ignoreBatch);
      if (saveResult!.success) {
        isSaved = true;
      }
    } else {
      await _mnRegionState.update(this);
    }

    return RegionCode;
  }

  /// Saves the (RegionState) object. If the RegionCode field is null, saves as a new record and returns new RegionCode, if RegionCode is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns RegionCode
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (RegionCode == null || RegionCode == 0 || !isSaved!) {
      await _mnRegionState.insertOrThrow(this, ignoreBatch);
      if (saveResult != null && saveResult!.success) {
        isSaved = true;
      }
      isInsert = true;
    } else {
      // RegionCode= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRegionState.updateOrThrow(this);
    }

    return RegionCode;
  }

  /// saveAll method saves the sent List<RegionState> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<RegionState> regionstates,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in regionstates) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns RegionCode
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRegionState.rawInsert(
          'INSERT OR REPLACE INTO RegionState (RegionCode, StateName)  VALUES (?,?)',
          [RegionCode, StateName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'RegionState RegionCode=$RegionCode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RegionState RegionCode=$RegionCode did not update');
      }
      return RegionCode;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'RegionState Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns RegionCode
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRegionState.rawInsert(
          'INSERT OR IGNORE INTO RegionState (RegionCode, StateName)  VALUES (?,?)',
          [RegionCode, StateName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'RegionState RegionCode=$RegionCode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RegionState RegionCode=$RegionCode did not update');
      }
      return RegionCode;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'RegionState Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<RegionState>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<RegionState> regionstates,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnRegionState.rawInsertAll(
        'INSERT OR REPLACE INTO RegionState (RegionCode, StateName)  VALUES (?,?)',
        regionstates,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes RegionState

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete RegionState invoked (RegionCode=$RegionCode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnRegionState.delete(QueryParams(
          whereString: 'RegionCode=?', whereArguments: [RegionCode]));
    } else {
      return _mnRegionState.updateBatch(
          QueryParams(
              whereString: 'RegionCode=?', whereArguments: [RegionCode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [RegionState] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  RegionStateFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegionStateFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RegionStateFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegionStateFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      RegionCode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion regionstate

// region RegionStateField
class RegionStateField extends FilterBase {
  RegionStateField(RegionStateFilterBuilder regionstateFB)
      : super(regionstateFB);

  @override
  RegionStateFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder isNull() {
    return super.isNull() as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RegionStateFilterBuilder;
  }

  @override
  RegionStateField get not {
    return super.not as RegionStateField;
  }
}
// endregion RegionStateField

// region RegionStateFilterBuilder
class RegionStateFilterBuilder extends ConjunctionBase {
  RegionStateFilterBuilder(RegionState obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnRegionState = obj._mnRegionState;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RegionStateManager? _mnRegionState;

  /// put the sql keyword 'AND'
  @override
  RegionStateFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RegionStateFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RegionStateFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RegionStateFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RegionStateFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RegionStateFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RegionStateFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegionStateFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegionStateFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegionStateFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegionStateFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RegionStateField _setField(
      RegionStateField? field, String colName, DbType dbtype) {
    return RegionStateField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RegionStateField? _RegionCode;
  RegionStateField get RegionCode {
    return _RegionCode = _setField(_RegionCode, 'RegionCode', DbType.integer);
  }

  RegionStateField? _StateName;
  RegionStateField get StateName {
    return _StateName = _setField(_StateName, 'StateName', DbType.text);
  }

  /// Deletes List<RegionState> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRegionState!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRegionState!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'RegionCode IN (SELECT RegionCode from RegionState ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRegionState!.updateBatch(qparams, values);
  }

  /// This method always returns [RegionState] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegionState?
  @override
  Future<RegionState?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRegionState!.toList(qparams);
    final data = await objFuture;
    RegionState? obj;
    if (data.isNotEmpty) {
      obj = RegionState.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RegionState]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegionState?
  @override
  Future<RegionState> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RegionState();
  }

  /// This method returns int. [RegionState]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? regionstateCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final regionstatesFuture = await _mnRegionState!.toList(qparams);
    final int count = regionstatesFuture[0]['CNT'] as int;
    if (regionstateCount != null) {
      regionstateCount(count);
    }
    return count;
  }

  /// This method returns List<RegionState> [RegionState]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<RegionState>
  @override
  Future<List<RegionState>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RegionState> regionstatesData = await RegionState.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return regionstatesData;
  }

  /// This method returns Json String [RegionState]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RegionState]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RegionState]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRegionState!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RegionState]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `RegionCode` FROM RegionState WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> RegionCodeData = <int>[];
    qparams.selectColumns = ['RegionCode'];
    final RegionCodeFuture = await _mnRegionState!.toList(qparams);

    final int count = RegionCodeFuture.length;
    for (int i = 0; i < count; i++) {
      RegionCodeData.add(RegionCodeFuture[i]['RegionCode'] as int);
    }
    return RegionCodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RegionState]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRegionState!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await RegionState.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRegionState!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RegionStateFilterBuilder

// region RegionStateFields
class RegionStateFields {
  static TableField? _fRegionCode;
  static TableField get RegionCode {
    return _fRegionCode = _fRegionCode ??
        SqlSyntax.setField(_fRegionCode, 'regioncode', DbType.integer);
  }

  static TableField? _fStateName;
  static TableField get StateName {
    return _fStateName = _fStateName ??
        SqlSyntax.setField(_fStateName, 'StateName', DbType.text);
  }
}
// endregion RegionStateFields

//region RegionStateManager
class RegionStateManager extends SqfEntityProvider {
  RegionStateManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'RegionState';
  static const List<String> _primaryKeyList = ['RegionCode'];
  static const String _whereStr = 'RegionCode=?';
}

//endregion RegionStateManager
// region TariffInfo
class TariffInfo extends TableBase {
  TariffInfo({this.Product, this.ProductDesc, this.Price}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TariffInfo.withFields(this.Product, this.ProductDesc, this.Price) {
    _setDefaultValues();
  }
  TariffInfo.withId(this.Product, this.ProductDesc, this.Price) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TariffInfo.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Product = o['Product'].toString();
    if (o['ProductDesc'] != null) {
      ProductDesc = o['ProductDesc'].toString();
    }
    if (o['Price'] != null) {
      Price = double.tryParse(o['Price'].toString());
    }

    isSaved = true;
  }
  // FIELDS (TariffInfo)
  String? Product;
  String? ProductDesc;
  double? Price;
  bool? isSaved;
  // end FIELDS (TariffInfo)

  static const bool _softDeleteActivated = false;
  TariffInfoManager? __mnTariffInfo;

  TariffInfoManager get _mnTariffInfo {
    return __mnTariffInfo = __mnTariffInfo ?? TariffInfoManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (ProductDesc != null || !forView) {
      map['ProductDesc'] = ProductDesc;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (ProductDesc != null || !forView) {
      map['ProductDesc'] = ProductDesc;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }

    return map;
  }

  /// This method returns Json String [TariffInfo]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TariffInfo]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Product, ProductDesc, Price];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Product, ProductDesc, Price];
  }

  static Future<List<TariffInfo>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TariffInfo.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TariffInfo>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TariffInfo>[];
    try {
      objList = list
          .map((tariffinfo) =>
              TariffInfo.fromMap(tariffinfo as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TariffInfo.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TariffInfo>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TariffInfo> objList = <TariffInfo>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TariffInfo.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TariffInfo by ID if exist, otherwise returns null
  /// Primary Keys: String? Product
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TariffInfo] if exist, otherwise returns null
  Future<TariffInfo?> getById(String? Product,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Product == null) {
      return null;
    }
    TariffInfo? obj;
    final data = await _mnTariffInfo.getById([Product]);
    if (data.length != 0) {
      obj = TariffInfo.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TariffInfo) object. If the Primary Key (Product) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Product
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTariffInfo.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO TariffInfo (Product, ProductDesc, Price)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TariffInfo> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TariffInfo> tariffinfos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in tariffinfos) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariffInfo.rawInsert(
          'INSERT OR REPLACE INTO TariffInfo (Product, ProductDesc, Price)  VALUES (?,?,?)',
          [Product, ProductDesc, Price],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TariffInfo Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TariffInfo Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TariffInfo Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariffInfo.rawInsert(
          'INSERT OR IGNORE INTO TariffInfo (Product, ProductDesc, Price)  VALUES (?,?,?)',
          [Product, ProductDesc, Price],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TariffInfo Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TariffInfo Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TariffInfo Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes TariffInfo

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TariffInfo invoked (Product=$Product)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTariffInfo.delete(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]));
    } else {
      return _mnTariffInfo.updateBatch(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TariffInfo] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TariffInfoFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TariffInfoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TariffInfoFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TariffInfoFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Product = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tariffinfo

// region TariffInfoField
class TariffInfoField extends FilterBase {
  TariffInfoField(TariffInfoFilterBuilder tariffinfoFB) : super(tariffinfoFB);

  @override
  TariffInfoFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder isNull() {
    return super.isNull() as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TariffInfoFilterBuilder;
  }

  @override
  TariffInfoField get not {
    return super.not as TariffInfoField;
  }
}
// endregion TariffInfoField

// region TariffInfoFilterBuilder
class TariffInfoFilterBuilder extends ConjunctionBase {
  TariffInfoFilterBuilder(TariffInfo obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTariffInfo = obj._mnTariffInfo;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TariffInfoManager? _mnTariffInfo;

  /// put the sql keyword 'AND'
  @override
  TariffInfoFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TariffInfoFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TariffInfoFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TariffInfoFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TariffInfoFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TariffInfoFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TariffInfoFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TariffInfoFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TariffInfoFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TariffInfoFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TariffInfoFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TariffInfoField _setField(
      TariffInfoField? field, String colName, DbType dbtype) {
    return TariffInfoField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TariffInfoField? _Product;
  TariffInfoField get Product {
    return _Product = _setField(_Product, 'Product', DbType.integer);
  }

  TariffInfoField? _ProductDesc;
  TariffInfoField get ProductDesc {
    return _ProductDesc = _setField(_ProductDesc, 'ProductDesc', DbType.text);
  }

  TariffInfoField? _Price;
  TariffInfoField get Price {
    return _Price = _setField(_Price, 'Price', DbType.real);
  }

  /// Deletes List<TariffInfo> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTariffInfo!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTariffInfo!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Product IN (SELECT Product from TariffInfo ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTariffInfo!.updateBatch(qparams, values);
  }

  /// This method always returns [TariffInfo] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TariffInfo?
  @override
  Future<TariffInfo?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTariffInfo!.toList(qparams);
    final data = await objFuture;
    TariffInfo? obj;
    if (data.isNotEmpty) {
      obj = TariffInfo.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TariffInfo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TariffInfo?
  @override
  Future<TariffInfo> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TariffInfo();
  }

  /// This method returns int. [TariffInfo]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tariffinfoCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tariffinfosFuture = await _mnTariffInfo!.toList(qparams);
    final int count = tariffinfosFuture[0]['CNT'] as int;
    if (tariffinfoCount != null) {
      tariffinfoCount(count);
    }
    return count;
  }

  /// This method returns List<TariffInfo> [TariffInfo]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TariffInfo>
  @override
  Future<List<TariffInfo>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TariffInfo> tariffinfosData = await TariffInfo.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tariffinfosData;
  }

  /// This method returns Json String [TariffInfo]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TariffInfo]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TariffInfo]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTariffInfo!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TariffInfo]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Product` FROM TariffInfo WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductData = <String>[];
    qparams.selectColumns = ['Product'];
    final ProductFuture = await _mnTariffInfo!.toList(qparams);

    final int count = ProductFuture.length;
    for (int i = 0; i < count; i++) {
      ProductData.add(ProductFuture[i]['Product'] as String);
    }
    return ProductData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TariffInfo]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTariffInfo!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TariffInfo.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTariffInfo!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TariffInfoFilterBuilder

// region TariffInfoFields
class TariffInfoFields {
  static TableField? _fProduct;
  static TableField get Product {
    return _fProduct =
        _fProduct ?? SqlSyntax.setField(_fProduct, 'product', DbType.integer);
  }

  static TableField? _fProductDesc;
  static TableField get ProductDesc {
    return _fProductDesc = _fProductDesc ??
        SqlSyntax.setField(_fProductDesc, 'ProductDesc', DbType.text);
  }

  static TableField? _fPrice;
  static TableField get Price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'Price', DbType.real);
  }
}
// endregion TariffInfoFields

//region TariffInfoManager
class TariffInfoManager extends SqfEntityProvider {
  TariffInfoManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TariffInfo';
  static const List<String> _primaryKeyList = ['Product'];
  static const String _whereStr = 'Product=?';
}

//endregion TariffInfoManager
// region Tariff_Info_mod
class Tariff_Info_mod extends TableBase {
  Tariff_Info_mod({this.Product, this.ProductDesc, this.Price}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Tariff_Info_mod.withFields(this.Product, this.ProductDesc, this.Price) {
    _setDefaultValues();
  }
  Tariff_Info_mod.withId(this.Product, this.ProductDesc, this.Price) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Tariff_Info_mod.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Product = o['Product'].toString();
    if (o['ProductDesc'] != null) {
      ProductDesc = o['ProductDesc'].toString();
    }
    if (o['Price'] != null) {
      Price = double.tryParse(o['Price'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Tariff_Info_mod)
  String? Product;
  String? ProductDesc;
  double? Price;
  bool? isSaved;
  // end FIELDS (Tariff_Info_mod)

  static const bool _softDeleteActivated = false;
  Tariff_Info_modManager? __mnTariff_Info_mod;

  Tariff_Info_modManager get _mnTariff_Info_mod {
    return __mnTariff_Info_mod =
        __mnTariff_Info_mod ?? Tariff_Info_modManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (ProductDesc != null || !forView) {
      map['ProductDesc'] = ProductDesc;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (ProductDesc != null || !forView) {
      map['ProductDesc'] = ProductDesc;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }

    return map;
  }

  /// This method returns Json String [Tariff_Info_mod]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Tariff_Info_mod]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Product, ProductDesc, Price];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Product, ProductDesc, Price];
  }

  static Future<List<Tariff_Info_mod>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tariff_Info_mod.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Tariff_Info_mod>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Tariff_Info_mod>[];
    try {
      objList = list
          .map((tariff_info_mod) =>
              Tariff_Info_mod.fromMap(tariff_info_mod as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Tariff_Info_mod.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Tariff_Info_mod>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Tariff_Info_mod> objList = <Tariff_Info_mod>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Tariff_Info_mod.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Tariff_Info_mod by ID if exist, otherwise returns null
  /// Primary Keys: String? Product
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Tariff_Info_mod] if exist, otherwise returns null
  Future<Tariff_Info_mod?> getById(String? Product,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Product == null) {
      return null;
    }
    Tariff_Info_mod? obj;
    final data = await _mnTariff_Info_mod.getById([Product]);
    if (data.length != 0) {
      obj = Tariff_Info_mod.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Tariff_Info_mod) object. If the Primary Key (Product) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Product
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTariff_Info_mod.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Tariff_Info_mod (Product, ProductDesc, Price)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Tariff_Info_mod> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Tariff_Info_mod> tariff_info_mods,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in tariff_info_mods) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariff_Info_mod.rawInsert(
          'INSERT OR REPLACE INTO Tariff_Info_mod (Product, ProductDesc, Price)  VALUES (?,?,?)',
          [Product, ProductDesc, Price],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Tariff_Info_mod Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Tariff_Info_mod Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tariff_Info_mod Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariff_Info_mod.rawInsert(
          'INSERT OR IGNORE INTO Tariff_Info_mod (Product, ProductDesc, Price)  VALUES (?,?,?)',
          [Product, ProductDesc, Price],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Tariff_Info_mod Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Tariff_Info_mod Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Tariff_Info_mod Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Tariff_Info_mod

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Tariff_Info_mod invoked (Product=$Product)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTariff_Info_mod.delete(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]));
    } else {
      return _mnTariff_Info_mod.updateBatch(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Tariff_Info_mod] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  Tariff_Info_modFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Tariff_Info_modFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  Tariff_Info_modFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return Tariff_Info_modFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Product = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tariff_info_mod

// region Tariff_Info_modField
class Tariff_Info_modField extends FilterBase {
  Tariff_Info_modField(Tariff_Info_modFilterBuilder tariff_info_modFB)
      : super(tariff_info_modFB);

  @override
  Tariff_Info_modFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder isNull() {
    return super.isNull() as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as Tariff_Info_modFilterBuilder;
  }

  @override
  Tariff_Info_modField get not {
    return super.not as Tariff_Info_modField;
  }
}
// endregion Tariff_Info_modField

// region Tariff_Info_modFilterBuilder
class Tariff_Info_modFilterBuilder extends ConjunctionBase {
  Tariff_Info_modFilterBuilder(Tariff_Info_mod obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTariff_Info_mod = obj._mnTariff_Info_mod;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  Tariff_Info_modManager? _mnTariff_Info_mod;

  /// put the sql keyword 'AND'
  @override
  Tariff_Info_modFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  Tariff_Info_modFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  Tariff_Info_modFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  Tariff_Info_modFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  Tariff_Info_modFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  Tariff_Info_modFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  Tariff_Info_modFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Tariff_Info_modFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Tariff_Info_modFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  Tariff_Info_modFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  Tariff_Info_modFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  Tariff_Info_modField _setField(
      Tariff_Info_modField? field, String colName, DbType dbtype) {
    return Tariff_Info_modField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  Tariff_Info_modField? _Product;
  Tariff_Info_modField get Product {
    return _Product = _setField(_Product, 'Product', DbType.integer);
  }

  Tariff_Info_modField? _ProductDesc;
  Tariff_Info_modField get ProductDesc {
    return _ProductDesc = _setField(_ProductDesc, 'ProductDesc', DbType.text);
  }

  Tariff_Info_modField? _Price;
  Tariff_Info_modField get Price {
    return _Price = _setField(_Price, 'Price', DbType.real);
  }

  /// Deletes List<Tariff_Info_mod> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTariff_Info_mod!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTariff_Info_mod!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Product IN (SELECT Product from Tariff_Info_mod ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTariff_Info_mod!.updateBatch(qparams, values);
  }

  /// This method always returns [Tariff_Info_mod] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tariff_Info_mod?
  @override
  Future<Tariff_Info_mod?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTariff_Info_mod!.toList(qparams);
    final data = await objFuture;
    Tariff_Info_mod? obj;
    if (data.isNotEmpty) {
      obj = Tariff_Info_mod.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Tariff_Info_mod]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Tariff_Info_mod?
  @override
  Future<Tariff_Info_mod> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Tariff_Info_mod();
  }

  /// This method returns int. [Tariff_Info_mod]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? tariff_info_modCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tariff_info_modsFuture = await _mnTariff_Info_mod!.toList(qparams);
    final int count = tariff_info_modsFuture[0]['CNT'] as int;
    if (tariff_info_modCount != null) {
      tariff_info_modCount(count);
    }
    return count;
  }

  /// This method returns List<Tariff_Info_mod> [Tariff_Info_mod]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Tariff_Info_mod>
  @override
  Future<List<Tariff_Info_mod>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Tariff_Info_mod> tariff_info_modsData =
        await Tariff_Info_mod.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tariff_info_modsData;
  }

  /// This method returns Json String [Tariff_Info_mod]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Tariff_Info_mod]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Tariff_Info_mod]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTariff_Info_mod!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Tariff_Info_mod]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Product` FROM Tariff_Info_mod WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductData = <String>[];
    qparams.selectColumns = ['Product'];
    final ProductFuture = await _mnTariff_Info_mod!.toList(qparams);

    final int count = ProductFuture.length;
    for (int i = 0; i < count; i++) {
      ProductData.add(ProductFuture[i]['Product'] as String);
    }
    return ProductData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Tariff_Info_mod]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTariff_Info_mod!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Tariff_Info_mod.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTariff_Info_mod!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion Tariff_Info_modFilterBuilder

// region Tariff_Info_modFields
class Tariff_Info_modFields {
  static TableField? _fProduct;
  static TableField get Product {
    return _fProduct =
        _fProduct ?? SqlSyntax.setField(_fProduct, 'product', DbType.integer);
  }

  static TableField? _fProductDesc;
  static TableField get ProductDesc {
    return _fProductDesc = _fProductDesc ??
        SqlSyntax.setField(_fProductDesc, 'ProductDesc', DbType.text);
  }

  static TableField? _fPrice;
  static TableField get Price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'Price', DbType.real);
  }
}
// endregion Tariff_Info_modFields

//region Tariff_Info_modManager
class Tariff_Info_modManager extends SqfEntityProvider {
  Tariff_Info_modManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Tariff_Info_mod';
  static const List<String> _primaryKeyList = ['Product'];
  static const String _whereStr = 'Product=?';
}

//endregion Tariff_Info_modManager
// region Vpp
class Vpp extends TableBase {
  Vpp(
      {this.ServiceID,
      this.MinAmount,
      this.MaxAmount,
      this.Commission,
      this.ActivationDate,
      this.ExpiryDate}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Vpp.withFields(this.ServiceID, this.MinAmount, this.MaxAmount,
      this.Commission, this.ActivationDate, this.ExpiryDate) {
    _setDefaultValues();
  }
  Vpp.withId(this.ServiceID, this.MinAmount, this.MaxAmount, this.Commission,
      this.ActivationDate, this.ExpiryDate) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Vpp.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ServiceID = o['ServiceID'].toString();
    if (o['MinAmount'] != null) {
      MinAmount = double.tryParse(o['MinAmount'].toString());
    }
    if (o['MaxAmount'] != null) {
      MaxAmount = double.tryParse(o['MaxAmount'].toString());
    }
    if (o['Commission'] != null) {
      Commission = double.tryParse(o['Commission'].toString());
    }
    if (o['ActivationDate'] != null) {
      ActivationDate = double.tryParse(o['ActivationDate'].toString());
    }
    if (o['ExpiryDate'] != null) {
      ExpiryDate = double.tryParse(o['ExpiryDate'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Vpp)
  String? ServiceID;
  double? MinAmount;
  double? MaxAmount;
  double? Commission;
  double? ActivationDate;
  double? ExpiryDate;
  bool? isSaved;
  // end FIELDS (Vpp)

  static const bool _softDeleteActivated = false;
  VppManager? __mnVpp;

  VppManager get _mnVpp {
    return __mnVpp = __mnVpp ?? VppManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ServiceID'] = ServiceID;
    if (MinAmount != null || !forView) {
      map['MinAmount'] = MinAmount;
    }
    if (MaxAmount != null || !forView) {
      map['MaxAmount'] = MaxAmount;
    }
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (ActivationDate != null || !forView) {
      map['ActivationDate'] = ActivationDate;
    }
    if (ExpiryDate != null || !forView) {
      map['ExpiryDate'] = ExpiryDate;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ServiceID'] = ServiceID;
    if (MinAmount != null || !forView) {
      map['MinAmount'] = MinAmount;
    }
    if (MaxAmount != null || !forView) {
      map['MaxAmount'] = MaxAmount;
    }
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (ActivationDate != null || !forView) {
      map['ActivationDate'] = ActivationDate;
    }
    if (ExpiryDate != null || !forView) {
      map['ExpiryDate'] = ExpiryDate;
    }

    return map;
  }

  /// This method returns Json String [Vpp]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Vpp]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ServiceID,
      MinAmount,
      MaxAmount,
      Commission,
      ActivationDate,
      ExpiryDate
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ServiceID,
      MinAmount,
      MaxAmount,
      Commission,
      ActivationDate,
      ExpiryDate
    ];
  }

  static Future<List<Vpp>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Vpp.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Vpp>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Vpp>[];
    try {
      objList =
          list.map((vpp) => Vpp.fromMap(vpp as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint('SQFENTITY ERROR Vpp.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Vpp>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Vpp> objList = <Vpp>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Vpp.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Vpp by ID if exist, otherwise returns null
  /// Primary Keys: String? ServiceID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Vpp] if exist, otherwise returns null
  Future<Vpp?> getById(String? ServiceID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ServiceID == null) {
      return null;
    }
    Vpp? obj;
    final data = await _mnVpp.getById([ServiceID]);
    if (data.length != 0) {
      obj = Vpp.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Vpp) object. If the Primary Key (ServiceID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ServiceID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnVpp.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Vpp (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Vpp> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Vpp> vpps,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in vpps) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVpp.rawInsert(
          'INSERT OR REPLACE INTO Vpp (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          [
            ServiceID,
            MinAmount,
            MaxAmount,
            Commission,
            ActivationDate,
            ExpiryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Vpp ServiceID=$ServiceID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Vpp ServiceID=$ServiceID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Vpp Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVpp.rawInsert(
          'INSERT OR IGNORE INTO Vpp (ServiceID, MinAmount, MaxAmount, Commission, ActivationDate, ExpiryDate)  VALUES (?,?,?,?,?,?)',
          [
            ServiceID,
            MinAmount,
            MaxAmount,
            Commission,
            ActivationDate,
            ExpiryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Vpp ServiceID=$ServiceID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Vpp ServiceID=$ServiceID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Vpp Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Vpp

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Vpp invoked (ServiceID=$ServiceID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnVpp.delete(
          QueryParams(whereString: 'ServiceID=?', whereArguments: [ServiceID]));
    } else {
      return _mnVpp.updateBatch(
          QueryParams(whereString: 'ServiceID=?', whereArguments: [ServiceID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Vpp] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  VppFilterBuilder select({List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VppFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VppFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VppFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ServiceID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vpp

// region VppField
class VppField extends FilterBase {
  VppField(VppFilterBuilder vppFB) : super(vppFB);

  @override
  VppFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder isNull() {
    return super.isNull() as VppFilterBuilder;
  }

  @override
  VppFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VppFilterBuilder;
  }

  @override
  VppFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VppFilterBuilder;
  }

  @override
  VppField get not {
    return super.not as VppField;
  }
}
// endregion VppField

// region VppFilterBuilder
class VppFilterBuilder extends ConjunctionBase {
  VppFilterBuilder(Vpp obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnVpp = obj._mnVpp;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  VppManager? _mnVpp;

  /// put the sql keyword 'AND'
  @override
  VppFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VppFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VppFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VppFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VppFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VppFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VppFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VppFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VppFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VppFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VppFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VppField _setField(VppField? field, String colName, DbType dbtype) {
    return VppField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VppField? _ServiceID;
  VppField get ServiceID {
    return _ServiceID = _setField(_ServiceID, 'ServiceID', DbType.integer);
  }

  VppField? _MinAmount;
  VppField get MinAmount {
    return _MinAmount = _setField(_MinAmount, 'MinAmount', DbType.real);
  }

  VppField? _MaxAmount;
  VppField get MaxAmount {
    return _MaxAmount = _setField(_MaxAmount, 'MaxAmount', DbType.real);
  }

  VppField? _Commission;
  VppField get Commission {
    return _Commission = _setField(_Commission, 'Commission', DbType.real);
  }

  VppField? _ActivationDate;
  VppField get ActivationDate {
    return _ActivationDate =
        _setField(_ActivationDate, 'ActivationDate', DbType.real);
  }

  VppField? _ExpiryDate;
  VppField get ExpiryDate {
    return _ExpiryDate = _setField(_ExpiryDate, 'ExpiryDate', DbType.real);
  }

  /// Deletes List<Vpp> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnVpp!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnVpp!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ServiceID IN (SELECT ServiceID from Vpp ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnVpp!.updateBatch(qparams, values);
  }

  /// This method always returns [Vpp] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Vpp?
  @override
  Future<Vpp?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVpp!.toList(qparams);
    final data = await objFuture;
    Vpp? obj;
    if (data.isNotEmpty) {
      obj = Vpp.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Vpp]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Vpp?
  @override
  Future<Vpp> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Vpp();
  }

  /// This method returns int. [Vpp]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? vppCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vppsFuture = await _mnVpp!.toList(qparams);
    final int count = vppsFuture[0]['CNT'] as int;
    if (vppCount != null) {
      vppCount(count);
    }
    return count;
  }

  /// This method returns List<Vpp> [Vpp]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Vpp>
  @override
  Future<List<Vpp>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Vpp> vppsData = await Vpp.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vppsData;
  }

  /// This method returns Json String [Vpp]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Vpp]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Vpp]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVpp!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Vpp]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `ServiceID` FROM Vpp WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ServiceIDData = <String>[];
    qparams.selectColumns = ['ServiceID'];
    final ServiceIDFuture = await _mnVpp!.toList(qparams);

    final int count = ServiceIDFuture.length;
    for (int i = 0; i < count; i++) {
      ServiceIDData.add(ServiceIDFuture[i]['ServiceID'] as String);
    }
    return ServiceIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Vpp]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVpp!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Vpp.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVpp!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VppFilterBuilder

// region VppFields
class VppFields {
  static TableField? _fServiceID;
  static TableField get ServiceID {
    return _fServiceID = _fServiceID ??
        SqlSyntax.setField(_fServiceID, 'serviceid', DbType.integer);
  }

  static TableField? _fMinAmount;
  static TableField get MinAmount {
    return _fMinAmount = _fMinAmount ??
        SqlSyntax.setField(_fMinAmount, 'MinAmount', DbType.real);
  }

  static TableField? _fMaxAmount;
  static TableField get MaxAmount {
    return _fMaxAmount = _fMaxAmount ??
        SqlSyntax.setField(_fMaxAmount, 'MaxAmount', DbType.real);
  }

  static TableField? _fCommission;
  static TableField get Commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'Commission', DbType.real);
  }

  static TableField? _fActivationDate;
  static TableField get ActivationDate {
    return _fActivationDate = _fActivationDate ??
        SqlSyntax.setField(_fActivationDate, 'ActivationDate', DbType.real);
  }

  static TableField? _fExpiryDate;
  static TableField get ExpiryDate {
    return _fExpiryDate = _fExpiryDate ??
        SqlSyntax.setField(_fExpiryDate, 'ExpiryDate', DbType.real);
  }
}
// endregion VppFields

//region VppManager
class VppManager extends SqfEntityProvider {
  VppManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Vpp';
  static const List<String> _primaryKeyList = ['ServiceID'];
  static const String _whereStr = 'ServiceID=?';
}

//endregion VppManager
// region WeightValidation
class WeightValidation extends TableBase {
  WeightValidation({this.Product, this.WeightMin, this.WeightMax}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  WeightValidation.withFields(this.Product, this.WeightMin, this.WeightMax) {
    _setDefaultValues();
  }
  WeightValidation.withId(this.Product, this.WeightMin, this.WeightMax) {
    _setDefaultValues();
  }
  // fromMap v2.0
  WeightValidation.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Product = o['Product'].toString();
    if (o['WeightMin'] != null) {
      WeightMin = double.tryParse(o['WeightMin'].toString());
    }
    if (o['WeightMax'] != null) {
      WeightMax = double.tryParse(o['WeightMax'].toString());
    }

    isSaved = true;
  }
  // FIELDS (WeightValidation)
  String? Product;
  double? WeightMin;
  double? WeightMax;
  bool? isSaved;
  // end FIELDS (WeightValidation)

  static const bool _softDeleteActivated = false;
  WeightValidationManager? __mnWeightValidation;

  WeightValidationManager get _mnWeightValidation {
    return __mnWeightValidation =
        __mnWeightValidation ?? WeightValidationManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (WeightMin != null || !forView) {
      map['WeightMin'] = WeightMin;
    }
    if (WeightMax != null || !forView) {
      map['WeightMax'] = WeightMax;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Product'] = Product;
    if (WeightMin != null || !forView) {
      map['WeightMin'] = WeightMin;
    }
    if (WeightMax != null || !forView) {
      map['WeightMax'] = WeightMax;
    }

    return map;
  }

  /// This method returns Json String [WeightValidation]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [WeightValidation]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Product, WeightMin, WeightMax];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Product, WeightMin, WeightMax];
  }

  static Future<List<WeightValidation>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR WeightValidation.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<WeightValidation>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <WeightValidation>[];
    try {
      objList = list
          .map((weightvalidation) => WeightValidation.fromMap(
              weightvalidation as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR WeightValidation.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<WeightValidation>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<WeightValidation> objList = <WeightValidation>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = WeightValidation.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns WeightValidation by ID if exist, otherwise returns null
  /// Primary Keys: String? Product
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [WeightValidation] if exist, otherwise returns null
  Future<WeightValidation?> getById(String? Product,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Product == null) {
      return null;
    }
    WeightValidation? obj;
    final data = await _mnWeightValidation.getById([Product]);
    if (data.length != 0) {
      obj = WeightValidation.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (WeightValidation) object. If the Primary Key (Product) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Product
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnWeightValidation.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO WeightValidations (Product, WeightMin, WeightMax)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<WeightValidation> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<WeightValidation> weightvalidations,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in weightvalidations) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnWeightValidation.rawInsert(
          'INSERT OR REPLACE INTO WeightValidations (Product, WeightMin, WeightMax)  VALUES (?,?,?)',
          [Product, WeightMin, WeightMax],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'WeightValidation Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'WeightValidation Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'WeightValidation Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnWeightValidation.rawInsert(
          'INSERT OR IGNORE INTO WeightValidations (Product, WeightMin, WeightMax)  VALUES (?,?,?)',
          [Product, WeightMin, WeightMax],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'WeightValidation Product=$Product updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'WeightValidation Product=$Product did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'WeightValidation Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes WeightValidation

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete WeightValidation invoked (Product=$Product)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnWeightValidation.delete(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]));
    } else {
      return _mnWeightValidation.updateBatch(
          QueryParams(whereString: 'Product=?', whereArguments: [Product]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [WeightValidation] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  WeightValidationFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return WeightValidationFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  WeightValidationFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return WeightValidationFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Product = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion weightvalidation

// region WeightValidationField
class WeightValidationField extends FilterBase {
  WeightValidationField(WeightValidationFilterBuilder weightvalidationFB)
      : super(weightvalidationFB);

  @override
  WeightValidationFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder isNull() {
    return super.isNull() as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as WeightValidationFilterBuilder;
  }

  @override
  WeightValidationField get not {
    return super.not as WeightValidationField;
  }
}
// endregion WeightValidationField

// region WeightValidationFilterBuilder
class WeightValidationFilterBuilder extends ConjunctionBase {
  WeightValidationFilterBuilder(WeightValidation obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnWeightValidation = obj._mnWeightValidation;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  WeightValidationManager? _mnWeightValidation;

  /// put the sql keyword 'AND'
  @override
  WeightValidationFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  WeightValidationFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  WeightValidationFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  WeightValidationFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  WeightValidationFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  WeightValidationFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  WeightValidationFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  WeightValidationFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  WeightValidationFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  WeightValidationFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  WeightValidationFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  WeightValidationField _setField(
      WeightValidationField? field, String colName, DbType dbtype) {
    return WeightValidationField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  WeightValidationField? _Product;
  WeightValidationField get Product {
    return _Product = _setField(_Product, 'Product', DbType.integer);
  }

  WeightValidationField? _WeightMin;
  WeightValidationField get WeightMin {
    return _WeightMin = _setField(_WeightMin, 'WeightMin', DbType.real);
  }

  WeightValidationField? _WeightMax;
  WeightValidationField get WeightMax {
    return _WeightMax = _setField(_WeightMax, 'WeightMax', DbType.real);
  }

  /// Deletes List<WeightValidation> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnWeightValidation!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnWeightValidation!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Product IN (SELECT Product from WeightValidations ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnWeightValidation!.updateBatch(qparams, values);
  }

  /// This method always returns [WeightValidation] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> WeightValidation?
  @override
  Future<WeightValidation?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnWeightValidation!.toList(qparams);
    final data = await objFuture;
    WeightValidation? obj;
    if (data.isNotEmpty) {
      obj = WeightValidation.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [WeightValidation]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> WeightValidation?
  @override
  Future<WeightValidation> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        WeightValidation();
  }

  /// This method returns int. [WeightValidation]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? weightvalidationCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final weightvalidationsFuture = await _mnWeightValidation!.toList(qparams);
    final int count = weightvalidationsFuture[0]['CNT'] as int;
    if (weightvalidationCount != null) {
      weightvalidationCount(count);
    }
    return count;
  }

  /// This method returns List<WeightValidation> [WeightValidation]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<WeightValidation>
  @override
  Future<List<WeightValidation>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<WeightValidation> weightvalidationsData =
        await WeightValidation.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return weightvalidationsData;
  }

  /// This method returns Json String [WeightValidation]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [WeightValidation]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [WeightValidation]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnWeightValidation!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [WeightValidation]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Product` FROM WeightValidations WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductData = <String>[];
    qparams.selectColumns = ['Product'];
    final ProductFuture = await _mnWeightValidation!.toList(qparams);

    final int count = ProductFuture.length;
    for (int i = 0; i < count; i++) {
      ProductData.add(ProductFuture[i]['Product'] as String);
    }
    return ProductData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [WeightValidation]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnWeightValidation!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await WeightValidation.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnWeightValidation!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion WeightValidationFilterBuilder

// region WeightValidationFields
class WeightValidationFields {
  static TableField? _fProduct;
  static TableField get Product {
    return _fProduct =
        _fProduct ?? SqlSyntax.setField(_fProduct, 'product', DbType.integer);
  }

  static TableField? _fWeightMin;
  static TableField get WeightMin {
    return _fWeightMin = _fWeightMin ??
        SqlSyntax.setField(_fWeightMin, 'WeightMin', DbType.real);
  }

  static TableField? _fWeightMax;
  static TableField get WeightMax {
    return _fWeightMax = _fWeightMax ??
        SqlSyntax.setField(_fWeightMax, 'WeightMax', DbType.real);
  }
}
// endregion WeightValidationFields

//region WeightValidationManager
class WeightValidationManager extends SqfEntityProvider {
  WeightValidationManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'WeightValidations';
  static const List<String> _primaryKeyList = ['Product'];
  static const String _whereStr = 'Product=?';
}

//endregion WeightValidationManager
// region Vaservice
class Vaservice extends TableBase {
  Vaservice(
      {this.Productcode,
      this.ServiceType,
      this.VASdescription,
      this.VASPrice}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Vaservice.withFields(
      this.Productcode, this.ServiceType, this.VASdescription, this.VASPrice) {
    _setDefaultValues();
  }
  Vaservice.withId(
      this.Productcode, this.ServiceType, this.VASdescription, this.VASPrice) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Vaservice.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Productcode = o['Productcode'].toString();
    if (o['ServiceType'] != null) {
      ServiceType = o['ServiceType'].toString();
    }
    if (o['VASdescription'] != null) {
      VASdescription = o['VASdescription'].toString();
    }
    if (o['VASPrice'] != null) {
      VASPrice = double.tryParse(o['VASPrice'].toString());
    }

    isSaved = true;
  }
  // FIELDS (Vaservice)
  String? Productcode;
  String? ServiceType;
  String? VASdescription;
  double? VASPrice;
  bool? isSaved;
  // end FIELDS (Vaservice)

  static const bool _softDeleteActivated = false;
  VaserviceManager? __mnVaservice;

  VaserviceManager get _mnVaservice {
    return __mnVaservice = __mnVaservice ?? VaserviceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ServiceType != null || !forView) {
      map['ServiceType'] = ServiceType;
    }
    if (VASdescription != null || !forView) {
      map['VASdescription'] = VASdescription;
    }
    if (VASPrice != null || !forView) {
      map['VASPrice'] = VASPrice;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Productcode'] = Productcode;
    if (ServiceType != null || !forView) {
      map['ServiceType'] = ServiceType;
    }
    if (VASdescription != null || !forView) {
      map['VASdescription'] = VASdescription;
    }
    if (VASPrice != null || !forView) {
      map['VASPrice'] = VASPrice;
    }

    return map;
  }

  /// This method returns Json String [Vaservice]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Vaservice]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Productcode, ServiceType, VASdescription, VASPrice];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Productcode, ServiceType, VASdescription, VASPrice];
  }

  static Future<List<Vaservice>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Vaservice.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Vaservice>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Vaservice>[];
    try {
      objList = list
          .map((vaservice) =>
              Vaservice.fromMap(vaservice as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Vaservice.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Vaservice>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Vaservice> objList = <Vaservice>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Vaservice.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Vaservice by ID if exist, otherwise returns null
  /// Primary Keys: String? Productcode
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Vaservice] if exist, otherwise returns null
  Future<Vaservice?> getById(String? Productcode,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Productcode == null) {
      return null;
    }
    Vaservice? obj;
    final data = await _mnVaservice.getById([Productcode]);
    if (data.length != 0) {
      obj = Vaservice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Vaservice) object. If the Primary Key (Productcode) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Productcode
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnVaservice.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Vaservices (Productcode, ServiceType, VASdescription, VASPrice)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Vaservice> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Vaservice> vaservices,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in vaservices) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVaservice.rawInsert(
          'INSERT OR REPLACE INTO Vaservices (Productcode, ServiceType, VASdescription, VASPrice)  VALUES (?,?,?,?)',
          [Productcode, ServiceType, VASdescription, VASPrice],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Vaservice Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Vaservice Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Vaservice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVaservice.rawInsert(
          'INSERT OR IGNORE INTO Vaservices (Productcode, ServiceType, VASdescription, VASPrice)  VALUES (?,?,?,?)',
          [Productcode, ServiceType, VASdescription, VASPrice],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Vaservice Productcode=$Productcode updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Vaservice Productcode=$Productcode did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Vaservice Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Vaservice

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete Vaservice invoked (Productcode=$Productcode)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnVaservice.delete(QueryParams(
          whereString: 'Productcode=?', whereArguments: [Productcode]));
    } else {
      return _mnVaservice.updateBatch(
          QueryParams(
              whereString: 'Productcode=?', whereArguments: [Productcode]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Vaservice] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  VaserviceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VaserviceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VaserviceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VaserviceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Productcode = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vaservice

// region VaserviceField
class VaserviceField extends FilterBase {
  VaserviceField(VaserviceFilterBuilder vaserviceFB) : super(vaserviceFB);

  @override
  VaserviceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder isNull() {
    return super.isNull() as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VaserviceFilterBuilder;
  }

  @override
  VaserviceField get not {
    return super.not as VaserviceField;
  }
}
// endregion VaserviceField

// region VaserviceFilterBuilder
class VaserviceFilterBuilder extends ConjunctionBase {
  VaserviceFilterBuilder(Vaservice obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnVaservice = obj._mnVaservice;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  VaserviceManager? _mnVaservice;

  /// put the sql keyword 'AND'
  @override
  VaserviceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VaserviceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VaserviceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VaserviceFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VaserviceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VaserviceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VaserviceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VaserviceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VaserviceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VaserviceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VaserviceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VaserviceField _setField(
      VaserviceField? field, String colName, DbType dbtype) {
    return VaserviceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VaserviceField? _Productcode;
  VaserviceField get Productcode {
    return _Productcode =
        _setField(_Productcode, 'Productcode', DbType.integer);
  }

  VaserviceField? _ServiceType;
  VaserviceField get ServiceType {
    return _ServiceType = _setField(_ServiceType, 'ServiceType', DbType.text);
  }

  VaserviceField? _VASdescription;
  VaserviceField get VASdescription {
    return _VASdescription =
        _setField(_VASdescription, 'VASdescription', DbType.text);
  }

  VaserviceField? _VASPrice;
  VaserviceField get VASPrice {
    return _VASPrice = _setField(_VASPrice, 'VASPrice', DbType.real);
  }

  /// Deletes List<Vaservice> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnVaservice!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnVaservice!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Productcode IN (SELECT Productcode from Vaservices ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnVaservice!.updateBatch(qparams, values);
  }

  /// This method always returns [Vaservice] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Vaservice?
  @override
  Future<Vaservice?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVaservice!.toList(qparams);
    final data = await objFuture;
    Vaservice? obj;
    if (data.isNotEmpty) {
      obj = Vaservice.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Vaservice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Vaservice?
  @override
  Future<Vaservice> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Vaservice();
  }

  /// This method returns int. [Vaservice]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? vaserviceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vaservicesFuture = await _mnVaservice!.toList(qparams);
    final int count = vaservicesFuture[0]['CNT'] as int;
    if (vaserviceCount != null) {
      vaserviceCount(count);
    }
    return count;
  }

  /// This method returns List<Vaservice> [Vaservice]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Vaservice>
  @override
  Future<List<Vaservice>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Vaservice> vaservicesData = await Vaservice.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vaservicesData;
  }

  /// This method returns Json String [Vaservice]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Vaservice]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Vaservice]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVaservice!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Vaservice]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Productcode` FROM Vaservices WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductcodeData = <String>[];
    qparams.selectColumns = ['Productcode'];
    final ProductcodeFuture = await _mnVaservice!.toList(qparams);

    final int count = ProductcodeFuture.length;
    for (int i = 0; i < count; i++) {
      ProductcodeData.add(ProductcodeFuture[i]['Productcode'] as String);
    }
    return ProductcodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Vaservice]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVaservice!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Vaservice.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVaservice!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VaserviceFilterBuilder

// region VaserviceFields
class VaserviceFields {
  static TableField? _fProductcode;
  static TableField get Productcode {
    return _fProductcode = _fProductcode ??
        SqlSyntax.setField(_fProductcode, 'productcode', DbType.integer);
  }

  static TableField? _fServiceType;
  static TableField get ServiceType {
    return _fServiceType = _fServiceType ??
        SqlSyntax.setField(_fServiceType, 'ServiceType', DbType.text);
  }

  static TableField? _fVASdescription;
  static TableField get VASdescription {
    return _fVASdescription = _fVASdescription ??
        SqlSyntax.setField(_fVASdescription, 'VASdescription', DbType.text);
  }

  static TableField? _fVASPrice;
  static TableField get VASPrice {
    return _fVASPrice =
        _fVASPrice ?? SqlSyntax.setField(_fVASPrice, 'VASPrice', DbType.real);
  }
}
// endregion VaserviceFields

//region VaserviceManager
class VaserviceManager extends SqfEntityProvider {
  VaserviceManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Vaservices';
  static const List<String> _primaryKeyList = ['Productcode'];
  static const String _whereStr = 'Productcode=?';
}

//endregion VaserviceManager
// region OfficeMasterPinCode
class OfficeMasterPinCode extends TableBase {
  OfficeMasterPinCode(
      {this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.Priority,
      this.State,
      this.Region,
      this.ReceiverCityDistrict}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  OfficeMasterPinCode.withFields(
      this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.Priority,
      this.State,
      this.Region,
      this.ReceiverCityDistrict) {
    _setDefaultValues();
  }
  OfficeMasterPinCode.withId(
      this.FacilityID,
      this.OfficeName,
      this.OfficeType,
      this.Pincode,
      this.Delivery,
      this.Latitude,
      this.Longitude,
      this.SOName,
      this.HOName,
      this.DOName,
      this.ROName,
      this.COName,
      this.ContactNumber,
      this.EndDate,
      this.ModifiedDate,
      this.Priority,
      this.State,
      this.Region,
      this.ReceiverCityDistrict) {
    _setDefaultValues();
  }
  // fromMap v2.0
  OfficeMasterPinCode.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    FacilityID = o['FacilityID'].toString();
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['OfficeType'] != null) {
      OfficeType = o['OfficeType'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = int.tryParse(o['Pincode'].toString());
    }
    if (o['Delivery'] != null) {
      Delivery = o['Delivery'].toString();
    }
    if (o['Latitude'] != null) {
      Latitude = double.tryParse(o['Latitude'].toString());
    }
    if (o['Longitude'] != null) {
      Longitude = double.tryParse(o['Longitude'].toString());
    }
    if (o['SOName'] != null) {
      SOName = o['SOName'].toString();
    }
    if (o['HOName'] != null) {
      HOName = o['HOName'].toString();
    }
    if (o['DOName'] != null) {
      DOName = o['DOName'].toString();
    }
    if (o['ROName'] != null) {
      ROName = o['ROName'].toString();
    }
    if (o['COName'] != null) {
      COName = o['COName'].toString();
    }
    if (o['ContactNumber'] != null) {
      ContactNumber = int.tryParse(o['ContactNumber'].toString());
    }
    if (o['EndDate'] != null) {
      EndDate = int.tryParse(o['EndDate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['EndDate'].toString())!)
          : DateTime.tryParse(o['EndDate'].toString());
    }
    if (o['ModifiedDate'] != null) {
      ModifiedDate = o['ModifiedDate'].toString();
    }
    if (o['Priority'] != null) {
      Priority = int.tryParse(o['Priority'].toString());
    }
    if (o['State'] != null) {
      State = o['State'].toString();
    }
    if (o['Region'] != null) {
      Region = int.tryParse(o['Region'].toString());
    }
    if (o['ReceiverCityDistrict'] != null) {
      ReceiverCityDistrict = o['ReceiverCityDistrict'].toString();
    }

    isSaved = true;
  }
  // FIELDS (OfficeMasterPinCode)
  String? FacilityID;
  String? OfficeName;
  String? OfficeType;
  int? Pincode;
  String? Delivery;
  double? Latitude;
  double? Longitude;
  String? SOName;
  String? HOName;
  String? DOName;
  String? ROName;
  String? COName;
  int? ContactNumber;
  DateTime? EndDate;
  String? ModifiedDate;
  int? Priority;
  String? State;
  int? Region;
  String? ReceiverCityDistrict;
  bool? isSaved;
  // end FIELDS (OfficeMasterPinCode)

  static const bool _softDeleteActivated = false;
  OfficeMasterPinCodeManager? __mnOfficeMasterPinCode;

  OfficeMasterPinCodeManager get _mnOfficeMasterPinCode {
    return __mnOfficeMasterPinCode =
        __mnOfficeMasterPinCode ?? OfficeMasterPinCodeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['FacilityID'] = FacilityID;
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (OfficeType != null || !forView) {
      map['OfficeType'] = OfficeType;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (Delivery != null || !forView) {
      map['Delivery'] = Delivery;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (ROName != null || !forView) {
      map['ROName'] = ROName;
    }
    if (COName != null || !forView) {
      map['COName'] = COName;
    }
    if (ContactNumber != null || !forView) {
      map['ContactNumber'] = ContactNumber;
    }
    if (EndDate != null) {
      map['EndDate'] = forJson
          ? '$EndDate!.year-$EndDate!.month-$EndDate!.day'
          : forQuery
              ? DateTime(EndDate!.year, EndDate!.month, EndDate!.day)
                  .millisecondsSinceEpoch
              : EndDate;
    } else if (EndDate != null || !forView) {
      map['EndDate'] = null;
    }
    if (ModifiedDate != null || !forView) {
      map['ModifiedDate'] = ModifiedDate;
    }
    if (Priority != null || !forView) {
      map['Priority'] = Priority;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Region != null || !forView) {
      map['Region'] = Region;
    }
    if (ReceiverCityDistrict != null || !forView) {
      map['ReceiverCityDistrict'] = ReceiverCityDistrict;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['FacilityID'] = FacilityID;
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (OfficeType != null || !forView) {
      map['OfficeType'] = OfficeType;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (Delivery != null || !forView) {
      map['Delivery'] = Delivery;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (ROName != null || !forView) {
      map['ROName'] = ROName;
    }
    if (COName != null || !forView) {
      map['COName'] = COName;
    }
    if (ContactNumber != null || !forView) {
      map['ContactNumber'] = ContactNumber;
    }
    if (EndDate != null) {
      map['EndDate'] = forJson
          ? '$EndDate!.year-$EndDate!.month-$EndDate!.day'
          : forQuery
              ? DateTime(EndDate!.year, EndDate!.month, EndDate!.day)
                  .millisecondsSinceEpoch
              : EndDate;
    } else if (EndDate != null || !forView) {
      map['EndDate'] = null;
    }
    if (ModifiedDate != null || !forView) {
      map['ModifiedDate'] = ModifiedDate;
    }
    if (Priority != null || !forView) {
      map['Priority'] = Priority;
    }
    if (State != null || !forView) {
      map['State'] = State;
    }
    if (Region != null || !forView) {
      map['Region'] = Region;
    }
    if (ReceiverCityDistrict != null || !forView) {
      map['ReceiverCityDistrict'] = ReceiverCityDistrict;
    }

    return map;
  }

  /// This method returns Json String [OfficeMasterPinCode]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [OfficeMasterPinCode]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityID,
      OfficeName,
      OfficeType,
      Pincode,
      Delivery,
      Latitude,
      Longitude,
      SOName,
      HOName,
      DOName,
      ROName,
      COName,
      ContactNumber,
      EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
      ModifiedDate,
      Priority,
      State,
      Region,
      ReceiverCityDistrict
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      FacilityID,
      OfficeName,
      OfficeType,
      Pincode,
      Delivery,
      Latitude,
      Longitude,
      SOName,
      HOName,
      DOName,
      ROName,
      COName,
      ContactNumber,
      EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
      ModifiedDate,
      Priority,
      State,
      Region,
      ReceiverCityDistrict
    ];
  }

  static Future<List<OfficeMasterPinCode>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OfficeMasterPinCode.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<OfficeMasterPinCode>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <OfficeMasterPinCode>[];
    try {
      objList = list
          .map((officemasterpincode) => OfficeMasterPinCode.fromMap(
              officemasterpincode as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OfficeMasterPinCode.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<OfficeMasterPinCode>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<OfficeMasterPinCode> objList = <OfficeMasterPinCode>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = OfficeMasterPinCode.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns OfficeMasterPinCode by ID if exist, otherwise returns null
  /// Primary Keys: String? FacilityID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [OfficeMasterPinCode] if exist, otherwise returns null
  Future<OfficeMasterPinCode?> getById(String? FacilityID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (FacilityID == null) {
      return null;
    }
    OfficeMasterPinCode? obj;
    final data = await _mnOfficeMasterPinCode.getById([FacilityID]);
    if (data.length != 0) {
      obj = OfficeMasterPinCode.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (OfficeMasterPinCode) object. If the Primary Key (FacilityID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same FacilityID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnOfficeMasterPinCode.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO OfficeMasterPinCode (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, Priority, State, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<OfficeMasterPinCode> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<OfficeMasterPinCode> officemasterpincodes,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await Tariffdb().batchStart();
    for (final obj in officemasterpincodes) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await Tariffdb().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOfficeMasterPinCode.rawInsert(
          'INSERT OR REPLACE INTO OfficeMasterPinCode (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, Priority, State, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            FacilityID,
            OfficeName,
            OfficeType,
            Pincode,
            Delivery,
            Latitude,
            Longitude,
            SOName,
            HOName,
            DOName,
            ROName,
            COName,
            ContactNumber,
            EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
            ModifiedDate,
            Priority,
            State,
            Region,
            ReceiverCityDistrict
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'OfficeMasterPinCode FacilityID=$FacilityID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'OfficeMasterPinCode FacilityID=$FacilityID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'OfficeMasterPinCode Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOfficeMasterPinCode.rawInsert(
          'INSERT OR IGNORE INTO OfficeMasterPinCode (FacilityID, OfficeName, OfficeType, Pincode, Delivery, Latitude, Longitude, SOName, HOName, DOName, ROName, COName, ContactNumber, EndDate, ModifiedDate, Priority, State, Region, ReceiverCityDistrict)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            FacilityID,
            OfficeName,
            OfficeType,
            Pincode,
            Delivery,
            Latitude,
            Longitude,
            SOName,
            HOName,
            DOName,
            ROName,
            COName,
            ContactNumber,
            EndDate != null ? EndDate!.millisecondsSinceEpoch : null,
            ModifiedDate,
            Priority,
            State,
            Region,
            ReceiverCityDistrict
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'OfficeMasterPinCode FacilityID=$FacilityID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'OfficeMasterPinCode FacilityID=$FacilityID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'OfficeMasterPinCode Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes OfficeMasterPinCode

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete OfficeMasterPinCode invoked (FacilityID=$FacilityID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnOfficeMasterPinCode.delete(QueryParams(
          whereString: 'FacilityID=?', whereArguments: [FacilityID]));
    } else {
      return _mnOfficeMasterPinCode.updateBatch(
          QueryParams(
              whereString: 'FacilityID=?', whereArguments: [FacilityID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [OfficeMasterPinCode] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  OfficeMasterPinCodeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OfficeMasterPinCodeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  OfficeMasterPinCodeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OfficeMasterPinCodeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      FacilityID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion officemasterpincode

// region OfficeMasterPinCodeField
class OfficeMasterPinCodeField extends FilterBase {
  OfficeMasterPinCodeField(
      OfficeMasterPinCodeFilterBuilder officemasterpincodeFB)
      : super(officemasterpincodeFB);

  @override
  OfficeMasterPinCodeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder isNull() {
    return super.isNull() as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as OfficeMasterPinCodeFilterBuilder;
  }

  @override
  OfficeMasterPinCodeField get not {
    return super.not as OfficeMasterPinCodeField;
  }
}
// endregion OfficeMasterPinCodeField

// region OfficeMasterPinCodeFilterBuilder
class OfficeMasterPinCodeFilterBuilder extends ConjunctionBase {
  OfficeMasterPinCodeFilterBuilder(OfficeMasterPinCode obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnOfficeMasterPinCode = obj._mnOfficeMasterPinCode;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  OfficeMasterPinCodeManager? _mnOfficeMasterPinCode;

  /// put the sql keyword 'AND'
  @override
  OfficeMasterPinCodeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  OfficeMasterPinCodeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  OfficeMasterPinCodeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  OfficeMasterPinCodeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  OfficeMasterPinCodeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  OfficeMasterPinCodeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  OfficeMasterPinCodeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OfficeMasterPinCodeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OfficeMasterPinCodeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OfficeMasterPinCodeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OfficeMasterPinCodeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  OfficeMasterPinCodeField _setField(
      OfficeMasterPinCodeField? field, String colName, DbType dbtype) {
    return OfficeMasterPinCodeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  OfficeMasterPinCodeField? _FacilityID;
  OfficeMasterPinCodeField get FacilityID {
    return _FacilityID = _setField(_FacilityID, 'FacilityID', DbType.integer);
  }

  OfficeMasterPinCodeField? _OfficeName;
  OfficeMasterPinCodeField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  OfficeMasterPinCodeField? _OfficeType;
  OfficeMasterPinCodeField get OfficeType {
    return _OfficeType = _setField(_OfficeType, 'OfficeType', DbType.text);
  }

  OfficeMasterPinCodeField? _Pincode;
  OfficeMasterPinCodeField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.integer);
  }

  OfficeMasterPinCodeField? _Delivery;
  OfficeMasterPinCodeField get Delivery {
    return _Delivery = _setField(_Delivery, 'Delivery', DbType.text);
  }

  OfficeMasterPinCodeField? _Latitude;
  OfficeMasterPinCodeField get Latitude {
    return _Latitude = _setField(_Latitude, 'Latitude', DbType.real);
  }

  OfficeMasterPinCodeField? _Longitude;
  OfficeMasterPinCodeField get Longitude {
    return _Longitude = _setField(_Longitude, 'Longitude', DbType.real);
  }

  OfficeMasterPinCodeField? _SOName;
  OfficeMasterPinCodeField get SOName {
    return _SOName = _setField(_SOName, 'SOName', DbType.text);
  }

  OfficeMasterPinCodeField? _HOName;
  OfficeMasterPinCodeField get HOName {
    return _HOName = _setField(_HOName, 'HOName', DbType.text);
  }

  OfficeMasterPinCodeField? _DOName;
  OfficeMasterPinCodeField get DOName {
    return _DOName = _setField(_DOName, 'DOName', DbType.text);
  }

  OfficeMasterPinCodeField? _ROName;
  OfficeMasterPinCodeField get ROName {
    return _ROName = _setField(_ROName, 'ROName', DbType.text);
  }

  OfficeMasterPinCodeField? _COName;
  OfficeMasterPinCodeField get COName {
    return _COName = _setField(_COName, 'COName', DbType.text);
  }

  OfficeMasterPinCodeField? _ContactNumber;
  OfficeMasterPinCodeField get ContactNumber {
    return _ContactNumber =
        _setField(_ContactNumber, 'ContactNumber', DbType.integer);
  }

  OfficeMasterPinCodeField? _EndDate;
  OfficeMasterPinCodeField get EndDate {
    return _EndDate = _setField(_EndDate, 'EndDate', DbType.date);
  }

  OfficeMasterPinCodeField? _ModifiedDate;
  OfficeMasterPinCodeField get ModifiedDate {
    return _ModifiedDate =
        _setField(_ModifiedDate, 'ModifiedDate', DbType.text);
  }

  OfficeMasterPinCodeField? _Priority;
  OfficeMasterPinCodeField get Priority {
    return _Priority = _setField(_Priority, 'Priority', DbType.integer);
  }

  OfficeMasterPinCodeField? _State;
  OfficeMasterPinCodeField get State {
    return _State = _setField(_State, 'State', DbType.text);
  }

  OfficeMasterPinCodeField? _Region;
  OfficeMasterPinCodeField get Region {
    return _Region = _setField(_Region, 'Region', DbType.integer);
  }

  OfficeMasterPinCodeField? _ReceiverCityDistrict;
  OfficeMasterPinCodeField get ReceiverCityDistrict {
    return _ReceiverCityDistrict =
        _setField(_ReceiverCityDistrict, 'ReceiverCityDistrict', DbType.text);
  }

  /// Deletes List<OfficeMasterPinCode> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnOfficeMasterPinCode!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnOfficeMasterPinCode!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'FacilityID IN (SELECT FacilityID from OfficeMasterPinCode ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnOfficeMasterPinCode!.updateBatch(qparams, values);
  }

  /// This method always returns [OfficeMasterPinCode] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OfficeMasterPinCode?
  @override
  Future<OfficeMasterPinCode?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnOfficeMasterPinCode!.toList(qparams);
    final data = await objFuture;
    OfficeMasterPinCode? obj;
    if (data.isNotEmpty) {
      obj = OfficeMasterPinCode.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [OfficeMasterPinCode]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OfficeMasterPinCode?
  @override
  Future<OfficeMasterPinCode> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        OfficeMasterPinCode();
  }

  /// This method returns int. [OfficeMasterPinCode]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? officemasterpincodeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final officemasterpincodesFuture =
        await _mnOfficeMasterPinCode!.toList(qparams);
    final int count = officemasterpincodesFuture[0]['CNT'] as int;
    if (officemasterpincodeCount != null) {
      officemasterpincodeCount(count);
    }
    return count;
  }

  /// This method returns List<OfficeMasterPinCode> [OfficeMasterPinCode]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<OfficeMasterPinCode>
  @override
  Future<List<OfficeMasterPinCode>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<OfficeMasterPinCode> officemasterpincodesData =
        await OfficeMasterPinCode.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return officemasterpincodesData;
  }

  /// This method returns Json String [OfficeMasterPinCode]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [OfficeMasterPinCode]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [OfficeMasterPinCode]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnOfficeMasterPinCode!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [OfficeMasterPinCode]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `FacilityID` FROM OfficeMasterPinCode WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> FacilityIDData = <String>[];
    qparams.selectColumns = ['FacilityID'];
    final FacilityIDFuture = await _mnOfficeMasterPinCode!.toList(qparams);

    final int count = FacilityIDFuture.length;
    for (int i = 0; i < count; i++) {
      FacilityIDData.add(FacilityIDFuture[i]['FacilityID'] as String);
    }
    return FacilityIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [OfficeMasterPinCode]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnOfficeMasterPinCode!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await OfficeMasterPinCode.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnOfficeMasterPinCode!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion OfficeMasterPinCodeFilterBuilder

// region OfficeMasterPinCodeFields
class OfficeMasterPinCodeFields {
  static TableField? _fFacilityID;
  static TableField get FacilityID {
    return _fFacilityID = _fFacilityID ??
        SqlSyntax.setField(_fFacilityID, 'facilityid', DbType.integer);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fOfficeType;
  static TableField get OfficeType {
    return _fOfficeType = _fOfficeType ??
        SqlSyntax.setField(_fOfficeType, 'OfficeType', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.integer);
  }

  static TableField? _fDelivery;
  static TableField get Delivery {
    return _fDelivery =
        _fDelivery ?? SqlSyntax.setField(_fDelivery, 'Delivery', DbType.text);
  }

  static TableField? _fLatitude;
  static TableField get Latitude {
    return _fLatitude =
        _fLatitude ?? SqlSyntax.setField(_fLatitude, 'Latitude', DbType.real);
  }

  static TableField? _fLongitude;
  static TableField get Longitude {
    return _fLongitude = _fLongitude ??
        SqlSyntax.setField(_fLongitude, 'Longitude', DbType.real);
  }

  static TableField? _fSOName;
  static TableField get SOName {
    return _fSOName =
        _fSOName ?? SqlSyntax.setField(_fSOName, 'SOName', DbType.text);
  }

  static TableField? _fHOName;
  static TableField get HOName {
    return _fHOName =
        _fHOName ?? SqlSyntax.setField(_fHOName, 'HOName', DbType.text);
  }

  static TableField? _fDOName;
  static TableField get DOName {
    return _fDOName =
        _fDOName ?? SqlSyntax.setField(_fDOName, 'DOName', DbType.text);
  }

  static TableField? _fROName;
  static TableField get ROName {
    return _fROName =
        _fROName ?? SqlSyntax.setField(_fROName, 'ROName', DbType.text);
  }

  static TableField? _fCOName;
  static TableField get COName {
    return _fCOName =
        _fCOName ?? SqlSyntax.setField(_fCOName, 'COName', DbType.text);
  }

  static TableField? _fContactNumber;
  static TableField get ContactNumber {
    return _fContactNumber = _fContactNumber ??
        SqlSyntax.setField(_fContactNumber, 'ContactNumber', DbType.integer);
  }

  static TableField? _fEndDate;
  static TableField get EndDate {
    return _fEndDate =
        _fEndDate ?? SqlSyntax.setField(_fEndDate, 'EndDate', DbType.date);
  }

  static TableField? _fModifiedDate;
  static TableField get ModifiedDate {
    return _fModifiedDate = _fModifiedDate ??
        SqlSyntax.setField(_fModifiedDate, 'ModifiedDate', DbType.text);
  }

  static TableField? _fPriority;
  static TableField get Priority {
    return _fPriority = _fPriority ??
        SqlSyntax.setField(_fPriority, 'Priority', DbType.integer);
  }

  static TableField? _fState;
  static TableField get State {
    return _fState =
        _fState ?? SqlSyntax.setField(_fState, 'State', DbType.text);
  }

  static TableField? _fRegion;
  static TableField get Region {
    return _fRegion =
        _fRegion ?? SqlSyntax.setField(_fRegion, 'Region', DbType.integer);
  }

  static TableField? _fReceiverCityDistrict;
  static TableField get ReceiverCityDistrict {
    return _fReceiverCityDistrict = _fReceiverCityDistrict ??
        SqlSyntax.setField(
            _fReceiverCityDistrict, 'ReceiverCityDistrict', DbType.text);
  }
}
// endregion OfficeMasterPinCodeFields

//region OfficeMasterPinCodeManager
class OfficeMasterPinCodeManager extends SqfEntityProvider {
  OfficeMasterPinCodeManager()
      : super(Tariffdb(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'OfficeMasterPinCode';
  static const List<String> _primaryKeyList = ['FacilityID'];
  static const String _whereStr = 'FacilityID=?';
}

//endregion OfficeMasterPinCodeManager
class TariffdbSequenceManager extends SqfEntityProvider {
  TariffdbSequenceManager() : super(Tariffdb());
}
// END OF ENTITIES
