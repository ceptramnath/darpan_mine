// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'transtable.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:TransactionTable.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// TransactionTable TABLE
class TableTransactionTable extends SqfEntityTableBase {
  TableTransactionTable() {
    // declare properties of EntityTable
    tableName = 'TransactionTable';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('tranid', DbType.text),
      SqfEntityFieldBase('tranType', DbType.text),
      SqfEntityFieldBase('tranDescription', DbType.text),
      SqfEntityFieldBase('tranDate', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('tranTime', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('tranAmount', DbType.real),
      SqfEntityFieldBase('valuation', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTransactionTable();
  }
}

// CashTable TABLE
class TableCashTable extends SqfEntityTableBase {
  TableCashTable() {
    // declare properties of EntityTable
    tableName = 'CashTable';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Cash_ID', DbType.text),
      SqfEntityFieldBase('Cash_Amount', DbType.real),
      SqfEntityFieldBase('Cash_Description', DbType.text),
      SqfEntityFieldBase('Cash_Type', DbType.text),
      SqfEntityFieldBase('Cash_Date', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('Cash_Time', DbType.text, isPrimaryKeyField: true),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCashTable();
  }
}

// DataEntry_DETAILS TABLE
class TableDataEntry_DETAILS extends SqfEntityTableBase {
  TableDataEntry_DETAILS() {
    // declare properties of EntityTable
    tableName = 'DataEntry_DETAILS';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('TRANSACTION_DATE', DbType.text),
      SqfEntityFieldBase('TRANSACTION_TIME', DbType.text),
      SqfEntityFieldBase('ENTRY_TYPE', DbType.text),
      SqfEntityFieldBase('TOTAL_DEPOSITS', DbType.text),
      SqfEntityFieldBase('TOTAL_DEPOSIT_AMOUNT', DbType.text),
      SqfEntityFieldBase('TOTAL_WITHDRAWALS', DbType.text),
      SqfEntityFieldBase('TOTAL_WITHDRAWAL_AMOUNT', DbType.text),
      SqfEntityFieldBase('Remarks', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDataEntry_DETAILS();
  }
}

// IppbApi TABLE
class TableIppbApi extends SqfEntityTableBase {
  TableIppbApi() {
    // declare properties of EntityTable
    tableName = 'IppbApi';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ReqDATE', DbType.text),
      SqfEntityFieldBase('ReqTime', DbType.text),
      SqfEntityFieldBase('FacId', DbType.text),
      SqfEntityFieldBase('TranDate', DbType.text),
      SqfEntityFieldBase('FromDateTime', DbType.text),
      SqfEntityFieldBase('ToDateTime', DbType.text),
      SqfEntityFieldBase('TotalDeposit', DbType.text),
      SqfEntityFieldBase('TotalWithdrawl', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('Remarks', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIppbApi();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class TransactionsMain extends SqfEntityModelProvider {
  TransactionsMain() {
    databaseName = cashModel.databaseName;
    password = cashModel.password;
    dbVersion = cashModel.dbVersion;
    preSaveAction = cashModel.preSaveAction;
    logFunction = cashModel.logFunction;
    databaseTables = [
      TableTransactionTable.getInstance,
      TableCashTable.getInstance,
      TableDataEntry_DETAILS.getInstance,
      TableIppbApi.getInstance,
    ];

    bundledDatabasePath = cashModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = cashModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region TransactionTable
class TransactionTable extends TableBase {
  TransactionTable(
      {this.Sl,
      this.tranid,
      this.tranType,
      this.tranDescription,
      this.tranDate,
      this.tranTime,
      this.tranAmount,
      this.valuation}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TransactionTable.withFields(this.tranid, this.tranType, this.tranDescription,
      this.tranDate, this.tranTime, this.tranAmount, this.valuation) {
    _setDefaultValues();
  }
  TransactionTable.withId(
      this.Sl,
      this.tranid,
      this.tranType,
      this.tranDescription,
      this.tranDate,
      this.tranTime,
      this.tranAmount,
      this.valuation) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TransactionTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['tranid'] != null) {
      tranid = o['tranid'].toString();
    }
    if (o['tranType'] != null) {
      tranType = o['tranType'].toString();
    }
    if (o['tranDescription'] != null) {
      tranDescription = o['tranDescription'].toString();
    }
    if (o['tranDate'] != null) {
      tranDate = o['tranDate'].toString();
    }
    if (o['tranTime'] != null) {
      tranTime = o['tranTime'].toString();
    }
    if (o['tranAmount'] != null) {
      tranAmount = double.tryParse(o['tranAmount'].toString());
    }
    if (o['valuation'] != null) {
      valuation = o['valuation'].toString();
    }
  }
  // FIELDS (TransactionTable)
  int? Sl;
  String? tranid;
  String? tranType;
  String? tranDescription;
  String? tranDate;
  String? tranTime;
  double? tranAmount;
  String? valuation;

  // end FIELDS (TransactionTable)

  static const bool _softDeleteActivated = false;
  TransactionTableManager? __mnTransactionTable;

  TransactionTableManager get _mnTransactionTable {
    return __mnTransactionTable =
        __mnTransactionTable ?? TransactionTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (tranid != null || !forView) {
      map['tranid'] = tranid;
    }
    if (tranType != null || !forView) {
      map['tranType'] = tranType;
    }
    if (tranDescription != null || !forView) {
      map['tranDescription'] = tranDescription;
    }
    if (tranDate != null || !forView) {
      map['tranDate'] = tranDate;
    }
    if (tranTime != null || !forView) {
      map['tranTime'] = tranTime;
    }
    if (tranAmount != null || !forView) {
      map['tranAmount'] = tranAmount;
    }
    if (valuation != null || !forView) {
      map['valuation'] = valuation;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (tranid != null || !forView) {
      map['tranid'] = tranid;
    }
    if (tranType != null || !forView) {
      map['tranType'] = tranType;
    }
    if (tranDescription != null || !forView) {
      map['tranDescription'] = tranDescription;
    }
    if (tranDate != null || !forView) {
      map['tranDate'] = tranDate;
    }
    if (tranTime != null || !forView) {
      map['tranTime'] = tranTime;
    }
    if (tranAmount != null || !forView) {
      map['tranAmount'] = tranAmount;
    }
    if (valuation != null || !forView) {
      map['valuation'] = valuation;
    }

    return map;
  }

  /// This method returns Json String [TransactionTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TransactionTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      tranid,
      tranType,
      tranDescription,
      tranDate,
      tranTime,
      tranAmount,
      valuation
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      tranid,
      tranType,
      tranDescription,
      tranDate,
      tranTime,
      tranAmount,
      valuation
    ];
  }

  static Future<List<TransactionTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TransactionTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TransactionTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TransactionTable>[];
    try {
      objList = list
          .map((transactiontable) => TransactionTable.fromMap(
              transactiontable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TransactionTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TransactionTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TransactionTable> objList = <TransactionTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TransactionTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TransactionTable by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? tranDate, String? tranTime
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TransactionTable] if exist, otherwise returns null
  Future<TransactionTable?> getById(int? Sl, String? tranDate, String? tranTime,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    TransactionTable? obj;
    final data = await _mnTransactionTable.getById([Sl, tranDate, tranTime]);
    if (data.length != 0) {
      obj = TransactionTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TransactionTable) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTransactionTable.rawInsert(
          'INSERT OR REPLACE INTO TransactionTable (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs TransactionTable
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTransactionTable.rawInsert(
          'INSERT INTO TransactionTable ( tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?)',
          [
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<TransactionTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TransactionTable> transactiontables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await TransactionsMain().batchStart();
    for (final obj in transactiontables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await TransactionsMain().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < transactiontables.length; i++) {
        if (transactiontables[i].Sl == null) {
          transactiontables[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTransactionTable.rawInsert(
          'INSERT OR REPLACE INTO TransactionTable (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TransactionTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TransactionTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TransactionTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTransactionTable.rawInsert(
          'INSERT OR IGNORE INTO TransactionTable (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            tranid,
            tranType,
            tranDescription,
            tranDate,
            tranTime,
            tranAmount,
            valuation
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TransactionTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TransactionTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TransactionTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// inserts or replaces the sent List<<TransactionTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<TransactionTable> transactiontables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnTransactionTable.rawInsertAll(
        'INSERT OR REPLACE INTO TransactionTable (Sl, tranid, tranType, tranDescription, tranDate, tranTime, tranAmount, valuation)  VALUES (?,?,?,?,?,?,?,?)',
        transactiontables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes TransactionTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TransactionTable invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTransactionTable.delete(QueryParams(
          whereString: 'Sl=? AND tranDate=? AND tranTime=?',
          whereArguments: [Sl, tranDate, tranTime]));
    } else {
      return _mnTransactionTable.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND tranDate=? AND tranTime=?',
              whereArguments: [Sl, tranDate, tranTime]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TransactionTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TransactionTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TransactionTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TransactionTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TransactionTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      tranDate = null;
      tranTime = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion transactiontable

// region TransactionTableField
class TransactionTableField extends FilterBase {
  TransactionTableField(TransactionTableFilterBuilder transactiontableFB)
      : super(transactiontableFB);

  @override
  TransactionTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder isNull() {
    return super.isNull() as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TransactionTableFilterBuilder;
  }

  @override
  TransactionTableField get not {
    return super.not as TransactionTableField;
  }
}
// endregion TransactionTableField

// region TransactionTableFilterBuilder
class TransactionTableFilterBuilder extends ConjunctionBase {
  TransactionTableFilterBuilder(TransactionTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTransactionTable = obj._mnTransactionTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TransactionTableManager? _mnTransactionTable;

  /// put the sql keyword 'AND'
  @override
  TransactionTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TransactionTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TransactionTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TransactionTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TransactionTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TransactionTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TransactionTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TransactionTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TransactionTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TransactionTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TransactionTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TransactionTableField _setField(
      TransactionTableField? field, String colName, DbType dbtype) {
    return TransactionTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TransactionTableField? _Sl;
  TransactionTableField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  TransactionTableField? _tranid;
  TransactionTableField get tranid {
    return _tranid = _setField(_tranid, 'tranid', DbType.text);
  }

  TransactionTableField? _tranType;
  TransactionTableField get tranType {
    return _tranType = _setField(_tranType, 'tranType', DbType.text);
  }

  TransactionTableField? _tranDescription;
  TransactionTableField get tranDescription {
    return _tranDescription =
        _setField(_tranDescription, 'tranDescription', DbType.text);
  }

  TransactionTableField? _tranDate;
  TransactionTableField get tranDate {
    return _tranDate = _setField(_tranDate, 'tranDate', DbType.text);
  }

  TransactionTableField? _tranTime;
  TransactionTableField get tranTime {
    return _tranTime = _setField(_tranTime, 'tranTime', DbType.text);
  }

  TransactionTableField? _tranAmount;
  TransactionTableField get tranAmount {
    return _tranAmount = _setField(_tranAmount, 'tranAmount', DbType.real);
  }

  TransactionTableField? _valuation;
  TransactionTableField get valuation {
    return _valuation = _setField(_valuation, 'valuation', DbType.text);
  }

  /// Deletes List<TransactionTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTransactionTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTransactionTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from TransactionTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTransactionTable!.updateBatch(qparams, values);
  }

  /// This method always returns [TransactionTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TransactionTable?
  @override
  Future<TransactionTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTransactionTable!.toList(qparams);
    final data = await objFuture;
    TransactionTable? obj;
    if (data.isNotEmpty) {
      obj = TransactionTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TransactionTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TransactionTable?
  @override
  Future<TransactionTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TransactionTable();
  }

  /// This method returns int. [TransactionTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? transactiontableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final transactiontablesFuture = await _mnTransactionTable!.toList(qparams);
    final int count = transactiontablesFuture[0]['CNT'] as int;
    if (transactiontableCount != null) {
      transactiontableCount(count);
    }
    return count;
  }

  /// This method returns List<TransactionTable> [TransactionTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TransactionTable>
  @override
  Future<List<TransactionTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TransactionTable> transactiontablesData =
        await TransactionTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return transactiontablesData;
  }

  /// This method returns Json String [TransactionTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TransactionTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TransactionTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTransactionTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TransactionTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`tranDate`tranTime` FROM TransactionTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,tranDate,tranTime> [TransactionTable]
  /// <returns>List<Sl,tranDate,tranTime>
  @override
  Future<List<TransactionTable>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'tranDate', 'tranTime'];
    final transactiontableFuture = await _mnTransactionTable!.toList(qparams);
    return await TransactionTable.fromMapList(transactiontableFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TransactionTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTransactionTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TransactionTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTransactionTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TransactionTableFilterBuilder

// region TransactionTableFields
class TransactionTableFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fTranid;
  static TableField get tranid {
    return _fTranid =
        _fTranid ?? SqlSyntax.setField(_fTranid, 'tranid', DbType.text);
  }

  static TableField? _fTranType;
  static TableField get tranType {
    return _fTranType =
        _fTranType ?? SqlSyntax.setField(_fTranType, 'tranType', DbType.text);
  }

  static TableField? _fTranDescription;
  static TableField get tranDescription {
    return _fTranDescription = _fTranDescription ??
        SqlSyntax.setField(_fTranDescription, 'tranDescription', DbType.text);
  }

  static TableField? _fTranDate;
  static TableField get tranDate {
    return _fTranDate =
        _fTranDate ?? SqlSyntax.setField(_fTranDate, 'tranDate', DbType.text);
  }

  static TableField? _fTranTime;
  static TableField get tranTime {
    return _fTranTime =
        _fTranTime ?? SqlSyntax.setField(_fTranTime, 'tranTime', DbType.text);
  }

  static TableField? _fTranAmount;
  static TableField get tranAmount {
    return _fTranAmount = _fTranAmount ??
        SqlSyntax.setField(_fTranAmount, 'tranAmount', DbType.real);
  }

  static TableField? _fValuation;
  static TableField get valuation {
    return _fValuation = _fValuation ??
        SqlSyntax.setField(_fValuation, 'valuation', DbType.text);
  }
}
// endregion TransactionTableFields

//region TransactionTableManager
class TransactionTableManager extends SqfEntityProvider {
  TransactionTableManager()
      : super(TransactionsMain(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TransactionTable';
  static const List<String> _primaryKeyList = ['Sl', 'tranDate', 'tranTime'];
  static const String _whereStr = 'Sl=? AND tranDate=? AND tranTime=?';
}

//endregion TransactionTableManager
// region CashTable
class CashTable extends TableBase {
  CashTable(
      {this.Sl,
      this.Cash_ID,
      this.Cash_Amount,
      this.Cash_Description,
      this.Cash_Type,
      this.Cash_Date,
      this.Cash_Time}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CashTable.withFields(this.Cash_ID, this.Cash_Amount, this.Cash_Description,
      this.Cash_Type, this.Cash_Date, this.Cash_Time) {
    _setDefaultValues();
  }
  CashTable.withId(this.Sl, this.Cash_ID, this.Cash_Amount,
      this.Cash_Description, this.Cash_Type, this.Cash_Date, this.Cash_Time) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CashTable.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['Cash_ID'] != null) {
      Cash_ID = o['Cash_ID'].toString();
    }
    if (o['Cash_Amount'] != null) {
      Cash_Amount = double.tryParse(o['Cash_Amount'].toString());
    }
    if (o['Cash_Description'] != null) {
      Cash_Description = o['Cash_Description'].toString();
    }
    if (o['Cash_Type'] != null) {
      Cash_Type = o['Cash_Type'].toString();
    }
    if (o['Cash_Date'] != null) {
      Cash_Date = o['Cash_Date'].toString();
    }
    if (o['Cash_Time'] != null) {
      Cash_Time = o['Cash_Time'].toString();
    }
  }
  // FIELDS (CashTable)
  int? Sl;
  String? Cash_ID;
  double? Cash_Amount;
  String? Cash_Description;
  String? Cash_Type;
  String? Cash_Date;
  String? Cash_Time;

  // end FIELDS (CashTable)

  static const bool _softDeleteActivated = false;
  CashTableManager? __mnCashTable;

  CashTableManager get _mnCashTable {
    return __mnCashTable = __mnCashTable ?? CashTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (Cash_ID != null || !forView) {
      map['Cash_ID'] = Cash_ID;
    }
    if (Cash_Amount != null || !forView) {
      map['Cash_Amount'] = Cash_Amount;
    }
    if (Cash_Description != null || !forView) {
      map['Cash_Description'] = Cash_Description;
    }
    if (Cash_Type != null || !forView) {
      map['Cash_Type'] = Cash_Type;
    }
    if (Cash_Date != null || !forView) {
      map['Cash_Date'] = Cash_Date;
    }
    if (Cash_Time != null || !forView) {
      map['Cash_Time'] = Cash_Time;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (Cash_ID != null || !forView) {
      map['Cash_ID'] = Cash_ID;
    }
    if (Cash_Amount != null || !forView) {
      map['Cash_Amount'] = Cash_Amount;
    }
    if (Cash_Description != null || !forView) {
      map['Cash_Description'] = Cash_Description;
    }
    if (Cash_Type != null || !forView) {
      map['Cash_Type'] = Cash_Type;
    }
    if (Cash_Date != null || !forView) {
      map['Cash_Date'] = Cash_Date;
    }
    if (Cash_Time != null || !forView) {
      map['Cash_Time'] = Cash_Time;
    }

    return map;
  }

  /// This method returns Json String [CashTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CashTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Cash_ID,
      Cash_Amount,
      Cash_Description,
      Cash_Type,
      Cash_Date,
      Cash_Time
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      Cash_ID,
      Cash_Amount,
      Cash_Description,
      Cash_Type,
      Cash_Date,
      Cash_Time
    ];
  }

  static Future<List<CashTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CashTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CashTable>[];
    try {
      objList = list
          .map((cashtable) =>
              CashTable.fromMap(cashtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CashTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CashTable> objList = <CashTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CashTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CashTable by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? Cash_Date, String? Cash_Time
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CashTable] if exist, otherwise returns null
  Future<CashTable?> getById(int? Sl, String? Cash_Date, String? Cash_Time,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    CashTable? obj;
    final data = await _mnCashTable.getById([Sl, Cash_Date, Cash_Time]);
    if (data.length != 0) {
      obj = CashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CashTable) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashTable.rawInsert(
          'INSERT OR REPLACE INTO CashTable (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs CashTable
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashTable.rawInsert(
          'INSERT INTO CashTable ( Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?)',
          [
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<CashTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CashTable> cashtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await TransactionsMain().batchStart();
    for (final obj in cashtables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await TransactionsMain().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < cashtables.length; i++) {
        if (cashtables[i].Sl == null) {
          cashtables[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashTable.rawInsert(
          'INSERT OR REPLACE INTO CashTable (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'CashTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashTable.rawInsert(
          'INSERT OR IGNORE INTO CashTable (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            Cash_ID,
            Cash_Amount,
            Cash_Description,
            Cash_Type,
            Cash_Date,
            Cash_Time
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'CashTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// inserts or replaces the sent List<<CashTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<CashTable> cashtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCashTable.rawInsertAll(
        'INSERT OR REPLACE INTO CashTable (Sl, Cash_ID, Cash_Amount, Cash_Description, Cash_Type, Cash_Date, Cash_Time)  VALUES (?,?,?,?,?,?,?)',
        cashtables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CashTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CashTable invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCashTable.delete(QueryParams(
          whereString: 'Sl=? AND Cash_Date=? AND Cash_Time=?',
          whereArguments: [Sl, Cash_Date, Cash_Time]));
    } else {
      return _mnCashTable.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND Cash_Date=? AND Cash_Time=?',
              whereArguments: [Sl, Cash_Date, Cash_Time]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CashTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CashTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CashTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      Cash_Date = null;
      Cash_Time = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cashtable

// region CashTableField
class CashTableField extends FilterBase {
  CashTableField(CashTableFilterBuilder cashtableFB) : super(cashtableFB);

  @override
  CashTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder isNull() {
    return super.isNull() as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CashTableFilterBuilder;
  }

  @override
  CashTableField get not {
    return super.not as CashTableField;
  }
}
// endregion CashTableField

// region CashTableFilterBuilder
class CashTableFilterBuilder extends ConjunctionBase {
  CashTableFilterBuilder(CashTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCashTable = obj._mnCashTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CashTableManager? _mnCashTable;

  /// put the sql keyword 'AND'
  @override
  CashTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CashTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CashTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CashTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CashTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CashTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CashTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CashTableField _setField(
      CashTableField? field, String colName, DbType dbtype) {
    return CashTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CashTableField? _Sl;
  CashTableField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  CashTableField? _Cash_ID;
  CashTableField get Cash_ID {
    return _Cash_ID = _setField(_Cash_ID, 'Cash_ID', DbType.text);
  }

  CashTableField? _Cash_Amount;
  CashTableField get Cash_Amount {
    return _Cash_Amount = _setField(_Cash_Amount, 'Cash_Amount', DbType.real);
  }

  CashTableField? _Cash_Description;
  CashTableField get Cash_Description {
    return _Cash_Description =
        _setField(_Cash_Description, 'Cash_Description', DbType.text);
  }

  CashTableField? _Cash_Type;
  CashTableField get Cash_Type {
    return _Cash_Type = _setField(_Cash_Type, 'Cash_Type', DbType.text);
  }

  CashTableField? _Cash_Date;
  CashTableField get Cash_Date {
    return _Cash_Date = _setField(_Cash_Date, 'Cash_Date', DbType.text);
  }

  CashTableField? _Cash_Time;
  CashTableField get Cash_Time {
    return _Cash_Time = _setField(_Cash_Time, 'Cash_Time', DbType.text);
  }

  /// Deletes List<CashTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCashTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCashTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from CashTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCashTable!.updateBatch(qparams, values);
  }

  /// This method always returns [CashTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashTable?
  @override
  Future<CashTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCashTable!.toList(qparams);
    final data = await objFuture;
    CashTable? obj;
    if (data.isNotEmpty) {
      obj = CashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashTable?
  @override
  Future<CashTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CashTable();
  }

  /// This method returns int. [CashTable]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? cashtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cashtablesFuture = await _mnCashTable!.toList(qparams);
    final int count = cashtablesFuture[0]['CNT'] as int;
    if (cashtableCount != null) {
      cashtableCount(count);
    }
    return count;
  }

  /// This method returns List<CashTable> [CashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CashTable>
  @override
  Future<List<CashTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CashTable> cashtablesData = await CashTable.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return cashtablesData;
  }

  /// This method returns Json String [CashTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CashTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CashTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCashTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CashTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`Cash_Date`Cash_Time` FROM CashTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,Cash_Date,Cash_Time> [CashTable]
  /// <returns>List<Sl,Cash_Date,Cash_Time>
  @override
  Future<List<CashTable>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'Cash_Date', 'Cash_Time'];
    final cashtableFuture = await _mnCashTable!.toList(qparams);
    return await CashTable.fromMapList(cashtableFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CashTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCashTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CashTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCashTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CashTableFilterBuilder

// region CashTableFields
class CashTableFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fCash_ID;
  static TableField get Cash_ID {
    return _fCash_ID =
        _fCash_ID ?? SqlSyntax.setField(_fCash_ID, 'Cash_ID', DbType.text);
  }

  static TableField? _fCash_Amount;
  static TableField get Cash_Amount {
    return _fCash_Amount = _fCash_Amount ??
        SqlSyntax.setField(_fCash_Amount, 'Cash_Amount', DbType.real);
  }

  static TableField? _fCash_Description;
  static TableField get Cash_Description {
    return _fCash_Description = _fCash_Description ??
        SqlSyntax.setField(_fCash_Description, 'Cash_Description', DbType.text);
  }

  static TableField? _fCash_Type;
  static TableField get Cash_Type {
    return _fCash_Type = _fCash_Type ??
        SqlSyntax.setField(_fCash_Type, 'Cash_Type', DbType.text);
  }

  static TableField? _fCash_Date;
  static TableField get Cash_Date {
    return _fCash_Date = _fCash_Date ??
        SqlSyntax.setField(_fCash_Date, 'Cash_Date', DbType.text);
  }

  static TableField? _fCash_Time;
  static TableField get Cash_Time {
    return _fCash_Time = _fCash_Time ??
        SqlSyntax.setField(_fCash_Time, 'Cash_Time', DbType.text);
  }
}
// endregion CashTableFields

//region CashTableManager
class CashTableManager extends SqfEntityProvider {
  CashTableManager()
      : super(TransactionsMain(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CashTable';
  static const List<String> _primaryKeyList = ['Sl', 'Cash_Date', 'Cash_Time'];
  static const String _whereStr = 'Sl=? AND Cash_Date=? AND Cash_Time=?';
}

//endregion CashTableManager
// region DataEntry_DETAILS
class DataEntry_DETAILS extends TableBase {
  DataEntry_DETAILS(
      {this.Sl,
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.ENTRY_TYPE,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DataEntry_DETAILS.withFields(
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.ENTRY_TYPE,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks) {
    _setDefaultValues();
  }
  DataEntry_DETAILS.withId(
      this.Sl,
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.ENTRY_TYPE,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DataEntry_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['TRANSACTION_DATE'] != null) {
      TRANSACTION_DATE = o['TRANSACTION_DATE'].toString();
    }
    if (o['TRANSACTION_TIME'] != null) {
      TRANSACTION_TIME = o['TRANSACTION_TIME'].toString();
    }
    if (o['ENTRY_TYPE'] != null) {
      ENTRY_TYPE = o['ENTRY_TYPE'].toString();
    }
    if (o['TOTAL_DEPOSITS'] != null) {
      TOTAL_DEPOSITS = o['TOTAL_DEPOSITS'].toString();
    }
    if (o['TOTAL_DEPOSIT_AMOUNT'] != null) {
      TOTAL_DEPOSIT_AMOUNT = o['TOTAL_DEPOSIT_AMOUNT'].toString();
    }
    if (o['TOTAL_WITHDRAWALS'] != null) {
      TOTAL_WITHDRAWALS = o['TOTAL_WITHDRAWALS'].toString();
    }
    if (o['TOTAL_WITHDRAWAL_AMOUNT'] != null) {
      TOTAL_WITHDRAWAL_AMOUNT = o['TOTAL_WITHDRAWAL_AMOUNT'].toString();
    }
    if (o['Remarks'] != null) {
      Remarks = o['Remarks'].toString();
    }
  }
  // FIELDS (DataEntry_DETAILS)
  int? Sl;
  String? TRANSACTION_DATE;
  String? TRANSACTION_TIME;
  String? ENTRY_TYPE;
  String? TOTAL_DEPOSITS;
  String? TOTAL_DEPOSIT_AMOUNT;
  String? TOTAL_WITHDRAWALS;
  String? TOTAL_WITHDRAWAL_AMOUNT;
  String? Remarks;

  // end FIELDS (DataEntry_DETAILS)

  static const bool _softDeleteActivated = false;
  DataEntry_DETAILSManager? __mnDataEntry_DETAILS;

  DataEntry_DETAILSManager get _mnDataEntry_DETAILS {
    return __mnDataEntry_DETAILS =
        __mnDataEntry_DETAILS ?? DataEntry_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (TRANSACTION_DATE != null || !forView) {
      map['TRANSACTION_DATE'] = TRANSACTION_DATE;
    }
    if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = TRANSACTION_TIME;
    }
    if (ENTRY_TYPE != null || !forView) {
      map['ENTRY_TYPE'] = ENTRY_TYPE;
    }
    if (TOTAL_DEPOSITS != null || !forView) {
      map['TOTAL_DEPOSITS'] = TOTAL_DEPOSITS;
    }
    if (TOTAL_DEPOSIT_AMOUNT != null || !forView) {
      map['TOTAL_DEPOSIT_AMOUNT'] = TOTAL_DEPOSIT_AMOUNT;
    }
    if (TOTAL_WITHDRAWALS != null || !forView) {
      map['TOTAL_WITHDRAWALS'] = TOTAL_WITHDRAWALS;
    }
    if (TOTAL_WITHDRAWAL_AMOUNT != null || !forView) {
      map['TOTAL_WITHDRAWAL_AMOUNT'] = TOTAL_WITHDRAWAL_AMOUNT;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (TRANSACTION_DATE != null || !forView) {
      map['TRANSACTION_DATE'] = TRANSACTION_DATE;
    }
    if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = TRANSACTION_TIME;
    }
    if (ENTRY_TYPE != null || !forView) {
      map['ENTRY_TYPE'] = ENTRY_TYPE;
    }
    if (TOTAL_DEPOSITS != null || !forView) {
      map['TOTAL_DEPOSITS'] = TOTAL_DEPOSITS;
    }
    if (TOTAL_DEPOSIT_AMOUNT != null || !forView) {
      map['TOTAL_DEPOSIT_AMOUNT'] = TOTAL_DEPOSIT_AMOUNT;
    }
    if (TOTAL_WITHDRAWALS != null || !forView) {
      map['TOTAL_WITHDRAWALS'] = TOTAL_WITHDRAWALS;
    }
    if (TOTAL_WITHDRAWAL_AMOUNT != null || !forView) {
      map['TOTAL_WITHDRAWAL_AMOUNT'] = TOTAL_WITHDRAWAL_AMOUNT;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  /// This method returns Json String [DataEntry_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DataEntry_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      TRANSACTION_DATE,
      TRANSACTION_TIME,
      ENTRY_TYPE,
      TOTAL_DEPOSITS,
      TOTAL_DEPOSIT_AMOUNT,
      TOTAL_WITHDRAWALS,
      TOTAL_WITHDRAWAL_AMOUNT,
      Remarks
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      TRANSACTION_DATE,
      TRANSACTION_TIME,
      ENTRY_TYPE,
      TOTAL_DEPOSITS,
      TOTAL_DEPOSIT_AMOUNT,
      TOTAL_WITHDRAWALS,
      TOTAL_WITHDRAWAL_AMOUNT,
      Remarks
    ];
  }

  static Future<List<DataEntry_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DataEntry_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DataEntry_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DataEntry_DETAILS>[];
    try {
      objList = list
          .map((dataentry_details) => DataEntry_DETAILS.fromMap(
              dataentry_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DataEntry_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DataEntry_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DataEntry_DETAILS> objList = <DataEntry_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DataEntry_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DataEntry_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DataEntry_DETAILS] if exist, otherwise returns null
  Future<DataEntry_DETAILS?> getById(int? Sl,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    DataEntry_DETAILS? obj;
    final data = await _mnDataEntry_DETAILS.getById([Sl]);
    if (data.length != 0) {
      obj = DataEntry_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DataEntry_DETAILS) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnDataEntry_DETAILS.insert(this, ignoreBatch);
    } else {
      await _mnDataEntry_DETAILS.update(this);
    }

    return Sl;
  }

  /// Saves the (DataEntry_DETAILS) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnDataEntry_DETAILS.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // Sl= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDataEntry_DETAILS.updateOrThrow(this);
    }

    return Sl;
  }

  /// saveAs DataEntry_DETAILS. Returns a new Primary Key value of DataEntry_DETAILS

  /// <returns>Returns a new Primary Key value of DataEntry_DETAILS
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    Sl = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<DataEntry_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<DataEntry_DETAILS> dataentry_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await TransactionsMain().batchStart();
    for (final obj in dataentry_detailses) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await TransactionsMain().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < dataentry_detailses.length; i++) {
        if (dataentry_detailses[i].Sl == null) {
          dataentry_detailses[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDataEntry_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO DataEntry_DETAILS (Sl, TRANSACTION_DATE, TRANSACTION_TIME, ENTRY_TYPE, TOTAL_DEPOSITS, TOTAL_DEPOSIT_AMOUNT, TOTAL_WITHDRAWALS, TOTAL_WITHDRAWAL_AMOUNT, Remarks)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            Sl,
            TRANSACTION_DATE,
            TRANSACTION_TIME,
            ENTRY_TYPE,
            TOTAL_DEPOSITS,
            TOTAL_DEPOSIT_AMOUNT,
            TOTAL_WITHDRAWALS,
            TOTAL_WITHDRAWAL_AMOUNT,
            Remarks
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DataEntry_DETAILS Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DataEntry_DETAILS Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'DataEntry_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<DataEntry_DETAILS>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<DataEntry_DETAILS> dataentry_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnDataEntry_DETAILS.rawInsertAll(
        'INSERT OR REPLACE INTO DataEntry_DETAILS (Sl, TRANSACTION_DATE, TRANSACTION_TIME, ENTRY_TYPE, TOTAL_DEPOSITS, TOTAL_DEPOSIT_AMOUNT, TOTAL_WITHDRAWALS, TOTAL_WITHDRAWAL_AMOUNT, Remarks)  VALUES (?,?,?,?,?,?,?,?,?)',
        dataentry_detailses,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes DataEntry_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete DataEntry_DETAILS invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDataEntry_DETAILS
          .delete(QueryParams(whereString: 'Sl=?', whereArguments: [Sl]));
    } else {
      return _mnDataEntry_DETAILS.updateBatch(
          QueryParams(whereString: 'Sl=?', whereArguments: [Sl]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DataEntry_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DataEntry_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DataEntry_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DataEntry_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DataEntry_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion dataentry_details

// region DataEntry_DETAILSField
class DataEntry_DETAILSField extends FilterBase {
  DataEntry_DETAILSField(DataEntry_DETAILSFilterBuilder dataentry_detailsFB)
      : super(dataentry_detailsFB);

  @override
  DataEntry_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder isNull() {
    return super.isNull() as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DataEntry_DETAILSFilterBuilder;
  }

  @override
  DataEntry_DETAILSField get not {
    return super.not as DataEntry_DETAILSField;
  }
}
// endregion DataEntry_DETAILSField

// region DataEntry_DETAILSFilterBuilder
class DataEntry_DETAILSFilterBuilder extends ConjunctionBase {
  DataEntry_DETAILSFilterBuilder(DataEntry_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDataEntry_DETAILS = obj._mnDataEntry_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DataEntry_DETAILSManager? _mnDataEntry_DETAILS;

  /// put the sql keyword 'AND'
  @override
  DataEntry_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DataEntry_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DataEntry_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DataEntry_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DataEntry_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DataEntry_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DataEntry_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DataEntry_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DataEntry_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DataEntry_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DataEntry_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DataEntry_DETAILSField _setField(
      DataEntry_DETAILSField? field, String colName, DbType dbtype) {
    return DataEntry_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DataEntry_DETAILSField? _Sl;
  DataEntry_DETAILSField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  DataEntry_DETAILSField? _TRANSACTION_DATE;
  DataEntry_DETAILSField get TRANSACTION_DATE {
    return _TRANSACTION_DATE =
        _setField(_TRANSACTION_DATE, 'TRANSACTION_DATE', DbType.text);
  }

  DataEntry_DETAILSField? _TRANSACTION_TIME;
  DataEntry_DETAILSField get TRANSACTION_TIME {
    return _TRANSACTION_TIME =
        _setField(_TRANSACTION_TIME, 'TRANSACTION_TIME', DbType.text);
  }

  DataEntry_DETAILSField? _ENTRY_TYPE;
  DataEntry_DETAILSField get ENTRY_TYPE {
    return _ENTRY_TYPE = _setField(_ENTRY_TYPE, 'ENTRY_TYPE', DbType.text);
  }

  DataEntry_DETAILSField? _TOTAL_DEPOSITS;
  DataEntry_DETAILSField get TOTAL_DEPOSITS {
    return _TOTAL_DEPOSITS =
        _setField(_TOTAL_DEPOSITS, 'TOTAL_DEPOSITS', DbType.text);
  }

  DataEntry_DETAILSField? _TOTAL_DEPOSIT_AMOUNT;
  DataEntry_DETAILSField get TOTAL_DEPOSIT_AMOUNT {
    return _TOTAL_DEPOSIT_AMOUNT =
        _setField(_TOTAL_DEPOSIT_AMOUNT, 'TOTAL_DEPOSIT_AMOUNT', DbType.text);
  }

  DataEntry_DETAILSField? _TOTAL_WITHDRAWALS;
  DataEntry_DETAILSField get TOTAL_WITHDRAWALS {
    return _TOTAL_WITHDRAWALS =
        _setField(_TOTAL_WITHDRAWALS, 'TOTAL_WITHDRAWALS', DbType.text);
  }

  DataEntry_DETAILSField? _TOTAL_WITHDRAWAL_AMOUNT;
  DataEntry_DETAILSField get TOTAL_WITHDRAWAL_AMOUNT {
    return _TOTAL_WITHDRAWAL_AMOUNT = _setField(
        _TOTAL_WITHDRAWAL_AMOUNT, 'TOTAL_WITHDRAWAL_AMOUNT', DbType.text);
  }

  DataEntry_DETAILSField? _Remarks;
  DataEntry_DETAILSField get Remarks {
    return _Remarks = _setField(_Remarks, 'Remarks', DbType.text);
  }

  /// Deletes List<DataEntry_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDataEntry_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDataEntry_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from DataEntry_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDataEntry_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [DataEntry_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DataEntry_DETAILS?
  @override
  Future<DataEntry_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDataEntry_DETAILS!.toList(qparams);
    final data = await objFuture;
    DataEntry_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = DataEntry_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DataEntry_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DataEntry_DETAILS?
  @override
  Future<DataEntry_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DataEntry_DETAILS();
  }

  /// This method returns int. [DataEntry_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? dataentry_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final dataentry_detailsesFuture =
        await _mnDataEntry_DETAILS!.toList(qparams);
    final int count = dataentry_detailsesFuture[0]['CNT'] as int;
    if (dataentry_detailsCount != null) {
      dataentry_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<DataEntry_DETAILS> [DataEntry_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DataEntry_DETAILS>
  @override
  Future<List<DataEntry_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DataEntry_DETAILS> dataentry_detailsesData =
        await DataEntry_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return dataentry_detailsesData;
  }

  /// This method returns Json String [DataEntry_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DataEntry_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DataEntry_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDataEntry_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DataEntry_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl` FROM DataEntry_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SlData = <int>[];
    qparams.selectColumns = ['Sl'];
    final SlFuture = await _mnDataEntry_DETAILS!.toList(qparams);

    final int count = SlFuture.length;
    for (int i = 0; i < count; i++) {
      SlData.add(SlFuture[i]['Sl'] as int);
    }
    return SlData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DataEntry_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDataEntry_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DataEntry_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDataEntry_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DataEntry_DETAILSFilterBuilder

// region DataEntry_DETAILSFields
class DataEntry_DETAILSFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fTRANSACTION_DATE;
  static TableField get TRANSACTION_DATE {
    return _fTRANSACTION_DATE = _fTRANSACTION_DATE ??
        SqlSyntax.setField(_fTRANSACTION_DATE, 'TRANSACTION_DATE', DbType.text);
  }

  static TableField? _fTRANSACTION_TIME;
  static TableField get TRANSACTION_TIME {
    return _fTRANSACTION_TIME = _fTRANSACTION_TIME ??
        SqlSyntax.setField(_fTRANSACTION_TIME, 'TRANSACTION_TIME', DbType.text);
  }

  static TableField? _fENTRY_TYPE;
  static TableField get ENTRY_TYPE {
    return _fENTRY_TYPE = _fENTRY_TYPE ??
        SqlSyntax.setField(_fENTRY_TYPE, 'ENTRY_TYPE', DbType.text);
  }

  static TableField? _fTOTAL_DEPOSITS;
  static TableField get TOTAL_DEPOSITS {
    return _fTOTAL_DEPOSITS = _fTOTAL_DEPOSITS ??
        SqlSyntax.setField(_fTOTAL_DEPOSITS, 'TOTAL_DEPOSITS', DbType.text);
  }

  static TableField? _fTOTAL_DEPOSIT_AMOUNT;
  static TableField get TOTAL_DEPOSIT_AMOUNT {
    return _fTOTAL_DEPOSIT_AMOUNT = _fTOTAL_DEPOSIT_AMOUNT ??
        SqlSyntax.setField(
            _fTOTAL_DEPOSIT_AMOUNT, 'TOTAL_DEPOSIT_AMOUNT', DbType.text);
  }

  static TableField? _fTOTAL_WITHDRAWALS;
  static TableField get TOTAL_WITHDRAWALS {
    return _fTOTAL_WITHDRAWALS = _fTOTAL_WITHDRAWALS ??
        SqlSyntax.setField(
            _fTOTAL_WITHDRAWALS, 'TOTAL_WITHDRAWALS', DbType.text);
  }

  static TableField? _fTOTAL_WITHDRAWAL_AMOUNT;
  static TableField get TOTAL_WITHDRAWAL_AMOUNT {
    return _fTOTAL_WITHDRAWAL_AMOUNT = _fTOTAL_WITHDRAWAL_AMOUNT ??
        SqlSyntax.setField(
            _fTOTAL_WITHDRAWAL_AMOUNT, 'TOTAL_WITHDRAWAL_AMOUNT', DbType.text);
  }

  static TableField? _fRemarks;
  static TableField get Remarks {
    return _fRemarks =
        _fRemarks ?? SqlSyntax.setField(_fRemarks, 'Remarks', DbType.text);
  }
}
// endregion DataEntry_DETAILSFields

//region DataEntry_DETAILSManager
class DataEntry_DETAILSManager extends SqfEntityProvider {
  DataEntry_DETAILSManager()
      : super(TransactionsMain(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'DataEntry_DETAILS';
  static const List<String> _primaryKeyList = ['Sl'];
  static const String _whereStr = 'Sl=?';
}

//endregion DataEntry_DETAILSManager
// region IppbApi
class IppbApi extends TableBase {
  IppbApi(
      {this.Sl,
      this.ReqDATE,
      this.ReqTime,
      this.FacId,
      this.TranDate,
      this.FromDateTime,
      this.ToDateTime,
      this.TotalDeposit,
      this.TotalWithdrawl,
      this.Status,
      this.Remarks}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  IppbApi.withFields(
      this.ReqDATE,
      this.ReqTime,
      this.FacId,
      this.TranDate,
      this.FromDateTime,
      this.ToDateTime,
      this.TotalDeposit,
      this.TotalWithdrawl,
      this.Status,
      this.Remarks) {
    _setDefaultValues();
  }
  IppbApi.withId(
      this.Sl,
      this.ReqDATE,
      this.ReqTime,
      this.FacId,
      this.TranDate,
      this.FromDateTime,
      this.ToDateTime,
      this.TotalDeposit,
      this.TotalWithdrawl,
      this.Status,
      this.Remarks) {
    _setDefaultValues();
  }
  // fromMap v2.0
  IppbApi.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['ReqDATE'] != null) {
      ReqDATE = o['ReqDATE'].toString();
    }
    if (o['ReqTime'] != null) {
      ReqTime = o['ReqTime'].toString();
    }
    if (o['FacId'] != null) {
      FacId = o['FacId'].toString();
    }
    if (o['TranDate'] != null) {
      TranDate = o['TranDate'].toString();
    }
    if (o['FromDateTime'] != null) {
      FromDateTime = o['FromDateTime'].toString();
    }
    if (o['ToDateTime'] != null) {
      ToDateTime = o['ToDateTime'].toString();
    }
    if (o['TotalDeposit'] != null) {
      TotalDeposit = o['TotalDeposit'].toString();
    }
    if (o['TotalWithdrawl'] != null) {
      TotalWithdrawl = o['TotalWithdrawl'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['Remarks'] != null) {
      Remarks = o['Remarks'].toString();
    }
  }
  // FIELDS (IppbApi)
  int? Sl;
  String? ReqDATE;
  String? ReqTime;
  String? FacId;
  String? TranDate;
  String? FromDateTime;
  String? ToDateTime;
  String? TotalDeposit;
  String? TotalWithdrawl;
  String? Status;
  String? Remarks;

  // end FIELDS (IppbApi)

  static const bool _softDeleteActivated = false;
  IppbApiManager? __mnIppbApi;

  IppbApiManager get _mnIppbApi {
    return __mnIppbApi = __mnIppbApi ?? IppbApiManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ReqDATE != null || !forView) {
      map['ReqDATE'] = ReqDATE;
    }
    if (ReqTime != null || !forView) {
      map['ReqTime'] = ReqTime;
    }
    if (FacId != null || !forView) {
      map['FacId'] = FacId;
    }
    if (TranDate != null || !forView) {
      map['TranDate'] = TranDate;
    }
    if (FromDateTime != null || !forView) {
      map['FromDateTime'] = FromDateTime;
    }
    if (ToDateTime != null || !forView) {
      map['ToDateTime'] = ToDateTime;
    }
    if (TotalDeposit != null || !forView) {
      map['TotalDeposit'] = TotalDeposit;
    }
    if (TotalWithdrawl != null || !forView) {
      map['TotalWithdrawl'] = TotalWithdrawl;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ReqDATE != null || !forView) {
      map['ReqDATE'] = ReqDATE;
    }
    if (ReqTime != null || !forView) {
      map['ReqTime'] = ReqTime;
    }
    if (FacId != null || !forView) {
      map['FacId'] = FacId;
    }
    if (TranDate != null || !forView) {
      map['TranDate'] = TranDate;
    }
    if (FromDateTime != null || !forView) {
      map['FromDateTime'] = FromDateTime;
    }
    if (ToDateTime != null || !forView) {
      map['ToDateTime'] = ToDateTime;
    }
    if (TotalDeposit != null || !forView) {
      map['TotalDeposit'] = TotalDeposit;
    }
    if (TotalWithdrawl != null || !forView) {
      map['TotalWithdrawl'] = TotalWithdrawl;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  /// This method returns Json String [IppbApi]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [IppbApi]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ReqDATE,
      ReqTime,
      FacId,
      TranDate,
      FromDateTime,
      ToDateTime,
      TotalDeposit,
      TotalWithdrawl,
      Status,
      Remarks
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      ReqDATE,
      ReqTime,
      FacId,
      TranDate,
      FromDateTime,
      ToDateTime,
      TotalDeposit,
      TotalWithdrawl,
      Status,
      Remarks
    ];
  }

  static Future<List<IppbApi>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR IppbApi.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<IppbApi>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <IppbApi>[];
    try {
      objList = list
          .map((ippbapi) => IppbApi.fromMap(ippbapi as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR IppbApi.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<IppbApi>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<IppbApi> objList = <IppbApi>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = IppbApi.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns IppbApi by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [IppbApi] if exist, otherwise returns null
  Future<IppbApi?> getById(int? Sl,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    IppbApi? obj;
    final data = await _mnIppbApi.getById([Sl]);
    if (data.length != 0) {
      obj = IppbApi.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (IppbApi) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnIppbApi.insert(this, ignoreBatch);
    } else {
      await _mnIppbApi.update(this);
    }

    return Sl;
  }

  /// Saves the (IppbApi) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnIppbApi.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // Sl= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnIppbApi.updateOrThrow(this);
    }

    return Sl;
  }

  /// saveAs IppbApi. Returns a new Primary Key value of IppbApi

  /// <returns>Returns a new Primary Key value of IppbApi
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    Sl = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<IppbApi> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<IppbApi> ippbapis,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await TransactionsMain().batchStart();
    for (final obj in ippbapis) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await TransactionsMain().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < ippbapis.length; i++) {
        if (ippbapis[i].Sl == null) {
          ippbapis[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnIppbApi.rawInsert(
          'INSERT OR REPLACE INTO IppbApi (Sl, ReqDATE, ReqTime, FacId, TranDate, FromDateTime, ToDateTime, TotalDeposit, TotalWithdrawl, Status, Remarks)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            Sl,
            ReqDATE,
            ReqTime,
            FacId,
            TranDate,
            FromDateTime,
            ToDateTime,
            TotalDeposit,
            TotalWithdrawl,
            Status,
            Remarks
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'IppbApi Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'IppbApi Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'IppbApi Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<IppbApi>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<IppbApi> ippbapis,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnIppbApi.rawInsertAll(
        'INSERT OR REPLACE INTO IppbApi (Sl, ReqDATE, ReqTime, FacId, TranDate, FromDateTime, ToDateTime, TotalDeposit, TotalWithdrawl, Status, Remarks)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        ippbapis,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes IppbApi

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete IppbApi invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnIppbApi
          .delete(QueryParams(whereString: 'Sl=?', whereArguments: [Sl]));
    } else {
      return _mnIppbApi.updateBatch(
          QueryParams(whereString: 'Sl=?', whereArguments: [Sl]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [IppbApi] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  IppbApiFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IppbApiFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  IppbApiFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IppbApiFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion ippbapi

// region IppbApiField
class IppbApiField extends FilterBase {
  IppbApiField(IppbApiFilterBuilder ippbapiFB) : super(ippbapiFB);

  @override
  IppbApiFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder isNull() {
    return super.isNull() as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as IppbApiFilterBuilder;
  }

  @override
  IppbApiField get not {
    return super.not as IppbApiField;
  }
}
// endregion IppbApiField

// region IppbApiFilterBuilder
class IppbApiFilterBuilder extends ConjunctionBase {
  IppbApiFilterBuilder(IppbApi obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnIppbApi = obj._mnIppbApi;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  IppbApiManager? _mnIppbApi;

  /// put the sql keyword 'AND'
  @override
  IppbApiFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  IppbApiFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  IppbApiFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  IppbApiFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  IppbApiFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  IppbApiFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  IppbApiFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  IppbApiFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  IppbApiFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  IppbApiFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  IppbApiFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  IppbApiField _setField(IppbApiField? field, String colName, DbType dbtype) {
    return IppbApiField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  IppbApiField? _Sl;
  IppbApiField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  IppbApiField? _ReqDATE;
  IppbApiField get ReqDATE {
    return _ReqDATE = _setField(_ReqDATE, 'ReqDATE', DbType.text);
  }

  IppbApiField? _ReqTime;
  IppbApiField get ReqTime {
    return _ReqTime = _setField(_ReqTime, 'ReqTime', DbType.text);
  }

  IppbApiField? _FacId;
  IppbApiField get FacId {
    return _FacId = _setField(_FacId, 'FacId', DbType.text);
  }

  IppbApiField? _TranDate;
  IppbApiField get TranDate {
    return _TranDate = _setField(_TranDate, 'TranDate', DbType.text);
  }

  IppbApiField? _FromDateTime;
  IppbApiField get FromDateTime {
    return _FromDateTime =
        _setField(_FromDateTime, 'FromDateTime', DbType.text);
  }

  IppbApiField? _ToDateTime;
  IppbApiField get ToDateTime {
    return _ToDateTime = _setField(_ToDateTime, 'ToDateTime', DbType.text);
  }

  IppbApiField? _TotalDeposit;
  IppbApiField get TotalDeposit {
    return _TotalDeposit =
        _setField(_TotalDeposit, 'TotalDeposit', DbType.text);
  }

  IppbApiField? _TotalWithdrawl;
  IppbApiField get TotalWithdrawl {
    return _TotalWithdrawl =
        _setField(_TotalWithdrawl, 'TotalWithdrawl', DbType.text);
  }

  IppbApiField? _Status;
  IppbApiField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  IppbApiField? _Remarks;
  IppbApiField get Remarks {
    return _Remarks = _setField(_Remarks, 'Remarks', DbType.text);
  }

  /// Deletes List<IppbApi> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnIppbApi!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnIppbApi!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from IppbApi ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnIppbApi!.updateBatch(qparams, values);
  }

  /// This method always returns [IppbApi] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> IppbApi?
  @override
  Future<IppbApi?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnIppbApi!.toList(qparams);
    final data = await objFuture;
    IppbApi? obj;
    if (data.isNotEmpty) {
      obj = IppbApi.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [IppbApi]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> IppbApi?
  @override
  Future<IppbApi> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        IppbApi();
  }

  /// This method returns int. [IppbApi]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? ippbapiCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final ippbapisFuture = await _mnIppbApi!.toList(qparams);
    final int count = ippbapisFuture[0]['CNT'] as int;
    if (ippbapiCount != null) {
      ippbapiCount(count);
    }
    return count;
  }

  /// This method returns List<IppbApi> [IppbApi]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<IppbApi>
  @override
  Future<List<IppbApi>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<IppbApi> ippbapisData = await IppbApi.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return ippbapisData;
  }

  /// This method returns Json String [IppbApi]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [IppbApi]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [IppbApi]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnIppbApi!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [IppbApi]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `Sl` FROM IppbApi WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SlData = <int>[];
    qparams.selectColumns = ['Sl'];
    final SlFuture = await _mnIppbApi!.toList(qparams);

    final int count = SlFuture.length;
    for (int i = 0; i < count; i++) {
      SlData.add(SlFuture[i]['Sl'] as int);
    }
    return SlData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [IppbApi]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnIppbApi!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await IppbApi.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnIppbApi!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IppbApiFilterBuilder

// region IppbApiFields
class IppbApiFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fReqDATE;
  static TableField get ReqDATE {
    return _fReqDATE =
        _fReqDATE ?? SqlSyntax.setField(_fReqDATE, 'ReqDATE', DbType.text);
  }

  static TableField? _fReqTime;
  static TableField get ReqTime {
    return _fReqTime =
        _fReqTime ?? SqlSyntax.setField(_fReqTime, 'ReqTime', DbType.text);
  }

  static TableField? _fFacId;
  static TableField get FacId {
    return _fFacId =
        _fFacId ?? SqlSyntax.setField(_fFacId, 'FacId', DbType.text);
  }

  static TableField? _fTranDate;
  static TableField get TranDate {
    return _fTranDate =
        _fTranDate ?? SqlSyntax.setField(_fTranDate, 'TranDate', DbType.text);
  }

  static TableField? _fFromDateTime;
  static TableField get FromDateTime {
    return _fFromDateTime = _fFromDateTime ??
        SqlSyntax.setField(_fFromDateTime, 'FromDateTime', DbType.text);
  }

  static TableField? _fToDateTime;
  static TableField get ToDateTime {
    return _fToDateTime = _fToDateTime ??
        SqlSyntax.setField(_fToDateTime, 'ToDateTime', DbType.text);
  }

  static TableField? _fTotalDeposit;
  static TableField get TotalDeposit {
    return _fTotalDeposit = _fTotalDeposit ??
        SqlSyntax.setField(_fTotalDeposit, 'TotalDeposit', DbType.text);
  }

  static TableField? _fTotalWithdrawl;
  static TableField get TotalWithdrawl {
    return _fTotalWithdrawl = _fTotalWithdrawl ??
        SqlSyntax.setField(_fTotalWithdrawl, 'TotalWithdrawl', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fRemarks;
  static TableField get Remarks {
    return _fRemarks =
        _fRemarks ?? SqlSyntax.setField(_fRemarks, 'Remarks', DbType.text);
  }
}
// endregion IppbApiFields

//region IppbApiManager
class IppbApiManager extends SqfEntityProvider {
  IppbApiManager()
      : super(TransactionsMain(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'IppbApi';
  static const List<String> _primaryKeyList = ['Sl'];
  static const String _whereStr = 'Sl=?';
}

//endregion IppbApiManager
class TransactionsMainSequenceManager extends SqfEntityProvider {
  TransactionsMainSequenceManager() : super(TransactionsMain());
}
// END OF ENTITIES
