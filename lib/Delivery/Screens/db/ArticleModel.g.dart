// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'ArticleModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Reason.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Reason TABLE
class TableReason extends SqfEntityTableBase {
  TableReason() {
    // declare properties of EntityTable
    tableName = 'reasons';
    primaryKeyName = 'reasonId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('reasonCode', DbType.text),
      SqfEntityFieldBase('reasonText', DbType.text),
      SqfEntityFieldBase('remarkCode', DbType.text),
      SqfEntityFieldBase('remarkText', DbType.text),
      SqfEntityFieldBase('actionCode', DbType.text),
      SqfEntityFieldBase('actionText', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableReason();
  }
}

// ScannedArticle TABLE
class TableScannedArticle extends SqfEntityTableBase {
  TableScannedArticle() {
    // declare properties of EntityTable
    tableName = 'scannedArticle';
    primaryKeyName = 'articleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('invoiceDate', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('beat', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('batch', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('invoicedDate', DbType.text),
      SqfEntityFieldBase('facilityID', DbType.text),
      SqfEntityFieldBase('invoiceTime', DbType.text),
      SqfEntityFieldBase('postmanID', DbType.text),
      SqfEntityFieldBase('articleType', DbType.text),
      SqfEntityFieldBase('articleStatus', DbType.text),
      SqfEntityFieldBase('remarkDate', DbType.text),
      SqfEntityFieldBase('reasonCode', DbType.text),
      SqfEntityFieldBase('actionCode', DbType.text),
      SqfEntityFieldBase('addressee', DbType.text),
      SqfEntityFieldBase('deliveredTo', DbType.text),
      SqfEntityFieldBase('addresseeType', DbType.text),
      SqfEntityFieldBase('latitude', DbType.text),
      SqfEntityFieldBase('longitude', DbType.text),
      SqfEntityFieldBase('isLTM', DbType.integer),
      SqfEntityFieldBase('isListArticle', DbType.integer),
      SqfEntityFieldBase('listCode', DbType.text),
      SqfEntityFieldBase('customerId', DbType.text),
      SqfEntityFieldBase('epds', DbType.integer),
      SqfEntityFieldBase('boxID', DbType.text),
      SqfEntityFieldBase('isCommunicated', DbType.integer),
      SqfEntityFieldBase('remarkTime', DbType.text),
      SqfEntityFieldBase('postman', DbType.text),
      SqfEntityFieldBase('deviceID', DbType.text),
      SqfEntityFieldBase('rubberStamp', DbType.blob),
      SqfEntityFieldBase('signature', DbType.blob),
      SqfEntityFieldBase('sync_time', DbType.text),
      SqfEntityFieldBase('sofficeid', DbType.text),
      SqfEntityFieldBase('dofficeid', DbType.text),
      SqfEntityFieldBase('bookdate', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('bookid', DbType.text),
      SqfEntityFieldBase('insurance', DbType.text),
      SqfEntityFieldBase('moneytocollect', DbType.integer),
      SqfEntityFieldBase('moneycollected', DbType.integer),
      SqfEntityFieldBase('commission', DbType.integer),
      SqfEntityFieldBase('moneytodeliver', DbType.integer),
      SqfEntityFieldBase('moneydelivered', DbType.integer),
      SqfEntityFieldBase('windowdelivery', DbType.text),
      SqfEntityFieldBase('totmoney', DbType.integer),
      SqfEntityFieldBase('vpp', DbType.text),
      SqfEntityFieldBase('redirectpin', DbType.integer),
      SqfEntityFieldBase('modpin', DbType.integer),
      SqfEntityFieldBase('sourcepin', DbType.integer),
      SqfEntityFieldBase('destpin', DbType.integer),
      SqfEntityFieldBase('emomessage', DbType.text),
      SqfEntityFieldBase('cashreturned', DbType.integer),
      SqfEntityFieldBase('cod', DbType.text),
      SqfEntityFieldBase('receiver', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableScannedArticle();
  }
}

// ArtRet TABLE
class TableArtRet extends SqfEntityTableBase {
  TableArtRet() {
    // declare properties of EntityTable
    tableName = 'artRet';
    primaryKeyName = 'articleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('addressee', DbType.text),
      SqfEntityFieldBase('invoiceDate', DbType.text),
      SqfEntityFieldBase('isListArticle', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArtRet();
  }
}

// ArticleReturn TABLE
class TableArticleReturn extends SqfEntityTableBase {
  TableArticleReturn() {
    // declare properties of EntityTable
    tableName = 'articleReturn';
    primaryKeyName = 'articleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('addressee', DbType.text),
      SqfEntityFieldBase('invoiceDate', DbType.text),
      SqfEntityFieldBase('isListArticle', DbType.integer),
      SqfEntityFieldBase('articleType', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArticleReturn();
  }
}

// TakeReturnArticle TABLE
class TableTakeReturnArticle extends SqfEntityTableBase {
  TableTakeReturnArticle() {
    // declare properties of EntityTable
    tableName = 'takeReturnArticle';
    primaryKeyName = 'articleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('addressee', DbType.text),
      SqfEntityFieldBase('articleType', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTakeReturnArticle();
  }
}

// TakeArticleReturn TABLE
class TableTakeArticleReturn extends SqfEntityTableBase {
  TableTakeArticleReturn() {
    // declare properties of EntityTable
    tableName = 'takeArticleReturn';
    primaryKeyName = 'articleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('addressee', DbType.text),
      SqfEntityFieldBase('invoiceDate', DbType.text),
      SqfEntityFieldBase('remarkDate', DbType.text),
      SqfEntityFieldBase('isListArticle', DbType.integer),
      SqfEntityFieldBase('articleType', DbType.text),
      SqfEntityFieldBase('articleStatus', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTakeArticleReturn();
  }
}

// Logintable TABLE
class TableLogintable extends SqfEntityTableBase {
  TableLogintable() {
    // declare properties of EntityTable
    tableName = 'logintable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('PostmanName', DbType.text),
      SqfEntityFieldBase('BeatNo', DbType.text),
      SqfEntityFieldBase('BatchNo', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.text),
      SqfEntityFieldBase('DelOfficeCode', DbType.text),
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('MobileNumber', DbType.text),
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('EmpId', DbType.text),
      SqfEntityFieldBase('is_Active', DbType.integer),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLogintable();
  }
}

// EMOTable TABLE
class TableEMOTable extends SqfEntityTableBase {
  TableEMOTable() {
    // declare properties of EntityTable
    tableName = 'EMOTable';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('artNo', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEMOTable();
  }
}

// ARTICLETYPEMASTER TABLE
class TableARTICLETYPEMASTER extends SqfEntityTableBase {
  TableARTICLETYPEMASTER() {
    // declare properties of EntityTable
    tableName = 'ARTICLETYPEMASTER';
    primaryKeyName = 'sno';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('material', DbType.text),
      SqfEntityFieldBase('description', DbType.text),
      SqfEntityFieldBase('category', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableARTICLETYPEMASTER();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class ArticleModel extends SqfEntityModelProvider {
  ArticleModel() {
    databaseName = articleModel.databaseName;
    password = articleModel.password;
    dbVersion = articleModel.dbVersion;
    preSaveAction = articleModel.preSaveAction;
    logFunction = articleModel.logFunction;
    databaseTables = [
      TableReason.getInstance,
      TableScannedArticle.getInstance,
      TableArtRet.getInstance,
      TableArticleReturn.getInstance,
      TableTakeReturnArticle.getInstance,
      TableTakeArticleReturn.getInstance,
      TableLogintable.getInstance,
      TableEMOTable.getInstance,
      TableARTICLETYPEMASTER.getInstance,
    ];

    bundledDatabasePath = articleModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = articleModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Reason
class Reason extends TableBase {
  Reason(
      {this.reasonId,
      this.reasonCode,
      this.reasonText,
      this.remarkCode,
      this.remarkText,
      this.actionCode,
      this.actionText}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Reason.withFields(this.reasonCode, this.reasonText, this.remarkCode,
      this.remarkText, this.actionCode, this.actionText) {
    _setDefaultValues();
  }
  Reason.withId(this.reasonId, this.reasonCode, this.reasonText,
      this.remarkCode, this.remarkText, this.actionCode, this.actionText) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Reason.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    reasonId = int.tryParse(o['reasonId'].toString());
    if (o['reasonCode'] != null) {
      reasonCode = o['reasonCode'].toString();
    }
    if (o['reasonText'] != null) {
      reasonText = o['reasonText'].toString();
    }
    if (o['remarkCode'] != null) {
      remarkCode = o['remarkCode'].toString();
    }
    if (o['remarkText'] != null) {
      remarkText = o['remarkText'].toString();
    }
    if (o['actionCode'] != null) {
      actionCode = o['actionCode'].toString();
    }
    if (o['actionText'] != null) {
      actionText = o['actionText'].toString();
    }
  }
  // FIELDS (Reason)
  int? reasonId;
  String? reasonCode;
  String? reasonText;
  String? remarkCode;
  String? remarkText;
  String? actionCode;
  String? actionText;

  // end FIELDS (Reason)

  static const bool _softDeleteActivated = false;
  ReasonManager? __mnReason;

  ReasonManager get _mnReason {
    return __mnReason = __mnReason ?? ReasonManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['reasonId'] = reasonId;
    if (reasonCode != null || !forView) {
      map['reasonCode'] = reasonCode;
    }
    if (reasonText != null || !forView) {
      map['reasonText'] = reasonText;
    }
    if (remarkCode != null || !forView) {
      map['remarkCode'] = remarkCode;
    }
    if (remarkText != null || !forView) {
      map['remarkText'] = remarkText;
    }
    if (actionCode != null || !forView) {
      map['actionCode'] = actionCode;
    }
    if (actionText != null || !forView) {
      map['actionText'] = actionText;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['reasonId'] = reasonId;
    if (reasonCode != null || !forView) {
      map['reasonCode'] = reasonCode;
    }
    if (reasonText != null || !forView) {
      map['reasonText'] = reasonText;
    }
    if (remarkCode != null || !forView) {
      map['remarkCode'] = remarkCode;
    }
    if (remarkText != null || !forView) {
      map['remarkText'] = remarkText;
    }
    if (actionCode != null || !forView) {
      map['actionCode'] = actionCode;
    }
    if (actionText != null || !forView) {
      map['actionText'] = actionText;
    }

    return map;
  }

  /// This method returns Json String [Reason]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Reason]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      reasonCode,
      reasonText,
      remarkCode,
      remarkText,
      actionCode,
      actionText
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      reasonId,
      reasonCode,
      reasonText,
      remarkCode,
      remarkText,
      actionCode,
      actionText
    ];
  }

  static Future<List<Reason>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Reason.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Reason>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Reason>[];
    try {
      objList = list
          .map((reason) => Reason.fromMap(reason as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Reason.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Reason>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Reason> objList = <Reason>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Reason.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Reason by ID if exist, otherwise returns null
  /// Primary Keys: int? reasonId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Reason] if exist, otherwise returns null
  Future<Reason?> getById(int? reasonId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (reasonId == null) {
      return null;
    }
    Reason? obj;
    final data = await _mnReason.getById([reasonId]);
    if (data.length != 0) {
      obj = Reason.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Reason) object. If the reasonId field is null, saves as a new record and returns new reasonId, if reasonId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns reasonId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (reasonId == null || reasonId == 0) {
      reasonId = await _mnReason.insert(this, ignoreBatch);
    } else {
      await _mnReason.update(this);
    }

    return reasonId;
  }

  /// Saves the (Reason) object. If the reasonId field is null, saves as a new record and returns new reasonId, if reasonId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns reasonId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (reasonId == null || reasonId == 0) {
      reasonId = await _mnReason.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // reasonId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnReason.updateOrThrow(this);
    }

    return reasonId;
  }

  /// saveAs Reason. Returns a new Primary Key value of Reason

  /// <returns>Returns a new Primary Key value of Reason
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    reasonId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Reason> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Reason> reasons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in reasons) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < reasons.length; i++) {
        if (reasons[i].reasonId == null) {
          reasons[i].reasonId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns reasonId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnReason.rawInsert(
          'INSERT OR REPLACE INTO reasons (reasonId, reasonCode, reasonText, remarkCode, remarkText, actionCode, actionText)  VALUES (?,?,?,?,?,?,?)',
          [
            reasonId,
            reasonCode,
            reasonText,
            remarkCode,
            remarkText,
            actionCode,
            actionText
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Reason reasonId=$reasonId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Reason reasonId=$reasonId did not update');
      }
      return reasonId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Reason Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns reasonId
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnReason.rawInsert(
          'INSERT OR IGNORE INTO reasons (reasonId, reasonCode, reasonText, remarkCode, remarkText, actionCode, actionText)  VALUES (?,?,?,?,?,?,?)',
          [
            reasonId,
            reasonCode,
            reasonText,
            remarkCode,
            remarkText,
            actionCode,
            actionText
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Reason reasonId=$reasonId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Reason reasonId=$reasonId did not update');
      }
      return reasonId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Reason Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Reason>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Reason> reasons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnReason.rawInsertAll(
        'INSERT OR REPLACE INTO reasons (reasonId, reasonCode, reasonText, remarkCode, remarkText, actionCode, actionText)  VALUES (?,?,?,?,?,?,?)',
        reasons,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Reason

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Reason invoked (reasonId=$reasonId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnReason.delete(
          QueryParams(whereString: 'reasonId=?', whereArguments: [reasonId]));
    } else {
      return _mnReason.updateBatch(
          QueryParams(whereString: 'reasonId=?', whereArguments: [reasonId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Reason] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ReasonFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ReasonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ReasonFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ReasonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      reasonId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion reason

// region ReasonField
class ReasonField extends FilterBase {
  ReasonField(ReasonFilterBuilder reasonFB) : super(reasonFB);

  @override
  ReasonFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder isNull() {
    return super.isNull() as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonField get not {
    return super.not as ReasonField;
  }
}
// endregion ReasonField

// region ReasonFilterBuilder
class ReasonFilterBuilder extends ConjunctionBase {
  ReasonFilterBuilder(Reason obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnReason = obj._mnReason;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ReasonManager? _mnReason;

  /// put the sql keyword 'AND'
  @override
  ReasonFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ReasonFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ReasonFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ReasonFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ReasonFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ReasonFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ReasonFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ReasonFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ReasonFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ReasonFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ReasonFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ReasonField _setField(ReasonField? field, String colName, DbType dbtype) {
    return ReasonField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ReasonField? _reasonId;
  ReasonField get reasonId {
    return _reasonId = _setField(_reasonId, 'reasonId', DbType.integer);
  }

  ReasonField? _reasonCode;
  ReasonField get reasonCode {
    return _reasonCode = _setField(_reasonCode, 'reasonCode', DbType.text);
  }

  ReasonField? _reasonText;
  ReasonField get reasonText {
    return _reasonText = _setField(_reasonText, 'reasonText', DbType.text);
  }

  ReasonField? _remarkCode;
  ReasonField get remarkCode {
    return _remarkCode = _setField(_remarkCode, 'remarkCode', DbType.text);
  }

  ReasonField? _remarkText;
  ReasonField get remarkText {
    return _remarkText = _setField(_remarkText, 'remarkText', DbType.text);
  }

  ReasonField? _actionCode;
  ReasonField get actionCode {
    return _actionCode = _setField(_actionCode, 'actionCode', DbType.text);
  }

  ReasonField? _actionText;
  ReasonField get actionText {
    return _actionText = _setField(_actionText, 'actionText', DbType.text);
  }

  /// Deletes List<Reason> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnReason!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnReason!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'reasonId IN (SELECT reasonId from reasons ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnReason!.updateBatch(qparams, values);
  }

  /// This method always returns [Reason] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Reason?
  @override
  Future<Reason?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnReason!.toList(qparams);
    final data = await objFuture;
    Reason? obj;
    if (data.isNotEmpty) {
      obj = Reason.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Reason]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Reason?
  @override
  Future<Reason> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Reason();
  }

  /// This method returns int. [Reason]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? reasonCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final reasonsFuture = await _mnReason!.toList(qparams);
    final int count = reasonsFuture[0]['CNT'] as int;
    if (reasonCount != null) {
      reasonCount(count);
    }
    return count;
  }

  /// This method returns List<Reason> [Reason]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Reason>
  @override
  Future<List<Reason>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Reason> reasonsData = await Reason.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return reasonsData;
  }

  /// This method returns Json String [Reason]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Reason]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Reason]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnReason!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Reason]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `reasonId` FROM reasons WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> reasonIdData = <int>[];
    qparams.selectColumns = ['reasonId'];
    final reasonIdFuture = await _mnReason!.toList(qparams);

    final int count = reasonIdFuture.length;
    for (int i = 0; i < count; i++) {
      reasonIdData.add(reasonIdFuture[i]['reasonId'] as int);
    }
    return reasonIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Reason]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnReason!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Reason.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnReason!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ReasonFilterBuilder

// region ReasonFields
class ReasonFields {
  static TableField? _fReasonId;
  static TableField get reasonId {
    return _fReasonId = _fReasonId ??
        SqlSyntax.setField(_fReasonId, 'reasonid', DbType.integer);
  }

  static TableField? _fReasonCode;
  static TableField get reasonCode {
    return _fReasonCode = _fReasonCode ??
        SqlSyntax.setField(_fReasonCode, 'reasonCode', DbType.text);
  }

  static TableField? _fReasonText;
  static TableField get reasonText {
    return _fReasonText = _fReasonText ??
        SqlSyntax.setField(_fReasonText, 'reasonText', DbType.text);
  }

  static TableField? _fRemarkCode;
  static TableField get remarkCode {
    return _fRemarkCode = _fRemarkCode ??
        SqlSyntax.setField(_fRemarkCode, 'remarkCode', DbType.text);
  }

  static TableField? _fRemarkText;
  static TableField get remarkText {
    return _fRemarkText = _fRemarkText ??
        SqlSyntax.setField(_fRemarkText, 'remarkText', DbType.text);
  }

  static TableField? _fActionCode;
  static TableField get actionCode {
    return _fActionCode = _fActionCode ??
        SqlSyntax.setField(_fActionCode, 'actionCode', DbType.text);
  }

  static TableField? _fActionText;
  static TableField get actionText {
    return _fActionText = _fActionText ??
        SqlSyntax.setField(_fActionText, 'actionText', DbType.text);
  }
}
// endregion ReasonFields

//region ReasonManager
class ReasonManager extends SqfEntityProvider {
  ReasonManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'reasons';
  static const List<String> _primaryKeyList = ['reasonId'];
  static const String _whereStr = 'reasonId=?';
}

//endregion ReasonManager
// region ScannedArticle
class ScannedArticle extends TableBase {
  ScannedArticle(
      {this.articleNumber,
      this.invoiceDate,
      this.beat,
      this.batch,
      this.invoicedDate,
      this.facilityID,
      this.invoiceTime,
      this.postmanID,
      this.articleType,
      this.articleStatus,
      this.remarkDate,
      this.reasonCode,
      this.actionCode,
      this.addressee,
      this.deliveredTo,
      this.addresseeType,
      this.latitude,
      this.longitude,
      this.isLTM,
      this.isListArticle,
      this.listCode,
      this.customerId,
      this.epds,
      this.boxID,
      this.isCommunicated,
      this.remarkTime,
      this.postman,
      this.deviceID,
      this.rubberStamp,
      this.signature,
      this.sync_time,
      this.sofficeid,
      this.dofficeid,
      this.bookdate,
      this.bookid,
      this.insurance,
      this.moneytocollect,
      this.moneycollected,
      this.commission,
      this.moneytodeliver,
      this.moneydelivered,
      this.windowdelivery,
      this.totmoney,
      this.vpp,
      this.redirectpin,
      this.modpin,
      this.sourcepin,
      this.destpin,
      this.emomessage,
      this.cashreturned,
      this.cod,
      this.receiver}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ScannedArticle.withFields(
      this.articleNumber,
      this.invoiceDate,
      this.beat,
      this.batch,
      this.invoicedDate,
      this.facilityID,
      this.invoiceTime,
      this.postmanID,
      this.articleType,
      this.articleStatus,
      this.remarkDate,
      this.reasonCode,
      this.actionCode,
      this.addressee,
      this.deliveredTo,
      this.addresseeType,
      this.latitude,
      this.longitude,
      this.isLTM,
      this.isListArticle,
      this.listCode,
      this.customerId,
      this.epds,
      this.boxID,
      this.isCommunicated,
      this.remarkTime,
      this.postman,
      this.deviceID,
      this.rubberStamp,
      this.signature,
      this.sync_time,
      this.sofficeid,
      this.dofficeid,
      this.bookdate,
      this.bookid,
      this.insurance,
      this.moneytocollect,
      this.moneycollected,
      this.commission,
      this.moneytodeliver,
      this.moneydelivered,
      this.windowdelivery,
      this.totmoney,
      this.vpp,
      this.redirectpin,
      this.modpin,
      this.sourcepin,
      this.destpin,
      this.emomessage,
      this.cashreturned,
      this.cod,
      this.receiver) {
    _setDefaultValues();
  }
  ScannedArticle.withId(
      this.articleNumber,
      this.invoiceDate,
      this.beat,
      this.batch,
      this.invoicedDate,
      this.facilityID,
      this.invoiceTime,
      this.postmanID,
      this.articleType,
      this.articleStatus,
      this.remarkDate,
      this.reasonCode,
      this.actionCode,
      this.addressee,
      this.deliveredTo,
      this.addresseeType,
      this.latitude,
      this.longitude,
      this.isLTM,
      this.isListArticle,
      this.listCode,
      this.customerId,
      this.epds,
      this.boxID,
      this.isCommunicated,
      this.remarkTime,
      this.postman,
      this.deviceID,
      this.rubberStamp,
      this.signature,
      this.sync_time,
      this.sofficeid,
      this.dofficeid,
      this.bookdate,
      this.bookid,
      this.insurance,
      this.moneytocollect,
      this.moneycollected,
      this.commission,
      this.moneytodeliver,
      this.moneydelivered,
      this.windowdelivery,
      this.totmoney,
      this.vpp,
      this.redirectpin,
      this.modpin,
      this.sourcepin,
      this.destpin,
      this.emomessage,
      this.cashreturned,
      this.cod,
      this.receiver) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ScannedArticle.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    articleNumber = o['articleNumber'].toString();
    if (o['invoiceDate'] != null) {
      invoiceDate = o['invoiceDate'].toString();
    }
    if (o['beat'] != null) {
      beat = o['beat'].toString();
    }
    if (o['batch'] != null) {
      batch = o['batch'].toString();
    }
    if (o['invoicedDate'] != null) {
      invoicedDate = o['invoicedDate'].toString();
    }
    if (o['facilityID'] != null) {
      facilityID = o['facilityID'].toString();
    }
    if (o['invoiceTime'] != null) {
      invoiceTime = o['invoiceTime'].toString();
    }
    if (o['postmanID'] != null) {
      postmanID = o['postmanID'].toString();
    }
    if (o['articleType'] != null) {
      articleType = o['articleType'].toString();
    }
    if (o['articleStatus'] != null) {
      articleStatus = o['articleStatus'].toString();
    }
    if (o['remarkDate'] != null) {
      remarkDate = o['remarkDate'].toString();
    }
    if (o['reasonCode'] != null) {
      reasonCode = o['reasonCode'].toString();
    }
    if (o['actionCode'] != null) {
      actionCode = o['actionCode'].toString();
    }
    if (o['addressee'] != null) {
      addressee = o['addressee'].toString();
    }
    if (o['deliveredTo'] != null) {
      deliveredTo = o['deliveredTo'].toString();
    }
    if (o['addresseeType'] != null) {
      addresseeType = o['addresseeType'].toString();
    }
    if (o['latitude'] != null) {
      latitude = o['latitude'].toString();
    }
    if (o['longitude'] != null) {
      longitude = o['longitude'].toString();
    }
    if (o['isLTM'] != null) {
      isLTM = int.tryParse(o['isLTM'].toString());
    }
    if (o['isListArticle'] != null) {
      isListArticle = int.tryParse(o['isListArticle'].toString());
    }
    if (o['listCode'] != null) {
      listCode = o['listCode'].toString();
    }
    if (o['customerId'] != null) {
      customerId = o['customerId'].toString();
    }
    if (o['epds'] != null) {
      epds = int.tryParse(o['epds'].toString());
    }
    if (o['boxID'] != null) {
      boxID = o['boxID'].toString();
    }
    if (o['isCommunicated'] != null) {
      isCommunicated = int.tryParse(o['isCommunicated'].toString());
    }
    if (o['remarkTime'] != null) {
      remarkTime = o['remarkTime'].toString();
    }
    if (o['postman'] != null) {
      postman = o['postman'].toString();
    }
    if (o['deviceID'] != null) {
      deviceID = o['deviceID'].toString();
    }
    if (o['rubberStamp'] != null) {
      rubberStamp = o['rubberStamp'] as Uint8List;
    }
    if (o['signature'] != null) {
      signature = o['signature'] as Uint8List;
    }
    if (o['sync_time'] != null) {
      sync_time = o['sync_time'].toString();
    }
    if (o['sofficeid'] != null) {
      sofficeid = o['sofficeid'].toString();
    }
    if (o['dofficeid'] != null) {
      dofficeid = o['dofficeid'].toString();
    }
    if (o['bookdate'] != null) {
      bookdate = int.tryParse(o['bookdate'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['bookdate'].toString())!)
          : DateTime.tryParse(o['bookdate'].toString());
    }
    if (o['bookid'] != null) {
      bookid = o['bookid'].toString();
    }
    if (o['insurance'] != null) {
      insurance = o['insurance'].toString();
    }
    if (o['moneytocollect'] != null) {
      moneytocollect = int.tryParse(o['moneytocollect'].toString());
    }
    if (o['moneycollected'] != null) {
      moneycollected = int.tryParse(o['moneycollected'].toString());
    }
    if (o['commission'] != null) {
      commission = int.tryParse(o['commission'].toString());
    }
    if (o['moneytodeliver'] != null) {
      moneytodeliver = int.tryParse(o['moneytodeliver'].toString());
    }
    if (o['moneydelivered'] != null) {
      moneydelivered = int.tryParse(o['moneydelivered'].toString());
    }
    if (o['windowdelivery'] != null) {
      windowdelivery = o['windowdelivery'].toString();
    }
    if (o['totmoney'] != null) {
      totmoney = int.tryParse(o['totmoney'].toString());
    }
    if (o['vpp'] != null) {
      vpp = o['vpp'].toString();
    }
    if (o['redirectpin'] != null) {
      redirectpin = int.tryParse(o['redirectpin'].toString());
    }
    if (o['modpin'] != null) {
      modpin = int.tryParse(o['modpin'].toString());
    }
    if (o['sourcepin'] != null) {
      sourcepin = int.tryParse(o['sourcepin'].toString());
    }
    if (o['destpin'] != null) {
      destpin = int.tryParse(o['destpin'].toString());
    }
    if (o['emomessage'] != null) {
      emomessage = o['emomessage'].toString();
    }
    if (o['cashreturned'] != null) {
      cashreturned = int.tryParse(o['cashreturned'].toString());
    }
    if (o['cod'] != null) {
      cod = o['cod'].toString();
    }
    if (o['receiver'] != null) {
      receiver = o['receiver'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ScannedArticle)
  String? articleNumber;
  String? invoiceDate;
  String? beat;
  String? batch;
  String? invoicedDate;
  String? facilityID;
  String? invoiceTime;
  String? postmanID;
  String? articleType;
  String? articleStatus;
  String? remarkDate;
  String? reasonCode;
  String? actionCode;
  String? addressee;
  String? deliveredTo;
  String? addresseeType;
  String? latitude;
  String? longitude;
  int? isLTM;
  int? isListArticle;
  String? listCode;
  String? customerId;
  int? epds;
  String? boxID;
  int? isCommunicated;
  String? remarkTime;
  String? postman;
  String? deviceID;
  Uint8List? rubberStamp;
  Uint8List? signature;
  String? sync_time;
  String? sofficeid;
  String? dofficeid;
  DateTime? bookdate;
  String? bookid;
  String? insurance;
  int? moneytocollect;
  int? moneycollected;
  int? commission;
  int? moneytodeliver;
  int? moneydelivered;
  String? windowdelivery;
  int? totmoney;
  String? vpp;
  int? redirectpin;
  int? modpin;
  int? sourcepin;
  int? destpin;
  String? emomessage;
  int? cashreturned;
  String? cod;
  String? receiver;
  bool? isSaved;
  // end FIELDS (ScannedArticle)

  static const bool _softDeleteActivated = false;
  ScannedArticleManager? __mnScannedArticle;

  ScannedArticleManager get _mnScannedArticle {
    return __mnScannedArticle = __mnScannedArticle ?? ScannedArticleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (beat != null || !forView) {
      map['beat'] = beat;
    }
    if (batch != null || !forView) {
      map['batch'] = batch;
    }
    if (invoicedDate != null || !forView) {
      map['invoicedDate'] = invoicedDate;
    }
    if (facilityID != null || !forView) {
      map['facilityID'] = facilityID;
    }
    if (invoiceTime != null || !forView) {
      map['invoiceTime'] = invoiceTime;
    }
    if (postmanID != null || !forView) {
      map['postmanID'] = postmanID;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }
    if (articleStatus != null || !forView) {
      map['articleStatus'] = articleStatus;
    }
    if (remarkDate != null || !forView) {
      map['remarkDate'] = remarkDate;
    }
    if (reasonCode != null || !forView) {
      map['reasonCode'] = reasonCode;
    }
    if (actionCode != null || !forView) {
      map['actionCode'] = actionCode;
    }
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (deliveredTo != null || !forView) {
      map['deliveredTo'] = deliveredTo;
    }
    if (addresseeType != null || !forView) {
      map['addresseeType'] = addresseeType;
    }
    if (latitude != null || !forView) {
      map['latitude'] = latitude;
    }
    if (longitude != null || !forView) {
      map['longitude'] = longitude;
    }
    if (isLTM != null || !forView) {
      map['isLTM'] = isLTM;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (listCode != null || !forView) {
      map['listCode'] = listCode;
    }
    if (customerId != null || !forView) {
      map['customerId'] = customerId;
    }
    if (epds != null || !forView) {
      map['epds'] = epds;
    }
    if (boxID != null || !forView) {
      map['boxID'] = boxID;
    }
    if (isCommunicated != null || !forView) {
      map['isCommunicated'] = isCommunicated;
    }
    if (remarkTime != null || !forView) {
      map['remarkTime'] = remarkTime;
    }
    if (postman != null || !forView) {
      map['postman'] = postman;
    }
    if (deviceID != null || !forView) {
      map['deviceID'] = deviceID;
    }
    if (rubberStamp != null || !forView) {
      map['rubberStamp'] = rubberStamp;
    }
    if (signature != null || !forView) {
      map['signature'] = signature;
    }
    if (sync_time != null || !forView) {
      map['sync_time'] = sync_time;
    }
    if (sofficeid != null || !forView) {
      map['sofficeid'] = sofficeid;
    }
    if (dofficeid != null || !forView) {
      map['dofficeid'] = dofficeid;
    }
    if (bookdate != null) {
      map['bookdate'] = forJson
          ? bookdate!.toString()
          : forQuery
              ? bookdate!.millisecondsSinceEpoch
              : bookdate;
    } else if (bookdate != null || !forView) {
      map['bookdate'] = null;
    }
    if (bookid != null || !forView) {
      map['bookid'] = bookid;
    }
    if (insurance != null || !forView) {
      map['insurance'] = insurance;
    }
    if (moneytocollect != null || !forView) {
      map['moneytocollect'] = moneytocollect;
    }
    if (moneycollected != null || !forView) {
      map['moneycollected'] = moneycollected;
    }
    if (commission != null || !forView) {
      map['commission'] = commission;
    }
    if (moneytodeliver != null || !forView) {
      map['moneytodeliver'] = moneytodeliver;
    }
    if (moneydelivered != null || !forView) {
      map['moneydelivered'] = moneydelivered;
    }
    if (windowdelivery != null || !forView) {
      map['windowdelivery'] = windowdelivery;
    }
    if (totmoney != null || !forView) {
      map['totmoney'] = totmoney;
    }
    if (vpp != null || !forView) {
      map['vpp'] = vpp;
    }
    if (redirectpin != null || !forView) {
      map['redirectpin'] = redirectpin;
    }
    if (modpin != null || !forView) {
      map['modpin'] = modpin;
    }
    if (sourcepin != null || !forView) {
      map['sourcepin'] = sourcepin;
    }
    if (destpin != null || !forView) {
      map['destpin'] = destpin;
    }
    if (emomessage != null || !forView) {
      map['emomessage'] = emomessage;
    }
    if (cashreturned != null || !forView) {
      map['cashreturned'] = cashreturned;
    }
    if (cod != null || !forView) {
      map['cod'] = cod;
    }
    if (receiver != null || !forView) {
      map['receiver'] = receiver;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (beat != null || !forView) {
      map['beat'] = beat;
    }
    if (batch != null || !forView) {
      map['batch'] = batch;
    }
    if (invoicedDate != null || !forView) {
      map['invoicedDate'] = invoicedDate;
    }
    if (facilityID != null || !forView) {
      map['facilityID'] = facilityID;
    }
    if (invoiceTime != null || !forView) {
      map['invoiceTime'] = invoiceTime;
    }
    if (postmanID != null || !forView) {
      map['postmanID'] = postmanID;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }
    if (articleStatus != null || !forView) {
      map['articleStatus'] = articleStatus;
    }
    if (remarkDate != null || !forView) {
      map['remarkDate'] = remarkDate;
    }
    if (reasonCode != null || !forView) {
      map['reasonCode'] = reasonCode;
    }
    if (actionCode != null || !forView) {
      map['actionCode'] = actionCode;
    }
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (deliveredTo != null || !forView) {
      map['deliveredTo'] = deliveredTo;
    }
    if (addresseeType != null || !forView) {
      map['addresseeType'] = addresseeType;
    }
    if (latitude != null || !forView) {
      map['latitude'] = latitude;
    }
    if (longitude != null || !forView) {
      map['longitude'] = longitude;
    }
    if (isLTM != null || !forView) {
      map['isLTM'] = isLTM;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (listCode != null || !forView) {
      map['listCode'] = listCode;
    }
    if (customerId != null || !forView) {
      map['customerId'] = customerId;
    }
    if (epds != null || !forView) {
      map['epds'] = epds;
    }
    if (boxID != null || !forView) {
      map['boxID'] = boxID;
    }
    if (isCommunicated != null || !forView) {
      map['isCommunicated'] = isCommunicated;
    }
    if (remarkTime != null || !forView) {
      map['remarkTime'] = remarkTime;
    }
    if (postman != null || !forView) {
      map['postman'] = postman;
    }
    if (deviceID != null || !forView) {
      map['deviceID'] = deviceID;
    }
    if (rubberStamp != null || !forView) {
      map['rubberStamp'] = rubberStamp;
    }
    if (signature != null || !forView) {
      map['signature'] = signature;
    }
    if (sync_time != null || !forView) {
      map['sync_time'] = sync_time;
    }
    if (sofficeid != null || !forView) {
      map['sofficeid'] = sofficeid;
    }
    if (dofficeid != null || !forView) {
      map['dofficeid'] = dofficeid;
    }
    if (bookdate != null) {
      map['bookdate'] = forJson
          ? bookdate!.toString()
          : forQuery
              ? bookdate!.millisecondsSinceEpoch
              : bookdate;
    } else if (bookdate != null || !forView) {
      map['bookdate'] = null;
    }
    if (bookid != null || !forView) {
      map['bookid'] = bookid;
    }
    if (insurance != null || !forView) {
      map['insurance'] = insurance;
    }
    if (moneytocollect != null || !forView) {
      map['moneytocollect'] = moneytocollect;
    }
    if (moneycollected != null || !forView) {
      map['moneycollected'] = moneycollected;
    }
    if (commission != null || !forView) {
      map['commission'] = commission;
    }
    if (moneytodeliver != null || !forView) {
      map['moneytodeliver'] = moneytodeliver;
    }
    if (moneydelivered != null || !forView) {
      map['moneydelivered'] = moneydelivered;
    }
    if (windowdelivery != null || !forView) {
      map['windowdelivery'] = windowdelivery;
    }
    if (totmoney != null || !forView) {
      map['totmoney'] = totmoney;
    }
    if (vpp != null || !forView) {
      map['vpp'] = vpp;
    }
    if (redirectpin != null || !forView) {
      map['redirectpin'] = redirectpin;
    }
    if (modpin != null || !forView) {
      map['modpin'] = modpin;
    }
    if (sourcepin != null || !forView) {
      map['sourcepin'] = sourcepin;
    }
    if (destpin != null || !forView) {
      map['destpin'] = destpin;
    }
    if (emomessage != null || !forView) {
      map['emomessage'] = emomessage;
    }
    if (cashreturned != null || !forView) {
      map['cashreturned'] = cashreturned;
    }
    if (cod != null || !forView) {
      map['cod'] = cod;
    }
    if (receiver != null || !forView) {
      map['receiver'] = receiver;
    }

    return map;
  }

  /// This method returns Json String [ScannedArticle]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ScannedArticle]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      articleNumber,
      invoiceDate,
      beat,
      batch,
      invoicedDate,
      facilityID,
      invoiceTime,
      postmanID,
      articleType,
      articleStatus,
      remarkDate,
      reasonCode,
      actionCode,
      addressee,
      deliveredTo,
      addresseeType,
      latitude,
      longitude,
      isLTM,
      isListArticle,
      listCode,
      customerId,
      epds,
      boxID,
      isCommunicated,
      remarkTime,
      postman,
      deviceID,
      rubberStamp,
      signature,
      sync_time,
      sofficeid,
      dofficeid,
      bookdate != null ? bookdate!.millisecondsSinceEpoch : null,
      bookid,
      insurance,
      moneytocollect,
      moneycollected,
      commission,
      moneytodeliver,
      moneydelivered,
      windowdelivery,
      totmoney,
      vpp,
      redirectpin,
      modpin,
      sourcepin,
      destpin,
      emomessage,
      cashreturned,
      cod,
      receiver
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      articleNumber,
      invoiceDate,
      beat,
      batch,
      invoicedDate,
      facilityID,
      invoiceTime,
      postmanID,
      articleType,
      articleStatus,
      remarkDate,
      reasonCode,
      actionCode,
      addressee,
      deliveredTo,
      addresseeType,
      latitude,
      longitude,
      isLTM,
      isListArticle,
      listCode,
      customerId,
      epds,
      boxID,
      isCommunicated,
      remarkTime,
      postman,
      deviceID,
      rubberStamp,
      signature,
      sync_time,
      sofficeid,
      dofficeid,
      bookdate != null ? bookdate!.millisecondsSinceEpoch : null,
      bookid,
      insurance,
      moneytocollect,
      moneycollected,
      commission,
      moneytodeliver,
      moneydelivered,
      windowdelivery,
      totmoney,
      vpp,
      redirectpin,
      modpin,
      sourcepin,
      destpin,
      emomessage,
      cashreturned,
      cod,
      receiver
    ];
  }

  static Future<List<ScannedArticle>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ScannedArticle.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ScannedArticle>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ScannedArticle>[];
    try {
      objList = list
          .map((scannedarticle) =>
              ScannedArticle.fromMap(scannedarticle as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ScannedArticle.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ScannedArticle>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ScannedArticle> objList = <ScannedArticle>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ScannedArticle.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ScannedArticle by ID if exist, otherwise returns null
  /// Primary Keys: String? articleNumber, String? invoiceDate, String? beat, String? batch
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ScannedArticle] if exist, otherwise returns null
  Future<ScannedArticle?> getById(
      String? articleNumber, String? invoiceDate, String? beat, String? batch,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (articleNumber == null) {
      return null;
    }
    ScannedArticle? obj;
    final data = await _mnScannedArticle
        .getById([articleNumber, invoiceDate, beat, batch]);
    if (data.length != 0) {
      obj = ScannedArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ScannedArticle) object. If the Primary Key (articleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same articleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnScannedArticle.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO scannedArticle (articleNumber, invoiceDate, beat, batch, invoicedDate, facilityID, invoiceTime, postmanID, articleType, articleStatus, remarkDate, reasonCode, actionCode, addressee, deliveredTo, addresseeType, latitude, longitude, isLTM, isListArticle, listCode, customerId, epds, boxID, isCommunicated, remarkTime, postman, deviceID, rubberStamp, signature, sync_time, sofficeid, dofficeid, bookdate, bookid, insurance, moneytocollect, moneycollected, commission, moneytodeliver, moneydelivered, windowdelivery, totmoney, vpp, redirectpin, modpin, sourcepin, destpin, emomessage, cashreturned, cod, receiver)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ScannedArticle> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ScannedArticle> scannedarticles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in scannedarticles) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnScannedArticle.rawInsert(
          'INSERT OR REPLACE INTO scannedArticle (articleNumber, invoiceDate, beat, batch, invoicedDate, facilityID, invoiceTime, postmanID, articleType, articleStatus, remarkDate, reasonCode, actionCode, addressee, deliveredTo, addresseeType, latitude, longitude, isLTM, isListArticle, listCode, customerId, epds, boxID, isCommunicated, remarkTime, postman, deviceID, rubberStamp, signature, sync_time, sofficeid, dofficeid, bookdate, bookid, insurance, moneytocollect, moneycollected, commission, moneytodeliver, moneydelivered, windowdelivery, totmoney, vpp, redirectpin, modpin, sourcepin, destpin, emomessage, cashreturned, cod, receiver)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            articleNumber,
            invoiceDate,
            beat,
            batch,
            invoicedDate,
            facilityID,
            invoiceTime,
            postmanID,
            articleType,
            articleStatus,
            remarkDate,
            reasonCode,
            actionCode,
            addressee,
            deliveredTo,
            addresseeType,
            latitude,
            longitude,
            isLTM,
            isListArticle,
            listCode,
            customerId,
            epds,
            boxID,
            isCommunicated,
            remarkTime,
            postman,
            deviceID,
            rubberStamp,
            signature,
            sync_time,
            sofficeid,
            dofficeid,
            bookdate != null ? bookdate!.millisecondsSinceEpoch : null,
            bookid,
            insurance,
            moneytocollect,
            moneycollected,
            commission,
            moneytodeliver,
            moneydelivered,
            windowdelivery,
            totmoney,
            vpp,
            redirectpin,
            modpin,
            sourcepin,
            destpin,
            emomessage,
            cashreturned,
            cod,
            receiver
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ScannedArticle articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ScannedArticle articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ScannedArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnScannedArticle.rawInsert(
          'INSERT OR IGNORE INTO scannedArticle (articleNumber, invoiceDate, beat, batch, invoicedDate, facilityID, invoiceTime, postmanID, articleType, articleStatus, remarkDate, reasonCode, actionCode, addressee, deliveredTo, addresseeType, latitude, longitude, isLTM, isListArticle, listCode, customerId, epds, boxID, isCommunicated, remarkTime, postman, deviceID, rubberStamp, signature, sync_time, sofficeid, dofficeid, bookdate, bookid, insurance, moneytocollect, moneycollected, commission, moneytodeliver, moneydelivered, windowdelivery, totmoney, vpp, redirectpin, modpin, sourcepin, destpin, emomessage, cashreturned, cod, receiver)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            articleNumber,
            invoiceDate,
            beat,
            batch,
            invoicedDate,
            facilityID,
            invoiceTime,
            postmanID,
            articleType,
            articleStatus,
            remarkDate,
            reasonCode,
            actionCode,
            addressee,
            deliveredTo,
            addresseeType,
            latitude,
            longitude,
            isLTM,
            isListArticle,
            listCode,
            customerId,
            epds,
            boxID,
            isCommunicated,
            remarkTime,
            postman,
            deviceID,
            rubberStamp,
            signature,
            sync_time,
            sofficeid,
            dofficeid,
            bookdate != null ? bookdate!.millisecondsSinceEpoch : null,
            bookid,
            insurance,
            moneytocollect,
            moneycollected,
            commission,
            moneytodeliver,
            moneydelivered,
            windowdelivery,
            totmoney,
            vpp,
            redirectpin,
            modpin,
            sourcepin,
            destpin,
            emomessage,
            cashreturned,
            cod,
            receiver
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ScannedArticle articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ScannedArticle articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ScannedArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ScannedArticle

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ScannedArticle invoked (articleNumber=$articleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnScannedArticle.delete(QueryParams(
          whereString:
              'articleNumber=? AND invoiceDate=? AND beat=? AND batch=?',
          whereArguments: [articleNumber, invoiceDate, beat, batch]));
    } else {
      return _mnScannedArticle.updateBatch(
          QueryParams(
              whereString:
                  'articleNumber=? AND invoiceDate=? AND beat=? AND batch=?',
              whereArguments: [articleNumber, invoiceDate, beat, batch]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ScannedArticle] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ScannedArticleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ScannedArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ScannedArticleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ScannedArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      articleNumber = null;
      invoiceDate = null;
      beat = null;
      batch = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion scannedarticle

// region ScannedArticleField
class ScannedArticleField extends FilterBase {
  ScannedArticleField(ScannedArticleFilterBuilder scannedarticleFB)
      : super(scannedarticleFB);

  @override
  ScannedArticleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder isNull() {
    return super.isNull() as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ScannedArticleFilterBuilder;
  }

  @override
  ScannedArticleField get not {
    return super.not as ScannedArticleField;
  }
}
// endregion ScannedArticleField

// region ScannedArticleFilterBuilder
class ScannedArticleFilterBuilder extends ConjunctionBase {
  ScannedArticleFilterBuilder(ScannedArticle obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnScannedArticle = obj._mnScannedArticle;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ScannedArticleManager? _mnScannedArticle;

  /// put the sql keyword 'AND'
  @override
  ScannedArticleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ScannedArticleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ScannedArticleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ScannedArticleFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ScannedArticleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ScannedArticleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ScannedArticleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ScannedArticleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ScannedArticleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ScannedArticleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ScannedArticleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ScannedArticleField _setField(
      ScannedArticleField? field, String colName, DbType dbtype) {
    return ScannedArticleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ScannedArticleField? _articleNumber;
  ScannedArticleField get articleNumber {
    return _articleNumber =
        _setField(_articleNumber, 'articleNumber', DbType.integer);
  }

  ScannedArticleField? _invoiceDate;
  ScannedArticleField get invoiceDate {
    return _invoiceDate = _setField(_invoiceDate, 'invoiceDate', DbType.text);
  }

  ScannedArticleField? _beat;
  ScannedArticleField get beat {
    return _beat = _setField(_beat, 'beat', DbType.text);
  }

  ScannedArticleField? _batch;
  ScannedArticleField get batch {
    return _batch = _setField(_batch, 'batch', DbType.text);
  }

  ScannedArticleField? _invoicedDate;
  ScannedArticleField get invoicedDate {
    return _invoicedDate =
        _setField(_invoicedDate, 'invoicedDate', DbType.text);
  }

  ScannedArticleField? _facilityID;
  ScannedArticleField get facilityID {
    return _facilityID = _setField(_facilityID, 'facilityID', DbType.text);
  }

  ScannedArticleField? _invoiceTime;
  ScannedArticleField get invoiceTime {
    return _invoiceTime = _setField(_invoiceTime, 'invoiceTime', DbType.text);
  }

  ScannedArticleField? _postmanID;
  ScannedArticleField get postmanID {
    return _postmanID = _setField(_postmanID, 'postmanID', DbType.text);
  }

  ScannedArticleField? _articleType;
  ScannedArticleField get articleType {
    return _articleType = _setField(_articleType, 'articleType', DbType.text);
  }

  ScannedArticleField? _articleStatus;
  ScannedArticleField get articleStatus {
    return _articleStatus =
        _setField(_articleStatus, 'articleStatus', DbType.text);
  }

  ScannedArticleField? _remarkDate;
  ScannedArticleField get remarkDate {
    return _remarkDate = _setField(_remarkDate, 'remarkDate', DbType.text);
  }

  ScannedArticleField? _reasonCode;
  ScannedArticleField get reasonCode {
    return _reasonCode = _setField(_reasonCode, 'reasonCode', DbType.text);
  }

  ScannedArticleField? _actionCode;
  ScannedArticleField get actionCode {
    return _actionCode = _setField(_actionCode, 'actionCode', DbType.text);
  }

  ScannedArticleField? _addressee;
  ScannedArticleField get addressee {
    return _addressee = _setField(_addressee, 'addressee', DbType.text);
  }

  ScannedArticleField? _deliveredTo;
  ScannedArticleField get deliveredTo {
    return _deliveredTo = _setField(_deliveredTo, 'deliveredTo', DbType.text);
  }

  ScannedArticleField? _addresseeType;
  ScannedArticleField get addresseeType {
    return _addresseeType =
        _setField(_addresseeType, 'addresseeType', DbType.text);
  }

  ScannedArticleField? _latitude;
  ScannedArticleField get latitude {
    return _latitude = _setField(_latitude, 'latitude', DbType.text);
  }

  ScannedArticleField? _longitude;
  ScannedArticleField get longitude {
    return _longitude = _setField(_longitude, 'longitude', DbType.text);
  }

  ScannedArticleField? _isLTM;
  ScannedArticleField get isLTM {
    return _isLTM = _setField(_isLTM, 'isLTM', DbType.integer);
  }

  ScannedArticleField? _isListArticle;
  ScannedArticleField get isListArticle {
    return _isListArticle =
        _setField(_isListArticle, 'isListArticle', DbType.integer);
  }

  ScannedArticleField? _listCode;
  ScannedArticleField get listCode {
    return _listCode = _setField(_listCode, 'listCode', DbType.text);
  }

  ScannedArticleField? _customerId;
  ScannedArticleField get customerId {
    return _customerId = _setField(_customerId, 'customerId', DbType.text);
  }

  ScannedArticleField? _epds;
  ScannedArticleField get epds {
    return _epds = _setField(_epds, 'epds', DbType.integer);
  }

  ScannedArticleField? _boxID;
  ScannedArticleField get boxID {
    return _boxID = _setField(_boxID, 'boxID', DbType.text);
  }

  ScannedArticleField? _isCommunicated;
  ScannedArticleField get isCommunicated {
    return _isCommunicated =
        _setField(_isCommunicated, 'isCommunicated', DbType.integer);
  }

  ScannedArticleField? _remarkTime;
  ScannedArticleField get remarkTime {
    return _remarkTime = _setField(_remarkTime, 'remarkTime', DbType.text);
  }

  ScannedArticleField? _postman;
  ScannedArticleField get postman {
    return _postman = _setField(_postman, 'postman', DbType.text);
  }

  ScannedArticleField? _deviceID;
  ScannedArticleField get deviceID {
    return _deviceID = _setField(_deviceID, 'deviceID', DbType.text);
  }

  ScannedArticleField? _rubberStamp;
  ScannedArticleField get rubberStamp {
    return _rubberStamp = _setField(_rubberStamp, 'rubberStamp', DbType.blob);
  }

  ScannedArticleField? _signature;
  ScannedArticleField get signature {
    return _signature = _setField(_signature, 'signature', DbType.blob);
  }

  ScannedArticleField? _sync_time;
  ScannedArticleField get sync_time {
    return _sync_time = _setField(_sync_time, 'sync_time', DbType.text);
  }

  ScannedArticleField? _sofficeid;
  ScannedArticleField get sofficeid {
    return _sofficeid = _setField(_sofficeid, 'sofficeid', DbType.text);
  }

  ScannedArticleField? _dofficeid;
  ScannedArticleField get dofficeid {
    return _dofficeid = _setField(_dofficeid, 'dofficeid', DbType.text);
  }

  ScannedArticleField? _bookdate;
  ScannedArticleField get bookdate {
    return _bookdate = _setField(_bookdate, 'bookdate', DbType.datetime);
  }

  ScannedArticleField? _bookid;
  ScannedArticleField get bookid {
    return _bookid = _setField(_bookid, 'bookid', DbType.text);
  }

  ScannedArticleField? _insurance;
  ScannedArticleField get insurance {
    return _insurance = _setField(_insurance, 'insurance', DbType.text);
  }

  ScannedArticleField? _moneytocollect;
  ScannedArticleField get moneytocollect {
    return _moneytocollect =
        _setField(_moneytocollect, 'moneytocollect', DbType.integer);
  }

  ScannedArticleField? _moneycollected;
  ScannedArticleField get moneycollected {
    return _moneycollected =
        _setField(_moneycollected, 'moneycollected', DbType.integer);
  }

  ScannedArticleField? _commission;
  ScannedArticleField get commission {
    return _commission = _setField(_commission, 'commission', DbType.integer);
  }

  ScannedArticleField? _moneytodeliver;
  ScannedArticleField get moneytodeliver {
    return _moneytodeliver =
        _setField(_moneytodeliver, 'moneytodeliver', DbType.integer);
  }

  ScannedArticleField? _moneydelivered;
  ScannedArticleField get moneydelivered {
    return _moneydelivered =
        _setField(_moneydelivered, 'moneydelivered', DbType.integer);
  }

  ScannedArticleField? _windowdelivery;
  ScannedArticleField get windowdelivery {
    return _windowdelivery =
        _setField(_windowdelivery, 'windowdelivery', DbType.text);
  }

  ScannedArticleField? _totmoney;
  ScannedArticleField get totmoney {
    return _totmoney = _setField(_totmoney, 'totmoney', DbType.integer);
  }

  ScannedArticleField? _vpp;
  ScannedArticleField get vpp {
    return _vpp = _setField(_vpp, 'vpp', DbType.text);
  }

  ScannedArticleField? _redirectpin;
  ScannedArticleField get redirectpin {
    return _redirectpin =
        _setField(_redirectpin, 'redirectpin', DbType.integer);
  }

  ScannedArticleField? _modpin;
  ScannedArticleField get modpin {
    return _modpin = _setField(_modpin, 'modpin', DbType.integer);
  }

  ScannedArticleField? _sourcepin;
  ScannedArticleField get sourcepin {
    return _sourcepin = _setField(_sourcepin, 'sourcepin', DbType.integer);
  }

  ScannedArticleField? _destpin;
  ScannedArticleField get destpin {
    return _destpin = _setField(_destpin, 'destpin', DbType.integer);
  }

  ScannedArticleField? _emomessage;
  ScannedArticleField get emomessage {
    return _emomessage = _setField(_emomessage, 'emomessage', DbType.text);
  }

  ScannedArticleField? _cashreturned;
  ScannedArticleField get cashreturned {
    return _cashreturned =
        _setField(_cashreturned, 'cashreturned', DbType.integer);
  }

  ScannedArticleField? _cod;
  ScannedArticleField get cod {
    return _cod = _setField(_cod, 'cod', DbType.text);
  }

  ScannedArticleField? _receiver;
  ScannedArticleField get receiver {
    return _receiver = _setField(_receiver, 'receiver', DbType.text);
  }

  /// Deletes List<ScannedArticle> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnScannedArticle!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnScannedArticle!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'articleNumber IN (SELECT articleNumber from scannedArticle ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnScannedArticle!.updateBatch(qparams, values);
  }

  /// This method always returns [ScannedArticle] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ScannedArticle?
  @override
  Future<ScannedArticle?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnScannedArticle!.toList(qparams);
    final data = await objFuture;
    ScannedArticle? obj;
    if (data.isNotEmpty) {
      obj = ScannedArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ScannedArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ScannedArticle?
  @override
  Future<ScannedArticle> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ScannedArticle();
  }

  /// This method returns int. [ScannedArticle]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? scannedarticleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final scannedarticlesFuture = await _mnScannedArticle!.toList(qparams);
    final int count = scannedarticlesFuture[0]['CNT'] as int;
    if (scannedarticleCount != null) {
      scannedarticleCount(count);
    }
    return count;
  }

  /// This method returns List<ScannedArticle> [ScannedArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ScannedArticle>
  @override
  Future<List<ScannedArticle>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ScannedArticle> scannedarticlesData =
        await ScannedArticle.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return scannedarticlesData;
  }

  /// This method returns Json String [ScannedArticle]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ScannedArticle]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ScannedArticle]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnScannedArticle!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ScannedArticle]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `articleNumber`invoiceDate`beat`batch` FROM scannedArticle WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<articleNumber,invoiceDate,beat,batch> [ScannedArticle]
  /// <returns>List<articleNumber,invoiceDate,beat,batch>
  @override
  Future<List<ScannedArticle>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['articleNumber', 'invoiceDate', 'beat', 'batch'];
    final scannedarticleFuture = await _mnScannedArticle!.toList(qparams);
    return await ScannedArticle.fromMapList(scannedarticleFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ScannedArticle]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnScannedArticle!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ScannedArticle.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnScannedArticle!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ScannedArticleFilterBuilder

// region ScannedArticleFields
class ScannedArticleFields {
  static TableField? _fArticleNumber;
  static TableField get articleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fInvoiceDate;
  static TableField get invoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'invoiceDate', DbType.text);
  }

  static TableField? _fBeat;
  static TableField get beat {
    return _fBeat = _fBeat ?? SqlSyntax.setField(_fBeat, 'beat', DbType.text);
  }

  static TableField? _fBatch;
  static TableField get batch {
    return _fBatch =
        _fBatch ?? SqlSyntax.setField(_fBatch, 'batch', DbType.text);
  }

  static TableField? _fInvoicedDate;
  static TableField get invoicedDate {
    return _fInvoicedDate = _fInvoicedDate ??
        SqlSyntax.setField(_fInvoicedDate, 'invoicedDate', DbType.text);
  }

  static TableField? _fFacilityID;
  static TableField get facilityID {
    return _fFacilityID = _fFacilityID ??
        SqlSyntax.setField(_fFacilityID, 'facilityID', DbType.text);
  }

  static TableField? _fInvoiceTime;
  static TableField get invoiceTime {
    return _fInvoiceTime = _fInvoiceTime ??
        SqlSyntax.setField(_fInvoiceTime, 'invoiceTime', DbType.text);
  }

  static TableField? _fPostmanID;
  static TableField get postmanID {
    return _fPostmanID = _fPostmanID ??
        SqlSyntax.setField(_fPostmanID, 'postmanID', DbType.text);
  }

  static TableField? _fArticleType;
  static TableField get articleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'articleType', DbType.text);
  }

  static TableField? _fArticleStatus;
  static TableField get articleStatus {
    return _fArticleStatus = _fArticleStatus ??
        SqlSyntax.setField(_fArticleStatus, 'articleStatus', DbType.text);
  }

  static TableField? _fRemarkDate;
  static TableField get remarkDate {
    return _fRemarkDate = _fRemarkDate ??
        SqlSyntax.setField(_fRemarkDate, 'remarkDate', DbType.text);
  }

  static TableField? _fReasonCode;
  static TableField get reasonCode {
    return _fReasonCode = _fReasonCode ??
        SqlSyntax.setField(_fReasonCode, 'reasonCode', DbType.text);
  }

  static TableField? _fActionCode;
  static TableField get actionCode {
    return _fActionCode = _fActionCode ??
        SqlSyntax.setField(_fActionCode, 'actionCode', DbType.text);
  }

  static TableField? _fAddressee;
  static TableField get addressee {
    return _fAddressee = _fAddressee ??
        SqlSyntax.setField(_fAddressee, 'addressee', DbType.text);
  }

  static TableField? _fDeliveredTo;
  static TableField get deliveredTo {
    return _fDeliveredTo = _fDeliveredTo ??
        SqlSyntax.setField(_fDeliveredTo, 'deliveredTo', DbType.text);
  }

  static TableField? _fAddresseeType;
  static TableField get addresseeType {
    return _fAddresseeType = _fAddresseeType ??
        SqlSyntax.setField(_fAddresseeType, 'addresseeType', DbType.text);
  }

  static TableField? _fLatitude;
  static TableField get latitude {
    return _fLatitude =
        _fLatitude ?? SqlSyntax.setField(_fLatitude, 'latitude', DbType.text);
  }

  static TableField? _fLongitude;
  static TableField get longitude {
    return _fLongitude = _fLongitude ??
        SqlSyntax.setField(_fLongitude, 'longitude', DbType.text);
  }

  static TableField? _fIsLTM;
  static TableField get isLTM {
    return _fIsLTM =
        _fIsLTM ?? SqlSyntax.setField(_fIsLTM, 'isLTM', DbType.integer);
  }

  static TableField? _fIsListArticle;
  static TableField get isListArticle {
    return _fIsListArticle = _fIsListArticle ??
        SqlSyntax.setField(_fIsListArticle, 'isListArticle', DbType.integer);
  }

  static TableField? _fListCode;
  static TableField get listCode {
    return _fListCode =
        _fListCode ?? SqlSyntax.setField(_fListCode, 'listCode', DbType.text);
  }

  static TableField? _fCustomerId;
  static TableField get customerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'customerId', DbType.text);
  }

  static TableField? _fEpds;
  static TableField get epds {
    return _fEpds =
        _fEpds ?? SqlSyntax.setField(_fEpds, 'epds', DbType.integer);
  }

  static TableField? _fBoxID;
  static TableField get boxID {
    return _fBoxID =
        _fBoxID ?? SqlSyntax.setField(_fBoxID, 'boxID', DbType.text);
  }

  static TableField? _fIsCommunicated;
  static TableField get isCommunicated {
    return _fIsCommunicated = _fIsCommunicated ??
        SqlSyntax.setField(_fIsCommunicated, 'isCommunicated', DbType.integer);
  }

  static TableField? _fRemarkTime;
  static TableField get remarkTime {
    return _fRemarkTime = _fRemarkTime ??
        SqlSyntax.setField(_fRemarkTime, 'remarkTime', DbType.text);
  }

  static TableField? _fPostman;
  static TableField get postman {
    return _fPostman =
        _fPostman ?? SqlSyntax.setField(_fPostman, 'postman', DbType.text);
  }

  static TableField? _fDeviceID;
  static TableField get deviceID {
    return _fDeviceID =
        _fDeviceID ?? SqlSyntax.setField(_fDeviceID, 'deviceID', DbType.text);
  }

  static TableField? _fRubberStamp;
  static TableField get rubberStamp {
    return _fRubberStamp = _fRubberStamp ??
        SqlSyntax.setField(_fRubberStamp, 'rubberStamp', DbType.blob);
  }

  static TableField? _fSignature;
  static TableField get signature {
    return _fSignature = _fSignature ??
        SqlSyntax.setField(_fSignature, 'signature', DbType.blob);
  }

  static TableField? _fSync_time;
  static TableField get sync_time {
    return _fSync_time = _fSync_time ??
        SqlSyntax.setField(_fSync_time, 'sync_time', DbType.text);
  }

  static TableField? _fSofficeid;
  static TableField get sofficeid {
    return _fSofficeid = _fSofficeid ??
        SqlSyntax.setField(_fSofficeid, 'sofficeid', DbType.text);
  }

  static TableField? _fDofficeid;
  static TableField get dofficeid {
    return _fDofficeid = _fDofficeid ??
        SqlSyntax.setField(_fDofficeid, 'dofficeid', DbType.text);
  }

  static TableField? _fBookdate;
  static TableField get bookdate {
    return _fBookdate = _fBookdate ??
        SqlSyntax.setField(_fBookdate, 'bookdate', DbType.datetime);
  }

  static TableField? _fBookid;
  static TableField get bookid {
    return _fBookid =
        _fBookid ?? SqlSyntax.setField(_fBookid, 'bookid', DbType.text);
  }

  static TableField? _fInsurance;
  static TableField get insurance {
    return _fInsurance = _fInsurance ??
        SqlSyntax.setField(_fInsurance, 'insurance', DbType.text);
  }

  static TableField? _fMoneytocollect;
  static TableField get moneytocollect {
    return _fMoneytocollect = _fMoneytocollect ??
        SqlSyntax.setField(_fMoneytocollect, 'moneytocollect', DbType.integer);
  }

  static TableField? _fMoneycollected;
  static TableField get moneycollected {
    return _fMoneycollected = _fMoneycollected ??
        SqlSyntax.setField(_fMoneycollected, 'moneycollected', DbType.integer);
  }

  static TableField? _fCommission;
  static TableField get commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'commission', DbType.integer);
  }

  static TableField? _fMoneytodeliver;
  static TableField get moneytodeliver {
    return _fMoneytodeliver = _fMoneytodeliver ??
        SqlSyntax.setField(_fMoneytodeliver, 'moneytodeliver', DbType.integer);
  }

  static TableField? _fMoneydelivered;
  static TableField get moneydelivered {
    return _fMoneydelivered = _fMoneydelivered ??
        SqlSyntax.setField(_fMoneydelivered, 'moneydelivered', DbType.integer);
  }

  static TableField? _fWindowdelivery;
  static TableField get windowdelivery {
    return _fWindowdelivery = _fWindowdelivery ??
        SqlSyntax.setField(_fWindowdelivery, 'windowdelivery', DbType.text);
  }

  static TableField? _fTotmoney;
  static TableField get totmoney {
    return _fTotmoney = _fTotmoney ??
        SqlSyntax.setField(_fTotmoney, 'totmoney', DbType.integer);
  }

  static TableField? _fVpp;
  static TableField get vpp {
    return _fVpp = _fVpp ?? SqlSyntax.setField(_fVpp, 'vpp', DbType.text);
  }

  static TableField? _fRedirectpin;
  static TableField get redirectpin {
    return _fRedirectpin = _fRedirectpin ??
        SqlSyntax.setField(_fRedirectpin, 'redirectpin', DbType.integer);
  }

  static TableField? _fModpin;
  static TableField get modpin {
    return _fModpin =
        _fModpin ?? SqlSyntax.setField(_fModpin, 'modpin', DbType.integer);
  }

  static TableField? _fSourcepin;
  static TableField get sourcepin {
    return _fSourcepin = _fSourcepin ??
        SqlSyntax.setField(_fSourcepin, 'sourcepin', DbType.integer);
  }

  static TableField? _fDestpin;
  static TableField get destpin {
    return _fDestpin =
        _fDestpin ?? SqlSyntax.setField(_fDestpin, 'destpin', DbType.integer);
  }

  static TableField? _fEmomessage;
  static TableField get emomessage {
    return _fEmomessage = _fEmomessage ??
        SqlSyntax.setField(_fEmomessage, 'emomessage', DbType.text);
  }

  static TableField? _fCashreturned;
  static TableField get cashreturned {
    return _fCashreturned = _fCashreturned ??
        SqlSyntax.setField(_fCashreturned, 'cashreturned', DbType.integer);
  }

  static TableField? _fCod;
  static TableField get cod {
    return _fCod = _fCod ?? SqlSyntax.setField(_fCod, 'cod', DbType.text);
  }

  static TableField? _fReceiver;
  static TableField get receiver {
    return _fReceiver =
        _fReceiver ?? SqlSyntax.setField(_fReceiver, 'receiver', DbType.text);
  }
}
// endregion ScannedArticleFields

//region ScannedArticleManager
class ScannedArticleManager extends SqfEntityProvider {
  ScannedArticleManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'scannedArticle';
  static const List<String> _primaryKeyList = [
    'articleNumber',
    'invoiceDate',
    'beat',
    'batch'
  ];
  static const String _whereStr =
      'articleNumber=? AND invoiceDate=? AND beat=? AND batch=?';
}

//endregion ScannedArticleManager
// region ArtRet
class ArtRet extends TableBase {
  ArtRet(
      {this.articleNumber,
      this.addressee,
      this.invoiceDate,
      this.isListArticle}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ArtRet.withFields(this.articleNumber, this.addressee, this.invoiceDate,
      this.isListArticle) {
    _setDefaultValues();
  }
  ArtRet.withId(this.articleNumber, this.addressee, this.invoiceDate,
      this.isListArticle) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ArtRet.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    articleNumber = o['articleNumber'].toString();
    if (o['addressee'] != null) {
      addressee = o['addressee'].toString();
    }
    if (o['invoiceDate'] != null) {
      invoiceDate = o['invoiceDate'].toString();
    }
    if (o['isListArticle'] != null) {
      isListArticle = int.tryParse(o['isListArticle'].toString());
    }

    isSaved = true;
  }
  // FIELDS (ArtRet)
  String? articleNumber;
  String? addressee;
  String? invoiceDate;
  int? isListArticle;
  bool? isSaved;
  // end FIELDS (ArtRet)

  static const bool _softDeleteActivated = false;
  ArtRetManager? __mnArtRet;

  ArtRetManager get _mnArtRet {
    return __mnArtRet = __mnArtRet ?? ArtRetManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }

    return map;
  }

  /// This method returns Json String [ArtRet]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ArtRet]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [articleNumber, addressee, invoiceDate, isListArticle];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [articleNumber, addressee, invoiceDate, isListArticle];
  }

  static Future<List<ArtRet>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArtRet.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ArtRet>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ArtRet>[];
    try {
      objList = list
          .map((artret) => ArtRet.fromMap(artret as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArtRet.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ArtRet>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ArtRet> objList = <ArtRet>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ArtRet.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ArtRet by ID if exist, otherwise returns null
  /// Primary Keys: String? articleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ArtRet] if exist, otherwise returns null
  Future<ArtRet?> getById(String? articleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (articleNumber == null) {
      return null;
    }
    ArtRet? obj;
    final data = await _mnArtRet.getById([articleNumber]);
    if (data.length != 0) {
      obj = ArtRet.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ArtRet) object. If the Primary Key (articleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same articleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnArtRet.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO artRet (articleNumber, addressee, invoiceDate, isListArticle)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ArtRet> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ArtRet> artrets,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in artrets) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArtRet.rawInsert(
          'INSERT OR REPLACE INTO artRet (articleNumber, addressee, invoiceDate, isListArticle)  VALUES (?,?,?,?)',
          [articleNumber, addressee, invoiceDate, isListArticle],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArtRet articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ArtRet articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArtRet Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArtRet.rawInsert(
          'INSERT OR IGNORE INTO artRet (articleNumber, addressee, invoiceDate, isListArticle)  VALUES (?,?,?,?)',
          [articleNumber, addressee, invoiceDate, isListArticle],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArtRet articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ArtRet articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArtRet Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ArtRet

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ArtRet invoked (articleNumber=$articleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnArtRet.delete(QueryParams(
          whereString: 'articleNumber=?', whereArguments: [articleNumber]));
    } else {
      return _mnArtRet.updateBatch(
          QueryParams(
              whereString: 'articleNumber=?', whereArguments: [articleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ArtRet] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ArtRetFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArtRetFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArtRetFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArtRetFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      articleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion artret

// region ArtRetField
class ArtRetField extends FilterBase {
  ArtRetField(ArtRetFilterBuilder artretFB) : super(artretFB);

  @override
  ArtRetFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder isNull() {
    return super.isNull() as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArtRetFilterBuilder;
  }

  @override
  ArtRetField get not {
    return super.not as ArtRetField;
  }
}
// endregion ArtRetField

// region ArtRetFilterBuilder
class ArtRetFilterBuilder extends ConjunctionBase {
  ArtRetFilterBuilder(ArtRet obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArtRet = obj._mnArtRet;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArtRetManager? _mnArtRet;

  /// put the sql keyword 'AND'
  @override
  ArtRetFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArtRetFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArtRetFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArtRetFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArtRetFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArtRetFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArtRetFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArtRetFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArtRetFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArtRetFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArtRetFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArtRetField _setField(ArtRetField? field, String colName, DbType dbtype) {
    return ArtRetField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArtRetField? _articleNumber;
  ArtRetField get articleNumber {
    return _articleNumber =
        _setField(_articleNumber, 'articleNumber', DbType.integer);
  }

  ArtRetField? _addressee;
  ArtRetField get addressee {
    return _addressee = _setField(_addressee, 'addressee', DbType.text);
  }

  ArtRetField? _invoiceDate;
  ArtRetField get invoiceDate {
    return _invoiceDate = _setField(_invoiceDate, 'invoiceDate', DbType.text);
  }

  ArtRetField? _isListArticle;
  ArtRetField get isListArticle {
    return _isListArticle =
        _setField(_isListArticle, 'isListArticle', DbType.integer);
  }

  /// Deletes List<ArtRet> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArtRet!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArtRet!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'articleNumber IN (SELECT articleNumber from artRet ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArtRet!.updateBatch(qparams, values);
  }

  /// This method always returns [ArtRet] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArtRet?
  @override
  Future<ArtRet?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArtRet!.toList(qparams);
    final data = await objFuture;
    ArtRet? obj;
    if (data.isNotEmpty) {
      obj = ArtRet.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ArtRet]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArtRet?
  @override
  Future<ArtRet> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ArtRet();
  }

  /// This method returns int. [ArtRet]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? artretCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final artretsFuture = await _mnArtRet!.toList(qparams);
    final int count = artretsFuture[0]['CNT'] as int;
    if (artretCount != null) {
      artretCount(count);
    }
    return count;
  }

  /// This method returns List<ArtRet> [ArtRet]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ArtRet>
  @override
  Future<List<ArtRet>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ArtRet> artretsData = await ArtRet.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return artretsData;
  }

  /// This method returns Json String [ArtRet]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ArtRet]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ArtRet]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArtRet!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ArtRet]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `articleNumber` FROM artRet WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> articleNumberData = <String>[];
    qparams.selectColumns = ['articleNumber'];
    final articleNumberFuture = await _mnArtRet!.toList(qparams);

    final int count = articleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      articleNumberData.add(articleNumberFuture[i]['articleNumber'] as String);
    }
    return articleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ArtRet]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArtRet!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ArtRet.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArtRet!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArtRetFilterBuilder

// region ArtRetFields
class ArtRetFields {
  static TableField? _fArticleNumber;
  static TableField get articleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fAddressee;
  static TableField get addressee {
    return _fAddressee = _fAddressee ??
        SqlSyntax.setField(_fAddressee, 'addressee', DbType.text);
  }

  static TableField? _fInvoiceDate;
  static TableField get invoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'invoiceDate', DbType.text);
  }

  static TableField? _fIsListArticle;
  static TableField get isListArticle {
    return _fIsListArticle = _fIsListArticle ??
        SqlSyntax.setField(_fIsListArticle, 'isListArticle', DbType.integer);
  }
}
// endregion ArtRetFields

//region ArtRetManager
class ArtRetManager extends SqfEntityProvider {
  ArtRetManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'artRet';
  static const List<String> _primaryKeyList = ['articleNumber'];
  static const String _whereStr = 'articleNumber=?';
}

//endregion ArtRetManager
// region ArticleReturn
class ArticleReturn extends TableBase {
  ArticleReturn(
      {this.articleNumber,
      this.addressee,
      this.invoiceDate,
      this.isListArticle,
      this.articleType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ArticleReturn.withFields(this.articleNumber, this.addressee, this.invoiceDate,
      this.isListArticle, this.articleType) {
    _setDefaultValues();
  }
  ArticleReturn.withId(this.articleNumber, this.addressee, this.invoiceDate,
      this.isListArticle, this.articleType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ArticleReturn.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    articleNumber = o['articleNumber'].toString();
    if (o['addressee'] != null) {
      addressee = o['addressee'].toString();
    }
    if (o['invoiceDate'] != null) {
      invoiceDate = o['invoiceDate'].toString();
    }
    if (o['isListArticle'] != null) {
      isListArticle = int.tryParse(o['isListArticle'].toString());
    }
    if (o['articleType'] != null) {
      articleType = o['articleType'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ArticleReturn)
  String? articleNumber;
  String? addressee;
  String? invoiceDate;
  int? isListArticle;
  String? articleType;
  bool? isSaved;
  // end FIELDS (ArticleReturn)

  static const bool _softDeleteActivated = false;
  ArticleReturnManager? __mnArticleReturn;

  ArticleReturnManager get _mnArticleReturn {
    return __mnArticleReturn = __mnArticleReturn ?? ArticleReturnManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }

    return map;
  }

  /// This method returns Json String [ArticleReturn]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ArticleReturn]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [articleNumber, addressee, invoiceDate, isListArticle, articleType];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [articleNumber, addressee, invoiceDate, isListArticle, articleType];
  }

  static Future<List<ArticleReturn>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArticleReturn.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ArticleReturn>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ArticleReturn>[];
    try {
      objList = list
          .map((articlereturn) =>
              ArticleReturn.fromMap(articlereturn as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArticleReturn.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ArticleReturn>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ArticleReturn> objList = <ArticleReturn>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ArticleReturn.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ArticleReturn by ID if exist, otherwise returns null
  /// Primary Keys: String? articleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ArticleReturn] if exist, otherwise returns null
  Future<ArticleReturn?> getById(String? articleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (articleNumber == null) {
      return null;
    }
    ArticleReturn? obj;
    final data = await _mnArticleReturn.getById([articleNumber]);
    if (data.length != 0) {
      obj = ArticleReturn.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ArticleReturn) object. If the Primary Key (articleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same articleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnArticleReturn.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO articleReturn (articleNumber, addressee, invoiceDate, isListArticle, articleType)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ArticleReturn> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ArticleReturn> articlereturns,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in articlereturns) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArticleReturn.rawInsert(
          'INSERT OR REPLACE INTO articleReturn (articleNumber, addressee, invoiceDate, isListArticle, articleType)  VALUES (?,?,?,?,?)',
          [articleNumber, addressee, invoiceDate, isListArticle, articleType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArticleReturn articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ArticleReturn articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArticleReturn Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArticleReturn.rawInsert(
          'INSERT OR IGNORE INTO articleReturn (articleNumber, addressee, invoiceDate, isListArticle, articleType)  VALUES (?,?,?,?,?)',
          [articleNumber, addressee, invoiceDate, isListArticle, articleType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArticleReturn articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ArticleReturn articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArticleReturn Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ArticleReturn

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ArticleReturn invoked (articleNumber=$articleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnArticleReturn.delete(QueryParams(
          whereString: 'articleNumber=?', whereArguments: [articleNumber]));
    } else {
      return _mnArticleReturn.updateBatch(
          QueryParams(
              whereString: 'articleNumber=?', whereArguments: [articleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ArticleReturn] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ArticleReturnFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArticleReturnFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArticleReturnFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArticleReturnFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      articleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion articlereturn

// region ArticleReturnField
class ArticleReturnField extends FilterBase {
  ArticleReturnField(ArticleReturnFilterBuilder articlereturnFB)
      : super(articlereturnFB);

  @override
  ArticleReturnFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder isNull() {
    return super.isNull() as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArticleReturnFilterBuilder;
  }

  @override
  ArticleReturnField get not {
    return super.not as ArticleReturnField;
  }
}
// endregion ArticleReturnField

// region ArticleReturnFilterBuilder
class ArticleReturnFilterBuilder extends ConjunctionBase {
  ArticleReturnFilterBuilder(ArticleReturn obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArticleReturn = obj._mnArticleReturn;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArticleReturnManager? _mnArticleReturn;

  /// put the sql keyword 'AND'
  @override
  ArticleReturnFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArticleReturnFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArticleReturnFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArticleReturnFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArticleReturnFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArticleReturnFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArticleReturnFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArticleReturnFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArticleReturnFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArticleReturnFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArticleReturnFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArticleReturnField _setField(
      ArticleReturnField? field, String colName, DbType dbtype) {
    return ArticleReturnField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArticleReturnField? _articleNumber;
  ArticleReturnField get articleNumber {
    return _articleNumber =
        _setField(_articleNumber, 'articleNumber', DbType.integer);
  }

  ArticleReturnField? _addressee;
  ArticleReturnField get addressee {
    return _addressee = _setField(_addressee, 'addressee', DbType.text);
  }

  ArticleReturnField? _invoiceDate;
  ArticleReturnField get invoiceDate {
    return _invoiceDate = _setField(_invoiceDate, 'invoiceDate', DbType.text);
  }

  ArticleReturnField? _isListArticle;
  ArticleReturnField get isListArticle {
    return _isListArticle =
        _setField(_isListArticle, 'isListArticle', DbType.integer);
  }

  ArticleReturnField? _articleType;
  ArticleReturnField get articleType {
    return _articleType = _setField(_articleType, 'articleType', DbType.text);
  }

  /// Deletes List<ArticleReturn> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArticleReturn!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArticleReturn!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'articleNumber IN (SELECT articleNumber from articleReturn ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArticleReturn!.updateBatch(qparams, values);
  }

  /// This method always returns [ArticleReturn] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArticleReturn?
  @override
  Future<ArticleReturn?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArticleReturn!.toList(qparams);
    final data = await objFuture;
    ArticleReturn? obj;
    if (data.isNotEmpty) {
      obj = ArticleReturn.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ArticleReturn]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArticleReturn?
  @override
  Future<ArticleReturn> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ArticleReturn();
  }

  /// This method returns int. [ArticleReturn]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? articlereturnCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final articlereturnsFuture = await _mnArticleReturn!.toList(qparams);
    final int count = articlereturnsFuture[0]['CNT'] as int;
    if (articlereturnCount != null) {
      articlereturnCount(count);
    }
    return count;
  }

  /// This method returns List<ArticleReturn> [ArticleReturn]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ArticleReturn>
  @override
  Future<List<ArticleReturn>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ArticleReturn> articlereturnsData =
        await ArticleReturn.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return articlereturnsData;
  }

  /// This method returns Json String [ArticleReturn]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ArticleReturn]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ArticleReturn]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArticleReturn!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ArticleReturn]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `articleNumber` FROM articleReturn WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> articleNumberData = <String>[];
    qparams.selectColumns = ['articleNumber'];
    final articleNumberFuture = await _mnArticleReturn!.toList(qparams);

    final int count = articleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      articleNumberData.add(articleNumberFuture[i]['articleNumber'] as String);
    }
    return articleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ArticleReturn]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArticleReturn!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ArticleReturn.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArticleReturn!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArticleReturnFilterBuilder

// region ArticleReturnFields
class ArticleReturnFields {
  static TableField? _fArticleNumber;
  static TableField get articleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fAddressee;
  static TableField get addressee {
    return _fAddressee = _fAddressee ??
        SqlSyntax.setField(_fAddressee, 'addressee', DbType.text);
  }

  static TableField? _fInvoiceDate;
  static TableField get invoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'invoiceDate', DbType.text);
  }

  static TableField? _fIsListArticle;
  static TableField get isListArticle {
    return _fIsListArticle = _fIsListArticle ??
        SqlSyntax.setField(_fIsListArticle, 'isListArticle', DbType.integer);
  }

  static TableField? _fArticleType;
  static TableField get articleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'articleType', DbType.text);
  }
}
// endregion ArticleReturnFields

//region ArticleReturnManager
class ArticleReturnManager extends SqfEntityProvider {
  ArticleReturnManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'articleReturn';
  static const List<String> _primaryKeyList = ['articleNumber'];
  static const String _whereStr = 'articleNumber=?';
}

//endregion ArticleReturnManager
// region TakeReturnArticle
class TakeReturnArticle extends TableBase {
  TakeReturnArticle({this.articleNumber, this.addressee, this.articleType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TakeReturnArticle.withFields(
      this.articleNumber, this.addressee, this.articleType) {
    _setDefaultValues();
  }
  TakeReturnArticle.withId(
      this.articleNumber, this.addressee, this.articleType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TakeReturnArticle.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    articleNumber = o['articleNumber'].toString();
    if (o['addressee'] != null) {
      addressee = o['addressee'].toString();
    }
    if (o['articleType'] != null) {
      articleType = o['articleType'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TakeReturnArticle)
  String? articleNumber;
  String? addressee;
  String? articleType;
  bool? isSaved;
  // end FIELDS (TakeReturnArticle)

  static const bool _softDeleteActivated = false;
  TakeReturnArticleManager? __mnTakeReturnArticle;

  TakeReturnArticleManager get _mnTakeReturnArticle {
    return __mnTakeReturnArticle =
        __mnTakeReturnArticle ?? TakeReturnArticleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }

    return map;
  }

  /// This method returns Json String [TakeReturnArticle]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TakeReturnArticle]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [articleNumber, addressee, articleType];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [articleNumber, addressee, articleType];
  }

  static Future<List<TakeReturnArticle>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TakeReturnArticle.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TakeReturnArticle>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TakeReturnArticle>[];
    try {
      objList = list
          .map((takereturnarticle) => TakeReturnArticle.fromMap(
              takereturnarticle as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TakeReturnArticle.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TakeReturnArticle>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TakeReturnArticle> objList = <TakeReturnArticle>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TakeReturnArticle.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TakeReturnArticle by ID if exist, otherwise returns null
  /// Primary Keys: String? articleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TakeReturnArticle] if exist, otherwise returns null
  Future<TakeReturnArticle?> getById(String? articleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (articleNumber == null) {
      return null;
    }
    TakeReturnArticle? obj;
    final data = await _mnTakeReturnArticle.getById([articleNumber]);
    if (data.length != 0) {
      obj = TakeReturnArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TakeReturnArticle) object. If the Primary Key (articleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same articleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTakeReturnArticle.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO takeReturnArticle (articleNumber, addressee, articleType)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TakeReturnArticle> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TakeReturnArticle> takereturnarticles,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in takereturnarticles) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTakeReturnArticle.rawInsert(
          'INSERT OR REPLACE INTO takeReturnArticle (articleNumber, addressee, articleType)  VALUES (?,?,?)',
          [articleNumber, addressee, articleType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TakeReturnArticle articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TakeReturnArticle articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TakeReturnArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTakeReturnArticle.rawInsert(
          'INSERT OR IGNORE INTO takeReturnArticle (articleNumber, addressee, articleType)  VALUES (?,?,?)',
          [articleNumber, addressee, articleType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TakeReturnArticle articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TakeReturnArticle articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TakeReturnArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes TakeReturnArticle

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete TakeReturnArticle invoked (articleNumber=$articleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTakeReturnArticle.delete(QueryParams(
          whereString: 'articleNumber=?', whereArguments: [articleNumber]));
    } else {
      return _mnTakeReturnArticle.updateBatch(
          QueryParams(
              whereString: 'articleNumber=?', whereArguments: [articleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TakeReturnArticle] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TakeReturnArticleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TakeReturnArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TakeReturnArticleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TakeReturnArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      articleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion takereturnarticle

// region TakeReturnArticleField
class TakeReturnArticleField extends FilterBase {
  TakeReturnArticleField(TakeReturnArticleFilterBuilder takereturnarticleFB)
      : super(takereturnarticleFB);

  @override
  TakeReturnArticleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder isNull() {
    return super.isNull() as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TakeReturnArticleFilterBuilder;
  }

  @override
  TakeReturnArticleField get not {
    return super.not as TakeReturnArticleField;
  }
}
// endregion TakeReturnArticleField

// region TakeReturnArticleFilterBuilder
class TakeReturnArticleFilterBuilder extends ConjunctionBase {
  TakeReturnArticleFilterBuilder(TakeReturnArticle obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTakeReturnArticle = obj._mnTakeReturnArticle;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TakeReturnArticleManager? _mnTakeReturnArticle;

  /// put the sql keyword 'AND'
  @override
  TakeReturnArticleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TakeReturnArticleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TakeReturnArticleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TakeReturnArticleFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TakeReturnArticleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TakeReturnArticleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TakeReturnArticleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TakeReturnArticleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TakeReturnArticleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TakeReturnArticleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TakeReturnArticleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TakeReturnArticleField _setField(
      TakeReturnArticleField? field, String colName, DbType dbtype) {
    return TakeReturnArticleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TakeReturnArticleField? _articleNumber;
  TakeReturnArticleField get articleNumber {
    return _articleNumber =
        _setField(_articleNumber, 'articleNumber', DbType.integer);
  }

  TakeReturnArticleField? _addressee;
  TakeReturnArticleField get addressee {
    return _addressee = _setField(_addressee, 'addressee', DbType.text);
  }

  TakeReturnArticleField? _articleType;
  TakeReturnArticleField get articleType {
    return _articleType = _setField(_articleType, 'articleType', DbType.text);
  }

  /// Deletes List<TakeReturnArticle> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTakeReturnArticle!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTakeReturnArticle!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'articleNumber IN (SELECT articleNumber from takeReturnArticle ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTakeReturnArticle!.updateBatch(qparams, values);
  }

  /// This method always returns [TakeReturnArticle] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TakeReturnArticle?
  @override
  Future<TakeReturnArticle?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTakeReturnArticle!.toList(qparams);
    final data = await objFuture;
    TakeReturnArticle? obj;
    if (data.isNotEmpty) {
      obj = TakeReturnArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TakeReturnArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TakeReturnArticle?
  @override
  Future<TakeReturnArticle> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TakeReturnArticle();
  }

  /// This method returns int. [TakeReturnArticle]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? takereturnarticleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final takereturnarticlesFuture =
        await _mnTakeReturnArticle!.toList(qparams);
    final int count = takereturnarticlesFuture[0]['CNT'] as int;
    if (takereturnarticleCount != null) {
      takereturnarticleCount(count);
    }
    return count;
  }

  /// This method returns List<TakeReturnArticle> [TakeReturnArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TakeReturnArticle>
  @override
  Future<List<TakeReturnArticle>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TakeReturnArticle> takereturnarticlesData =
        await TakeReturnArticle.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return takereturnarticlesData;
  }

  /// This method returns Json String [TakeReturnArticle]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TakeReturnArticle]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TakeReturnArticle]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTakeReturnArticle!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TakeReturnArticle]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `articleNumber` FROM takeReturnArticle WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> articleNumberData = <String>[];
    qparams.selectColumns = ['articleNumber'];
    final articleNumberFuture = await _mnTakeReturnArticle!.toList(qparams);

    final int count = articleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      articleNumberData.add(articleNumberFuture[i]['articleNumber'] as String);
    }
    return articleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TakeReturnArticle]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTakeReturnArticle!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TakeReturnArticle.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTakeReturnArticle!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TakeReturnArticleFilterBuilder

// region TakeReturnArticleFields
class TakeReturnArticleFields {
  static TableField? _fArticleNumber;
  static TableField get articleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fAddressee;
  static TableField get addressee {
    return _fAddressee = _fAddressee ??
        SqlSyntax.setField(_fAddressee, 'addressee', DbType.text);
  }

  static TableField? _fArticleType;
  static TableField get articleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'articleType', DbType.text);
  }
}
// endregion TakeReturnArticleFields

//region TakeReturnArticleManager
class TakeReturnArticleManager extends SqfEntityProvider {
  TakeReturnArticleManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'takeReturnArticle';
  static const List<String> _primaryKeyList = ['articleNumber'];
  static const String _whereStr = 'articleNumber=?';
}

//endregion TakeReturnArticleManager
// region TakeArticleReturn
class TakeArticleReturn extends TableBase {
  TakeArticleReturn(
      {this.articleNumber,
      this.addressee,
      this.invoiceDate,
      this.remarkDate,
      this.isListArticle,
      this.articleType,
      this.articleStatus}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TakeArticleReturn.withFields(
      this.articleNumber,
      this.addressee,
      this.invoiceDate,
      this.remarkDate,
      this.isListArticle,
      this.articleType,
      this.articleStatus) {
    _setDefaultValues();
  }
  TakeArticleReturn.withId(
      this.articleNumber,
      this.addressee,
      this.invoiceDate,
      this.remarkDate,
      this.isListArticle,
      this.articleType,
      this.articleStatus) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TakeArticleReturn.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    articleNumber = o['articleNumber'].toString();
    if (o['addressee'] != null) {
      addressee = o['addressee'].toString();
    }
    if (o['invoiceDate'] != null) {
      invoiceDate = o['invoiceDate'].toString();
    }
    if (o['remarkDate'] != null) {
      remarkDate = o['remarkDate'].toString();
    }
    if (o['isListArticle'] != null) {
      isListArticle = int.tryParse(o['isListArticle'].toString());
    }
    if (o['articleType'] != null) {
      articleType = o['articleType'].toString();
    }
    if (o['articleStatus'] != null) {
      articleStatus = o['articleStatus'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TakeArticleReturn)
  String? articleNumber;
  String? addressee;
  String? invoiceDate;
  String? remarkDate;
  int? isListArticle;
  String? articleType;
  String? articleStatus;
  bool? isSaved;
  // end FIELDS (TakeArticleReturn)

  static const bool _softDeleteActivated = false;
  TakeArticleReturnManager? __mnTakeArticleReturn;

  TakeArticleReturnManager get _mnTakeArticleReturn {
    return __mnTakeArticleReturn =
        __mnTakeArticleReturn ?? TakeArticleReturnManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (remarkDate != null || !forView) {
      map['remarkDate'] = remarkDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }
    if (articleStatus != null || !forView) {
      map['articleStatus'] = articleStatus;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['articleNumber'] = articleNumber;
    if (addressee != null || !forView) {
      map['addressee'] = addressee;
    }
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (remarkDate != null || !forView) {
      map['remarkDate'] = remarkDate;
    }
    if (isListArticle != null || !forView) {
      map['isListArticle'] = isListArticle;
    }
    if (articleType != null || !forView) {
      map['articleType'] = articleType;
    }
    if (articleStatus != null || !forView) {
      map['articleStatus'] = articleStatus;
    }

    return map;
  }

  /// This method returns Json String [TakeArticleReturn]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TakeArticleReturn]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      articleNumber,
      addressee,
      invoiceDate,
      remarkDate,
      isListArticle,
      articleType,
      articleStatus
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      articleNumber,
      addressee,
      invoiceDate,
      remarkDate,
      isListArticle,
      articleType,
      articleStatus
    ];
  }

  static Future<List<TakeArticleReturn>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TakeArticleReturn.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TakeArticleReturn>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TakeArticleReturn>[];
    try {
      objList = list
          .map((takearticlereturn) => TakeArticleReturn.fromMap(
              takearticlereturn as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TakeArticleReturn.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TakeArticleReturn>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TakeArticleReturn> objList = <TakeArticleReturn>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TakeArticleReturn.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TakeArticleReturn by ID if exist, otherwise returns null
  /// Primary Keys: String? articleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TakeArticleReturn] if exist, otherwise returns null
  Future<TakeArticleReturn?> getById(String? articleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (articleNumber == null) {
      return null;
    }
    TakeArticleReturn? obj;
    final data = await _mnTakeArticleReturn.getById([articleNumber]);
    if (data.length != 0) {
      obj = TakeArticleReturn.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TakeArticleReturn) object. If the Primary Key (articleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same articleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTakeArticleReturn.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO takeArticleReturn (articleNumber, addressee, invoiceDate, remarkDate, isListArticle, articleType, articleStatus)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TakeArticleReturn> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TakeArticleReturn> takearticlereturns,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in takearticlereturns) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTakeArticleReturn.rawInsert(
          'INSERT OR REPLACE INTO takeArticleReturn (articleNumber, addressee, invoiceDate, remarkDate, isListArticle, articleType, articleStatus)  VALUES (?,?,?,?,?,?,?)',
          [
            articleNumber,
            addressee,
            invoiceDate,
            remarkDate,
            isListArticle,
            articleType,
            articleStatus
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TakeArticleReturn articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TakeArticleReturn articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TakeArticleReturn Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTakeArticleReturn.rawInsert(
          'INSERT OR IGNORE INTO takeArticleReturn (articleNumber, addressee, invoiceDate, remarkDate, isListArticle, articleType, articleStatus)  VALUES (?,?,?,?,?,?,?)',
          [
            articleNumber,
            addressee,
            invoiceDate,
            remarkDate,
            isListArticle,
            articleType,
            articleStatus
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TakeArticleReturn articleNumber=$articleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TakeArticleReturn articleNumber=$articleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TakeArticleReturn Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes TakeArticleReturn

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete TakeArticleReturn invoked (articleNumber=$articleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTakeArticleReturn.delete(QueryParams(
          whereString: 'articleNumber=?', whereArguments: [articleNumber]));
    } else {
      return _mnTakeArticleReturn.updateBatch(
          QueryParams(
              whereString: 'articleNumber=?', whereArguments: [articleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TakeArticleReturn] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TakeArticleReturnFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TakeArticleReturnFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TakeArticleReturnFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TakeArticleReturnFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      articleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion takearticlereturn

// region TakeArticleReturnField
class TakeArticleReturnField extends FilterBase {
  TakeArticleReturnField(TakeArticleReturnFilterBuilder takearticlereturnFB)
      : super(takearticlereturnFB);

  @override
  TakeArticleReturnFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder isNull() {
    return super.isNull() as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TakeArticleReturnFilterBuilder;
  }

  @override
  TakeArticleReturnField get not {
    return super.not as TakeArticleReturnField;
  }
}
// endregion TakeArticleReturnField

// region TakeArticleReturnFilterBuilder
class TakeArticleReturnFilterBuilder extends ConjunctionBase {
  TakeArticleReturnFilterBuilder(TakeArticleReturn obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTakeArticleReturn = obj._mnTakeArticleReturn;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TakeArticleReturnManager? _mnTakeArticleReturn;

  /// put the sql keyword 'AND'
  @override
  TakeArticleReturnFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TakeArticleReturnFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TakeArticleReturnFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TakeArticleReturnFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TakeArticleReturnFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TakeArticleReturnFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TakeArticleReturnFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TakeArticleReturnFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TakeArticleReturnFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TakeArticleReturnFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TakeArticleReturnFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TakeArticleReturnField _setField(
      TakeArticleReturnField? field, String colName, DbType dbtype) {
    return TakeArticleReturnField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TakeArticleReturnField? _articleNumber;
  TakeArticleReturnField get articleNumber {
    return _articleNumber =
        _setField(_articleNumber, 'articleNumber', DbType.integer);
  }

  TakeArticleReturnField? _addressee;
  TakeArticleReturnField get addressee {
    return _addressee = _setField(_addressee, 'addressee', DbType.text);
  }

  TakeArticleReturnField? _invoiceDate;
  TakeArticleReturnField get invoiceDate {
    return _invoiceDate = _setField(_invoiceDate, 'invoiceDate', DbType.text);
  }

  TakeArticleReturnField? _remarkDate;
  TakeArticleReturnField get remarkDate {
    return _remarkDate = _setField(_remarkDate, 'remarkDate', DbType.text);
  }

  TakeArticleReturnField? _isListArticle;
  TakeArticleReturnField get isListArticle {
    return _isListArticle =
        _setField(_isListArticle, 'isListArticle', DbType.integer);
  }

  TakeArticleReturnField? _articleType;
  TakeArticleReturnField get articleType {
    return _articleType = _setField(_articleType, 'articleType', DbType.text);
  }

  TakeArticleReturnField? _articleStatus;
  TakeArticleReturnField get articleStatus {
    return _articleStatus =
        _setField(_articleStatus, 'articleStatus', DbType.text);
  }

  /// Deletes List<TakeArticleReturn> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTakeArticleReturn!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTakeArticleReturn!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'articleNumber IN (SELECT articleNumber from takeArticleReturn ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTakeArticleReturn!.updateBatch(qparams, values);
  }

  /// This method always returns [TakeArticleReturn] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TakeArticleReturn?
  @override
  Future<TakeArticleReturn?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTakeArticleReturn!.toList(qparams);
    final data = await objFuture;
    TakeArticleReturn? obj;
    if (data.isNotEmpty) {
      obj = TakeArticleReturn.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TakeArticleReturn]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TakeArticleReturn?
  @override
  Future<TakeArticleReturn> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TakeArticleReturn();
  }

  /// This method returns int. [TakeArticleReturn]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? takearticlereturnCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final takearticlereturnsFuture =
        await _mnTakeArticleReturn!.toList(qparams);
    final int count = takearticlereturnsFuture[0]['CNT'] as int;
    if (takearticlereturnCount != null) {
      takearticlereturnCount(count);
    }
    return count;
  }

  /// This method returns List<TakeArticleReturn> [TakeArticleReturn]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TakeArticleReturn>
  @override
  Future<List<TakeArticleReturn>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TakeArticleReturn> takearticlereturnsData =
        await TakeArticleReturn.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return takearticlereturnsData;
  }

  /// This method returns Json String [TakeArticleReturn]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TakeArticleReturn]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TakeArticleReturn]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTakeArticleReturn!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TakeArticleReturn]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `articleNumber` FROM takeArticleReturn WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> articleNumberData = <String>[];
    qparams.selectColumns = ['articleNumber'];
    final articleNumberFuture = await _mnTakeArticleReturn!.toList(qparams);

    final int count = articleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      articleNumberData.add(articleNumberFuture[i]['articleNumber'] as String);
    }
    return articleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TakeArticleReturn]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTakeArticleReturn!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TakeArticleReturn.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTakeArticleReturn!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TakeArticleReturnFilterBuilder

// region TakeArticleReturnFields
class TakeArticleReturnFields {
  static TableField? _fArticleNumber;
  static TableField get articleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fAddressee;
  static TableField get addressee {
    return _fAddressee = _fAddressee ??
        SqlSyntax.setField(_fAddressee, 'addressee', DbType.text);
  }

  static TableField? _fInvoiceDate;
  static TableField get invoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'invoiceDate', DbType.text);
  }

  static TableField? _fRemarkDate;
  static TableField get remarkDate {
    return _fRemarkDate = _fRemarkDate ??
        SqlSyntax.setField(_fRemarkDate, 'remarkDate', DbType.text);
  }

  static TableField? _fIsListArticle;
  static TableField get isListArticle {
    return _fIsListArticle = _fIsListArticle ??
        SqlSyntax.setField(_fIsListArticle, 'isListArticle', DbType.integer);
  }

  static TableField? _fArticleType;
  static TableField get articleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'articleType', DbType.text);
  }

  static TableField? _fArticleStatus;
  static TableField get articleStatus {
    return _fArticleStatus = _fArticleStatus ??
        SqlSyntax.setField(_fArticleStatus, 'articleStatus', DbType.text);
  }
}
// endregion TakeArticleReturnFields

//region TakeArticleReturnManager
class TakeArticleReturnManager extends SqfEntityProvider {
  TakeArticleReturnManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'takeArticleReturn';
  static const List<String> _primaryKeyList = ['articleNumber'];
  static const String _whereStr = 'articleNumber=?';
}

//endregion TakeArticleReturnManager
// region Logintable
class Logintable extends TableBase {
  Logintable(
      {this.id,
      this.PostmanName,
      this.BeatNo,
      this.BatchNo,
      this.Pincode,
      this.DelOfficeCode,
      this.OfficeName,
      this.MobileNumber,
      this.FacilityId,
      this.EmpId,
      this.is_Active}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Logintable.withFields(
      this.PostmanName,
      this.BeatNo,
      this.BatchNo,
      this.Pincode,
      this.DelOfficeCode,
      this.OfficeName,
      this.MobileNumber,
      this.FacilityId,
      this.EmpId,
      this.is_Active) {
    _setDefaultValues();
  }
  Logintable.withId(
      this.id,
      this.PostmanName,
      this.BeatNo,
      this.BatchNo,
      this.Pincode,
      this.DelOfficeCode,
      this.OfficeName,
      this.MobileNumber,
      this.FacilityId,
      this.EmpId,
      this.is_Active) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Logintable.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['PostmanName'] != null) {
      PostmanName = o['PostmanName'].toString();
    }
    if (o['BeatNo'] != null) {
      BeatNo = o['BeatNo'].toString();
    }
    if (o['BatchNo'] != null) {
      BatchNo = o['BatchNo'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = o['Pincode'].toString();
    }
    if (o['DelOfficeCode'] != null) {
      DelOfficeCode = o['DelOfficeCode'].toString();
    }
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['MobileNumber'] != null) {
      MobileNumber = o['MobileNumber'].toString();
    }
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['EmpId'] != null) {
      EmpId = o['EmpId'].toString();
    }
    if (o['is_Active'] != null) {
      is_Active = int.tryParse(o['is_Active'].toString());
    }
  }
  // FIELDS (Logintable)
  int? id;
  String? PostmanName;
  String? BeatNo;
  String? BatchNo;
  String? Pincode;
  String? DelOfficeCode;
  String? OfficeName;
  String? MobileNumber;
  String? FacilityId;
  String? EmpId;
  int? is_Active;

  // end FIELDS (Logintable)

  static const bool _softDeleteActivated = false;
  LogintableManager? __mnLogintable;

  LogintableManager get _mnLogintable {
    return __mnLogintable = __mnLogintable ?? LogintableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (PostmanName != null || !forView) {
      map['PostmanName'] = PostmanName;
    }
    if (BeatNo != null || !forView) {
      map['BeatNo'] = BeatNo;
    }
    if (BatchNo != null || !forView) {
      map['BatchNo'] = BatchNo;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (DelOfficeCode != null || !forView) {
      map['DelOfficeCode'] = DelOfficeCode;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (EmpId != null || !forView) {
      map['EmpId'] = EmpId;
    }
    if (is_Active != null || !forView) {
      map['is_Active'] = is_Active;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (PostmanName != null || !forView) {
      map['PostmanName'] = PostmanName;
    }
    if (BeatNo != null || !forView) {
      map['BeatNo'] = BeatNo;
    }
    if (BatchNo != null || !forView) {
      map['BatchNo'] = BatchNo;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (DelOfficeCode != null || !forView) {
      map['DelOfficeCode'] = DelOfficeCode;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (EmpId != null || !forView) {
      map['EmpId'] = EmpId;
    }
    if (is_Active != null || !forView) {
      map['is_Active'] = is_Active;
    }

    return map;
  }

  /// This method returns Json String [Logintable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Logintable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      PostmanName,
      BeatNo,
      BatchNo,
      Pincode,
      DelOfficeCode,
      OfficeName,
      MobileNumber,
      FacilityId,
      EmpId,
      is_Active
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      PostmanName,
      BeatNo,
      BatchNo,
      Pincode,
      DelOfficeCode,
      OfficeName,
      MobileNumber,
      FacilityId,
      EmpId,
      is_Active
    ];
  }

  static Future<List<Logintable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Logintable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Logintable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Logintable>[];
    try {
      objList = list
          .map((logintable) =>
              Logintable.fromMap(logintable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Logintable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Logintable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Logintable> objList = <Logintable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Logintable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Logintable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Logintable] if exist, otherwise returns null
  Future<Logintable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    Logintable? obj;
    final data = await _mnLogintable.getById([id]);
    if (data.length != 0) {
      obj = Logintable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Logintable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLogintable.insert(this, ignoreBatch);
    } else {
      await _mnLogintable.update(this);
    }

    return id;
  }

  /// Saves the (Logintable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLogintable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnLogintable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs Logintable. Returns a new Primary Key value of Logintable

  /// <returns>Returns a new Primary Key value of Logintable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Logintable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Logintable> logintables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in logintables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < logintables.length; i++) {
        if (logintables[i].id == null) {
          logintables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLogintable.rawInsert(
          'INSERT OR REPLACE INTO logintable (id, PostmanName, BeatNo, BatchNo, Pincode, DelOfficeCode, OfficeName, MobileNumber, FacilityId, EmpId, is_Active)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            PostmanName,
            BeatNo,
            BatchNo,
            Pincode,
            DelOfficeCode,
            OfficeName,
            MobileNumber,
            FacilityId,
            EmpId,
            is_Active
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Logintable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Logintable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Logintable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLogintable.rawInsert(
          'INSERT OR IGNORE INTO logintable (id, PostmanName, BeatNo, BatchNo, Pincode, DelOfficeCode, OfficeName, MobileNumber, FacilityId, EmpId, is_Active)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            PostmanName,
            BeatNo,
            BatchNo,
            Pincode,
            DelOfficeCode,
            OfficeName,
            MobileNumber,
            FacilityId,
            EmpId,
            is_Active
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Logintable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Logintable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Logintable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Logintable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Logintable> logintables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnLogintable.rawInsertAll(
        'INSERT OR REPLACE INTO logintable (id, PostmanName, BeatNo, BatchNo, Pincode, DelOfficeCode, OfficeName, MobileNumber, FacilityId, EmpId, is_Active)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        logintables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Logintable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Logintable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLogintable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnLogintable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Logintable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LogintableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LogintableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LogintableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LogintableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion logintable

// region LogintableField
class LogintableField extends FilterBase {
  LogintableField(LogintableFilterBuilder logintableFB) : super(logintableFB);

  @override
  LogintableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder isNull() {
    return super.isNull() as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LogintableFilterBuilder;
  }

  @override
  LogintableField get not {
    return super.not as LogintableField;
  }
}
// endregion LogintableField

// region LogintableFilterBuilder
class LogintableFilterBuilder extends ConjunctionBase {
  LogintableFilterBuilder(Logintable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLogintable = obj._mnLogintable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LogintableManager? _mnLogintable;

  /// put the sql keyword 'AND'
  @override
  LogintableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LogintableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LogintableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LogintableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LogintableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LogintableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LogintableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LogintableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LogintableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LogintableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LogintableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LogintableField _setField(
      LogintableField? field, String colName, DbType dbtype) {
    return LogintableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LogintableField? _id;
  LogintableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  LogintableField? _PostmanName;
  LogintableField get PostmanName {
    return _PostmanName = _setField(_PostmanName, 'PostmanName', DbType.text);
  }

  LogintableField? _BeatNo;
  LogintableField get BeatNo {
    return _BeatNo = _setField(_BeatNo, 'BeatNo', DbType.text);
  }

  LogintableField? _BatchNo;
  LogintableField get BatchNo {
    return _BatchNo = _setField(_BatchNo, 'BatchNo', DbType.text);
  }

  LogintableField? _Pincode;
  LogintableField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.text);
  }

  LogintableField? _DelOfficeCode;
  LogintableField get DelOfficeCode {
    return _DelOfficeCode =
        _setField(_DelOfficeCode, 'DelOfficeCode', DbType.text);
  }

  LogintableField? _OfficeName;
  LogintableField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  LogintableField? _MobileNumber;
  LogintableField get MobileNumber {
    return _MobileNumber =
        _setField(_MobileNumber, 'MobileNumber', DbType.text);
  }

  LogintableField? _FacilityId;
  LogintableField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  LogintableField? _EmpId;
  LogintableField get EmpId {
    return _EmpId = _setField(_EmpId, 'EmpId', DbType.text);
  }

  LogintableField? _is_Active;
  LogintableField get is_Active {
    return _is_Active = _setField(_is_Active, 'is_Active', DbType.integer);
  }

  /// Deletes List<Logintable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLogintable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLogintable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from logintable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLogintable!.updateBatch(qparams, values);
  }

  /// This method always returns [Logintable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Logintable?
  @override
  Future<Logintable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLogintable!.toList(qparams);
    final data = await objFuture;
    Logintable? obj;
    if (data.isNotEmpty) {
      obj = Logintable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Logintable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Logintable?
  @override
  Future<Logintable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Logintable();
  }

  /// This method returns int. [Logintable]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? logintableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final logintablesFuture = await _mnLogintable!.toList(qparams);
    final int count = logintablesFuture[0]['CNT'] as int;
    if (logintableCount != null) {
      logintableCount(count);
    }
    return count;
  }

  /// This method returns List<Logintable> [Logintable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Logintable>
  @override
  Future<List<Logintable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Logintable> logintablesData = await Logintable.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return logintablesData;
  }

  /// This method returns Json String [Logintable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Logintable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Logintable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLogintable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Logintable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM logintable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnLogintable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Logintable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLogintable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Logintable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLogintable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LogintableFilterBuilder

// region LogintableFields
class LogintableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fPostmanName;
  static TableField get PostmanName {
    return _fPostmanName = _fPostmanName ??
        SqlSyntax.setField(_fPostmanName, 'PostmanName', DbType.text);
  }

  static TableField? _fBeatNo;
  static TableField get BeatNo {
    return _fBeatNo =
        _fBeatNo ?? SqlSyntax.setField(_fBeatNo, 'BeatNo', DbType.text);
  }

  static TableField? _fBatchNo;
  static TableField get BatchNo {
    return _fBatchNo =
        _fBatchNo ?? SqlSyntax.setField(_fBatchNo, 'BatchNo', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.text);
  }

  static TableField? _fDelOfficeCode;
  static TableField get DelOfficeCode {
    return _fDelOfficeCode = _fDelOfficeCode ??
        SqlSyntax.setField(_fDelOfficeCode, 'DelOfficeCode', DbType.text);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fMobileNumber;
  static TableField get MobileNumber {
    return _fMobileNumber = _fMobileNumber ??
        SqlSyntax.setField(_fMobileNumber, 'MobileNumber', DbType.text);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fEmpId;
  static TableField get EmpId {
    return _fEmpId =
        _fEmpId ?? SqlSyntax.setField(_fEmpId, 'EmpId', DbType.text);
  }

  static TableField? _fIs_Active;
  static TableField get is_Active {
    return _fIs_Active = _fIs_Active ??
        SqlSyntax.setField(_fIs_Active, 'is_Active', DbType.integer);
  }
}
// endregion LogintableFields

//region LogintableManager
class LogintableManager extends SqfEntityProvider {
  LogintableManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'logintable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion LogintableManager
// region EMOTable
class EMOTable extends TableBase {
  EMOTable({this.SNo, this.artNo}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  EMOTable.withFields(this.artNo) {
    _setDefaultValues();
  }
  EMOTable.withId(this.SNo, this.artNo) {
    _setDefaultValues();
  }
  // fromMap v2.0
  EMOTable.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['artNo'] != null) {
      artNo = o['artNo'].toString();
    }
  }
  // FIELDS (EMOTable)
  int? SNo;
  String? artNo;

  // end FIELDS (EMOTable)

  static const bool _softDeleteActivated = false;
  EMOTableManager? __mnEMOTable;

  EMOTableManager get _mnEMOTable {
    return __mnEMOTable = __mnEMOTable ?? EMOTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (artNo != null || !forView) {
      map['artNo'] = artNo;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (artNo != null || !forView) {
      map['artNo'] = artNo;
    }

    return map;
  }

  /// This method returns Json String [EMOTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [EMOTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [artNo];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [SNo, artNo];
  }

  static Future<List<EMOTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EMOTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<EMOTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <EMOTable>[];
    try {
      objList = list
          .map((emotable) => EMOTable.fromMap(emotable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EMOTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<EMOTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<EMOTable> objList = <EMOTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = EMOTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns EMOTable by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [EMOTable] if exist, otherwise returns null
  Future<EMOTable?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    EMOTable? obj;
    final data = await _mnEMOTable.getById([SNo]);
    if (data.length != 0) {
      obj = EMOTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (EMOTable) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnEMOTable.insert(this, ignoreBatch);
    } else {
      await _mnEMOTable.update(this);
    }

    return SNo;
  }

  /// Saves the (EMOTable) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnEMOTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnEMOTable.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs EMOTable. Returns a new Primary Key value of EMOTable

  /// <returns>Returns a new Primary Key value of EMOTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<EMOTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<EMOTable> emotables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in emotables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < emotables.length; i++) {
        if (emotables[i].SNo == null) {
          emotables[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEMOTable.rawInsert(
          'INSERT OR REPLACE INTO EMOTable (SNo, artNo)  VALUES (?,?)',
          [SNo, artNo],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'EMOTable SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'EMOTable SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EMOTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEMOTable.rawInsert(
          'INSERT OR IGNORE INTO EMOTable (SNo, artNo)  VALUES (?,?)',
          [SNo, artNo],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'EMOTable SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'EMOTable SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EMOTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<EMOTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<EMOTable> emotables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnEMOTable.rawInsertAll(
        'INSERT OR REPLACE INTO EMOTable (SNo, artNo)  VALUES (?,?)', emotables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes EMOTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete EMOTable invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnEMOTable
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnEMOTable.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [EMOTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  EMOTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EMOTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  EMOTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EMOTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion emotable

// region EMOTableField
class EMOTableField extends FilterBase {
  EMOTableField(EMOTableFilterBuilder emotableFB) : super(emotableFB);

  @override
  EMOTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder isNull() {
    return super.isNull() as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as EMOTableFilterBuilder;
  }

  @override
  EMOTableField get not {
    return super.not as EMOTableField;
  }
}
// endregion EMOTableField

// region EMOTableFilterBuilder
class EMOTableFilterBuilder extends ConjunctionBase {
  EMOTableFilterBuilder(EMOTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnEMOTable = obj._mnEMOTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  EMOTableManager? _mnEMOTable;

  /// put the sql keyword 'AND'
  @override
  EMOTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  EMOTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  EMOTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  EMOTableFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  EMOTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  EMOTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  EMOTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EMOTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EMOTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EMOTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EMOTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  EMOTableField _setField(EMOTableField? field, String colName, DbType dbtype) {
    return EMOTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  EMOTableField? _SNo;
  EMOTableField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  EMOTableField? _artNo;
  EMOTableField get artNo {
    return _artNo = _setField(_artNo, 'artNo', DbType.text);
  }

  /// Deletes List<EMOTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnEMOTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnEMOTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from EMOTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnEMOTable!.updateBatch(qparams, values);
  }

  /// This method always returns [EMOTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EMOTable?
  @override
  Future<EMOTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnEMOTable!.toList(qparams);
    final data = await objFuture;
    EMOTable? obj;
    if (data.isNotEmpty) {
      obj = EMOTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [EMOTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EMOTable?
  @override
  Future<EMOTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        EMOTable();
  }

  /// This method returns int. [EMOTable]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? emotableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final emotablesFuture = await _mnEMOTable!.toList(qparams);
    final int count = emotablesFuture[0]['CNT'] as int;
    if (emotableCount != null) {
      emotableCount(count);
    }
    return count;
  }

  /// This method returns List<EMOTable> [EMOTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<EMOTable>
  @override
  Future<List<EMOTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<EMOTable> emotablesData = await EMOTable.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return emotablesData;
  }

  /// This method returns Json String [EMOTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [EMOTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [EMOTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnEMOTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [EMOTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `SNo` FROM EMOTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnEMOTable!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [EMOTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnEMOTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await EMOTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnEMOTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EMOTableFilterBuilder

// region EMOTableFields
class EMOTableFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fArtNo;
  static TableField get artNo {
    return _fArtNo =
        _fArtNo ?? SqlSyntax.setField(_fArtNo, 'artNo', DbType.text);
  }
}
// endregion EMOTableFields

//region EMOTableManager
class EMOTableManager extends SqfEntityProvider {
  EMOTableManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'EMOTable';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion EMOTableManager
// region ARTICLETYPEMASTER
class ARTICLETYPEMASTER extends TableBase {
  ARTICLETYPEMASTER(
      {this.sno, this.material, this.description, this.category}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ARTICLETYPEMASTER.withFields(
      this.sno, this.material, this.description, this.category) {
    _setDefaultValues();
  }
  ARTICLETYPEMASTER.withId(
      this.sno, this.material, this.description, this.category) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ARTICLETYPEMASTER.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    sno = o['sno'].toString();
    if (o['material'] != null) {
      material = o['material'].toString();
    }
    if (o['description'] != null) {
      description = o['description'].toString();
    }
    if (o['category'] != null) {
      category = o['category'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ARTICLETYPEMASTER)
  String? sno;
  String? material;
  String? description;
  String? category;
  bool? isSaved;
  // end FIELDS (ARTICLETYPEMASTER)

  static const bool _softDeleteActivated = false;
  ARTICLETYPEMASTERManager? __mnARTICLETYPEMASTER;

  ARTICLETYPEMASTERManager get _mnARTICLETYPEMASTER {
    return __mnARTICLETYPEMASTER =
        __mnARTICLETYPEMASTER ?? ARTICLETYPEMASTERManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['sno'] = sno;
    if (material != null || !forView) {
      map['material'] = material;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (category != null || !forView) {
      map['category'] = category;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['sno'] = sno;
    if (material != null || !forView) {
      map['material'] = material;
    }
    if (description != null || !forView) {
      map['description'] = description;
    }
    if (category != null || !forView) {
      map['category'] = category;
    }

    return map;
  }

  /// This method returns Json String [ARTICLETYPEMASTER]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ARTICLETYPEMASTER]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [sno, material, description, category];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [sno, material, description, category];
  }

  static Future<List<ARTICLETYPEMASTER>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ARTICLETYPEMASTER.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ARTICLETYPEMASTER>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ARTICLETYPEMASTER>[];
    try {
      objList = list
          .map((articletypemaster) => ARTICLETYPEMASTER
              .fromMap(articletypemaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ARTICLETYPEMASTER.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ARTICLETYPEMASTER>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ARTICLETYPEMASTER> objList = <ARTICLETYPEMASTER>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ARTICLETYPEMASTER.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ARTICLETYPEMASTER by ID if exist, otherwise returns null
  /// Primary Keys: String? sno
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ARTICLETYPEMASTER] if exist, otherwise returns null
  Future<ARTICLETYPEMASTER?> getById(String? sno,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (sno == null) {
      return null;
    }
    ARTICLETYPEMASTER? obj;
    final data = await _mnARTICLETYPEMASTER.getById([sno]);
    if (data.length != 0) {
      obj = ARTICLETYPEMASTER.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ARTICLETYPEMASTER) object. If the Primary Key (sno) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same sno
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnARTICLETYPEMASTER.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO ARTICLETYPEMASTER (sno, material, description, category)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ARTICLETYPEMASTER> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ARTICLETYPEMASTER> articletypemasters,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await ArticleModel().batchStart();
    for (final obj in articletypemasters) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await ArticleModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnARTICLETYPEMASTER.rawInsert(
          'INSERT OR REPLACE INTO ARTICLETYPEMASTER (sno, material, description, category)  VALUES (?,?,?,?)',
          [sno, material, description, category],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ARTICLETYPEMASTER sno=$sno updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ARTICLETYPEMASTER sno=$sno did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'ARTICLETYPEMASTER Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnARTICLETYPEMASTER.rawInsert(
          'INSERT OR IGNORE INTO ARTICLETYPEMASTER (sno, material, description, category)  VALUES (?,?,?,?)',
          [sno, material, description, category],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ARTICLETYPEMASTER sno=$sno updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ARTICLETYPEMASTER sno=$sno did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'ARTICLETYPEMASTER Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ARTICLETYPEMASTER

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ARTICLETYPEMASTER invoked (sno=$sno)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnARTICLETYPEMASTER
          .delete(QueryParams(whereString: 'sno=?', whereArguments: [sno]));
    } else {
      return _mnARTICLETYPEMASTER.updateBatch(
          QueryParams(whereString: 'sno=?', whereArguments: [sno]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ARTICLETYPEMASTER] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ARTICLETYPEMASTERFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ARTICLETYPEMASTERFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ARTICLETYPEMASTERFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      sno = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion articletypemaster

// region ARTICLETYPEMASTERField
class ARTICLETYPEMASTERField extends FilterBase {
  ARTICLETYPEMASTERField(ARTICLETYPEMASTERFilterBuilder articletypemasterFB)
      : super(articletypemasterFB);

  @override
  ARTICLETYPEMASTERFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder isNull() {
    return super.isNull() as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ARTICLETYPEMASTERFilterBuilder;
  }

  @override
  ARTICLETYPEMASTERField get not {
    return super.not as ARTICLETYPEMASTERField;
  }
}
// endregion ARTICLETYPEMASTERField

// region ARTICLETYPEMASTERFilterBuilder
class ARTICLETYPEMASTERFilterBuilder extends ConjunctionBase {
  ARTICLETYPEMASTERFilterBuilder(ARTICLETYPEMASTER obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnARTICLETYPEMASTER = obj._mnARTICLETYPEMASTER;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ARTICLETYPEMASTERManager? _mnARTICLETYPEMASTER;

  /// put the sql keyword 'AND'
  @override
  ARTICLETYPEMASTERFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ARTICLETYPEMASTERFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ARTICLETYPEMASTERFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ARTICLETYPEMASTERFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ARTICLETYPEMASTERFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ARTICLETYPEMASTERFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ARTICLETYPEMASTERFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ARTICLETYPEMASTERFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ARTICLETYPEMASTERFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ARTICLETYPEMASTERFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ARTICLETYPEMASTERFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ARTICLETYPEMASTERField _setField(
      ARTICLETYPEMASTERField? field, String colName, DbType dbtype) {
    return ARTICLETYPEMASTERField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ARTICLETYPEMASTERField? _sno;
  ARTICLETYPEMASTERField get sno {
    return _sno = _setField(_sno, 'sno', DbType.integer);
  }

  ARTICLETYPEMASTERField? _material;
  ARTICLETYPEMASTERField get material {
    return _material = _setField(_material, 'material', DbType.text);
  }

  ARTICLETYPEMASTERField? _description;
  ARTICLETYPEMASTERField get description {
    return _description = _setField(_description, 'description', DbType.text);
  }

  ARTICLETYPEMASTERField? _category;
  ARTICLETYPEMASTERField get category {
    return _category = _setField(_category, 'category', DbType.text);
  }

  /// Deletes List<ARTICLETYPEMASTER> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnARTICLETYPEMASTER!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnARTICLETYPEMASTER!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'sno IN (SELECT sno from ARTICLETYPEMASTER ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnARTICLETYPEMASTER!.updateBatch(qparams, values);
  }

  /// This method always returns [ARTICLETYPEMASTER] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ARTICLETYPEMASTER?
  @override
  Future<ARTICLETYPEMASTER?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnARTICLETYPEMASTER!.toList(qparams);
    final data = await objFuture;
    ARTICLETYPEMASTER? obj;
    if (data.isNotEmpty) {
      obj = ARTICLETYPEMASTER.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ARTICLETYPEMASTER]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ARTICLETYPEMASTER?
  @override
  Future<ARTICLETYPEMASTER> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ARTICLETYPEMASTER();
  }

  /// This method returns int. [ARTICLETYPEMASTER]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? articletypemasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final articletypemastersFuture =
        await _mnARTICLETYPEMASTER!.toList(qparams);
    final int count = articletypemastersFuture[0]['CNT'] as int;
    if (articletypemasterCount != null) {
      articletypemasterCount(count);
    }
    return count;
  }

  /// This method returns List<ARTICLETYPEMASTER> [ARTICLETYPEMASTER]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ARTICLETYPEMASTER>
  @override
  Future<List<ARTICLETYPEMASTER>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ARTICLETYPEMASTER> articletypemastersData =
        await ARTICLETYPEMASTER.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return articletypemastersData;
  }

  /// This method returns Json String [ARTICLETYPEMASTER]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ARTICLETYPEMASTER]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ARTICLETYPEMASTER]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnARTICLETYPEMASTER!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ARTICLETYPEMASTER]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `sno` FROM ARTICLETYPEMASTER WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> snoData = <String>[];
    qparams.selectColumns = ['sno'];
    final snoFuture = await _mnARTICLETYPEMASTER!.toList(qparams);

    final int count = snoFuture.length;
    for (int i = 0; i < count; i++) {
      snoData.add(snoFuture[i]['sno'] as String);
    }
    return snoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ARTICLETYPEMASTER]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnARTICLETYPEMASTER!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ARTICLETYPEMASTER.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnARTICLETYPEMASTER!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ARTICLETYPEMASTERFilterBuilder

// region ARTICLETYPEMASTERFields
class ARTICLETYPEMASTERFields {
  static TableField? _fSno;
  static TableField get sno {
    return _fSno = _fSno ?? SqlSyntax.setField(_fSno, 'sno', DbType.integer);
  }

  static TableField? _fMaterial;
  static TableField get material {
    return _fMaterial =
        _fMaterial ?? SqlSyntax.setField(_fMaterial, 'material', DbType.text);
  }

  static TableField? _fDescription;
  static TableField get description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'description', DbType.text);
  }

  static TableField? _fCategory;
  static TableField get category {
    return _fCategory =
        _fCategory ?? SqlSyntax.setField(_fCategory, 'category', DbType.text);
  }
}
// endregion ARTICLETYPEMASTERFields

//region ARTICLETYPEMASTERManager
class ARTICLETYPEMASTERManager extends SqfEntityProvider {
  ARTICLETYPEMASTERManager()
      : super(ArticleModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ARTICLETYPEMASTER';
  static const List<String> _primaryKeyList = ['sno'];
  static const String _whereStr = 'sno=?';
}

//endregion ARTICLETYPEMASTERManager
class ArticleModelSequenceManager extends SqfEntityProvider {
  ArticleModelSequenceManager() : super(ArticleModel());
}
// END OF ENTITIES
