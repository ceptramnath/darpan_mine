// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'DarpanDBModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:Delivery.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// Delivery TABLE
class TableDelivery extends SqfEntityTableBase {
  TableDelivery() {
    // declare properties of EntityTable
    tableName = 'Delivery';
    primaryKeyName = 'ART_NUMBER';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('invoiceDate', DbType.text),
      SqfEntityFieldBase('invoiced', DbType.text),
      SqfEntityFieldBase('SOFFICE_ID ', DbType.text),
      SqfEntityFieldBase('DOFFICE_ID', DbType.text),
      SqfEntityFieldBase('BOOK_DATE', DbType.text),
      SqfEntityFieldBase('BOOK_ID', DbType.text),
      SqfEntityFieldBase('LINE_ITEM', DbType.real),
      SqfEntityFieldBase('BAG_ID', DbType.text),
      SqfEntityFieldBase('INSURANCE', DbType.text),
      SqfEntityFieldBase('ON_HOLD', DbType.text),
      SqfEntityFieldBase('HOLD_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('HOLD_TILL_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('PENSIONER_ID', DbType.text),
      SqfEntityFieldBase('REASON_FOR_NONDELIVERY', DbType.text),
      SqfEntityFieldBase('REASON_TYPE', DbType.text),
      SqfEntityFieldBase('ACTION', DbType.text),
      SqfEntityFieldBase('MONEY_TO_BE_COLLECTED', DbType.real),
      SqfEntityFieldBase('MONEY_COLLECTED', DbType.real, defaultValue: 0),
      SqfEntityFieldBase('POST_DUE', DbType.real),
      SqfEntityFieldBase('DEM_CHARGE', DbType.real),
      SqfEntityFieldBase('COMMISSION', DbType.real),
      SqfEntityFieldBase('MONEY_TO_BE_DELIVERED', DbType.real),
      SqfEntityFieldBase('MONEY_DELIVERED', DbType.real),
      SqfEntityFieldBase('NO_OF_HOLD_DAYS', DbType.real),
      SqfEntityFieldBase('DATE_OF_DELIVERY', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DATE_OF_DELIVERY_CONFIRM', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('TIME_OF_DELIVERY_CONFIRM', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DATE_OF_1ST_DELIVERY_CONFIRM', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DATE_OF_2ND_DELIVERY_CONFIRM', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DATE_OF_3RD_DELIVERY_CONFIRM', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DELIVERY_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('DEL_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('ID_PROOF_DOC', DbType.text),
      SqfEntityFieldBase('ID_PROOF_NMBR', DbType.text),
      SqfEntityFieldBase('ISSUING_AUTHORITY', DbType.text),
      SqfEntityFieldBase('ID_PROOF_VALIDITY_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('WINDOW_DELIVERY', DbType.text),
      SqfEntityFieldBase('REDIRECTION_FEE', DbType.real),
      SqfEntityFieldBase('RETRN_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('RETRN_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('BEAT_NO', DbType.text),
      SqfEntityFieldBase('PERNR', DbType.real),
      SqfEntityFieldBase('ART_STATUS', DbType.text),
      SqfEntityFieldBase('ART_RECEIVE_DATE', DbType.text),
      SqfEntityFieldBase('ART_RECEIVE_TIME', DbType.text),
      SqfEntityFieldBase('REMARKS', DbType.text),
      SqfEntityFieldBase('ZCONDITION', DbType.text),
      SqfEntityFieldBase('TOTAL_MONEY', DbType.real),
      SqfEntityFieldBase('POSTAGE_NOT_COLLECTED', DbType.real),
      SqfEntityFieldBase('MOP', DbType.text),
      SqfEntityFieldBase('VPP', DbType.text),
      SqfEntityFieldBase('BATCH_ID', DbType.text),
      SqfEntityFieldBase('SHIFT_NO', DbType.text),
      SqfEntityFieldBase('RET_RCL_RDL_STOPDELV_STATUS2', DbType.text),
      SqfEntityFieldBase('TYPE_OF_PAYEE', DbType.text),
      SqfEntityFieldBase('REDIRECT_PIN', DbType.integer),
      SqfEntityFieldBase('MOD_PIN', DbType.integer),
      SqfEntityFieldBase('SOURCE_PINCODE', DbType.integer),
      SqfEntityFieldBase('DESTN_PINCODE', DbType.integer),
      SqfEntityFieldBase('EMO_MESSAGE', DbType.text),
      SqfEntityFieldBase('REGISTERED', DbType.text),
      SqfEntityFieldBase('RETURN_SERVICE', DbType.text),
      SqfEntityFieldBase('COD', DbType.text),
      SqfEntityFieldBase('RT', DbType.text),
      SqfEntityFieldBase('RT_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('RT_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('RD', DbType.text),
      SqfEntityFieldBase('RD_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('RD_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('SP', DbType.text),
      SqfEntityFieldBase('SP_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('SP_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('POSTE_RESTANTE', DbType.text),
      SqfEntityFieldBase('BO_ID', DbType.text),
      SqfEntityFieldBase('LAST_CHANGED_USER', DbType.text),
      SqfEntityFieldBase('BELNR', DbType.text),
      SqfEntityFieldBase('ALREADY_RTN_FLAG', DbType.text),
      SqfEntityFieldBase('ALREADY_RD_FLAG', DbType.text),
      SqfEntityFieldBase('REDIRECT_BO_ID', DbType.text),
      SqfEntityFieldBase('IFS_SOFFICE_NAME', DbType.text),
      SqfEntityFieldBase('CHECT', DbType.text),
      SqfEntityFieldBase('TREASURY_SUBMIT_DONE', DbType.text),
      SqfEntityFieldBase('TREASURY_SUBMIT_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('REDIRECTION_SL', DbType.real),
      SqfEntityFieldBase('TRANSACTION_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('TRANSACTION_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('IS_PREVIOUS_DAY_DEPOSIT', DbType.text),
      SqfEntityFieldBase('E_PROOF', DbType.text),
      SqfEntityFieldBase('MATNR', DbType.text),
      SqfEntityFieldBase('CASH_ID', DbType.text),
      SqfEntityFieldBase('REMARK_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('CASH_RETURNED', DbType.text),
      SqfEntityFieldBase('FILE_NAME', DbType.text),
      SqfEntityFieldBase('REPORTING_SO_ID', DbType.text),
      SqfEntityFieldBase('despatchStatus', DbType.text),
      SqfEntityFieldBase('CUST_DUTY', DbType.real),
      SqfEntityFieldBase('BO_SLIP', DbType.text),
      SqfEntityFieldBase('ZIP_FILE_NAME', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDelivery();
  }
}

// Addres TABLE
class TableAddres extends SqfEntityTableBase {
  TableAddres() {
    // declare properties of EntityTable
    tableName = 'Address';
    primaryKeyName = 'ART_NUMBER';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SEND_CUST_N ', DbType.text),
      SqfEntityFieldBase('SEND_ADD1', DbType.text),
      SqfEntityFieldBase('SEND_ADD2', DbType.text),
      SqfEntityFieldBase('SEND_ADD3', DbType.text),
      SqfEntityFieldBase('SEND_STREET', DbType.text),
      SqfEntityFieldBase('SEND_CITY', DbType.text),
      SqfEntityFieldBase('SEND_COUNTRY', DbType.text),
      SqfEntityFieldBase('SEND_STATE', DbType.text),
      SqfEntityFieldBase('SEND_EMAIL', DbType.text),
      SqfEntityFieldBase('SEND_PIN', DbType.integer),
      SqfEntityFieldBase('SEND_FAX', DbType.text),
      SqfEntityFieldBase('SEND_MOB', DbType.text),
      SqfEntityFieldBase('REC_NAME', DbType.text),
      SqfEntityFieldBase('REC_ADDRESS1', DbType.text),
      SqfEntityFieldBase('REC_ADDRESS2', DbType.text),
      SqfEntityFieldBase('REC_ADDRESS3', DbType.text),
      SqfEntityFieldBase('REC_COUNTRY', DbType.text),
      SqfEntityFieldBase('REC_STATE', DbType.text),
      SqfEntityFieldBase('REC_STREET', DbType.text),
      SqfEntityFieldBase('REC_CITY', DbType.text),
      SqfEntityFieldBase('REC_PIN', DbType.integer),
      SqfEntityFieldBase('MOD_PIN', DbType.real),
      SqfEntityFieldBase('REC_MOB', DbType.text),
      SqfEntityFieldBase('REC_EMAIL', DbType.text),
      SqfEntityFieldBase('REC_FAX', DbType.text),
      SqfEntityFieldBase('RECIPIENT_NAME', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_ADD1', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_ADD2', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_ADD3', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_STREET', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_CITY', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_COUNTRY', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_STATE', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_PIN', DbType.real),
      SqfEntityFieldBase('REDIRECT_REC_MOB', DbType.real),
      SqfEntityFieldBase('REDIRECT_REC_EMAIL', DbType.text),
      SqfEntityFieldBase('REDIRECT_REC_FAX', DbType.text),
      SqfEntityFieldBase('REDIRECT_FROM_PIN', DbType.real),
      SqfEntityFieldBase('REDIRECT_FROM_BO_ID', DbType.text),
      SqfEntityFieldBase('BOOK_ID', DbType.text),
      SqfEntityFieldBase('BAG_ID', DbType.text),
      SqfEntityFieldBase('BO_SLIP', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAddres();
  }
}

// Reason TABLE
class TableReason extends SqfEntityTableBase {
  TableReason() {
    // declare properties of EntityTable
    tableName = 'Reason';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MANDT', DbType.text),
      SqfEntityFieldBase('SERIAL', DbType.real),
      SqfEntityFieldBase('REASON_FOR_NDELI', DbType.text),
      SqfEntityFieldBase('APPLICABLE_FOR', DbType.text),
      SqfEntityFieldBase('REASON_TYPE', DbType.text),
      SqfEntityFieldBase('ACTION', DbType.text),
      SqfEntityFieldBase('REASON_NDEL_TEXT', DbType.text),
      SqfEntityFieldBase('APPL_FOR_TEXT', DbType.text),
      SqfEntityFieldBase('REASON_TYPE_TEXT', DbType.text),
      SqfEntityFieldBase('ACTION_TEXT', DbType.text),
      SqfEntityFieldBase('DELE_FLAG', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableReason();
  }
}

// RECEIVEDARTDETAILS TABLE
class TableRECEIVEDARTDETAILS extends SqfEntityTableBase {
  TableRECEIVEDARTDETAILS() {
    // declare properties of EntityTable
    tableName = 'RECEIVEDARTDETAILS';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ART_NUMBER', DbType.text),
      SqfEntityFieldBase('BAGNUMBER', DbType.text),
      SqfEntityFieldBase('ART_RECEIVE_DATE', DbType.date,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('ART_RECEIVE_TIME', DbType.datetime,
          minValue: DateTime.parse('1900-01-01')),
      SqfEntityFieldBase('MATNR', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('FILE_NAME', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRECEIVEDARTDETAILS();
  }
}

// ARTICLEMASTER TABLE
class TableARTICLEMASTER extends SqfEntityTableBase {
  TableARTICLEMASTER() {
    // declare properties of EntityTable
    tableName = 'ARTICLEMASTER';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ARTICLETYPE', DbType.text),
      SqfEntityFieldBase('ARTICLECODE', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableARTICLEMASTER();
  }
}

// Login TABLE
class TableLogin extends SqfEntityTableBase {
  TableLogin() {
    // declare properties of EntityTable
    tableName = 'Login';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('IMEI', DbType.text),
      SqfEntityFieldBase('empName', DbType.text),
      SqfEntityFieldBase('empId', DbType.text),
      SqfEntityFieldBase('mobile', DbType.text),
      SqfEntityFieldBase('pincode', DbType.text),
      SqfEntityFieldBase('facilityID', DbType.text),
      SqfEntityFieldBase('digitalToken', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLogin();
  }
}

// DESPATCHBAG TABLE
class TableDESPATCHBAG extends SqfEntityTableBase {
  TableDESPATCHBAG() {
    // declare properties of EntityTable
    tableName = 'DESPATCHBAG';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SCHEDULE', DbType.text),
      SqfEntityFieldBase('SCHEDULED_TIME', DbType.text),
      SqfEntityFieldBase('MAILLIST_TO_OFFICE', DbType.text),
      SqfEntityFieldBase('BAGNUMBER', DbType.text),
      SqfEntityFieldBase('FROM_OFFICE', DbType.text),
      SqfEntityFieldBase('TO_OFFICE', DbType.text),
      SqfEntityFieldBase('CLOSING_DATE', DbType.text),
      SqfEntityFieldBase('REMARKS', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('IS_RCVD', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDESPATCHBAG();
  }
}

// BOSLIP_STAMP1 TABLE
class TableBOSLIP_STAMP1 extends SqfEntityTableBase {
  TableBOSLIP_STAMP1() {
    // declare properties of EntityTable
    tableName = 'BOSLIP_STAMP1';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BO_SLIP_NO', DbType.text),
      SqfEntityFieldBase('ZMOFACILITYID', DbType.text),
      SqfEntityFieldBase('MATNR', DbType.text),
      SqfEntityFieldBase('ZINV_PARTICULAR', DbType.text),
      SqfEntityFieldBase('MENGE_D', DbType.text),
      SqfEntityFieldBase('ZCREATEDT', DbType.text),
      SqfEntityFieldBase('ZMOCREATEDBY', DbType.text),
      SqfEntityFieldBase('IS_RCVD', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBOSLIP_STAMP1();
  }
}

// BOSLIP_CASH1 TABLE
class TableBOSLIP_CASH1 extends SqfEntityTableBase {
  TableBOSLIP_CASH1() {
    // declare properties of EntityTable
    tableName = 'BOSLIP_CASH1';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BO_SLIP_NO', DbType.text),
      SqfEntityFieldBase('DATE_OF_SENT', DbType.text),
      SqfEntityFieldBase('SO_PROFIT_CENTER', DbType.text),
      SqfEntityFieldBase('BO_PROFIT_CENTER', DbType.text),
      SqfEntityFieldBase('AMOUNT', DbType.text),
      SqfEntityFieldBase('WEIGHT_OF_CASH_BAG', DbType.text),
      SqfEntityFieldBase('CHEQUE_NO', DbType.text),
      SqfEntityFieldBase('CHEQUE_AMOUNT', DbType.text),
      SqfEntityFieldBase('CASHORCHEQUE', DbType.text),
      SqfEntityFieldBase('LESS_CASH', DbType.text),
      SqfEntityFieldBase('OVER_CASH', DbType.text),
      SqfEntityFieldBase('ACTUAL_CASH', DbType.text),
      SqfEntityFieldBase('IS_RCVD', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBOSLIP_CASH1();
  }
}

// BOSLIP_DOCUMENT1 TABLE
class TableBOSLIP_DOCUMENT1 extends SqfEntityTableBase {
  TableBOSLIP_DOCUMENT1() {
    // declare properties of EntityTable
    tableName = 'BOSLIP_DOCUMENT1';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BO_SLIP_NO', DbType.text),
      SqfEntityFieldBase('DOCUMENT_DETAILS', DbType.text),
      SqfEntityFieldBase('FROMOFFICE', DbType.text),
      SqfEntityFieldBase('TOOFFICE', DbType.text),
      SqfEntityFieldBase('IS_RCVD', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBOSLIP_DOCUMENT1();
  }
}

// BSRDETAILS_NEW TABLE
class TableBSRDETAILS_NEW extends SqfEntityTableBase {
  TableBSRDETAILS_NEW() {
    // declare properties of EntityTable
    tableName = 'BSRDETAILS_NEW';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BOSLIPID', DbType.text),
      SqfEntityFieldBase('BAGNUMBER', DbType.text),
      SqfEntityFieldBase('RECEIVEDATE', DbType.text),
      SqfEntityFieldBase('BO_SLIP_DATE', DbType.text),
      SqfEntityFieldBase('CLOSING_BALANCE', DbType.text),
      SqfEntityFieldBase('CB_DATE', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('CASH_STATUS', DbType.text),
      SqfEntityFieldBase('STAMP_STATUS', DbType.text),
      SqfEntityFieldBase('DOCUMENT_STATUS', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBSRDETAILS_NEW();
  }
}

// BAGDETAILS_NEW TABLE
class TableBAGDETAILS_NEW extends SqfEntityTableBase {
  TableBAGDETAILS_NEW() {
    // declare properties of EntityTable
    tableName = 'BAGDETAILS_NEW';
    primaryKeyName = 'SNo';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FROMOFFICE', DbType.text),
      SqfEntityFieldBase('TOOFFICE', DbType.text),
      SqfEntityFieldBase('TDATE', DbType.text),
      SqfEntityFieldBase('TIME', DbType.text),
      SqfEntityFieldBase('USERID', DbType.text),
      SqfEntityFieldBase('BAGNUMBER', DbType.text),
      SqfEntityFieldBase('BAGSTATUS', DbType.text),
      SqfEntityFieldBase('BOTDATE', DbType.text),
      SqfEntityFieldBase('IS_RCVD', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('BOSLIPNO', DbType.text),
      SqfEntityFieldBase('NO_OF_ARTICLES', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBAGDETAILS_NEW();
  }
}

// FILE_SYNC_DETAILS TABLE
class TableFILE_SYNC_DETAILS extends SqfEntityTableBase {
  TableFILE_SYNC_DETAILS() {
    // declare properties of EntityTable
    tableName = 'FILE_SYNC_DETAILS';
    primaryKeyName = 'CLIENT_TRANSACTION_ID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FILE_NAME', DbType.text),
      SqfEntityFieldBase('ZIP_FILE_NAME', DbType.text, isIndex: true),
      SqfEntityFieldBase('FILE_PATH', DbType.text),
      SqfEntityFieldBase('SERVICE', DbType.text),
      SqfEntityFieldBase('STATUS', DbType.text),
      SqfEntityFieldBase('LAST_UPDATED_DT', DbType.text),
      SqfEntityFieldBase('PROCESSED', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFILE_SYNC_DETAILS();
  }
}

// VPPEMO TABLE
class TableVPPEMO extends SqfEntityTableBase {
  TableVPPEMO() {
    // declare properties of EntityTable
    tableName = 'VPPEMO';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('VP_ART', DbType.text),
      SqfEntityFieldBase('MONEY_TO_BE_COLLECTED', DbType.real),
      SqfEntityFieldBase('COMMISSION', DbType.real),
      SqfEntityFieldBase('DATE_OF_DELIVERY', DbType.text),
      SqfEntityFieldBase('EMO_NUMBER', DbType.text),
      SqfEntityFieldBase('REMARKS', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVPPEMO();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class DeliveryModel extends SqfEntityModelProvider {
  DeliveryModel() {
    databaseName = deliveryModel.databaseName;
    password = deliveryModel.password;
    dbVersion = deliveryModel.dbVersion;
    preSaveAction = deliveryModel.preSaveAction;
    logFunction = deliveryModel.logFunction;
    databaseTables = [
      TableDelivery.getInstance,
      TableAddres.getInstance,
      TableReason.getInstance,
      TableRECEIVEDARTDETAILS.getInstance,
      TableARTICLEMASTER.getInstance,
      TableLogin.getInstance,
      TableDESPATCHBAG.getInstance,
      TableBOSLIP_STAMP1.getInstance,
      TableBOSLIP_CASH1.getInstance,
      TableBOSLIP_DOCUMENT1.getInstance,
      TableBSRDETAILS_NEW.getInstance,
      TableBAGDETAILS_NEW.getInstance,
      TableFILE_SYNC_DETAILS.getInstance,
      TableVPPEMO.getInstance,
    ];

    bundledDatabasePath = deliveryModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = deliveryModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region Delivery
class Delivery extends TableBase {
  Delivery(
      {this.ART_NUMBER,
      this.invoiceDate,
      this.invoiced,
      this.SOFFICE_ID,
      this.DOFFICE_ID,
      this.BOOK_DATE,
      this.BOOK_ID,
      this.LINE_ITEM,
      this.BAG_ID,
      this.INSURANCE,
      this.ON_HOLD,
      this.HOLD_DATE,
      this.HOLD_TILL_DATE,
      this.PENSIONER_ID,
      this.REASON_FOR_NONDELIVERY,
      this.REASON_TYPE,
      this.ACTION,
      this.MONEY_TO_BE_COLLECTED,
      this.MONEY_COLLECTED,
      this.POST_DUE,
      this.DEM_CHARGE,
      this.COMMISSION,
      this.MONEY_TO_BE_DELIVERED,
      this.MONEY_DELIVERED,
      this.NO_OF_HOLD_DAYS,
      this.DATE_OF_DELIVERY,
      this.DATE_OF_DELIVERY_CONFIRM,
      this.TIME_OF_DELIVERY_CONFIRM,
      this.DATE_OF_1ST_DELIVERY_CONFIRM,
      this.DATE_OF_2ND_DELIVERY_CONFIRM,
      this.DATE_OF_3RD_DELIVERY_CONFIRM,
      this.DELIVERY_TIME,
      this.DEL_DATE,
      this.ID_PROOF_DOC,
      this.ID_PROOF_NMBR,
      this.ISSUING_AUTHORITY,
      this.ID_PROOF_VALIDITY_DATE,
      this.WINDOW_DELIVERY,
      this.REDIRECTION_FEE,
      this.RETRN_DATE,
      this.RETRN_TIME,
      this.BEAT_NO,
      this.PERNR,
      this.ART_STATUS,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.REMARKS,
      this.ZCONDITION,
      this.TOTAL_MONEY,
      this.POSTAGE_NOT_COLLECTED,
      this.MOP,
      this.VPP,
      this.BATCH_ID,
      this.SHIFT_NO,
      this.RET_RCL_RDL_STOPDELV_STATUS2,
      this.TYPE_OF_PAYEE,
      this.REDIRECT_PIN,
      this.MOD_PIN,
      this.SOURCE_PINCODE,
      this.DESTN_PINCODE,
      this.EMO_MESSAGE,
      this.REGISTERED,
      this.RETURN_SERVICE,
      this.COD,
      this.RT,
      this.RT_DATE,
      this.RT_TIME,
      this.RD,
      this.RD_DATE,
      this.RD_TIME,
      this.SP,
      this.SP_DATE,
      this.SP_TIME,
      this.POSTE_RESTANTE,
      this.BO_ID,
      this.LAST_CHANGED_USER,
      this.BELNR,
      this.ALREADY_RTN_FLAG,
      this.ALREADY_RD_FLAG,
      this.REDIRECT_BO_ID,
      this.IFS_SOFFICE_NAME,
      this.CHECT,
      this.TREASURY_SUBMIT_DONE,
      this.TREASURY_SUBMIT_DATE,
      this.REDIRECTION_SL,
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.IS_COMMUNICATED,
      this.IS_PREVIOUS_DAY_DEPOSIT,
      this.E_PROOF,
      this.MATNR,
      this.CASH_ID,
      this.REMARK_DATE,
      this.CASH_RETURNED,
      this.FILE_NAME,
      this.REPORTING_SO_ID,
      this.despatchStatus,
      this.CUST_DUTY,
      this.BO_SLIP,
      this.ZIP_FILE_NAME}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Delivery.withFields(
      this.ART_NUMBER,
      this.invoiceDate,
      this.invoiced,
      this.SOFFICE_ID,
      this.DOFFICE_ID,
      this.BOOK_DATE,
      this.BOOK_ID,
      this.LINE_ITEM,
      this.BAG_ID,
      this.INSURANCE,
      this.ON_HOLD,
      this.HOLD_DATE,
      this.HOLD_TILL_DATE,
      this.PENSIONER_ID,
      this.REASON_FOR_NONDELIVERY,
      this.REASON_TYPE,
      this.ACTION,
      this.MONEY_TO_BE_COLLECTED,
      this.MONEY_COLLECTED,
      this.POST_DUE,
      this.DEM_CHARGE,
      this.COMMISSION,
      this.MONEY_TO_BE_DELIVERED,
      this.MONEY_DELIVERED,
      this.NO_OF_HOLD_DAYS,
      this.DATE_OF_DELIVERY,
      this.DATE_OF_DELIVERY_CONFIRM,
      this.TIME_OF_DELIVERY_CONFIRM,
      this.DATE_OF_1ST_DELIVERY_CONFIRM,
      this.DATE_OF_2ND_DELIVERY_CONFIRM,
      this.DATE_OF_3RD_DELIVERY_CONFIRM,
      this.DELIVERY_TIME,
      this.DEL_DATE,
      this.ID_PROOF_DOC,
      this.ID_PROOF_NMBR,
      this.ISSUING_AUTHORITY,
      this.ID_PROOF_VALIDITY_DATE,
      this.WINDOW_DELIVERY,
      this.REDIRECTION_FEE,
      this.RETRN_DATE,
      this.RETRN_TIME,
      this.BEAT_NO,
      this.PERNR,
      this.ART_STATUS,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.REMARKS,
      this.ZCONDITION,
      this.TOTAL_MONEY,
      this.POSTAGE_NOT_COLLECTED,
      this.MOP,
      this.VPP,
      this.BATCH_ID,
      this.SHIFT_NO,
      this.RET_RCL_RDL_STOPDELV_STATUS2,
      this.TYPE_OF_PAYEE,
      this.REDIRECT_PIN,
      this.MOD_PIN,
      this.SOURCE_PINCODE,
      this.DESTN_PINCODE,
      this.EMO_MESSAGE,
      this.REGISTERED,
      this.RETURN_SERVICE,
      this.COD,
      this.RT,
      this.RT_DATE,
      this.RT_TIME,
      this.RD,
      this.RD_DATE,
      this.RD_TIME,
      this.SP,
      this.SP_DATE,
      this.SP_TIME,
      this.POSTE_RESTANTE,
      this.BO_ID,
      this.LAST_CHANGED_USER,
      this.BELNR,
      this.ALREADY_RTN_FLAG,
      this.ALREADY_RD_FLAG,
      this.REDIRECT_BO_ID,
      this.IFS_SOFFICE_NAME,
      this.CHECT,
      this.TREASURY_SUBMIT_DONE,
      this.TREASURY_SUBMIT_DATE,
      this.REDIRECTION_SL,
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.IS_COMMUNICATED,
      this.IS_PREVIOUS_DAY_DEPOSIT,
      this.E_PROOF,
      this.MATNR,
      this.CASH_ID,
      this.REMARK_DATE,
      this.CASH_RETURNED,
      this.FILE_NAME,
      this.REPORTING_SO_ID,
      this.despatchStatus,
      this.CUST_DUTY,
      this.BO_SLIP,
      this.ZIP_FILE_NAME) {
    _setDefaultValues();
  }
  Delivery.withId(
      this.ART_NUMBER,
      this.invoiceDate,
      this.invoiced,
      this.SOFFICE_ID,
      this.DOFFICE_ID,
      this.BOOK_DATE,
      this.BOOK_ID,
      this.LINE_ITEM,
      this.BAG_ID,
      this.INSURANCE,
      this.ON_HOLD,
      this.HOLD_DATE,
      this.HOLD_TILL_DATE,
      this.PENSIONER_ID,
      this.REASON_FOR_NONDELIVERY,
      this.REASON_TYPE,
      this.ACTION,
      this.MONEY_TO_BE_COLLECTED,
      this.MONEY_COLLECTED,
      this.POST_DUE,
      this.DEM_CHARGE,
      this.COMMISSION,
      this.MONEY_TO_BE_DELIVERED,
      this.MONEY_DELIVERED,
      this.NO_OF_HOLD_DAYS,
      this.DATE_OF_DELIVERY,
      this.DATE_OF_DELIVERY_CONFIRM,
      this.TIME_OF_DELIVERY_CONFIRM,
      this.DATE_OF_1ST_DELIVERY_CONFIRM,
      this.DATE_OF_2ND_DELIVERY_CONFIRM,
      this.DATE_OF_3RD_DELIVERY_CONFIRM,
      this.DELIVERY_TIME,
      this.DEL_DATE,
      this.ID_PROOF_DOC,
      this.ID_PROOF_NMBR,
      this.ISSUING_AUTHORITY,
      this.ID_PROOF_VALIDITY_DATE,
      this.WINDOW_DELIVERY,
      this.REDIRECTION_FEE,
      this.RETRN_DATE,
      this.RETRN_TIME,
      this.BEAT_NO,
      this.PERNR,
      this.ART_STATUS,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.REMARKS,
      this.ZCONDITION,
      this.TOTAL_MONEY,
      this.POSTAGE_NOT_COLLECTED,
      this.MOP,
      this.VPP,
      this.BATCH_ID,
      this.SHIFT_NO,
      this.RET_RCL_RDL_STOPDELV_STATUS2,
      this.TYPE_OF_PAYEE,
      this.REDIRECT_PIN,
      this.MOD_PIN,
      this.SOURCE_PINCODE,
      this.DESTN_PINCODE,
      this.EMO_MESSAGE,
      this.REGISTERED,
      this.RETURN_SERVICE,
      this.COD,
      this.RT,
      this.RT_DATE,
      this.RT_TIME,
      this.RD,
      this.RD_DATE,
      this.RD_TIME,
      this.SP,
      this.SP_DATE,
      this.SP_TIME,
      this.POSTE_RESTANTE,
      this.BO_ID,
      this.LAST_CHANGED_USER,
      this.BELNR,
      this.ALREADY_RTN_FLAG,
      this.ALREADY_RD_FLAG,
      this.REDIRECT_BO_ID,
      this.IFS_SOFFICE_NAME,
      this.CHECT,
      this.TREASURY_SUBMIT_DONE,
      this.TREASURY_SUBMIT_DATE,
      this.REDIRECTION_SL,
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.IS_COMMUNICATED,
      this.IS_PREVIOUS_DAY_DEPOSIT,
      this.E_PROOF,
      this.MATNR,
      this.CASH_ID,
      this.REMARK_DATE,
      this.CASH_RETURNED,
      this.FILE_NAME,
      this.REPORTING_SO_ID,
      this.despatchStatus,
      this.CUST_DUTY,
      this.BO_SLIP,
      this.ZIP_FILE_NAME) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Delivery.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ART_NUMBER = o['ART_NUMBER'].toString();
    if (o['invoiceDate'] != null) {
      invoiceDate = o['invoiceDate'].toString();
    }
    if (o['invoiced'] != null) {
      invoiced = o['invoiced'].toString();
    }
    if (o['SOFFICE_ID '] != null) {
      SOFFICE_ID = o['SOFFICE_ID '].toString();
    }
    if (o['DOFFICE_ID'] != null) {
      DOFFICE_ID = o['DOFFICE_ID'].toString();
    }
    if (o['BOOK_DATE'] != null) {
      BOOK_DATE = o['BOOK_DATE'].toString();
    }
    if (o['BOOK_ID'] != null) {
      BOOK_ID = o['BOOK_ID'].toString();
    }
    if (o['LINE_ITEM'] != null) {
      LINE_ITEM = double.tryParse(o['LINE_ITEM'].toString());
    }
    if (o['BAG_ID'] != null) {
      BAG_ID = o['BAG_ID'].toString();
    }
    if (o['INSURANCE'] != null) {
      INSURANCE = o['INSURANCE'].toString();
    }
    if (o['ON_HOLD'] != null) {
      ON_HOLD = o['ON_HOLD'].toString();
    }
    if (o['HOLD_DATE'] != null) {
      HOLD_DATE = int.tryParse(o['HOLD_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['HOLD_DATE'].toString())!)
          : DateTime.tryParse(o['HOLD_DATE'].toString());
    }
    if (o['HOLD_TILL_DATE'] != null) {
      HOLD_TILL_DATE = int.tryParse(o['HOLD_TILL_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['HOLD_TILL_DATE'].toString())!)
          : DateTime.tryParse(o['HOLD_TILL_DATE'].toString());
    }
    if (o['PENSIONER_ID'] != null) {
      PENSIONER_ID = o['PENSIONER_ID'].toString();
    }
    if (o['REASON_FOR_NONDELIVERY'] != null) {
      REASON_FOR_NONDELIVERY = o['REASON_FOR_NONDELIVERY'].toString();
    }
    if (o['REASON_TYPE'] != null) {
      REASON_TYPE = o['REASON_TYPE'].toString();
    }
    if (o['ACTION'] != null) {
      ACTION = o['ACTION'].toString();
    }
    if (o['MONEY_TO_BE_COLLECTED'] != null) {
      MONEY_TO_BE_COLLECTED =
          double.tryParse(o['MONEY_TO_BE_COLLECTED'].toString());
    }
    if (o['MONEY_COLLECTED'] != null) {
      MONEY_COLLECTED = double.tryParse(o['MONEY_COLLECTED'].toString());
    }
    if (o['POST_DUE'] != null) {
      POST_DUE = double.tryParse(o['POST_DUE'].toString());
    }
    if (o['DEM_CHARGE'] != null) {
      DEM_CHARGE = double.tryParse(o['DEM_CHARGE'].toString());
    }
    if (o['COMMISSION'] != null) {
      COMMISSION = double.tryParse(o['COMMISSION'].toString());
    }
    if (o['MONEY_TO_BE_DELIVERED'] != null) {
      MONEY_TO_BE_DELIVERED =
          double.tryParse(o['MONEY_TO_BE_DELIVERED'].toString());
    }
    if (o['MONEY_DELIVERED'] != null) {
      MONEY_DELIVERED = double.tryParse(o['MONEY_DELIVERED'].toString());
    }
    if (o['NO_OF_HOLD_DAYS'] != null) {
      NO_OF_HOLD_DAYS = double.tryParse(o['NO_OF_HOLD_DAYS'].toString());
    }
    if (o['DATE_OF_DELIVERY'] != null) {
      DATE_OF_DELIVERY = int.tryParse(o['DATE_OF_DELIVERY'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['DATE_OF_DELIVERY'].toString())!)
          : DateTime.tryParse(o['DATE_OF_DELIVERY'].toString());
    }
    if (o['DATE_OF_DELIVERY_CONFIRM'] != null) {
      DATE_OF_DELIVERY_CONFIRM =
          int.tryParse(o['DATE_OF_DELIVERY_CONFIRM'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['DATE_OF_DELIVERY_CONFIRM'].toString())!)
              : DateTime.tryParse(o['DATE_OF_DELIVERY_CONFIRM'].toString());
    }
    if (o['TIME_OF_DELIVERY_CONFIRM'] != null) {
      TIME_OF_DELIVERY_CONFIRM =
          int.tryParse(o['TIME_OF_DELIVERY_CONFIRM'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['TIME_OF_DELIVERY_CONFIRM'].toString())!)
              : DateTime.tryParse(o['TIME_OF_DELIVERY_CONFIRM'].toString());
    }
    if (o['DATE_OF_1ST_DELIVERY_CONFIRM'] != null) {
      DATE_OF_1ST_DELIVERY_CONFIRM =
          int.tryParse(o['DATE_OF_1ST_DELIVERY_CONFIRM'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['DATE_OF_1ST_DELIVERY_CONFIRM'].toString())!)
              : DateTime.tryParse(o['DATE_OF_1ST_DELIVERY_CONFIRM'].toString());
    }
    if (o['DATE_OF_2ND_DELIVERY_CONFIRM'] != null) {
      DATE_OF_2ND_DELIVERY_CONFIRM =
          int.tryParse(o['DATE_OF_2ND_DELIVERY_CONFIRM'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['DATE_OF_2ND_DELIVERY_CONFIRM'].toString())!)
              : DateTime.tryParse(o['DATE_OF_2ND_DELIVERY_CONFIRM'].toString());
    }
    if (o['DATE_OF_3RD_DELIVERY_CONFIRM'] != null) {
      DATE_OF_3RD_DELIVERY_CONFIRM =
          int.tryParse(o['DATE_OF_3RD_DELIVERY_CONFIRM'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['DATE_OF_3RD_DELIVERY_CONFIRM'].toString())!)
              : DateTime.tryParse(o['DATE_OF_3RD_DELIVERY_CONFIRM'].toString());
    }
    if (o['DELIVERY_TIME'] != null) {
      DELIVERY_TIME = int.tryParse(o['DELIVERY_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['DELIVERY_TIME'].toString())!)
          : DateTime.tryParse(o['DELIVERY_TIME'].toString());
    }
    if (o['DEL_DATE'] != null) {
      DEL_DATE = int.tryParse(o['DEL_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['DEL_DATE'].toString())!)
          : DateTime.tryParse(o['DEL_DATE'].toString());
    }
    if (o['ID_PROOF_DOC'] != null) {
      ID_PROOF_DOC = o['ID_PROOF_DOC'].toString();
    }
    if (o['ID_PROOF_NMBR'] != null) {
      ID_PROOF_NMBR = o['ID_PROOF_NMBR'].toString();
    }
    if (o['ISSUING_AUTHORITY'] != null) {
      ISSUING_AUTHORITY = o['ISSUING_AUTHORITY'].toString();
    }
    if (o['ID_PROOF_VALIDITY_DATE'] != null) {
      ID_PROOF_VALIDITY_DATE =
          int.tryParse(o['ID_PROOF_VALIDITY_DATE'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['ID_PROOF_VALIDITY_DATE'].toString())!)
              : DateTime.tryParse(o['ID_PROOF_VALIDITY_DATE'].toString());
    }
    if (o['WINDOW_DELIVERY'] != null) {
      WINDOW_DELIVERY = o['WINDOW_DELIVERY'].toString();
    }
    if (o['REDIRECTION_FEE'] != null) {
      REDIRECTION_FEE = double.tryParse(o['REDIRECTION_FEE'].toString());
    }
    if (o['RETRN_DATE'] != null) {
      RETRN_DATE = int.tryParse(o['RETRN_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RETRN_DATE'].toString())!)
          : DateTime.tryParse(o['RETRN_DATE'].toString());
    }
    if (o['RETRN_TIME'] != null) {
      RETRN_TIME = int.tryParse(o['RETRN_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RETRN_TIME'].toString())!)
          : DateTime.tryParse(o['RETRN_TIME'].toString());
    }
    if (o['BEAT_NO'] != null) {
      BEAT_NO = o['BEAT_NO'].toString();
    }
    if (o['PERNR'] != null) {
      PERNR = double.tryParse(o['PERNR'].toString());
    }
    if (o['ART_STATUS'] != null) {
      ART_STATUS = o['ART_STATUS'].toString();
    }
    if (o['ART_RECEIVE_DATE'] != null) {
      ART_RECEIVE_DATE = o['ART_RECEIVE_DATE'].toString();
    }
    if (o['ART_RECEIVE_TIME'] != null) {
      ART_RECEIVE_TIME = o['ART_RECEIVE_TIME'].toString();
    }
    if (o['REMARKS'] != null) {
      REMARKS = o['REMARKS'].toString();
    }
    if (o['ZCONDITION'] != null) {
      ZCONDITION = o['ZCONDITION'].toString();
    }
    if (o['TOTAL_MONEY'] != null) {
      TOTAL_MONEY = double.tryParse(o['TOTAL_MONEY'].toString());
    }
    if (o['POSTAGE_NOT_COLLECTED'] != null) {
      POSTAGE_NOT_COLLECTED =
          double.tryParse(o['POSTAGE_NOT_COLLECTED'].toString());
    }
    if (o['MOP'] != null) {
      MOP = o['MOP'].toString();
    }
    if (o['VPP'] != null) {
      VPP = o['VPP'].toString();
    }
    if (o['BATCH_ID'] != null) {
      BATCH_ID = o['BATCH_ID'].toString();
    }
    if (o['SHIFT_NO'] != null) {
      SHIFT_NO = o['SHIFT_NO'].toString();
    }
    if (o['RET_RCL_RDL_STOPDELV_STATUS2'] != null) {
      RET_RCL_RDL_STOPDELV_STATUS2 =
          o['RET_RCL_RDL_STOPDELV_STATUS2'].toString();
    }
    if (o['TYPE_OF_PAYEE'] != null) {
      TYPE_OF_PAYEE = o['TYPE_OF_PAYEE'].toString();
    }
    if (o['REDIRECT_PIN'] != null) {
      REDIRECT_PIN = int.tryParse(o['REDIRECT_PIN'].toString());
    }
    if (o['MOD_PIN'] != null) {
      MOD_PIN = int.tryParse(o['MOD_PIN'].toString());
    }
    if (o['SOURCE_PINCODE'] != null) {
      SOURCE_PINCODE = int.tryParse(o['SOURCE_PINCODE'].toString());
    }
    if (o['DESTN_PINCODE'] != null) {
      DESTN_PINCODE = int.tryParse(o['DESTN_PINCODE'].toString());
    }
    if (o['EMO_MESSAGE'] != null) {
      EMO_MESSAGE = o['EMO_MESSAGE'].toString();
    }
    if (o['REGISTERED'] != null) {
      REGISTERED = o['REGISTERED'].toString();
    }
    if (o['RETURN_SERVICE'] != null) {
      RETURN_SERVICE = o['RETURN_SERVICE'].toString();
    }
    if (o['COD'] != null) {
      COD = o['COD'].toString();
    }
    if (o['RT'] != null) {
      RT = o['RT'].toString();
    }
    if (o['RT_DATE'] != null) {
      RT_DATE = int.tryParse(o['RT_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RT_DATE'].toString())!)
          : DateTime.tryParse(o['RT_DATE'].toString());
    }
    if (o['RT_TIME'] != null) {
      RT_TIME = int.tryParse(o['RT_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RT_TIME'].toString())!)
          : DateTime.tryParse(o['RT_TIME'].toString());
    }
    if (o['RD'] != null) {
      RD = o['RD'].toString();
    }
    if (o['RD_DATE'] != null) {
      RD_DATE = int.tryParse(o['RD_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RD_DATE'].toString())!)
          : DateTime.tryParse(o['RD_DATE'].toString());
    }
    if (o['RD_TIME'] != null) {
      RD_TIME = int.tryParse(o['RD_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['RD_TIME'].toString())!)
          : DateTime.tryParse(o['RD_TIME'].toString());
    }
    if (o['SP'] != null) {
      SP = o['SP'].toString();
    }
    if (o['SP_DATE'] != null) {
      SP_DATE = int.tryParse(o['SP_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['SP_DATE'].toString())!)
          : DateTime.tryParse(o['SP_DATE'].toString());
    }
    if (o['SP_TIME'] != null) {
      SP_TIME = int.tryParse(o['SP_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['SP_TIME'].toString())!)
          : DateTime.tryParse(o['SP_TIME'].toString());
    }
    if (o['POSTE_RESTANTE'] != null) {
      POSTE_RESTANTE = o['POSTE_RESTANTE'].toString();
    }
    if (o['BO_ID'] != null) {
      BO_ID = o['BO_ID'].toString();
    }
    if (o['LAST_CHANGED_USER'] != null) {
      LAST_CHANGED_USER = o['LAST_CHANGED_USER'].toString();
    }
    if (o['BELNR'] != null) {
      BELNR = o['BELNR'].toString();
    }
    if (o['ALREADY_RTN_FLAG'] != null) {
      ALREADY_RTN_FLAG = o['ALREADY_RTN_FLAG'].toString();
    }
    if (o['ALREADY_RD_FLAG'] != null) {
      ALREADY_RD_FLAG = o['ALREADY_RD_FLAG'].toString();
    }
    if (o['REDIRECT_BO_ID'] != null) {
      REDIRECT_BO_ID = o['REDIRECT_BO_ID'].toString();
    }
    if (o['IFS_SOFFICE_NAME'] != null) {
      IFS_SOFFICE_NAME = o['IFS_SOFFICE_NAME'].toString();
    }
    if (o['CHECT'] != null) {
      CHECT = o['CHECT'].toString();
    }
    if (o['TREASURY_SUBMIT_DONE'] != null) {
      TREASURY_SUBMIT_DONE = o['TREASURY_SUBMIT_DONE'].toString();
    }
    if (o['TREASURY_SUBMIT_DATE'] != null) {
      TREASURY_SUBMIT_DATE =
          int.tryParse(o['TREASURY_SUBMIT_DATE'].toString()) != null
              ? DateTime.fromMillisecondsSinceEpoch(
                  int.tryParse(o['TREASURY_SUBMIT_DATE'].toString())!)
              : DateTime.tryParse(o['TREASURY_SUBMIT_DATE'].toString());
    }
    if (o['REDIRECTION_SL'] != null) {
      REDIRECTION_SL = double.tryParse(o['REDIRECTION_SL'].toString());
    }
    if (o['TRANSACTION_DATE'] != null) {
      TRANSACTION_DATE = int.tryParse(o['TRANSACTION_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['TRANSACTION_DATE'].toString())!)
          : DateTime.tryParse(o['TRANSACTION_DATE'].toString());
    }
    if (o['TRANSACTION_TIME'] != null) {
      TRANSACTION_TIME = int.tryParse(o['TRANSACTION_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['TRANSACTION_TIME'].toString())!)
          : DateTime.tryParse(o['TRANSACTION_TIME'].toString());
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['IS_PREVIOUS_DAY_DEPOSIT'] != null) {
      IS_PREVIOUS_DAY_DEPOSIT = o['IS_PREVIOUS_DAY_DEPOSIT'].toString();
    }
    if (o['E_PROOF'] != null) {
      E_PROOF = o['E_PROOF'].toString();
    }
    if (o['MATNR'] != null) {
      MATNR = o['MATNR'].toString();
    }
    if (o['CASH_ID'] != null) {
      CASH_ID = o['CASH_ID'].toString();
    }
    if (o['REMARK_DATE'] != null) {
      REMARK_DATE = int.tryParse(o['REMARK_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['REMARK_DATE'].toString())!)
          : DateTime.tryParse(o['REMARK_DATE'].toString());
    }
    if (o['CASH_RETURNED'] != null) {
      CASH_RETURNED = o['CASH_RETURNED'].toString();
    }
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
    if (o['REPORTING_SO_ID'] != null) {
      REPORTING_SO_ID = o['REPORTING_SO_ID'].toString();
    }
    if (o['despatchStatus'] != null) {
      despatchStatus = o['despatchStatus'].toString();
    }
    if (o['CUST_DUTY'] != null) {
      CUST_DUTY = double.tryParse(o['CUST_DUTY'].toString());
    }
    if (o['BO_SLIP'] != null) {
      BO_SLIP = o['BO_SLIP'].toString();
    }
    if (o['ZIP_FILE_NAME'] != null) {
      ZIP_FILE_NAME = o['ZIP_FILE_NAME'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Delivery)
  String? ART_NUMBER;
  String? invoiceDate;
  String? invoiced;
  String? SOFFICE_ID;
  String? DOFFICE_ID;
  String? BOOK_DATE;
  String? BOOK_ID;
  double? LINE_ITEM;
  String? BAG_ID;
  String? INSURANCE;
  String? ON_HOLD;
  DateTime? HOLD_DATE;
  DateTime? HOLD_TILL_DATE;
  String? PENSIONER_ID;
  String? REASON_FOR_NONDELIVERY;
  String? REASON_TYPE;
  String? ACTION;
  double? MONEY_TO_BE_COLLECTED;
  double? MONEY_COLLECTED;
  double? POST_DUE;
  double? DEM_CHARGE;
  double? COMMISSION;
  double? MONEY_TO_BE_DELIVERED;
  double? MONEY_DELIVERED;
  double? NO_OF_HOLD_DAYS;
  DateTime? DATE_OF_DELIVERY;
  DateTime? DATE_OF_DELIVERY_CONFIRM;
  DateTime? TIME_OF_DELIVERY_CONFIRM;
  DateTime? DATE_OF_1ST_DELIVERY_CONFIRM;
  DateTime? DATE_OF_2ND_DELIVERY_CONFIRM;
  DateTime? DATE_OF_3RD_DELIVERY_CONFIRM;
  DateTime? DELIVERY_TIME;
  DateTime? DEL_DATE;
  String? ID_PROOF_DOC;
  String? ID_PROOF_NMBR;
  String? ISSUING_AUTHORITY;
  DateTime? ID_PROOF_VALIDITY_DATE;
  String? WINDOW_DELIVERY;
  double? REDIRECTION_FEE;
  DateTime? RETRN_DATE;
  DateTime? RETRN_TIME;
  String? BEAT_NO;
  double? PERNR;
  String? ART_STATUS;
  String? ART_RECEIVE_DATE;
  String? ART_RECEIVE_TIME;
  String? REMARKS;
  String? ZCONDITION;
  double? TOTAL_MONEY;
  double? POSTAGE_NOT_COLLECTED;
  String? MOP;
  String? VPP;
  String? BATCH_ID;
  String? SHIFT_NO;
  String? RET_RCL_RDL_STOPDELV_STATUS2;
  String? TYPE_OF_PAYEE;
  int? REDIRECT_PIN;
  int? MOD_PIN;
  int? SOURCE_PINCODE;
  int? DESTN_PINCODE;
  String? EMO_MESSAGE;
  String? REGISTERED;
  String? RETURN_SERVICE;
  String? COD;
  String? RT;
  DateTime? RT_DATE;
  DateTime? RT_TIME;
  String? RD;
  DateTime? RD_DATE;
  DateTime? RD_TIME;
  String? SP;
  DateTime? SP_DATE;
  DateTime? SP_TIME;
  String? POSTE_RESTANTE;
  String? BO_ID;
  String? LAST_CHANGED_USER;
  String? BELNR;
  String? ALREADY_RTN_FLAG;
  String? ALREADY_RD_FLAG;
  String? REDIRECT_BO_ID;
  String? IFS_SOFFICE_NAME;
  String? CHECT;
  String? TREASURY_SUBMIT_DONE;
  DateTime? TREASURY_SUBMIT_DATE;
  double? REDIRECTION_SL;
  DateTime? TRANSACTION_DATE;
  DateTime? TRANSACTION_TIME;
  String? IS_COMMUNICATED;
  String? IS_PREVIOUS_DAY_DEPOSIT;
  String? E_PROOF;
  String? MATNR;
  String? CASH_ID;
  DateTime? REMARK_DATE;
  String? CASH_RETURNED;
  String? FILE_NAME;
  String? REPORTING_SO_ID;
  String? despatchStatus;
  double? CUST_DUTY;
  String? BO_SLIP;
  String? ZIP_FILE_NAME;
  bool? isSaved;
  // end FIELDS (Delivery)

  static const bool _softDeleteActivated = false;
  DeliveryManager? __mnDelivery;

  DeliveryManager get _mnDelivery {
    return __mnDelivery = __mnDelivery ?? DeliveryManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ART_NUMBER'] = ART_NUMBER;
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (invoiced != null || !forView) {
      map['invoiced'] = invoiced;
    }
    if (SOFFICE_ID != null || !forView) {
      map['SOFFICE_ID '] = SOFFICE_ID;
    }
    if (DOFFICE_ID != null || !forView) {
      map['DOFFICE_ID'] = DOFFICE_ID;
    }
    if (BOOK_DATE != null || !forView) {
      map['BOOK_DATE'] = BOOK_DATE;
    }
    if (BOOK_ID != null || !forView) {
      map['BOOK_ID'] = BOOK_ID;
    }
    if (LINE_ITEM != null || !forView) {
      map['LINE_ITEM'] = LINE_ITEM;
    }
    if (BAG_ID != null || !forView) {
      map['BAG_ID'] = BAG_ID;
    }
    if (INSURANCE != null || !forView) {
      map['INSURANCE'] = INSURANCE;
    }
    if (ON_HOLD != null || !forView) {
      map['ON_HOLD'] = ON_HOLD;
    }
    if (HOLD_DATE != null) {
      map['HOLD_DATE'] = forJson
          ? '$HOLD_DATE!.year-$HOLD_DATE!.month-$HOLD_DATE!.day'
          : forQuery
              ? DateTime(HOLD_DATE!.year, HOLD_DATE!.month, HOLD_DATE!.day)
                  .millisecondsSinceEpoch
              : HOLD_DATE;
    } else if (HOLD_DATE != null || !forView) {
      map['HOLD_DATE'] = null;
    }
    if (HOLD_TILL_DATE != null) {
      map['HOLD_TILL_DATE'] = forJson
          ? '$HOLD_TILL_DATE!.year-$HOLD_TILL_DATE!.month-$HOLD_TILL_DATE!.day'
          : forQuery
              ? DateTime(HOLD_TILL_DATE!.year, HOLD_TILL_DATE!.month,
                      HOLD_TILL_DATE!.day)
                  .millisecondsSinceEpoch
              : HOLD_TILL_DATE;
    } else if (HOLD_TILL_DATE != null || !forView) {
      map['HOLD_TILL_DATE'] = null;
    }
    if (PENSIONER_ID != null || !forView) {
      map['PENSIONER_ID'] = PENSIONER_ID;
    }
    if (REASON_FOR_NONDELIVERY != null || !forView) {
      map['REASON_FOR_NONDELIVERY'] = REASON_FOR_NONDELIVERY;
    }
    if (REASON_TYPE != null || !forView) {
      map['REASON_TYPE'] = REASON_TYPE;
    }
    if (ACTION != null || !forView) {
      map['ACTION'] = ACTION;
    }
    if (MONEY_TO_BE_COLLECTED != null || !forView) {
      map['MONEY_TO_BE_COLLECTED'] = MONEY_TO_BE_COLLECTED;
    }
    if (MONEY_COLLECTED != null || !forView) {
      map['MONEY_COLLECTED'] = MONEY_COLLECTED;
    }
    if (POST_DUE != null || !forView) {
      map['POST_DUE'] = POST_DUE;
    }
    if (DEM_CHARGE != null || !forView) {
      map['DEM_CHARGE'] = DEM_CHARGE;
    }
    if (COMMISSION != null || !forView) {
      map['COMMISSION'] = COMMISSION;
    }
    if (MONEY_TO_BE_DELIVERED != null || !forView) {
      map['MONEY_TO_BE_DELIVERED'] = MONEY_TO_BE_DELIVERED;
    }
    if (MONEY_DELIVERED != null || !forView) {
      map['MONEY_DELIVERED'] = MONEY_DELIVERED;
    }
    if (NO_OF_HOLD_DAYS != null || !forView) {
      map['NO_OF_HOLD_DAYS'] = NO_OF_HOLD_DAYS;
    }
    if (DATE_OF_DELIVERY != null) {
      map['DATE_OF_DELIVERY'] = forJson
          ? '$DATE_OF_DELIVERY!.year-$DATE_OF_DELIVERY!.month-$DATE_OF_DELIVERY!.day'
          : forQuery
              ? DateTime(DATE_OF_DELIVERY!.year, DATE_OF_DELIVERY!.month,
                      DATE_OF_DELIVERY!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_DELIVERY;
    } else if (DATE_OF_DELIVERY != null || !forView) {
      map['DATE_OF_DELIVERY'] = null;
    }
    if (DATE_OF_DELIVERY_CONFIRM != null) {
      map['DATE_OF_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_DELIVERY_CONFIRM!.year-$DATE_OF_DELIVERY_CONFIRM!.month-$DATE_OF_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_DELIVERY_CONFIRM!.year,
                      DATE_OF_DELIVERY_CONFIRM!.month,
                      DATE_OF_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_DELIVERY_CONFIRM;
    } else if (DATE_OF_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_DELIVERY_CONFIRM'] = null;
    }
    if (TIME_OF_DELIVERY_CONFIRM != null) {
      map['TIME_OF_DELIVERY_CONFIRM'] = forJson
          ? TIME_OF_DELIVERY_CONFIRM!.toString()
          : forQuery
              ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
              : TIME_OF_DELIVERY_CONFIRM;
    } else if (TIME_OF_DELIVERY_CONFIRM != null || !forView) {
      map['TIME_OF_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_1ST_DELIVERY_CONFIRM != null) {
      map['DATE_OF_1ST_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_1ST_DELIVERY_CONFIRM!.year-$DATE_OF_1ST_DELIVERY_CONFIRM!.month-$DATE_OF_1ST_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_1ST_DELIVERY_CONFIRM!.year,
                      DATE_OF_1ST_DELIVERY_CONFIRM!.month,
                      DATE_OF_1ST_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_1ST_DELIVERY_CONFIRM;
    } else if (DATE_OF_1ST_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_1ST_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_2ND_DELIVERY_CONFIRM != null) {
      map['DATE_OF_2ND_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_2ND_DELIVERY_CONFIRM!.year-$DATE_OF_2ND_DELIVERY_CONFIRM!.month-$DATE_OF_2ND_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_2ND_DELIVERY_CONFIRM!.year,
                      DATE_OF_2ND_DELIVERY_CONFIRM!.month,
                      DATE_OF_2ND_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_2ND_DELIVERY_CONFIRM;
    } else if (DATE_OF_2ND_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_2ND_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_3RD_DELIVERY_CONFIRM != null) {
      map['DATE_OF_3RD_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_3RD_DELIVERY_CONFIRM!.year-$DATE_OF_3RD_DELIVERY_CONFIRM!.month-$DATE_OF_3RD_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_3RD_DELIVERY_CONFIRM!.year,
                      DATE_OF_3RD_DELIVERY_CONFIRM!.month,
                      DATE_OF_3RD_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_3RD_DELIVERY_CONFIRM;
    } else if (DATE_OF_3RD_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_3RD_DELIVERY_CONFIRM'] = null;
    }
    if (DELIVERY_TIME != null) {
      map['DELIVERY_TIME'] = forJson
          ? DELIVERY_TIME!.toString()
          : forQuery
              ? DELIVERY_TIME!.millisecondsSinceEpoch
              : DELIVERY_TIME;
    } else if (DELIVERY_TIME != null || !forView) {
      map['DELIVERY_TIME'] = null;
    }
    if (DEL_DATE != null) {
      map['DEL_DATE'] = forJson
          ? '$DEL_DATE!.year-$DEL_DATE!.month-$DEL_DATE!.day'
          : forQuery
              ? DateTime(DEL_DATE!.year, DEL_DATE!.month, DEL_DATE!.day)
                  .millisecondsSinceEpoch
              : DEL_DATE;
    } else if (DEL_DATE != null || !forView) {
      map['DEL_DATE'] = null;
    }
    if (ID_PROOF_DOC != null || !forView) {
      map['ID_PROOF_DOC'] = ID_PROOF_DOC;
    }
    if (ID_PROOF_NMBR != null || !forView) {
      map['ID_PROOF_NMBR'] = ID_PROOF_NMBR;
    }
    if (ISSUING_AUTHORITY != null || !forView) {
      map['ISSUING_AUTHORITY'] = ISSUING_AUTHORITY;
    }
    if (ID_PROOF_VALIDITY_DATE != null) {
      map['ID_PROOF_VALIDITY_DATE'] = forJson
          ? '$ID_PROOF_VALIDITY_DATE!.year-$ID_PROOF_VALIDITY_DATE!.month-$ID_PROOF_VALIDITY_DATE!.day'
          : forQuery
              ? DateTime(
                      ID_PROOF_VALIDITY_DATE!.year,
                      ID_PROOF_VALIDITY_DATE!.month,
                      ID_PROOF_VALIDITY_DATE!.day)
                  .millisecondsSinceEpoch
              : ID_PROOF_VALIDITY_DATE;
    } else if (ID_PROOF_VALIDITY_DATE != null || !forView) {
      map['ID_PROOF_VALIDITY_DATE'] = null;
    }
    if (WINDOW_DELIVERY != null || !forView) {
      map['WINDOW_DELIVERY'] = WINDOW_DELIVERY;
    }
    if (REDIRECTION_FEE != null || !forView) {
      map['REDIRECTION_FEE'] = REDIRECTION_FEE;
    }
    if (RETRN_DATE != null) {
      map['RETRN_DATE'] = forJson
          ? '$RETRN_DATE!.year-$RETRN_DATE!.month-$RETRN_DATE!.day'
          : forQuery
              ? DateTime(RETRN_DATE!.year, RETRN_DATE!.month, RETRN_DATE!.day)
                  .millisecondsSinceEpoch
              : RETRN_DATE;
    } else if (RETRN_DATE != null || !forView) {
      map['RETRN_DATE'] = null;
    }
    if (RETRN_TIME != null) {
      map['RETRN_TIME'] = forJson
          ? RETRN_TIME!.toString()
          : forQuery
              ? RETRN_TIME!.millisecondsSinceEpoch
              : RETRN_TIME;
    } else if (RETRN_TIME != null || !forView) {
      map['RETRN_TIME'] = null;
    }
    if (BEAT_NO != null || !forView) {
      map['BEAT_NO'] = BEAT_NO;
    }
    if (PERNR != null || !forView) {
      map['PERNR'] = PERNR;
    }
    if (ART_STATUS != null || !forView) {
      map['ART_STATUS'] = ART_STATUS;
    }
    if (ART_RECEIVE_DATE != null || !forView) {
      map['ART_RECEIVE_DATE'] = ART_RECEIVE_DATE;
    }
    if (ART_RECEIVE_TIME != null || !forView) {
      map['ART_RECEIVE_TIME'] = ART_RECEIVE_TIME;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (ZCONDITION != null || !forView) {
      map['ZCONDITION'] = ZCONDITION;
    }
    if (TOTAL_MONEY != null || !forView) {
      map['TOTAL_MONEY'] = TOTAL_MONEY;
    }
    if (POSTAGE_NOT_COLLECTED != null || !forView) {
      map['POSTAGE_NOT_COLLECTED'] = POSTAGE_NOT_COLLECTED;
    }
    if (MOP != null || !forView) {
      map['MOP'] = MOP;
    }
    if (VPP != null || !forView) {
      map['VPP'] = VPP;
    }
    if (BATCH_ID != null || !forView) {
      map['BATCH_ID'] = BATCH_ID;
    }
    if (SHIFT_NO != null || !forView) {
      map['SHIFT_NO'] = SHIFT_NO;
    }
    if (RET_RCL_RDL_STOPDELV_STATUS2 != null || !forView) {
      map['RET_RCL_RDL_STOPDELV_STATUS2'] = RET_RCL_RDL_STOPDELV_STATUS2;
    }
    if (TYPE_OF_PAYEE != null || !forView) {
      map['TYPE_OF_PAYEE'] = TYPE_OF_PAYEE;
    }
    if (REDIRECT_PIN != null || !forView) {
      map['REDIRECT_PIN'] = REDIRECT_PIN;
    }
    if (MOD_PIN != null || !forView) {
      map['MOD_PIN'] = MOD_PIN;
    }
    if (SOURCE_PINCODE != null || !forView) {
      map['SOURCE_PINCODE'] = SOURCE_PINCODE;
    }
    if (DESTN_PINCODE != null || !forView) {
      map['DESTN_PINCODE'] = DESTN_PINCODE;
    }
    if (EMO_MESSAGE != null || !forView) {
      map['EMO_MESSAGE'] = EMO_MESSAGE;
    }
    if (REGISTERED != null || !forView) {
      map['REGISTERED'] = REGISTERED;
    }
    if (RETURN_SERVICE != null || !forView) {
      map['RETURN_SERVICE'] = RETURN_SERVICE;
    }
    if (COD != null || !forView) {
      map['COD'] = COD;
    }
    if (RT != null || !forView) {
      map['RT'] = RT;
    }
    if (RT_DATE != null) {
      map['RT_DATE'] = forJson
          ? '$RT_DATE!.year-$RT_DATE!.month-$RT_DATE!.day'
          : forQuery
              ? DateTime(RT_DATE!.year, RT_DATE!.month, RT_DATE!.day)
                  .millisecondsSinceEpoch
              : RT_DATE;
    } else if (RT_DATE != null || !forView) {
      map['RT_DATE'] = null;
    }
    if (RT_TIME != null) {
      map['RT_TIME'] = forJson
          ? RT_TIME!.toString()
          : forQuery
              ? RT_TIME!.millisecondsSinceEpoch
              : RT_TIME;
    } else if (RT_TIME != null || !forView) {
      map['RT_TIME'] = null;
    }
    if (RD != null || !forView) {
      map['RD'] = RD;
    }
    if (RD_DATE != null) {
      map['RD_DATE'] = forJson
          ? '$RD_DATE!.year-$RD_DATE!.month-$RD_DATE!.day'
          : forQuery
              ? DateTime(RD_DATE!.year, RD_DATE!.month, RD_DATE!.day)
                  .millisecondsSinceEpoch
              : RD_DATE;
    } else if (RD_DATE != null || !forView) {
      map['RD_DATE'] = null;
    }
    if (RD_TIME != null) {
      map['RD_TIME'] = forJson
          ? RD_TIME!.toString()
          : forQuery
              ? RD_TIME!.millisecondsSinceEpoch
              : RD_TIME;
    } else if (RD_TIME != null || !forView) {
      map['RD_TIME'] = null;
    }
    if (SP != null || !forView) {
      map['SP'] = SP;
    }
    if (SP_DATE != null) {
      map['SP_DATE'] = forJson
          ? '$SP_DATE!.year-$SP_DATE!.month-$SP_DATE!.day'
          : forQuery
              ? DateTime(SP_DATE!.year, SP_DATE!.month, SP_DATE!.day)
                  .millisecondsSinceEpoch
              : SP_DATE;
    } else if (SP_DATE != null || !forView) {
      map['SP_DATE'] = null;
    }
    if (SP_TIME != null) {
      map['SP_TIME'] = forJson
          ? SP_TIME!.toString()
          : forQuery
              ? SP_TIME!.millisecondsSinceEpoch
              : SP_TIME;
    } else if (SP_TIME != null || !forView) {
      map['SP_TIME'] = null;
    }
    if (POSTE_RESTANTE != null || !forView) {
      map['POSTE_RESTANTE'] = POSTE_RESTANTE;
    }
    if (BO_ID != null || !forView) {
      map['BO_ID'] = BO_ID;
    }
    if (LAST_CHANGED_USER != null || !forView) {
      map['LAST_CHANGED_USER'] = LAST_CHANGED_USER;
    }
    if (BELNR != null || !forView) {
      map['BELNR'] = BELNR;
    }
    if (ALREADY_RTN_FLAG != null || !forView) {
      map['ALREADY_RTN_FLAG'] = ALREADY_RTN_FLAG;
    }
    if (ALREADY_RD_FLAG != null || !forView) {
      map['ALREADY_RD_FLAG'] = ALREADY_RD_FLAG;
    }
    if (REDIRECT_BO_ID != null || !forView) {
      map['REDIRECT_BO_ID'] = REDIRECT_BO_ID;
    }
    if (IFS_SOFFICE_NAME != null || !forView) {
      map['IFS_SOFFICE_NAME'] = IFS_SOFFICE_NAME;
    }
    if (CHECT != null || !forView) {
      map['CHECT'] = CHECT;
    }
    if (TREASURY_SUBMIT_DONE != null || !forView) {
      map['TREASURY_SUBMIT_DONE'] = TREASURY_SUBMIT_DONE;
    }
    if (TREASURY_SUBMIT_DATE != null) {
      map['TREASURY_SUBMIT_DATE'] = forJson
          ? '$TREASURY_SUBMIT_DATE!.year-$TREASURY_SUBMIT_DATE!.month-$TREASURY_SUBMIT_DATE!.day'
          : forQuery
              ? DateTime(TREASURY_SUBMIT_DATE!.year,
                      TREASURY_SUBMIT_DATE!.month, TREASURY_SUBMIT_DATE!.day)
                  .millisecondsSinceEpoch
              : TREASURY_SUBMIT_DATE;
    } else if (TREASURY_SUBMIT_DATE != null || !forView) {
      map['TREASURY_SUBMIT_DATE'] = null;
    }
    if (REDIRECTION_SL != null || !forView) {
      map['REDIRECTION_SL'] = REDIRECTION_SL;
    }
    if (TRANSACTION_DATE != null) {
      map['TRANSACTION_DATE'] = forJson
          ? '$TRANSACTION_DATE!.year-$TRANSACTION_DATE!.month-$TRANSACTION_DATE!.day'
          : forQuery
              ? DateTime(TRANSACTION_DATE!.year, TRANSACTION_DATE!.month,
                      TRANSACTION_DATE!.day)
                  .millisecondsSinceEpoch
              : TRANSACTION_DATE;
    } else if (TRANSACTION_DATE != null || !forView) {
      map['TRANSACTION_DATE'] = null;
    }
    if (TRANSACTION_TIME != null) {
      map['TRANSACTION_TIME'] = forJson
          ? TRANSACTION_TIME!.toString()
          : forQuery
              ? TRANSACTION_TIME!.millisecondsSinceEpoch
              : TRANSACTION_TIME;
    } else if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = null;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (IS_PREVIOUS_DAY_DEPOSIT != null || !forView) {
      map['IS_PREVIOUS_DAY_DEPOSIT'] = IS_PREVIOUS_DAY_DEPOSIT;
    }
    if (E_PROOF != null || !forView) {
      map['E_PROOF'] = E_PROOF;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (CASH_ID != null || !forView) {
      map['CASH_ID'] = CASH_ID;
    }
    if (REMARK_DATE != null) {
      map['REMARK_DATE'] = forJson
          ? '$REMARK_DATE!.year-$REMARK_DATE!.month-$REMARK_DATE!.day'
          : forQuery
              ? DateTime(
                      REMARK_DATE!.year, REMARK_DATE!.month, REMARK_DATE!.day)
                  .millisecondsSinceEpoch
              : REMARK_DATE;
    } else if (REMARK_DATE != null || !forView) {
      map['REMARK_DATE'] = null;
    }
    if (CASH_RETURNED != null || !forView) {
      map['CASH_RETURNED'] = CASH_RETURNED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }
    if (REPORTING_SO_ID != null || !forView) {
      map['REPORTING_SO_ID'] = REPORTING_SO_ID;
    }
    if (despatchStatus != null || !forView) {
      map['despatchStatus'] = despatchStatus;
    }
    if (CUST_DUTY != null || !forView) {
      map['CUST_DUTY'] = CUST_DUTY;
    }
    if (BO_SLIP != null || !forView) {
      map['BO_SLIP'] = BO_SLIP;
    }
    if (ZIP_FILE_NAME != null || !forView) {
      map['ZIP_FILE_NAME'] = ZIP_FILE_NAME;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ART_NUMBER'] = ART_NUMBER;
    if (invoiceDate != null || !forView) {
      map['invoiceDate'] = invoiceDate;
    }
    if (invoiced != null || !forView) {
      map['invoiced'] = invoiced;
    }
    if (SOFFICE_ID != null || !forView) {
      map['SOFFICE_ID '] = SOFFICE_ID;
    }
    if (DOFFICE_ID != null || !forView) {
      map['DOFFICE_ID'] = DOFFICE_ID;
    }
    if (BOOK_DATE != null || !forView) {
      map['BOOK_DATE'] = BOOK_DATE;
    }
    if (BOOK_ID != null || !forView) {
      map['BOOK_ID'] = BOOK_ID;
    }
    if (LINE_ITEM != null || !forView) {
      map['LINE_ITEM'] = LINE_ITEM;
    }
    if (BAG_ID != null || !forView) {
      map['BAG_ID'] = BAG_ID;
    }
    if (INSURANCE != null || !forView) {
      map['INSURANCE'] = INSURANCE;
    }
    if (ON_HOLD != null || !forView) {
      map['ON_HOLD'] = ON_HOLD;
    }
    if (HOLD_DATE != null) {
      map['HOLD_DATE'] = forJson
          ? '$HOLD_DATE!.year-$HOLD_DATE!.month-$HOLD_DATE!.day'
          : forQuery
              ? DateTime(HOLD_DATE!.year, HOLD_DATE!.month, HOLD_DATE!.day)
                  .millisecondsSinceEpoch
              : HOLD_DATE;
    } else if (HOLD_DATE != null || !forView) {
      map['HOLD_DATE'] = null;
    }
    if (HOLD_TILL_DATE != null) {
      map['HOLD_TILL_DATE'] = forJson
          ? '$HOLD_TILL_DATE!.year-$HOLD_TILL_DATE!.month-$HOLD_TILL_DATE!.day'
          : forQuery
              ? DateTime(HOLD_TILL_DATE!.year, HOLD_TILL_DATE!.month,
                      HOLD_TILL_DATE!.day)
                  .millisecondsSinceEpoch
              : HOLD_TILL_DATE;
    } else if (HOLD_TILL_DATE != null || !forView) {
      map['HOLD_TILL_DATE'] = null;
    }
    if (PENSIONER_ID != null || !forView) {
      map['PENSIONER_ID'] = PENSIONER_ID;
    }
    if (REASON_FOR_NONDELIVERY != null || !forView) {
      map['REASON_FOR_NONDELIVERY'] = REASON_FOR_NONDELIVERY;
    }
    if (REASON_TYPE != null || !forView) {
      map['REASON_TYPE'] = REASON_TYPE;
    }
    if (ACTION != null || !forView) {
      map['ACTION'] = ACTION;
    }
    if (MONEY_TO_BE_COLLECTED != null || !forView) {
      map['MONEY_TO_BE_COLLECTED'] = MONEY_TO_BE_COLLECTED;
    }
    if (MONEY_COLLECTED != null || !forView) {
      map['MONEY_COLLECTED'] = MONEY_COLLECTED;
    }
    if (POST_DUE != null || !forView) {
      map['POST_DUE'] = POST_DUE;
    }
    if (DEM_CHARGE != null || !forView) {
      map['DEM_CHARGE'] = DEM_CHARGE;
    }
    if (COMMISSION != null || !forView) {
      map['COMMISSION'] = COMMISSION;
    }
    if (MONEY_TO_BE_DELIVERED != null || !forView) {
      map['MONEY_TO_BE_DELIVERED'] = MONEY_TO_BE_DELIVERED;
    }
    if (MONEY_DELIVERED != null || !forView) {
      map['MONEY_DELIVERED'] = MONEY_DELIVERED;
    }
    if (NO_OF_HOLD_DAYS != null || !forView) {
      map['NO_OF_HOLD_DAYS'] = NO_OF_HOLD_DAYS;
    }
    if (DATE_OF_DELIVERY != null) {
      map['DATE_OF_DELIVERY'] = forJson
          ? '$DATE_OF_DELIVERY!.year-$DATE_OF_DELIVERY!.month-$DATE_OF_DELIVERY!.day'
          : forQuery
              ? DateTime(DATE_OF_DELIVERY!.year, DATE_OF_DELIVERY!.month,
                      DATE_OF_DELIVERY!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_DELIVERY;
    } else if (DATE_OF_DELIVERY != null || !forView) {
      map['DATE_OF_DELIVERY'] = null;
    }
    if (DATE_OF_DELIVERY_CONFIRM != null) {
      map['DATE_OF_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_DELIVERY_CONFIRM!.year-$DATE_OF_DELIVERY_CONFIRM!.month-$DATE_OF_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_DELIVERY_CONFIRM!.year,
                      DATE_OF_DELIVERY_CONFIRM!.month,
                      DATE_OF_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_DELIVERY_CONFIRM;
    } else if (DATE_OF_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_DELIVERY_CONFIRM'] = null;
    }
    if (TIME_OF_DELIVERY_CONFIRM != null) {
      map['TIME_OF_DELIVERY_CONFIRM'] = forJson
          ? TIME_OF_DELIVERY_CONFIRM!.toString()
          : forQuery
              ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
              : TIME_OF_DELIVERY_CONFIRM;
    } else if (TIME_OF_DELIVERY_CONFIRM != null || !forView) {
      map['TIME_OF_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_1ST_DELIVERY_CONFIRM != null) {
      map['DATE_OF_1ST_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_1ST_DELIVERY_CONFIRM!.year-$DATE_OF_1ST_DELIVERY_CONFIRM!.month-$DATE_OF_1ST_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_1ST_DELIVERY_CONFIRM!.year,
                      DATE_OF_1ST_DELIVERY_CONFIRM!.month,
                      DATE_OF_1ST_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_1ST_DELIVERY_CONFIRM;
    } else if (DATE_OF_1ST_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_1ST_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_2ND_DELIVERY_CONFIRM != null) {
      map['DATE_OF_2ND_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_2ND_DELIVERY_CONFIRM!.year-$DATE_OF_2ND_DELIVERY_CONFIRM!.month-$DATE_OF_2ND_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_2ND_DELIVERY_CONFIRM!.year,
                      DATE_OF_2ND_DELIVERY_CONFIRM!.month,
                      DATE_OF_2ND_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_2ND_DELIVERY_CONFIRM;
    } else if (DATE_OF_2ND_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_2ND_DELIVERY_CONFIRM'] = null;
    }
    if (DATE_OF_3RD_DELIVERY_CONFIRM != null) {
      map['DATE_OF_3RD_DELIVERY_CONFIRM'] = forJson
          ? '$DATE_OF_3RD_DELIVERY_CONFIRM!.year-$DATE_OF_3RD_DELIVERY_CONFIRM!.month-$DATE_OF_3RD_DELIVERY_CONFIRM!.day'
          : forQuery
              ? DateTime(
                      DATE_OF_3RD_DELIVERY_CONFIRM!.year,
                      DATE_OF_3RD_DELIVERY_CONFIRM!.month,
                      DATE_OF_3RD_DELIVERY_CONFIRM!.day)
                  .millisecondsSinceEpoch
              : DATE_OF_3RD_DELIVERY_CONFIRM;
    } else if (DATE_OF_3RD_DELIVERY_CONFIRM != null || !forView) {
      map['DATE_OF_3RD_DELIVERY_CONFIRM'] = null;
    }
    if (DELIVERY_TIME != null) {
      map['DELIVERY_TIME'] = forJson
          ? DELIVERY_TIME!.toString()
          : forQuery
              ? DELIVERY_TIME!.millisecondsSinceEpoch
              : DELIVERY_TIME;
    } else if (DELIVERY_TIME != null || !forView) {
      map['DELIVERY_TIME'] = null;
    }
    if (DEL_DATE != null) {
      map['DEL_DATE'] = forJson
          ? '$DEL_DATE!.year-$DEL_DATE!.month-$DEL_DATE!.day'
          : forQuery
              ? DateTime(DEL_DATE!.year, DEL_DATE!.month, DEL_DATE!.day)
                  .millisecondsSinceEpoch
              : DEL_DATE;
    } else if (DEL_DATE != null || !forView) {
      map['DEL_DATE'] = null;
    }
    if (ID_PROOF_DOC != null || !forView) {
      map['ID_PROOF_DOC'] = ID_PROOF_DOC;
    }
    if (ID_PROOF_NMBR != null || !forView) {
      map['ID_PROOF_NMBR'] = ID_PROOF_NMBR;
    }
    if (ISSUING_AUTHORITY != null || !forView) {
      map['ISSUING_AUTHORITY'] = ISSUING_AUTHORITY;
    }
    if (ID_PROOF_VALIDITY_DATE != null) {
      map['ID_PROOF_VALIDITY_DATE'] = forJson
          ? '$ID_PROOF_VALIDITY_DATE!.year-$ID_PROOF_VALIDITY_DATE!.month-$ID_PROOF_VALIDITY_DATE!.day'
          : forQuery
              ? DateTime(
                      ID_PROOF_VALIDITY_DATE!.year,
                      ID_PROOF_VALIDITY_DATE!.month,
                      ID_PROOF_VALIDITY_DATE!.day)
                  .millisecondsSinceEpoch
              : ID_PROOF_VALIDITY_DATE;
    } else if (ID_PROOF_VALIDITY_DATE != null || !forView) {
      map['ID_PROOF_VALIDITY_DATE'] = null;
    }
    if (WINDOW_DELIVERY != null || !forView) {
      map['WINDOW_DELIVERY'] = WINDOW_DELIVERY;
    }
    if (REDIRECTION_FEE != null || !forView) {
      map['REDIRECTION_FEE'] = REDIRECTION_FEE;
    }
    if (RETRN_DATE != null) {
      map['RETRN_DATE'] = forJson
          ? '$RETRN_DATE!.year-$RETRN_DATE!.month-$RETRN_DATE!.day'
          : forQuery
              ? DateTime(RETRN_DATE!.year, RETRN_DATE!.month, RETRN_DATE!.day)
                  .millisecondsSinceEpoch
              : RETRN_DATE;
    } else if (RETRN_DATE != null || !forView) {
      map['RETRN_DATE'] = null;
    }
    if (RETRN_TIME != null) {
      map['RETRN_TIME'] = forJson
          ? RETRN_TIME!.toString()
          : forQuery
              ? RETRN_TIME!.millisecondsSinceEpoch
              : RETRN_TIME;
    } else if (RETRN_TIME != null || !forView) {
      map['RETRN_TIME'] = null;
    }
    if (BEAT_NO != null || !forView) {
      map['BEAT_NO'] = BEAT_NO;
    }
    if (PERNR != null || !forView) {
      map['PERNR'] = PERNR;
    }
    if (ART_STATUS != null || !forView) {
      map['ART_STATUS'] = ART_STATUS;
    }
    if (ART_RECEIVE_DATE != null || !forView) {
      map['ART_RECEIVE_DATE'] = ART_RECEIVE_DATE;
    }
    if (ART_RECEIVE_TIME != null || !forView) {
      map['ART_RECEIVE_TIME'] = ART_RECEIVE_TIME;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (ZCONDITION != null || !forView) {
      map['ZCONDITION'] = ZCONDITION;
    }
    if (TOTAL_MONEY != null || !forView) {
      map['TOTAL_MONEY'] = TOTAL_MONEY;
    }
    if (POSTAGE_NOT_COLLECTED != null || !forView) {
      map['POSTAGE_NOT_COLLECTED'] = POSTAGE_NOT_COLLECTED;
    }
    if (MOP != null || !forView) {
      map['MOP'] = MOP;
    }
    if (VPP != null || !forView) {
      map['VPP'] = VPP;
    }
    if (BATCH_ID != null || !forView) {
      map['BATCH_ID'] = BATCH_ID;
    }
    if (SHIFT_NO != null || !forView) {
      map['SHIFT_NO'] = SHIFT_NO;
    }
    if (RET_RCL_RDL_STOPDELV_STATUS2 != null || !forView) {
      map['RET_RCL_RDL_STOPDELV_STATUS2'] = RET_RCL_RDL_STOPDELV_STATUS2;
    }
    if (TYPE_OF_PAYEE != null || !forView) {
      map['TYPE_OF_PAYEE'] = TYPE_OF_PAYEE;
    }
    if (REDIRECT_PIN != null || !forView) {
      map['REDIRECT_PIN'] = REDIRECT_PIN;
    }
    if (MOD_PIN != null || !forView) {
      map['MOD_PIN'] = MOD_PIN;
    }
    if (SOURCE_PINCODE != null || !forView) {
      map['SOURCE_PINCODE'] = SOURCE_PINCODE;
    }
    if (DESTN_PINCODE != null || !forView) {
      map['DESTN_PINCODE'] = DESTN_PINCODE;
    }
    if (EMO_MESSAGE != null || !forView) {
      map['EMO_MESSAGE'] = EMO_MESSAGE;
    }
    if (REGISTERED != null || !forView) {
      map['REGISTERED'] = REGISTERED;
    }
    if (RETURN_SERVICE != null || !forView) {
      map['RETURN_SERVICE'] = RETURN_SERVICE;
    }
    if (COD != null || !forView) {
      map['COD'] = COD;
    }
    if (RT != null || !forView) {
      map['RT'] = RT;
    }
    if (RT_DATE != null) {
      map['RT_DATE'] = forJson
          ? '$RT_DATE!.year-$RT_DATE!.month-$RT_DATE!.day'
          : forQuery
              ? DateTime(RT_DATE!.year, RT_DATE!.month, RT_DATE!.day)
                  .millisecondsSinceEpoch
              : RT_DATE;
    } else if (RT_DATE != null || !forView) {
      map['RT_DATE'] = null;
    }
    if (RT_TIME != null) {
      map['RT_TIME'] = forJson
          ? RT_TIME!.toString()
          : forQuery
              ? RT_TIME!.millisecondsSinceEpoch
              : RT_TIME;
    } else if (RT_TIME != null || !forView) {
      map['RT_TIME'] = null;
    }
    if (RD != null || !forView) {
      map['RD'] = RD;
    }
    if (RD_DATE != null) {
      map['RD_DATE'] = forJson
          ? '$RD_DATE!.year-$RD_DATE!.month-$RD_DATE!.day'
          : forQuery
              ? DateTime(RD_DATE!.year, RD_DATE!.month, RD_DATE!.day)
                  .millisecondsSinceEpoch
              : RD_DATE;
    } else if (RD_DATE != null || !forView) {
      map['RD_DATE'] = null;
    }
    if (RD_TIME != null) {
      map['RD_TIME'] = forJson
          ? RD_TIME!.toString()
          : forQuery
              ? RD_TIME!.millisecondsSinceEpoch
              : RD_TIME;
    } else if (RD_TIME != null || !forView) {
      map['RD_TIME'] = null;
    }
    if (SP != null || !forView) {
      map['SP'] = SP;
    }
    if (SP_DATE != null) {
      map['SP_DATE'] = forJson
          ? '$SP_DATE!.year-$SP_DATE!.month-$SP_DATE!.day'
          : forQuery
              ? DateTime(SP_DATE!.year, SP_DATE!.month, SP_DATE!.day)
                  .millisecondsSinceEpoch
              : SP_DATE;
    } else if (SP_DATE != null || !forView) {
      map['SP_DATE'] = null;
    }
    if (SP_TIME != null) {
      map['SP_TIME'] = forJson
          ? SP_TIME!.toString()
          : forQuery
              ? SP_TIME!.millisecondsSinceEpoch
              : SP_TIME;
    } else if (SP_TIME != null || !forView) {
      map['SP_TIME'] = null;
    }
    if (POSTE_RESTANTE != null || !forView) {
      map['POSTE_RESTANTE'] = POSTE_RESTANTE;
    }
    if (BO_ID != null || !forView) {
      map['BO_ID'] = BO_ID;
    }
    if (LAST_CHANGED_USER != null || !forView) {
      map['LAST_CHANGED_USER'] = LAST_CHANGED_USER;
    }
    if (BELNR != null || !forView) {
      map['BELNR'] = BELNR;
    }
    if (ALREADY_RTN_FLAG != null || !forView) {
      map['ALREADY_RTN_FLAG'] = ALREADY_RTN_FLAG;
    }
    if (ALREADY_RD_FLAG != null || !forView) {
      map['ALREADY_RD_FLAG'] = ALREADY_RD_FLAG;
    }
    if (REDIRECT_BO_ID != null || !forView) {
      map['REDIRECT_BO_ID'] = REDIRECT_BO_ID;
    }
    if (IFS_SOFFICE_NAME != null || !forView) {
      map['IFS_SOFFICE_NAME'] = IFS_SOFFICE_NAME;
    }
    if (CHECT != null || !forView) {
      map['CHECT'] = CHECT;
    }
    if (TREASURY_SUBMIT_DONE != null || !forView) {
      map['TREASURY_SUBMIT_DONE'] = TREASURY_SUBMIT_DONE;
    }
    if (TREASURY_SUBMIT_DATE != null) {
      map['TREASURY_SUBMIT_DATE'] = forJson
          ? '$TREASURY_SUBMIT_DATE!.year-$TREASURY_SUBMIT_DATE!.month-$TREASURY_SUBMIT_DATE!.day'
          : forQuery
              ? DateTime(TREASURY_SUBMIT_DATE!.year,
                      TREASURY_SUBMIT_DATE!.month, TREASURY_SUBMIT_DATE!.day)
                  .millisecondsSinceEpoch
              : TREASURY_SUBMIT_DATE;
    } else if (TREASURY_SUBMIT_DATE != null || !forView) {
      map['TREASURY_SUBMIT_DATE'] = null;
    }
    if (REDIRECTION_SL != null || !forView) {
      map['REDIRECTION_SL'] = REDIRECTION_SL;
    }
    if (TRANSACTION_DATE != null) {
      map['TRANSACTION_DATE'] = forJson
          ? '$TRANSACTION_DATE!.year-$TRANSACTION_DATE!.month-$TRANSACTION_DATE!.day'
          : forQuery
              ? DateTime(TRANSACTION_DATE!.year, TRANSACTION_DATE!.month,
                      TRANSACTION_DATE!.day)
                  .millisecondsSinceEpoch
              : TRANSACTION_DATE;
    } else if (TRANSACTION_DATE != null || !forView) {
      map['TRANSACTION_DATE'] = null;
    }
    if (TRANSACTION_TIME != null) {
      map['TRANSACTION_TIME'] = forJson
          ? TRANSACTION_TIME!.toString()
          : forQuery
              ? TRANSACTION_TIME!.millisecondsSinceEpoch
              : TRANSACTION_TIME;
    } else if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = null;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (IS_PREVIOUS_DAY_DEPOSIT != null || !forView) {
      map['IS_PREVIOUS_DAY_DEPOSIT'] = IS_PREVIOUS_DAY_DEPOSIT;
    }
    if (E_PROOF != null || !forView) {
      map['E_PROOF'] = E_PROOF;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (CASH_ID != null || !forView) {
      map['CASH_ID'] = CASH_ID;
    }
    if (REMARK_DATE != null) {
      map['REMARK_DATE'] = forJson
          ? '$REMARK_DATE!.year-$REMARK_DATE!.month-$REMARK_DATE!.day'
          : forQuery
              ? DateTime(
                      REMARK_DATE!.year, REMARK_DATE!.month, REMARK_DATE!.day)
                  .millisecondsSinceEpoch
              : REMARK_DATE;
    } else if (REMARK_DATE != null || !forView) {
      map['REMARK_DATE'] = null;
    }
    if (CASH_RETURNED != null || !forView) {
      map['CASH_RETURNED'] = CASH_RETURNED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }
    if (REPORTING_SO_ID != null || !forView) {
      map['REPORTING_SO_ID'] = REPORTING_SO_ID;
    }
    if (despatchStatus != null || !forView) {
      map['despatchStatus'] = despatchStatus;
    }
    if (CUST_DUTY != null || !forView) {
      map['CUST_DUTY'] = CUST_DUTY;
    }
    if (BO_SLIP != null || !forView) {
      map['BO_SLIP'] = BO_SLIP;
    }
    if (ZIP_FILE_NAME != null || !forView) {
      map['ZIP_FILE_NAME'] = ZIP_FILE_NAME;
    }

    return map;
  }

  /// This method returns Json String [Delivery]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Delivery]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ART_NUMBER,
      invoiceDate,
      invoiced,
      SOFFICE_ID,
      DOFFICE_ID,
      BOOK_DATE,
      BOOK_ID,
      LINE_ITEM,
      BAG_ID,
      INSURANCE,
      ON_HOLD,
      HOLD_DATE != null ? HOLD_DATE!.millisecondsSinceEpoch : null,
      HOLD_TILL_DATE != null ? HOLD_TILL_DATE!.millisecondsSinceEpoch : null,
      PENSIONER_ID,
      REASON_FOR_NONDELIVERY,
      REASON_TYPE,
      ACTION,
      MONEY_TO_BE_COLLECTED,
      MONEY_COLLECTED,
      POST_DUE,
      DEM_CHARGE,
      COMMISSION,
      MONEY_TO_BE_DELIVERED,
      MONEY_DELIVERED,
      NO_OF_HOLD_DAYS,
      DATE_OF_DELIVERY != null
          ? DATE_OF_DELIVERY!.millisecondsSinceEpoch
          : null,
      DATE_OF_DELIVERY_CONFIRM != null
          ? DATE_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      TIME_OF_DELIVERY_CONFIRM != null
          ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_1ST_DELIVERY_CONFIRM != null
          ? DATE_OF_1ST_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_2ND_DELIVERY_CONFIRM != null
          ? DATE_OF_2ND_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_3RD_DELIVERY_CONFIRM != null
          ? DATE_OF_3RD_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DELIVERY_TIME != null ? DELIVERY_TIME!.millisecondsSinceEpoch : null,
      DEL_DATE != null ? DEL_DATE!.millisecondsSinceEpoch : null,
      ID_PROOF_DOC,
      ID_PROOF_NMBR,
      ISSUING_AUTHORITY,
      ID_PROOF_VALIDITY_DATE != null
          ? ID_PROOF_VALIDITY_DATE!.millisecondsSinceEpoch
          : null,
      WINDOW_DELIVERY,
      REDIRECTION_FEE,
      RETRN_DATE != null ? RETRN_DATE!.millisecondsSinceEpoch : null,
      RETRN_TIME != null ? RETRN_TIME!.millisecondsSinceEpoch : null,
      BEAT_NO,
      PERNR,
      ART_STATUS,
      ART_RECEIVE_DATE,
      ART_RECEIVE_TIME,
      REMARKS,
      ZCONDITION,
      TOTAL_MONEY,
      POSTAGE_NOT_COLLECTED,
      MOP,
      VPP,
      BATCH_ID,
      SHIFT_NO,
      RET_RCL_RDL_STOPDELV_STATUS2,
      TYPE_OF_PAYEE,
      REDIRECT_PIN,
      MOD_PIN,
      SOURCE_PINCODE,
      DESTN_PINCODE,
      EMO_MESSAGE,
      REGISTERED,
      RETURN_SERVICE,
      COD,
      RT,
      RT_DATE != null ? RT_DATE!.millisecondsSinceEpoch : null,
      RT_TIME != null ? RT_TIME!.millisecondsSinceEpoch : null,
      RD,
      RD_DATE != null ? RD_DATE!.millisecondsSinceEpoch : null,
      RD_TIME != null ? RD_TIME!.millisecondsSinceEpoch : null,
      SP,
      SP_DATE != null ? SP_DATE!.millisecondsSinceEpoch : null,
      SP_TIME != null ? SP_TIME!.millisecondsSinceEpoch : null,
      POSTE_RESTANTE,
      BO_ID,
      LAST_CHANGED_USER,
      BELNR,
      ALREADY_RTN_FLAG,
      ALREADY_RD_FLAG,
      REDIRECT_BO_ID,
      IFS_SOFFICE_NAME,
      CHECT,
      TREASURY_SUBMIT_DONE,
      TREASURY_SUBMIT_DATE != null
          ? TREASURY_SUBMIT_DATE!.millisecondsSinceEpoch
          : null,
      REDIRECTION_SL,
      TRANSACTION_DATE != null
          ? TRANSACTION_DATE!.millisecondsSinceEpoch
          : null,
      TRANSACTION_TIME != null
          ? TRANSACTION_TIME!.millisecondsSinceEpoch
          : null,
      IS_COMMUNICATED,
      IS_PREVIOUS_DAY_DEPOSIT,
      E_PROOF,
      MATNR,
      CASH_ID,
      REMARK_DATE != null ? REMARK_DATE!.millisecondsSinceEpoch : null,
      CASH_RETURNED,
      FILE_NAME,
      REPORTING_SO_ID,
      despatchStatus,
      CUST_DUTY,
      BO_SLIP,
      ZIP_FILE_NAME
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ART_NUMBER,
      invoiceDate,
      invoiced,
      SOFFICE_ID,
      DOFFICE_ID,
      BOOK_DATE,
      BOOK_ID,
      LINE_ITEM,
      BAG_ID,
      INSURANCE,
      ON_HOLD,
      HOLD_DATE != null ? HOLD_DATE!.millisecondsSinceEpoch : null,
      HOLD_TILL_DATE != null ? HOLD_TILL_DATE!.millisecondsSinceEpoch : null,
      PENSIONER_ID,
      REASON_FOR_NONDELIVERY,
      REASON_TYPE,
      ACTION,
      MONEY_TO_BE_COLLECTED,
      MONEY_COLLECTED,
      POST_DUE,
      DEM_CHARGE,
      COMMISSION,
      MONEY_TO_BE_DELIVERED,
      MONEY_DELIVERED,
      NO_OF_HOLD_DAYS,
      DATE_OF_DELIVERY != null
          ? DATE_OF_DELIVERY!.millisecondsSinceEpoch
          : null,
      DATE_OF_DELIVERY_CONFIRM != null
          ? DATE_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      TIME_OF_DELIVERY_CONFIRM != null
          ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_1ST_DELIVERY_CONFIRM != null
          ? DATE_OF_1ST_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_2ND_DELIVERY_CONFIRM != null
          ? DATE_OF_2ND_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DATE_OF_3RD_DELIVERY_CONFIRM != null
          ? DATE_OF_3RD_DELIVERY_CONFIRM!.millisecondsSinceEpoch
          : null,
      DELIVERY_TIME != null ? DELIVERY_TIME!.millisecondsSinceEpoch : null,
      DEL_DATE != null ? DEL_DATE!.millisecondsSinceEpoch : null,
      ID_PROOF_DOC,
      ID_PROOF_NMBR,
      ISSUING_AUTHORITY,
      ID_PROOF_VALIDITY_DATE != null
          ? ID_PROOF_VALIDITY_DATE!.millisecondsSinceEpoch
          : null,
      WINDOW_DELIVERY,
      REDIRECTION_FEE,
      RETRN_DATE != null ? RETRN_DATE!.millisecondsSinceEpoch : null,
      RETRN_TIME != null ? RETRN_TIME!.millisecondsSinceEpoch : null,
      BEAT_NO,
      PERNR,
      ART_STATUS,
      ART_RECEIVE_DATE,
      ART_RECEIVE_TIME,
      REMARKS,
      ZCONDITION,
      TOTAL_MONEY,
      POSTAGE_NOT_COLLECTED,
      MOP,
      VPP,
      BATCH_ID,
      SHIFT_NO,
      RET_RCL_RDL_STOPDELV_STATUS2,
      TYPE_OF_PAYEE,
      REDIRECT_PIN,
      MOD_PIN,
      SOURCE_PINCODE,
      DESTN_PINCODE,
      EMO_MESSAGE,
      REGISTERED,
      RETURN_SERVICE,
      COD,
      RT,
      RT_DATE != null ? RT_DATE!.millisecondsSinceEpoch : null,
      RT_TIME != null ? RT_TIME!.millisecondsSinceEpoch : null,
      RD,
      RD_DATE != null ? RD_DATE!.millisecondsSinceEpoch : null,
      RD_TIME != null ? RD_TIME!.millisecondsSinceEpoch : null,
      SP,
      SP_DATE != null ? SP_DATE!.millisecondsSinceEpoch : null,
      SP_TIME != null ? SP_TIME!.millisecondsSinceEpoch : null,
      POSTE_RESTANTE,
      BO_ID,
      LAST_CHANGED_USER,
      BELNR,
      ALREADY_RTN_FLAG,
      ALREADY_RD_FLAG,
      REDIRECT_BO_ID,
      IFS_SOFFICE_NAME,
      CHECT,
      TREASURY_SUBMIT_DONE,
      TREASURY_SUBMIT_DATE != null
          ? TREASURY_SUBMIT_DATE!.millisecondsSinceEpoch
          : null,
      REDIRECTION_SL,
      TRANSACTION_DATE != null
          ? TRANSACTION_DATE!.millisecondsSinceEpoch
          : null,
      TRANSACTION_TIME != null
          ? TRANSACTION_TIME!.millisecondsSinceEpoch
          : null,
      IS_COMMUNICATED,
      IS_PREVIOUS_DAY_DEPOSIT,
      E_PROOF,
      MATNR,
      CASH_ID,
      REMARK_DATE != null ? REMARK_DATE!.millisecondsSinceEpoch : null,
      CASH_RETURNED,
      FILE_NAME,
      REPORTING_SO_ID,
      despatchStatus,
      CUST_DUTY,
      BO_SLIP,
      ZIP_FILE_NAME
    ];
  }

  static Future<List<Delivery>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Delivery.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Delivery>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Delivery>[];
    try {
      objList = list
          .map((delivery) => Delivery.fromMap(delivery as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Delivery.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Delivery>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Delivery> objList = <Delivery>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Delivery.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Delivery by ID if exist, otherwise returns null
  /// Primary Keys: String? ART_NUMBER
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Delivery] if exist, otherwise returns null
  Future<Delivery?> getById(String? ART_NUMBER,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ART_NUMBER == null) {
      return null;
    }
    Delivery? obj;
    final data = await _mnDelivery.getById([ART_NUMBER]);
    if (data.length != 0) {
      obj = Delivery.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Delivery) object. If the Primary Key (ART_NUMBER) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ART_NUMBER
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnDelivery.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Delivery (ART_NUMBER, invoiceDate, invoiced, SOFFICE_ID , DOFFICE_ID, BOOK_DATE, BOOK_ID, LINE_ITEM, BAG_ID, INSURANCE, ON_HOLD, HOLD_DATE, HOLD_TILL_DATE, PENSIONER_ID, REASON_FOR_NONDELIVERY, REASON_TYPE, ACTION, MONEY_TO_BE_COLLECTED, MONEY_COLLECTED, POST_DUE, DEM_CHARGE, COMMISSION, MONEY_TO_BE_DELIVERED, MONEY_DELIVERED, NO_OF_HOLD_DAYS, DATE_OF_DELIVERY, DATE_OF_DELIVERY_CONFIRM, TIME_OF_DELIVERY_CONFIRM, DATE_OF_1ST_DELIVERY_CONFIRM, DATE_OF_2ND_DELIVERY_CONFIRM, DATE_OF_3RD_DELIVERY_CONFIRM, DELIVERY_TIME, DEL_DATE, ID_PROOF_DOC, ID_PROOF_NMBR, ISSUING_AUTHORITY, ID_PROOF_VALIDITY_DATE, WINDOW_DELIVERY, REDIRECTION_FEE, RETRN_DATE, RETRN_TIME, BEAT_NO, PERNR, ART_STATUS, ART_RECEIVE_DATE, ART_RECEIVE_TIME, REMARKS, ZCONDITION, TOTAL_MONEY, POSTAGE_NOT_COLLECTED, MOP, VPP, BATCH_ID, SHIFT_NO, RET_RCL_RDL_STOPDELV_STATUS2, TYPE_OF_PAYEE, REDIRECT_PIN, MOD_PIN, SOURCE_PINCODE, DESTN_PINCODE, EMO_MESSAGE, REGISTERED, RETURN_SERVICE, COD, RT, RT_DATE, RT_TIME, RD, RD_DATE, RD_TIME, SP, SP_DATE, SP_TIME, POSTE_RESTANTE, BO_ID, LAST_CHANGED_USER, BELNR, ALREADY_RTN_FLAG, ALREADY_RD_FLAG, REDIRECT_BO_ID, IFS_SOFFICE_NAME, CHECT, TREASURY_SUBMIT_DONE, TREASURY_SUBMIT_DATE, REDIRECTION_SL, TRANSACTION_DATE, TRANSACTION_TIME, IS_COMMUNICATED, IS_PREVIOUS_DAY_DEPOSIT, E_PROOF, MATNR, CASH_ID, REMARK_DATE, CASH_RETURNED, FILE_NAME, REPORTING_SO_ID, despatchStatus, CUST_DUTY, BO_SLIP, ZIP_FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Delivery> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Delivery> deliveries,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in deliveries) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDelivery.rawInsert(
          'INSERT OR REPLACE INTO Delivery (ART_NUMBER, invoiceDate, invoiced, SOFFICE_ID , DOFFICE_ID, BOOK_DATE, BOOK_ID, LINE_ITEM, BAG_ID, INSURANCE, ON_HOLD, HOLD_DATE, HOLD_TILL_DATE, PENSIONER_ID, REASON_FOR_NONDELIVERY, REASON_TYPE, ACTION, MONEY_TO_BE_COLLECTED, MONEY_COLLECTED, POST_DUE, DEM_CHARGE, COMMISSION, MONEY_TO_BE_DELIVERED, MONEY_DELIVERED, NO_OF_HOLD_DAYS, DATE_OF_DELIVERY, DATE_OF_DELIVERY_CONFIRM, TIME_OF_DELIVERY_CONFIRM, DATE_OF_1ST_DELIVERY_CONFIRM, DATE_OF_2ND_DELIVERY_CONFIRM, DATE_OF_3RD_DELIVERY_CONFIRM, DELIVERY_TIME, DEL_DATE, ID_PROOF_DOC, ID_PROOF_NMBR, ISSUING_AUTHORITY, ID_PROOF_VALIDITY_DATE, WINDOW_DELIVERY, REDIRECTION_FEE, RETRN_DATE, RETRN_TIME, BEAT_NO, PERNR, ART_STATUS, ART_RECEIVE_DATE, ART_RECEIVE_TIME, REMARKS, ZCONDITION, TOTAL_MONEY, POSTAGE_NOT_COLLECTED, MOP, VPP, BATCH_ID, SHIFT_NO, RET_RCL_RDL_STOPDELV_STATUS2, TYPE_OF_PAYEE, REDIRECT_PIN, MOD_PIN, SOURCE_PINCODE, DESTN_PINCODE, EMO_MESSAGE, REGISTERED, RETURN_SERVICE, COD, RT, RT_DATE, RT_TIME, RD, RD_DATE, RD_TIME, SP, SP_DATE, SP_TIME, POSTE_RESTANTE, BO_ID, LAST_CHANGED_USER, BELNR, ALREADY_RTN_FLAG, ALREADY_RD_FLAG, REDIRECT_BO_ID, IFS_SOFFICE_NAME, CHECT, TREASURY_SUBMIT_DONE, TREASURY_SUBMIT_DATE, REDIRECTION_SL, TRANSACTION_DATE, TRANSACTION_TIME, IS_COMMUNICATED, IS_PREVIOUS_DAY_DEPOSIT, E_PROOF, MATNR, CASH_ID, REMARK_DATE, CASH_RETURNED, FILE_NAME, REPORTING_SO_ID, despatchStatus, CUST_DUTY, BO_SLIP, ZIP_FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ART_NUMBER,
            invoiceDate,
            invoiced,
            SOFFICE_ID,
            DOFFICE_ID,
            BOOK_DATE,
            BOOK_ID,
            LINE_ITEM,
            BAG_ID,
            INSURANCE,
            ON_HOLD,
            HOLD_DATE != null ? HOLD_DATE!.millisecondsSinceEpoch : null,
            HOLD_TILL_DATE != null
                ? HOLD_TILL_DATE!.millisecondsSinceEpoch
                : null,
            PENSIONER_ID,
            REASON_FOR_NONDELIVERY,
            REASON_TYPE,
            ACTION,
            MONEY_TO_BE_COLLECTED,
            MONEY_COLLECTED,
            POST_DUE,
            DEM_CHARGE,
            COMMISSION,
            MONEY_TO_BE_DELIVERED,
            MONEY_DELIVERED,
            NO_OF_HOLD_DAYS,
            DATE_OF_DELIVERY != null
                ? DATE_OF_DELIVERY!.millisecondsSinceEpoch
                : null,
            DATE_OF_DELIVERY_CONFIRM != null
                ? DATE_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            TIME_OF_DELIVERY_CONFIRM != null
                ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_1ST_DELIVERY_CONFIRM != null
                ? DATE_OF_1ST_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_2ND_DELIVERY_CONFIRM != null
                ? DATE_OF_2ND_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_3RD_DELIVERY_CONFIRM != null
                ? DATE_OF_3RD_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DELIVERY_TIME != null
                ? DELIVERY_TIME!.millisecondsSinceEpoch
                : null,
            DEL_DATE != null ? DEL_DATE!.millisecondsSinceEpoch : null,
            ID_PROOF_DOC,
            ID_PROOF_NMBR,
            ISSUING_AUTHORITY,
            ID_PROOF_VALIDITY_DATE != null
                ? ID_PROOF_VALIDITY_DATE!.millisecondsSinceEpoch
                : null,
            WINDOW_DELIVERY,
            REDIRECTION_FEE,
            RETRN_DATE != null ? RETRN_DATE!.millisecondsSinceEpoch : null,
            RETRN_TIME != null ? RETRN_TIME!.millisecondsSinceEpoch : null,
            BEAT_NO,
            PERNR,
            ART_STATUS,
            ART_RECEIVE_DATE,
            ART_RECEIVE_TIME,
            REMARKS,
            ZCONDITION,
            TOTAL_MONEY,
            POSTAGE_NOT_COLLECTED,
            MOP,
            VPP,
            BATCH_ID,
            SHIFT_NO,
            RET_RCL_RDL_STOPDELV_STATUS2,
            TYPE_OF_PAYEE,
            REDIRECT_PIN,
            MOD_PIN,
            SOURCE_PINCODE,
            DESTN_PINCODE,
            EMO_MESSAGE,
            REGISTERED,
            RETURN_SERVICE,
            COD,
            RT,
            RT_DATE != null ? RT_DATE!.millisecondsSinceEpoch : null,
            RT_TIME != null ? RT_TIME!.millisecondsSinceEpoch : null,
            RD,
            RD_DATE != null ? RD_DATE!.millisecondsSinceEpoch : null,
            RD_TIME != null ? RD_TIME!.millisecondsSinceEpoch : null,
            SP,
            SP_DATE != null ? SP_DATE!.millisecondsSinceEpoch : null,
            SP_TIME != null ? SP_TIME!.millisecondsSinceEpoch : null,
            POSTE_RESTANTE,
            BO_ID,
            LAST_CHANGED_USER,
            BELNR,
            ALREADY_RTN_FLAG,
            ALREADY_RD_FLAG,
            REDIRECT_BO_ID,
            IFS_SOFFICE_NAME,
            CHECT,
            TREASURY_SUBMIT_DONE,
            TREASURY_SUBMIT_DATE != null
                ? TREASURY_SUBMIT_DATE!.millisecondsSinceEpoch
                : null,
            REDIRECTION_SL,
            TRANSACTION_DATE != null
                ? TRANSACTION_DATE!.millisecondsSinceEpoch
                : null,
            TRANSACTION_TIME != null
                ? TRANSACTION_TIME!.millisecondsSinceEpoch
                : null,
            IS_COMMUNICATED,
            IS_PREVIOUS_DAY_DEPOSIT,
            E_PROOF,
            MATNR,
            CASH_ID,
            REMARK_DATE != null ? REMARK_DATE!.millisecondsSinceEpoch : null,
            CASH_RETURNED,
            FILE_NAME,
            REPORTING_SO_ID,
            despatchStatus,
            CUST_DUTY,
            BO_SLIP,
            ZIP_FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Delivery ART_NUMBER=$ART_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Delivery ART_NUMBER=$ART_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Delivery Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDelivery.rawInsert(
          'INSERT OR IGNORE INTO Delivery (ART_NUMBER, invoiceDate, invoiced, SOFFICE_ID , DOFFICE_ID, BOOK_DATE, BOOK_ID, LINE_ITEM, BAG_ID, INSURANCE, ON_HOLD, HOLD_DATE, HOLD_TILL_DATE, PENSIONER_ID, REASON_FOR_NONDELIVERY, REASON_TYPE, ACTION, MONEY_TO_BE_COLLECTED, MONEY_COLLECTED, POST_DUE, DEM_CHARGE, COMMISSION, MONEY_TO_BE_DELIVERED, MONEY_DELIVERED, NO_OF_HOLD_DAYS, DATE_OF_DELIVERY, DATE_OF_DELIVERY_CONFIRM, TIME_OF_DELIVERY_CONFIRM, DATE_OF_1ST_DELIVERY_CONFIRM, DATE_OF_2ND_DELIVERY_CONFIRM, DATE_OF_3RD_DELIVERY_CONFIRM, DELIVERY_TIME, DEL_DATE, ID_PROOF_DOC, ID_PROOF_NMBR, ISSUING_AUTHORITY, ID_PROOF_VALIDITY_DATE, WINDOW_DELIVERY, REDIRECTION_FEE, RETRN_DATE, RETRN_TIME, BEAT_NO, PERNR, ART_STATUS, ART_RECEIVE_DATE, ART_RECEIVE_TIME, REMARKS, ZCONDITION, TOTAL_MONEY, POSTAGE_NOT_COLLECTED, MOP, VPP, BATCH_ID, SHIFT_NO, RET_RCL_RDL_STOPDELV_STATUS2, TYPE_OF_PAYEE, REDIRECT_PIN, MOD_PIN, SOURCE_PINCODE, DESTN_PINCODE, EMO_MESSAGE, REGISTERED, RETURN_SERVICE, COD, RT, RT_DATE, RT_TIME, RD, RD_DATE, RD_TIME, SP, SP_DATE, SP_TIME, POSTE_RESTANTE, BO_ID, LAST_CHANGED_USER, BELNR, ALREADY_RTN_FLAG, ALREADY_RD_FLAG, REDIRECT_BO_ID, IFS_SOFFICE_NAME, CHECT, TREASURY_SUBMIT_DONE, TREASURY_SUBMIT_DATE, REDIRECTION_SL, TRANSACTION_DATE, TRANSACTION_TIME, IS_COMMUNICATED, IS_PREVIOUS_DAY_DEPOSIT, E_PROOF, MATNR, CASH_ID, REMARK_DATE, CASH_RETURNED, FILE_NAME, REPORTING_SO_ID, despatchStatus, CUST_DUTY, BO_SLIP, ZIP_FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ART_NUMBER,
            invoiceDate,
            invoiced,
            SOFFICE_ID,
            DOFFICE_ID,
            BOOK_DATE,
            BOOK_ID,
            LINE_ITEM,
            BAG_ID,
            INSURANCE,
            ON_HOLD,
            HOLD_DATE != null ? HOLD_DATE!.millisecondsSinceEpoch : null,
            HOLD_TILL_DATE != null
                ? HOLD_TILL_DATE!.millisecondsSinceEpoch
                : null,
            PENSIONER_ID,
            REASON_FOR_NONDELIVERY,
            REASON_TYPE,
            ACTION,
            MONEY_TO_BE_COLLECTED,
            MONEY_COLLECTED,
            POST_DUE,
            DEM_CHARGE,
            COMMISSION,
            MONEY_TO_BE_DELIVERED,
            MONEY_DELIVERED,
            NO_OF_HOLD_DAYS,
            DATE_OF_DELIVERY != null
                ? DATE_OF_DELIVERY!.millisecondsSinceEpoch
                : null,
            DATE_OF_DELIVERY_CONFIRM != null
                ? DATE_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            TIME_OF_DELIVERY_CONFIRM != null
                ? TIME_OF_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_1ST_DELIVERY_CONFIRM != null
                ? DATE_OF_1ST_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_2ND_DELIVERY_CONFIRM != null
                ? DATE_OF_2ND_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DATE_OF_3RD_DELIVERY_CONFIRM != null
                ? DATE_OF_3RD_DELIVERY_CONFIRM!.millisecondsSinceEpoch
                : null,
            DELIVERY_TIME != null
                ? DELIVERY_TIME!.millisecondsSinceEpoch
                : null,
            DEL_DATE != null ? DEL_DATE!.millisecondsSinceEpoch : null,
            ID_PROOF_DOC,
            ID_PROOF_NMBR,
            ISSUING_AUTHORITY,
            ID_PROOF_VALIDITY_DATE != null
                ? ID_PROOF_VALIDITY_DATE!.millisecondsSinceEpoch
                : null,
            WINDOW_DELIVERY,
            REDIRECTION_FEE,
            RETRN_DATE != null ? RETRN_DATE!.millisecondsSinceEpoch : null,
            RETRN_TIME != null ? RETRN_TIME!.millisecondsSinceEpoch : null,
            BEAT_NO,
            PERNR,
            ART_STATUS,
            ART_RECEIVE_DATE,
            ART_RECEIVE_TIME,
            REMARKS,
            ZCONDITION,
            TOTAL_MONEY,
            POSTAGE_NOT_COLLECTED,
            MOP,
            VPP,
            BATCH_ID,
            SHIFT_NO,
            RET_RCL_RDL_STOPDELV_STATUS2,
            TYPE_OF_PAYEE,
            REDIRECT_PIN,
            MOD_PIN,
            SOURCE_PINCODE,
            DESTN_PINCODE,
            EMO_MESSAGE,
            REGISTERED,
            RETURN_SERVICE,
            COD,
            RT,
            RT_DATE != null ? RT_DATE!.millisecondsSinceEpoch : null,
            RT_TIME != null ? RT_TIME!.millisecondsSinceEpoch : null,
            RD,
            RD_DATE != null ? RD_DATE!.millisecondsSinceEpoch : null,
            RD_TIME != null ? RD_TIME!.millisecondsSinceEpoch : null,
            SP,
            SP_DATE != null ? SP_DATE!.millisecondsSinceEpoch : null,
            SP_TIME != null ? SP_TIME!.millisecondsSinceEpoch : null,
            POSTE_RESTANTE,
            BO_ID,
            LAST_CHANGED_USER,
            BELNR,
            ALREADY_RTN_FLAG,
            ALREADY_RD_FLAG,
            REDIRECT_BO_ID,
            IFS_SOFFICE_NAME,
            CHECT,
            TREASURY_SUBMIT_DONE,
            TREASURY_SUBMIT_DATE != null
                ? TREASURY_SUBMIT_DATE!.millisecondsSinceEpoch
                : null,
            REDIRECTION_SL,
            TRANSACTION_DATE != null
                ? TRANSACTION_DATE!.millisecondsSinceEpoch
                : null,
            TRANSACTION_TIME != null
                ? TRANSACTION_TIME!.millisecondsSinceEpoch
                : null,
            IS_COMMUNICATED,
            IS_PREVIOUS_DAY_DEPOSIT,
            E_PROOF,
            MATNR,
            CASH_ID,
            REMARK_DATE != null ? REMARK_DATE!.millisecondsSinceEpoch : null,
            CASH_RETURNED,
            FILE_NAME,
            REPORTING_SO_ID,
            despatchStatus,
            CUST_DUTY,
            BO_SLIP,
            ZIP_FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Delivery ART_NUMBER=$ART_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Delivery ART_NUMBER=$ART_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Delivery Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Delivery

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Delivery invoked (ART_NUMBER=$ART_NUMBER)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDelivery.delete(QueryParams(
          whereString: 'ART_NUMBER=?', whereArguments: [ART_NUMBER]));
    } else {
      return _mnDelivery.updateBatch(
          QueryParams(
              whereString: 'ART_NUMBER=?', whereArguments: [ART_NUMBER]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Delivery] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DeliveryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DeliveryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DeliveryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DeliveryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    MONEY_COLLECTED = MONEY_COLLECTED ?? 0;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ART_NUMBER = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion delivery

// region DeliveryField
class DeliveryField extends FilterBase {
  DeliveryField(DeliveryFilterBuilder deliveryFB) : super(deliveryFB);

  @override
  DeliveryFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder isNull() {
    return super.isNull() as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DeliveryFilterBuilder;
  }

  @override
  DeliveryField get not {
    return super.not as DeliveryField;
  }
}
// endregion DeliveryField

// region DeliveryFilterBuilder
class DeliveryFilterBuilder extends ConjunctionBase {
  DeliveryFilterBuilder(Delivery obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDelivery = obj._mnDelivery;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DeliveryManager? _mnDelivery;

  /// put the sql keyword 'AND'
  @override
  DeliveryFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DeliveryFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DeliveryFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DeliveryFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DeliveryFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DeliveryFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DeliveryFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DeliveryFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DeliveryFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DeliveryFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DeliveryFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DeliveryField _setField(DeliveryField? field, String colName, DbType dbtype) {
    return DeliveryField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DeliveryField? _ART_NUMBER;
  DeliveryField get ART_NUMBER {
    return _ART_NUMBER = _setField(_ART_NUMBER, 'ART_NUMBER', DbType.integer);
  }

  DeliveryField? _invoiceDate;
  DeliveryField get invoiceDate {
    return _invoiceDate = _setField(_invoiceDate, 'invoiceDate', DbType.text);
  }

  DeliveryField? _invoiced;
  DeliveryField get invoiced {
    return _invoiced = _setField(_invoiced, 'invoiced', DbType.text);
  }

  DeliveryField? _SOFFICE_ID;
  DeliveryField get SOFFICE_ID {
    return _SOFFICE_ID = _setField(_SOFFICE_ID, 'SOFFICE_ID ', DbType.text);
  }

  DeliveryField? _DOFFICE_ID;
  DeliveryField get DOFFICE_ID {
    return _DOFFICE_ID = _setField(_DOFFICE_ID, 'DOFFICE_ID', DbType.text);
  }

  DeliveryField? _BOOK_DATE;
  DeliveryField get BOOK_DATE {
    return _BOOK_DATE = _setField(_BOOK_DATE, 'BOOK_DATE', DbType.text);
  }

  DeliveryField? _BOOK_ID;
  DeliveryField get BOOK_ID {
    return _BOOK_ID = _setField(_BOOK_ID, 'BOOK_ID', DbType.text);
  }

  DeliveryField? _LINE_ITEM;
  DeliveryField get LINE_ITEM {
    return _LINE_ITEM = _setField(_LINE_ITEM, 'LINE_ITEM', DbType.real);
  }

  DeliveryField? _BAG_ID;
  DeliveryField get BAG_ID {
    return _BAG_ID = _setField(_BAG_ID, 'BAG_ID', DbType.text);
  }

  DeliveryField? _INSURANCE;
  DeliveryField get INSURANCE {
    return _INSURANCE = _setField(_INSURANCE, 'INSURANCE', DbType.text);
  }

  DeliveryField? _ON_HOLD;
  DeliveryField get ON_HOLD {
    return _ON_HOLD = _setField(_ON_HOLD, 'ON_HOLD', DbType.text);
  }

  DeliveryField? _HOLD_DATE;
  DeliveryField get HOLD_DATE {
    return _HOLD_DATE = _setField(_HOLD_DATE, 'HOLD_DATE', DbType.date);
  }

  DeliveryField? _HOLD_TILL_DATE;
  DeliveryField get HOLD_TILL_DATE {
    return _HOLD_TILL_DATE =
        _setField(_HOLD_TILL_DATE, 'HOLD_TILL_DATE', DbType.date);
  }

  DeliveryField? _PENSIONER_ID;
  DeliveryField get PENSIONER_ID {
    return _PENSIONER_ID =
        _setField(_PENSIONER_ID, 'PENSIONER_ID', DbType.text);
  }

  DeliveryField? _REASON_FOR_NONDELIVERY;
  DeliveryField get REASON_FOR_NONDELIVERY {
    return _REASON_FOR_NONDELIVERY = _setField(
        _REASON_FOR_NONDELIVERY, 'REASON_FOR_NONDELIVERY', DbType.text);
  }

  DeliveryField? _REASON_TYPE;
  DeliveryField get REASON_TYPE {
    return _REASON_TYPE = _setField(_REASON_TYPE, 'REASON_TYPE', DbType.text);
  }

  DeliveryField? _ACTION;
  DeliveryField get ACTION {
    return _ACTION = _setField(_ACTION, 'ACTION', DbType.text);
  }

  DeliveryField? _MONEY_TO_BE_COLLECTED;
  DeliveryField get MONEY_TO_BE_COLLECTED {
    return _MONEY_TO_BE_COLLECTED =
        _setField(_MONEY_TO_BE_COLLECTED, 'MONEY_TO_BE_COLLECTED', DbType.real);
  }

  DeliveryField? _MONEY_COLLECTED;
  DeliveryField get MONEY_COLLECTED {
    return _MONEY_COLLECTED =
        _setField(_MONEY_COLLECTED, 'MONEY_COLLECTED', DbType.real);
  }

  DeliveryField? _POST_DUE;
  DeliveryField get POST_DUE {
    return _POST_DUE = _setField(_POST_DUE, 'POST_DUE', DbType.real);
  }

  DeliveryField? _DEM_CHARGE;
  DeliveryField get DEM_CHARGE {
    return _DEM_CHARGE = _setField(_DEM_CHARGE, 'DEM_CHARGE', DbType.real);
  }

  DeliveryField? _COMMISSION;
  DeliveryField get COMMISSION {
    return _COMMISSION = _setField(_COMMISSION, 'COMMISSION', DbType.real);
  }

  DeliveryField? _MONEY_TO_BE_DELIVERED;
  DeliveryField get MONEY_TO_BE_DELIVERED {
    return _MONEY_TO_BE_DELIVERED =
        _setField(_MONEY_TO_BE_DELIVERED, 'MONEY_TO_BE_DELIVERED', DbType.real);
  }

  DeliveryField? _MONEY_DELIVERED;
  DeliveryField get MONEY_DELIVERED {
    return _MONEY_DELIVERED =
        _setField(_MONEY_DELIVERED, 'MONEY_DELIVERED', DbType.real);
  }

  DeliveryField? _NO_OF_HOLD_DAYS;
  DeliveryField get NO_OF_HOLD_DAYS {
    return _NO_OF_HOLD_DAYS =
        _setField(_NO_OF_HOLD_DAYS, 'NO_OF_HOLD_DAYS', DbType.real);
  }

  DeliveryField? _DATE_OF_DELIVERY;
  DeliveryField get DATE_OF_DELIVERY {
    return _DATE_OF_DELIVERY =
        _setField(_DATE_OF_DELIVERY, 'DATE_OF_DELIVERY', DbType.date);
  }

  DeliveryField? _DATE_OF_DELIVERY_CONFIRM;
  DeliveryField get DATE_OF_DELIVERY_CONFIRM {
    return _DATE_OF_DELIVERY_CONFIRM = _setField(
        _DATE_OF_DELIVERY_CONFIRM, 'DATE_OF_DELIVERY_CONFIRM', DbType.date);
  }

  DeliveryField? _TIME_OF_DELIVERY_CONFIRM;
  DeliveryField get TIME_OF_DELIVERY_CONFIRM {
    return _TIME_OF_DELIVERY_CONFIRM = _setField(
        _TIME_OF_DELIVERY_CONFIRM, 'TIME_OF_DELIVERY_CONFIRM', DbType.datetime);
  }

  DeliveryField? _DATE_OF_1ST_DELIVERY_CONFIRM;
  DeliveryField get DATE_OF_1ST_DELIVERY_CONFIRM {
    return _DATE_OF_1ST_DELIVERY_CONFIRM = _setField(
        _DATE_OF_1ST_DELIVERY_CONFIRM,
        'DATE_OF_1ST_DELIVERY_CONFIRM',
        DbType.date);
  }

  DeliveryField? _DATE_OF_2ND_DELIVERY_CONFIRM;
  DeliveryField get DATE_OF_2ND_DELIVERY_CONFIRM {
    return _DATE_OF_2ND_DELIVERY_CONFIRM = _setField(
        _DATE_OF_2ND_DELIVERY_CONFIRM,
        'DATE_OF_2ND_DELIVERY_CONFIRM',
        DbType.date);
  }

  DeliveryField? _DATE_OF_3RD_DELIVERY_CONFIRM;
  DeliveryField get DATE_OF_3RD_DELIVERY_CONFIRM {
    return _DATE_OF_3RD_DELIVERY_CONFIRM = _setField(
        _DATE_OF_3RD_DELIVERY_CONFIRM,
        'DATE_OF_3RD_DELIVERY_CONFIRM',
        DbType.date);
  }

  DeliveryField? _DELIVERY_TIME;
  DeliveryField get DELIVERY_TIME {
    return _DELIVERY_TIME =
        _setField(_DELIVERY_TIME, 'DELIVERY_TIME', DbType.datetime);
  }

  DeliveryField? _DEL_DATE;
  DeliveryField get DEL_DATE {
    return _DEL_DATE = _setField(_DEL_DATE, 'DEL_DATE', DbType.date);
  }

  DeliveryField? _ID_PROOF_DOC;
  DeliveryField get ID_PROOF_DOC {
    return _ID_PROOF_DOC =
        _setField(_ID_PROOF_DOC, 'ID_PROOF_DOC', DbType.text);
  }

  DeliveryField? _ID_PROOF_NMBR;
  DeliveryField get ID_PROOF_NMBR {
    return _ID_PROOF_NMBR =
        _setField(_ID_PROOF_NMBR, 'ID_PROOF_NMBR', DbType.text);
  }

  DeliveryField? _ISSUING_AUTHORITY;
  DeliveryField get ISSUING_AUTHORITY {
    return _ISSUING_AUTHORITY =
        _setField(_ISSUING_AUTHORITY, 'ISSUING_AUTHORITY', DbType.text);
  }

  DeliveryField? _ID_PROOF_VALIDITY_DATE;
  DeliveryField get ID_PROOF_VALIDITY_DATE {
    return _ID_PROOF_VALIDITY_DATE = _setField(
        _ID_PROOF_VALIDITY_DATE, 'ID_PROOF_VALIDITY_DATE', DbType.date);
  }

  DeliveryField? _WINDOW_DELIVERY;
  DeliveryField get WINDOW_DELIVERY {
    return _WINDOW_DELIVERY =
        _setField(_WINDOW_DELIVERY, 'WINDOW_DELIVERY', DbType.text);
  }

  DeliveryField? _REDIRECTION_FEE;
  DeliveryField get REDIRECTION_FEE {
    return _REDIRECTION_FEE =
        _setField(_REDIRECTION_FEE, 'REDIRECTION_FEE', DbType.real);
  }

  DeliveryField? _RETRN_DATE;
  DeliveryField get RETRN_DATE {
    return _RETRN_DATE = _setField(_RETRN_DATE, 'RETRN_DATE', DbType.date);
  }

  DeliveryField? _RETRN_TIME;
  DeliveryField get RETRN_TIME {
    return _RETRN_TIME = _setField(_RETRN_TIME, 'RETRN_TIME', DbType.datetime);
  }

  DeliveryField? _BEAT_NO;
  DeliveryField get BEAT_NO {
    return _BEAT_NO = _setField(_BEAT_NO, 'BEAT_NO', DbType.text);
  }

  DeliveryField? _PERNR;
  DeliveryField get PERNR {
    return _PERNR = _setField(_PERNR, 'PERNR', DbType.real);
  }

  DeliveryField? _ART_STATUS;
  DeliveryField get ART_STATUS {
    return _ART_STATUS = _setField(_ART_STATUS, 'ART_STATUS', DbType.text);
  }

  DeliveryField? _ART_RECEIVE_DATE;
  DeliveryField get ART_RECEIVE_DATE {
    return _ART_RECEIVE_DATE =
        _setField(_ART_RECEIVE_DATE, 'ART_RECEIVE_DATE', DbType.text);
  }

  DeliveryField? _ART_RECEIVE_TIME;
  DeliveryField get ART_RECEIVE_TIME {
    return _ART_RECEIVE_TIME =
        _setField(_ART_RECEIVE_TIME, 'ART_RECEIVE_TIME', DbType.text);
  }

  DeliveryField? _REMARKS;
  DeliveryField get REMARKS {
    return _REMARKS = _setField(_REMARKS, 'REMARKS', DbType.text);
  }

  DeliveryField? _ZCONDITION;
  DeliveryField get ZCONDITION {
    return _ZCONDITION = _setField(_ZCONDITION, 'ZCONDITION', DbType.text);
  }

  DeliveryField? _TOTAL_MONEY;
  DeliveryField get TOTAL_MONEY {
    return _TOTAL_MONEY = _setField(_TOTAL_MONEY, 'TOTAL_MONEY', DbType.real);
  }

  DeliveryField? _POSTAGE_NOT_COLLECTED;
  DeliveryField get POSTAGE_NOT_COLLECTED {
    return _POSTAGE_NOT_COLLECTED =
        _setField(_POSTAGE_NOT_COLLECTED, 'POSTAGE_NOT_COLLECTED', DbType.real);
  }

  DeliveryField? _MOP;
  DeliveryField get MOP {
    return _MOP = _setField(_MOP, 'MOP', DbType.text);
  }

  DeliveryField? _VPP;
  DeliveryField get VPP {
    return _VPP = _setField(_VPP, 'VPP', DbType.text);
  }

  DeliveryField? _BATCH_ID;
  DeliveryField get BATCH_ID {
    return _BATCH_ID = _setField(_BATCH_ID, 'BATCH_ID', DbType.text);
  }

  DeliveryField? _SHIFT_NO;
  DeliveryField get SHIFT_NO {
    return _SHIFT_NO = _setField(_SHIFT_NO, 'SHIFT_NO', DbType.text);
  }

  DeliveryField? _RET_RCL_RDL_STOPDELV_STATUS2;
  DeliveryField get RET_RCL_RDL_STOPDELV_STATUS2 {
    return _RET_RCL_RDL_STOPDELV_STATUS2 = _setField(
        _RET_RCL_RDL_STOPDELV_STATUS2,
        'RET_RCL_RDL_STOPDELV_STATUS2',
        DbType.text);
  }

  DeliveryField? _TYPE_OF_PAYEE;
  DeliveryField get TYPE_OF_PAYEE {
    return _TYPE_OF_PAYEE =
        _setField(_TYPE_OF_PAYEE, 'TYPE_OF_PAYEE', DbType.text);
  }

  DeliveryField? _REDIRECT_PIN;
  DeliveryField get REDIRECT_PIN {
    return _REDIRECT_PIN =
        _setField(_REDIRECT_PIN, 'REDIRECT_PIN', DbType.integer);
  }

  DeliveryField? _MOD_PIN;
  DeliveryField get MOD_PIN {
    return _MOD_PIN = _setField(_MOD_PIN, 'MOD_PIN', DbType.integer);
  }

  DeliveryField? _SOURCE_PINCODE;
  DeliveryField get SOURCE_PINCODE {
    return _SOURCE_PINCODE =
        _setField(_SOURCE_PINCODE, 'SOURCE_PINCODE', DbType.integer);
  }

  DeliveryField? _DESTN_PINCODE;
  DeliveryField get DESTN_PINCODE {
    return _DESTN_PINCODE =
        _setField(_DESTN_PINCODE, 'DESTN_PINCODE', DbType.integer);
  }

  DeliveryField? _EMO_MESSAGE;
  DeliveryField get EMO_MESSAGE {
    return _EMO_MESSAGE = _setField(_EMO_MESSAGE, 'EMO_MESSAGE', DbType.text);
  }

  DeliveryField? _REGISTERED;
  DeliveryField get REGISTERED {
    return _REGISTERED = _setField(_REGISTERED, 'REGISTERED', DbType.text);
  }

  DeliveryField? _RETURN_SERVICE;
  DeliveryField get RETURN_SERVICE {
    return _RETURN_SERVICE =
        _setField(_RETURN_SERVICE, 'RETURN_SERVICE', DbType.text);
  }

  DeliveryField? _COD;
  DeliveryField get COD {
    return _COD = _setField(_COD, 'COD', DbType.text);
  }

  DeliveryField? _RT;
  DeliveryField get RT {
    return _RT = _setField(_RT, 'RT', DbType.text);
  }

  DeliveryField? _RT_DATE;
  DeliveryField get RT_DATE {
    return _RT_DATE = _setField(_RT_DATE, 'RT_DATE', DbType.date);
  }

  DeliveryField? _RT_TIME;
  DeliveryField get RT_TIME {
    return _RT_TIME = _setField(_RT_TIME, 'RT_TIME', DbType.datetime);
  }

  DeliveryField? _RD;
  DeliveryField get RD {
    return _RD = _setField(_RD, 'RD', DbType.text);
  }

  DeliveryField? _RD_DATE;
  DeliveryField get RD_DATE {
    return _RD_DATE = _setField(_RD_DATE, 'RD_DATE', DbType.date);
  }

  DeliveryField? _RD_TIME;
  DeliveryField get RD_TIME {
    return _RD_TIME = _setField(_RD_TIME, 'RD_TIME', DbType.datetime);
  }

  DeliveryField? _SP;
  DeliveryField get SP {
    return _SP = _setField(_SP, 'SP', DbType.text);
  }

  DeliveryField? _SP_DATE;
  DeliveryField get SP_DATE {
    return _SP_DATE = _setField(_SP_DATE, 'SP_DATE', DbType.date);
  }

  DeliveryField? _SP_TIME;
  DeliveryField get SP_TIME {
    return _SP_TIME = _setField(_SP_TIME, 'SP_TIME', DbType.datetime);
  }

  DeliveryField? _POSTE_RESTANTE;
  DeliveryField get POSTE_RESTANTE {
    return _POSTE_RESTANTE =
        _setField(_POSTE_RESTANTE, 'POSTE_RESTANTE', DbType.text);
  }

  DeliveryField? _BO_ID;
  DeliveryField get BO_ID {
    return _BO_ID = _setField(_BO_ID, 'BO_ID', DbType.text);
  }

  DeliveryField? _LAST_CHANGED_USER;
  DeliveryField get LAST_CHANGED_USER {
    return _LAST_CHANGED_USER =
        _setField(_LAST_CHANGED_USER, 'LAST_CHANGED_USER', DbType.text);
  }

  DeliveryField? _BELNR;
  DeliveryField get BELNR {
    return _BELNR = _setField(_BELNR, 'BELNR', DbType.text);
  }

  DeliveryField? _ALREADY_RTN_FLAG;
  DeliveryField get ALREADY_RTN_FLAG {
    return _ALREADY_RTN_FLAG =
        _setField(_ALREADY_RTN_FLAG, 'ALREADY_RTN_FLAG', DbType.text);
  }

  DeliveryField? _ALREADY_RD_FLAG;
  DeliveryField get ALREADY_RD_FLAG {
    return _ALREADY_RD_FLAG =
        _setField(_ALREADY_RD_FLAG, 'ALREADY_RD_FLAG', DbType.text);
  }

  DeliveryField? _REDIRECT_BO_ID;
  DeliveryField get REDIRECT_BO_ID {
    return _REDIRECT_BO_ID =
        _setField(_REDIRECT_BO_ID, 'REDIRECT_BO_ID', DbType.text);
  }

  DeliveryField? _IFS_SOFFICE_NAME;
  DeliveryField get IFS_SOFFICE_NAME {
    return _IFS_SOFFICE_NAME =
        _setField(_IFS_SOFFICE_NAME, 'IFS_SOFFICE_NAME', DbType.text);
  }

  DeliveryField? _CHECT;
  DeliveryField get CHECT {
    return _CHECT = _setField(_CHECT, 'CHECT', DbType.text);
  }

  DeliveryField? _TREASURY_SUBMIT_DONE;
  DeliveryField get TREASURY_SUBMIT_DONE {
    return _TREASURY_SUBMIT_DONE =
        _setField(_TREASURY_SUBMIT_DONE, 'TREASURY_SUBMIT_DONE', DbType.text);
  }

  DeliveryField? _TREASURY_SUBMIT_DATE;
  DeliveryField get TREASURY_SUBMIT_DATE {
    return _TREASURY_SUBMIT_DATE =
        _setField(_TREASURY_SUBMIT_DATE, 'TREASURY_SUBMIT_DATE', DbType.date);
  }

  DeliveryField? _REDIRECTION_SL;
  DeliveryField get REDIRECTION_SL {
    return _REDIRECTION_SL =
        _setField(_REDIRECTION_SL, 'REDIRECTION_SL', DbType.real);
  }

  DeliveryField? _TRANSACTION_DATE;
  DeliveryField get TRANSACTION_DATE {
    return _TRANSACTION_DATE =
        _setField(_TRANSACTION_DATE, 'TRANSACTION_DATE', DbType.date);
  }

  DeliveryField? _TRANSACTION_TIME;
  DeliveryField get TRANSACTION_TIME {
    return _TRANSACTION_TIME =
        _setField(_TRANSACTION_TIME, 'TRANSACTION_TIME', DbType.datetime);
  }

  DeliveryField? _IS_COMMUNICATED;
  DeliveryField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  DeliveryField? _IS_PREVIOUS_DAY_DEPOSIT;
  DeliveryField get IS_PREVIOUS_DAY_DEPOSIT {
    return _IS_PREVIOUS_DAY_DEPOSIT = _setField(
        _IS_PREVIOUS_DAY_DEPOSIT, 'IS_PREVIOUS_DAY_DEPOSIT', DbType.text);
  }

  DeliveryField? _E_PROOF;
  DeliveryField get E_PROOF {
    return _E_PROOF = _setField(_E_PROOF, 'E_PROOF', DbType.text);
  }

  DeliveryField? _MATNR;
  DeliveryField get MATNR {
    return _MATNR = _setField(_MATNR, 'MATNR', DbType.text);
  }

  DeliveryField? _CASH_ID;
  DeliveryField get CASH_ID {
    return _CASH_ID = _setField(_CASH_ID, 'CASH_ID', DbType.text);
  }

  DeliveryField? _REMARK_DATE;
  DeliveryField get REMARK_DATE {
    return _REMARK_DATE = _setField(_REMARK_DATE, 'REMARK_DATE', DbType.date);
  }

  DeliveryField? _CASH_RETURNED;
  DeliveryField get CASH_RETURNED {
    return _CASH_RETURNED =
        _setField(_CASH_RETURNED, 'CASH_RETURNED', DbType.text);
  }

  DeliveryField? _FILE_NAME;
  DeliveryField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  DeliveryField? _REPORTING_SO_ID;
  DeliveryField get REPORTING_SO_ID {
    return _REPORTING_SO_ID =
        _setField(_REPORTING_SO_ID, 'REPORTING_SO_ID', DbType.text);
  }

  DeliveryField? _despatchStatus;
  DeliveryField get despatchStatus {
    return _despatchStatus =
        _setField(_despatchStatus, 'despatchStatus', DbType.text);
  }

  DeliveryField? _CUST_DUTY;
  DeliveryField get CUST_DUTY {
    return _CUST_DUTY = _setField(_CUST_DUTY, 'CUST_DUTY', DbType.real);
  }

  DeliveryField? _BO_SLIP;
  DeliveryField get BO_SLIP {
    return _BO_SLIP = _setField(_BO_SLIP, 'BO_SLIP', DbType.text);
  }

  DeliveryField? _ZIP_FILE_NAME;
  DeliveryField get ZIP_FILE_NAME {
    return _ZIP_FILE_NAME =
        _setField(_ZIP_FILE_NAME, 'ZIP_FILE_NAME', DbType.text);
  }

  /// Deletes List<Delivery> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDelivery!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDelivery!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ART_NUMBER IN (SELECT ART_NUMBER from Delivery ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDelivery!.updateBatch(qparams, values);
  }

  /// This method always returns [Delivery] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Delivery?
  @override
  Future<Delivery?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDelivery!.toList(qparams);
    final data = await objFuture;
    Delivery? obj;
    if (data.isNotEmpty) {
      obj = Delivery.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Delivery]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Delivery?
  @override
  Future<Delivery> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Delivery();
  }

  /// This method returns int. [Delivery]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? deliveryCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final deliveriesFuture = await _mnDelivery!.toList(qparams);
    final int count = deliveriesFuture[0]['CNT'] as int;
    if (deliveryCount != null) {
      deliveryCount(count);
    }
    return count;
  }

  /// This method returns List<Delivery> [Delivery]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Delivery>
  @override
  Future<List<Delivery>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Delivery> deliveriesData = await Delivery.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return deliveriesData;
  }

  /// This method returns Json String [Delivery]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Delivery]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Delivery]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDelivery!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Delivery]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ART_NUMBER` FROM Delivery WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ART_NUMBERData = <String>[];
    qparams.selectColumns = ['ART_NUMBER'];
    final ART_NUMBERFuture = await _mnDelivery!.toList(qparams);

    final int count = ART_NUMBERFuture.length;
    for (int i = 0; i < count; i++) {
      ART_NUMBERData.add(ART_NUMBERFuture[i]['ART_NUMBER'] as String);
    }
    return ART_NUMBERData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Delivery]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDelivery!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Delivery.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDelivery!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DeliveryFilterBuilder

// region DeliveryFields
class DeliveryFields {
  static TableField? _fART_NUMBER;
  static TableField get ART_NUMBER {
    return _fART_NUMBER = _fART_NUMBER ??
        SqlSyntax.setField(_fART_NUMBER, 'art_number', DbType.integer);
  }

  static TableField? _fInvoiceDate;
  static TableField get invoiceDate {
    return _fInvoiceDate = _fInvoiceDate ??
        SqlSyntax.setField(_fInvoiceDate, 'invoiceDate', DbType.text);
  }

  static TableField? _fInvoiced;
  static TableField get invoiced {
    return _fInvoiced =
        _fInvoiced ?? SqlSyntax.setField(_fInvoiced, 'invoiced', DbType.text);
  }

  static TableField? _fSOFFICE_ID;
  static TableField get SOFFICE_ID {
    return _fSOFFICE_ID = _fSOFFICE_ID ??
        SqlSyntax.setField(_fSOFFICE_ID, 'SOFFICE_ID ', DbType.text);
  }

  static TableField? _fDOFFICE_ID;
  static TableField get DOFFICE_ID {
    return _fDOFFICE_ID = _fDOFFICE_ID ??
        SqlSyntax.setField(_fDOFFICE_ID, 'DOFFICE_ID', DbType.text);
  }

  static TableField? _fBOOK_DATE;
  static TableField get BOOK_DATE {
    return _fBOOK_DATE = _fBOOK_DATE ??
        SqlSyntax.setField(_fBOOK_DATE, 'BOOK_DATE', DbType.text);
  }

  static TableField? _fBOOK_ID;
  static TableField get BOOK_ID {
    return _fBOOK_ID =
        _fBOOK_ID ?? SqlSyntax.setField(_fBOOK_ID, 'BOOK_ID', DbType.text);
  }

  static TableField? _fLINE_ITEM;
  static TableField get LINE_ITEM {
    return _fLINE_ITEM = _fLINE_ITEM ??
        SqlSyntax.setField(_fLINE_ITEM, 'LINE_ITEM', DbType.real);
  }

  static TableField? _fBAG_ID;
  static TableField get BAG_ID {
    return _fBAG_ID =
        _fBAG_ID ?? SqlSyntax.setField(_fBAG_ID, 'BAG_ID', DbType.text);
  }

  static TableField? _fINSURANCE;
  static TableField get INSURANCE {
    return _fINSURANCE = _fINSURANCE ??
        SqlSyntax.setField(_fINSURANCE, 'INSURANCE', DbType.text);
  }

  static TableField? _fON_HOLD;
  static TableField get ON_HOLD {
    return _fON_HOLD =
        _fON_HOLD ?? SqlSyntax.setField(_fON_HOLD, 'ON_HOLD', DbType.text);
  }

  static TableField? _fHOLD_DATE;
  static TableField get HOLD_DATE {
    return _fHOLD_DATE = _fHOLD_DATE ??
        SqlSyntax.setField(_fHOLD_DATE, 'HOLD_DATE', DbType.date);
  }

  static TableField? _fHOLD_TILL_DATE;
  static TableField get HOLD_TILL_DATE {
    return _fHOLD_TILL_DATE = _fHOLD_TILL_DATE ??
        SqlSyntax.setField(_fHOLD_TILL_DATE, 'HOLD_TILL_DATE', DbType.date);
  }

  static TableField? _fPENSIONER_ID;
  static TableField get PENSIONER_ID {
    return _fPENSIONER_ID = _fPENSIONER_ID ??
        SqlSyntax.setField(_fPENSIONER_ID, 'PENSIONER_ID', DbType.text);
  }

  static TableField? _fREASON_FOR_NONDELIVERY;
  static TableField get REASON_FOR_NONDELIVERY {
    return _fREASON_FOR_NONDELIVERY = _fREASON_FOR_NONDELIVERY ??
        SqlSyntax.setField(
            _fREASON_FOR_NONDELIVERY, 'REASON_FOR_NONDELIVERY', DbType.text);
  }

  static TableField? _fREASON_TYPE;
  static TableField get REASON_TYPE {
    return _fREASON_TYPE = _fREASON_TYPE ??
        SqlSyntax.setField(_fREASON_TYPE, 'REASON_TYPE', DbType.text);
  }

  static TableField? _fACTION;
  static TableField get ACTION {
    return _fACTION =
        _fACTION ?? SqlSyntax.setField(_fACTION, 'ACTION', DbType.text);
  }

  static TableField? _fMONEY_TO_BE_COLLECTED;
  static TableField get MONEY_TO_BE_COLLECTED {
    return _fMONEY_TO_BE_COLLECTED = _fMONEY_TO_BE_COLLECTED ??
        SqlSyntax.setField(
            _fMONEY_TO_BE_COLLECTED, 'MONEY_TO_BE_COLLECTED', DbType.real);
  }

  static TableField? _fMONEY_COLLECTED;
  static TableField get MONEY_COLLECTED {
    return _fMONEY_COLLECTED = _fMONEY_COLLECTED ??
        SqlSyntax.setField(_fMONEY_COLLECTED, 'MONEY_COLLECTED', DbType.real);
  }

  static TableField? _fPOST_DUE;
  static TableField get POST_DUE {
    return _fPOST_DUE =
        _fPOST_DUE ?? SqlSyntax.setField(_fPOST_DUE, 'POST_DUE', DbType.real);
  }

  static TableField? _fDEM_CHARGE;
  static TableField get DEM_CHARGE {
    return _fDEM_CHARGE = _fDEM_CHARGE ??
        SqlSyntax.setField(_fDEM_CHARGE, 'DEM_CHARGE', DbType.real);
  }

  static TableField? _fCOMMISSION;
  static TableField get COMMISSION {
    return _fCOMMISSION = _fCOMMISSION ??
        SqlSyntax.setField(_fCOMMISSION, 'COMMISSION', DbType.real);
  }

  static TableField? _fMONEY_TO_BE_DELIVERED;
  static TableField get MONEY_TO_BE_DELIVERED {
    return _fMONEY_TO_BE_DELIVERED = _fMONEY_TO_BE_DELIVERED ??
        SqlSyntax.setField(
            _fMONEY_TO_BE_DELIVERED, 'MONEY_TO_BE_DELIVERED', DbType.real);
  }

  static TableField? _fMONEY_DELIVERED;
  static TableField get MONEY_DELIVERED {
    return _fMONEY_DELIVERED = _fMONEY_DELIVERED ??
        SqlSyntax.setField(_fMONEY_DELIVERED, 'MONEY_DELIVERED', DbType.real);
  }

  static TableField? _fNO_OF_HOLD_DAYS;
  static TableField get NO_OF_HOLD_DAYS {
    return _fNO_OF_HOLD_DAYS = _fNO_OF_HOLD_DAYS ??
        SqlSyntax.setField(_fNO_OF_HOLD_DAYS, 'NO_OF_HOLD_DAYS', DbType.real);
  }

  static TableField? _fDATE_OF_DELIVERY;
  static TableField get DATE_OF_DELIVERY {
    return _fDATE_OF_DELIVERY = _fDATE_OF_DELIVERY ??
        SqlSyntax.setField(_fDATE_OF_DELIVERY, 'DATE_OF_DELIVERY', DbType.date);
  }

  static TableField? _fDATE_OF_DELIVERY_CONFIRM;
  static TableField get DATE_OF_DELIVERY_CONFIRM {
    return _fDATE_OF_DELIVERY_CONFIRM = _fDATE_OF_DELIVERY_CONFIRM ??
        SqlSyntax.setField(_fDATE_OF_DELIVERY_CONFIRM,
            'DATE_OF_DELIVERY_CONFIRM', DbType.date);
  }

  static TableField? _fTIME_OF_DELIVERY_CONFIRM;
  static TableField get TIME_OF_DELIVERY_CONFIRM {
    return _fTIME_OF_DELIVERY_CONFIRM = _fTIME_OF_DELIVERY_CONFIRM ??
        SqlSyntax.setField(_fTIME_OF_DELIVERY_CONFIRM,
            'TIME_OF_DELIVERY_CONFIRM', DbType.datetime);
  }

  static TableField? _fDATE_OF_1ST_DELIVERY_CONFIRM;
  static TableField get DATE_OF_1ST_DELIVERY_CONFIRM {
    return _fDATE_OF_1ST_DELIVERY_CONFIRM = _fDATE_OF_1ST_DELIVERY_CONFIRM ??
        SqlSyntax.setField(_fDATE_OF_1ST_DELIVERY_CONFIRM,
            'DATE_OF_1ST_DELIVERY_CONFIRM', DbType.date);
  }

  static TableField? _fDATE_OF_2ND_DELIVERY_CONFIRM;
  static TableField get DATE_OF_2ND_DELIVERY_CONFIRM {
    return _fDATE_OF_2ND_DELIVERY_CONFIRM = _fDATE_OF_2ND_DELIVERY_CONFIRM ??
        SqlSyntax.setField(_fDATE_OF_2ND_DELIVERY_CONFIRM,
            'DATE_OF_2ND_DELIVERY_CONFIRM', DbType.date);
  }

  static TableField? _fDATE_OF_3RD_DELIVERY_CONFIRM;
  static TableField get DATE_OF_3RD_DELIVERY_CONFIRM {
    return _fDATE_OF_3RD_DELIVERY_CONFIRM = _fDATE_OF_3RD_DELIVERY_CONFIRM ??
        SqlSyntax.setField(_fDATE_OF_3RD_DELIVERY_CONFIRM,
            'DATE_OF_3RD_DELIVERY_CONFIRM', DbType.date);
  }

  static TableField? _fDELIVERY_TIME;
  static TableField get DELIVERY_TIME {
    return _fDELIVERY_TIME = _fDELIVERY_TIME ??
        SqlSyntax.setField(_fDELIVERY_TIME, 'DELIVERY_TIME', DbType.datetime);
  }

  static TableField? _fDEL_DATE;
  static TableField get DEL_DATE {
    return _fDEL_DATE =
        _fDEL_DATE ?? SqlSyntax.setField(_fDEL_DATE, 'DEL_DATE', DbType.date);
  }

  static TableField? _fID_PROOF_DOC;
  static TableField get ID_PROOF_DOC {
    return _fID_PROOF_DOC = _fID_PROOF_DOC ??
        SqlSyntax.setField(_fID_PROOF_DOC, 'ID_PROOF_DOC', DbType.text);
  }

  static TableField? _fID_PROOF_NMBR;
  static TableField get ID_PROOF_NMBR {
    return _fID_PROOF_NMBR = _fID_PROOF_NMBR ??
        SqlSyntax.setField(_fID_PROOF_NMBR, 'ID_PROOF_NMBR', DbType.text);
  }

  static TableField? _fISSUING_AUTHORITY;
  static TableField get ISSUING_AUTHORITY {
    return _fISSUING_AUTHORITY = _fISSUING_AUTHORITY ??
        SqlSyntax.setField(
            _fISSUING_AUTHORITY, 'ISSUING_AUTHORITY', DbType.text);
  }

  static TableField? _fID_PROOF_VALIDITY_DATE;
  static TableField get ID_PROOF_VALIDITY_DATE {
    return _fID_PROOF_VALIDITY_DATE = _fID_PROOF_VALIDITY_DATE ??
        SqlSyntax.setField(
            _fID_PROOF_VALIDITY_DATE, 'ID_PROOF_VALIDITY_DATE', DbType.date);
  }

  static TableField? _fWINDOW_DELIVERY;
  static TableField get WINDOW_DELIVERY {
    return _fWINDOW_DELIVERY = _fWINDOW_DELIVERY ??
        SqlSyntax.setField(_fWINDOW_DELIVERY, 'WINDOW_DELIVERY', DbType.text);
  }

  static TableField? _fREDIRECTION_FEE;
  static TableField get REDIRECTION_FEE {
    return _fREDIRECTION_FEE = _fREDIRECTION_FEE ??
        SqlSyntax.setField(_fREDIRECTION_FEE, 'REDIRECTION_FEE', DbType.real);
  }

  static TableField? _fRETRN_DATE;
  static TableField get RETRN_DATE {
    return _fRETRN_DATE = _fRETRN_DATE ??
        SqlSyntax.setField(_fRETRN_DATE, 'RETRN_DATE', DbType.date);
  }

  static TableField? _fRETRN_TIME;
  static TableField get RETRN_TIME {
    return _fRETRN_TIME = _fRETRN_TIME ??
        SqlSyntax.setField(_fRETRN_TIME, 'RETRN_TIME', DbType.datetime);
  }

  static TableField? _fBEAT_NO;
  static TableField get BEAT_NO {
    return _fBEAT_NO =
        _fBEAT_NO ?? SqlSyntax.setField(_fBEAT_NO, 'BEAT_NO', DbType.text);
  }

  static TableField? _fPERNR;
  static TableField get PERNR {
    return _fPERNR =
        _fPERNR ?? SqlSyntax.setField(_fPERNR, 'PERNR', DbType.real);
  }

  static TableField? _fART_STATUS;
  static TableField get ART_STATUS {
    return _fART_STATUS = _fART_STATUS ??
        SqlSyntax.setField(_fART_STATUS, 'ART_STATUS', DbType.text);
  }

  static TableField? _fART_RECEIVE_DATE;
  static TableField get ART_RECEIVE_DATE {
    return _fART_RECEIVE_DATE = _fART_RECEIVE_DATE ??
        SqlSyntax.setField(_fART_RECEIVE_DATE, 'ART_RECEIVE_DATE', DbType.text);
  }

  static TableField? _fART_RECEIVE_TIME;
  static TableField get ART_RECEIVE_TIME {
    return _fART_RECEIVE_TIME = _fART_RECEIVE_TIME ??
        SqlSyntax.setField(_fART_RECEIVE_TIME, 'ART_RECEIVE_TIME', DbType.text);
  }

  static TableField? _fREMARKS;
  static TableField get REMARKS {
    return _fREMARKS =
        _fREMARKS ?? SqlSyntax.setField(_fREMARKS, 'REMARKS', DbType.text);
  }

  static TableField? _fZCONDITION;
  static TableField get ZCONDITION {
    return _fZCONDITION = _fZCONDITION ??
        SqlSyntax.setField(_fZCONDITION, 'ZCONDITION', DbType.text);
  }

  static TableField? _fTOTAL_MONEY;
  static TableField get TOTAL_MONEY {
    return _fTOTAL_MONEY = _fTOTAL_MONEY ??
        SqlSyntax.setField(_fTOTAL_MONEY, 'TOTAL_MONEY', DbType.real);
  }

  static TableField? _fPOSTAGE_NOT_COLLECTED;
  static TableField get POSTAGE_NOT_COLLECTED {
    return _fPOSTAGE_NOT_COLLECTED = _fPOSTAGE_NOT_COLLECTED ??
        SqlSyntax.setField(
            _fPOSTAGE_NOT_COLLECTED, 'POSTAGE_NOT_COLLECTED', DbType.real);
  }

  static TableField? _fMOP;
  static TableField get MOP {
    return _fMOP = _fMOP ?? SqlSyntax.setField(_fMOP, 'MOP', DbType.text);
  }

  static TableField? _fVPP;
  static TableField get VPP {
    return _fVPP = _fVPP ?? SqlSyntax.setField(_fVPP, 'VPP', DbType.text);
  }

  static TableField? _fBATCH_ID;
  static TableField get BATCH_ID {
    return _fBATCH_ID =
        _fBATCH_ID ?? SqlSyntax.setField(_fBATCH_ID, 'BATCH_ID', DbType.text);
  }

  static TableField? _fSHIFT_NO;
  static TableField get SHIFT_NO {
    return _fSHIFT_NO =
        _fSHIFT_NO ?? SqlSyntax.setField(_fSHIFT_NO, 'SHIFT_NO', DbType.text);
  }

  static TableField? _fRET_RCL_RDL_STOPDELV_STATUS2;
  static TableField get RET_RCL_RDL_STOPDELV_STATUS2 {
    return _fRET_RCL_RDL_STOPDELV_STATUS2 = _fRET_RCL_RDL_STOPDELV_STATUS2 ??
        SqlSyntax.setField(_fRET_RCL_RDL_STOPDELV_STATUS2,
            'RET_RCL_RDL_STOPDELV_STATUS2', DbType.text);
  }

  static TableField? _fTYPE_OF_PAYEE;
  static TableField get TYPE_OF_PAYEE {
    return _fTYPE_OF_PAYEE = _fTYPE_OF_PAYEE ??
        SqlSyntax.setField(_fTYPE_OF_PAYEE, 'TYPE_OF_PAYEE', DbType.text);
  }

  static TableField? _fREDIRECT_PIN;
  static TableField get REDIRECT_PIN {
    return _fREDIRECT_PIN = _fREDIRECT_PIN ??
        SqlSyntax.setField(_fREDIRECT_PIN, 'REDIRECT_PIN', DbType.integer);
  }

  static TableField? _fMOD_PIN;
  static TableField get MOD_PIN {
    return _fMOD_PIN =
        _fMOD_PIN ?? SqlSyntax.setField(_fMOD_PIN, 'MOD_PIN', DbType.integer);
  }

  static TableField? _fSOURCE_PINCODE;
  static TableField get SOURCE_PINCODE {
    return _fSOURCE_PINCODE = _fSOURCE_PINCODE ??
        SqlSyntax.setField(_fSOURCE_PINCODE, 'SOURCE_PINCODE', DbType.integer);
  }

  static TableField? _fDESTN_PINCODE;
  static TableField get DESTN_PINCODE {
    return _fDESTN_PINCODE = _fDESTN_PINCODE ??
        SqlSyntax.setField(_fDESTN_PINCODE, 'DESTN_PINCODE', DbType.integer);
  }

  static TableField? _fEMO_MESSAGE;
  static TableField get EMO_MESSAGE {
    return _fEMO_MESSAGE = _fEMO_MESSAGE ??
        SqlSyntax.setField(_fEMO_MESSAGE, 'EMO_MESSAGE', DbType.text);
  }

  static TableField? _fREGISTERED;
  static TableField get REGISTERED {
    return _fREGISTERED = _fREGISTERED ??
        SqlSyntax.setField(_fREGISTERED, 'REGISTERED', DbType.text);
  }

  static TableField? _fRETURN_SERVICE;
  static TableField get RETURN_SERVICE {
    return _fRETURN_SERVICE = _fRETURN_SERVICE ??
        SqlSyntax.setField(_fRETURN_SERVICE, 'RETURN_SERVICE', DbType.text);
  }

  static TableField? _fCOD;
  static TableField get COD {
    return _fCOD = _fCOD ?? SqlSyntax.setField(_fCOD, 'COD', DbType.text);
  }

  static TableField? _fRT;
  static TableField get RT {
    return _fRT = _fRT ?? SqlSyntax.setField(_fRT, 'RT', DbType.text);
  }

  static TableField? _fRT_DATE;
  static TableField get RT_DATE {
    return _fRT_DATE =
        _fRT_DATE ?? SqlSyntax.setField(_fRT_DATE, 'RT_DATE', DbType.date);
  }

  static TableField? _fRT_TIME;
  static TableField get RT_TIME {
    return _fRT_TIME =
        _fRT_TIME ?? SqlSyntax.setField(_fRT_TIME, 'RT_TIME', DbType.datetime);
  }

  static TableField? _fRD;
  static TableField get RD {
    return _fRD = _fRD ?? SqlSyntax.setField(_fRD, 'RD', DbType.text);
  }

  static TableField? _fRD_DATE;
  static TableField get RD_DATE {
    return _fRD_DATE =
        _fRD_DATE ?? SqlSyntax.setField(_fRD_DATE, 'RD_DATE', DbType.date);
  }

  static TableField? _fRD_TIME;
  static TableField get RD_TIME {
    return _fRD_TIME =
        _fRD_TIME ?? SqlSyntax.setField(_fRD_TIME, 'RD_TIME', DbType.datetime);
  }

  static TableField? _fSP;
  static TableField get SP {
    return _fSP = _fSP ?? SqlSyntax.setField(_fSP, 'SP', DbType.text);
  }

  static TableField? _fSP_DATE;
  static TableField get SP_DATE {
    return _fSP_DATE =
        _fSP_DATE ?? SqlSyntax.setField(_fSP_DATE, 'SP_DATE', DbType.date);
  }

  static TableField? _fSP_TIME;
  static TableField get SP_TIME {
    return _fSP_TIME =
        _fSP_TIME ?? SqlSyntax.setField(_fSP_TIME, 'SP_TIME', DbType.datetime);
  }

  static TableField? _fPOSTE_RESTANTE;
  static TableField get POSTE_RESTANTE {
    return _fPOSTE_RESTANTE = _fPOSTE_RESTANTE ??
        SqlSyntax.setField(_fPOSTE_RESTANTE, 'POSTE_RESTANTE', DbType.text);
  }

  static TableField? _fBO_ID;
  static TableField get BO_ID {
    return _fBO_ID =
        _fBO_ID ?? SqlSyntax.setField(_fBO_ID, 'BO_ID', DbType.text);
  }

  static TableField? _fLAST_CHANGED_USER;
  static TableField get LAST_CHANGED_USER {
    return _fLAST_CHANGED_USER = _fLAST_CHANGED_USER ??
        SqlSyntax.setField(
            _fLAST_CHANGED_USER, 'LAST_CHANGED_USER', DbType.text);
  }

  static TableField? _fBELNR;
  static TableField get BELNR {
    return _fBELNR =
        _fBELNR ?? SqlSyntax.setField(_fBELNR, 'BELNR', DbType.text);
  }

  static TableField? _fALREADY_RTN_FLAG;
  static TableField get ALREADY_RTN_FLAG {
    return _fALREADY_RTN_FLAG = _fALREADY_RTN_FLAG ??
        SqlSyntax.setField(_fALREADY_RTN_FLAG, 'ALREADY_RTN_FLAG', DbType.text);
  }

  static TableField? _fALREADY_RD_FLAG;
  static TableField get ALREADY_RD_FLAG {
    return _fALREADY_RD_FLAG = _fALREADY_RD_FLAG ??
        SqlSyntax.setField(_fALREADY_RD_FLAG, 'ALREADY_RD_FLAG', DbType.text);
  }

  static TableField? _fREDIRECT_BO_ID;
  static TableField get REDIRECT_BO_ID {
    return _fREDIRECT_BO_ID = _fREDIRECT_BO_ID ??
        SqlSyntax.setField(_fREDIRECT_BO_ID, 'REDIRECT_BO_ID', DbType.text);
  }

  static TableField? _fIFS_SOFFICE_NAME;
  static TableField get IFS_SOFFICE_NAME {
    return _fIFS_SOFFICE_NAME = _fIFS_SOFFICE_NAME ??
        SqlSyntax.setField(_fIFS_SOFFICE_NAME, 'IFS_SOFFICE_NAME', DbType.text);
  }

  static TableField? _fCHECT;
  static TableField get CHECT {
    return _fCHECT =
        _fCHECT ?? SqlSyntax.setField(_fCHECT, 'CHECT', DbType.text);
  }

  static TableField? _fTREASURY_SUBMIT_DONE;
  static TableField get TREASURY_SUBMIT_DONE {
    return _fTREASURY_SUBMIT_DONE = _fTREASURY_SUBMIT_DONE ??
        SqlSyntax.setField(
            _fTREASURY_SUBMIT_DONE, 'TREASURY_SUBMIT_DONE', DbType.text);
  }

  static TableField? _fTREASURY_SUBMIT_DATE;
  static TableField get TREASURY_SUBMIT_DATE {
    return _fTREASURY_SUBMIT_DATE = _fTREASURY_SUBMIT_DATE ??
        SqlSyntax.setField(
            _fTREASURY_SUBMIT_DATE, 'TREASURY_SUBMIT_DATE', DbType.date);
  }

  static TableField? _fREDIRECTION_SL;
  static TableField get REDIRECTION_SL {
    return _fREDIRECTION_SL = _fREDIRECTION_SL ??
        SqlSyntax.setField(_fREDIRECTION_SL, 'REDIRECTION_SL', DbType.real);
  }

  static TableField? _fTRANSACTION_DATE;
  static TableField get TRANSACTION_DATE {
    return _fTRANSACTION_DATE = _fTRANSACTION_DATE ??
        SqlSyntax.setField(_fTRANSACTION_DATE, 'TRANSACTION_DATE', DbType.date);
  }

  static TableField? _fTRANSACTION_TIME;
  static TableField get TRANSACTION_TIME {
    return _fTRANSACTION_TIME = _fTRANSACTION_TIME ??
        SqlSyntax.setField(
            _fTRANSACTION_TIME, 'TRANSACTION_TIME', DbType.datetime);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fIS_PREVIOUS_DAY_DEPOSIT;
  static TableField get IS_PREVIOUS_DAY_DEPOSIT {
    return _fIS_PREVIOUS_DAY_DEPOSIT = _fIS_PREVIOUS_DAY_DEPOSIT ??
        SqlSyntax.setField(
            _fIS_PREVIOUS_DAY_DEPOSIT, 'IS_PREVIOUS_DAY_DEPOSIT', DbType.text);
  }

  static TableField? _fE_PROOF;
  static TableField get E_PROOF {
    return _fE_PROOF =
        _fE_PROOF ?? SqlSyntax.setField(_fE_PROOF, 'E_PROOF', DbType.text);
  }

  static TableField? _fMATNR;
  static TableField get MATNR {
    return _fMATNR =
        _fMATNR ?? SqlSyntax.setField(_fMATNR, 'MATNR', DbType.text);
  }

  static TableField? _fCASH_ID;
  static TableField get CASH_ID {
    return _fCASH_ID =
        _fCASH_ID ?? SqlSyntax.setField(_fCASH_ID, 'CASH_ID', DbType.text);
  }

  static TableField? _fREMARK_DATE;
  static TableField get REMARK_DATE {
    return _fREMARK_DATE = _fREMARK_DATE ??
        SqlSyntax.setField(_fREMARK_DATE, 'REMARK_DATE', DbType.date);
  }

  static TableField? _fCASH_RETURNED;
  static TableField get CASH_RETURNED {
    return _fCASH_RETURNED = _fCASH_RETURNED ??
        SqlSyntax.setField(_fCASH_RETURNED, 'CASH_RETURNED', DbType.text);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }

  static TableField? _fREPORTING_SO_ID;
  static TableField get REPORTING_SO_ID {
    return _fREPORTING_SO_ID = _fREPORTING_SO_ID ??
        SqlSyntax.setField(_fREPORTING_SO_ID, 'REPORTING_SO_ID', DbType.text);
  }

  static TableField? _fDespatchStatus;
  static TableField get despatchStatus {
    return _fDespatchStatus = _fDespatchStatus ??
        SqlSyntax.setField(_fDespatchStatus, 'despatchStatus', DbType.text);
  }

  static TableField? _fCUST_DUTY;
  static TableField get CUST_DUTY {
    return _fCUST_DUTY = _fCUST_DUTY ??
        SqlSyntax.setField(_fCUST_DUTY, 'CUST_DUTY', DbType.real);
  }

  static TableField? _fBO_SLIP;
  static TableField get BO_SLIP {
    return _fBO_SLIP =
        _fBO_SLIP ?? SqlSyntax.setField(_fBO_SLIP, 'BO_SLIP', DbType.text);
  }

  static TableField? _fZIP_FILE_NAME;
  static TableField get ZIP_FILE_NAME {
    return _fZIP_FILE_NAME = _fZIP_FILE_NAME ??
        SqlSyntax.setField(_fZIP_FILE_NAME, 'ZIP_FILE_NAME', DbType.text);
  }
}
// endregion DeliveryFields

//region DeliveryManager
class DeliveryManager extends SqfEntityProvider {
  DeliveryManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Delivery';
  static const List<String> _primaryKeyList = ['ART_NUMBER'];
  static const String _whereStr = 'ART_NUMBER=?';
}

//endregion DeliveryManager
// region Addres
class Addres extends TableBase {
  Addres(
      {this.ART_NUMBER,
      this.SEND_CUST_N,
      this.SEND_ADD1,
      this.SEND_ADD2,
      this.SEND_ADD3,
      this.SEND_STREET,
      this.SEND_CITY,
      this.SEND_COUNTRY,
      this.SEND_STATE,
      this.SEND_EMAIL,
      this.SEND_PIN,
      this.SEND_FAX,
      this.SEND_MOB,
      this.REC_NAME,
      this.REC_ADDRESS1,
      this.REC_ADDRESS2,
      this.REC_ADDRESS3,
      this.REC_COUNTRY,
      this.REC_STATE,
      this.REC_STREET,
      this.REC_CITY,
      this.REC_PIN,
      this.MOD_PIN,
      this.REC_MOB,
      this.REC_EMAIL,
      this.REC_FAX,
      this.RECIPIENT_NAME,
      this.REDIRECT_REC_ADD1,
      this.REDIRECT_REC_ADD2,
      this.REDIRECT_REC_ADD3,
      this.REDIRECT_REC_STREET,
      this.REDIRECT_REC_CITY,
      this.REDIRECT_REC_COUNTRY,
      this.REDIRECT_REC_STATE,
      this.REDIRECT_REC_PIN,
      this.REDIRECT_REC_MOB,
      this.REDIRECT_REC_EMAIL,
      this.REDIRECT_REC_FAX,
      this.REDIRECT_FROM_PIN,
      this.REDIRECT_FROM_BO_ID,
      this.BOOK_ID,
      this.BAG_ID,
      this.BO_SLIP}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Addres.withFields(
      this.ART_NUMBER,
      this.SEND_CUST_N,
      this.SEND_ADD1,
      this.SEND_ADD2,
      this.SEND_ADD3,
      this.SEND_STREET,
      this.SEND_CITY,
      this.SEND_COUNTRY,
      this.SEND_STATE,
      this.SEND_EMAIL,
      this.SEND_PIN,
      this.SEND_FAX,
      this.SEND_MOB,
      this.REC_NAME,
      this.REC_ADDRESS1,
      this.REC_ADDRESS2,
      this.REC_ADDRESS3,
      this.REC_COUNTRY,
      this.REC_STATE,
      this.REC_STREET,
      this.REC_CITY,
      this.REC_PIN,
      this.MOD_PIN,
      this.REC_MOB,
      this.REC_EMAIL,
      this.REC_FAX,
      this.RECIPIENT_NAME,
      this.REDIRECT_REC_ADD1,
      this.REDIRECT_REC_ADD2,
      this.REDIRECT_REC_ADD3,
      this.REDIRECT_REC_STREET,
      this.REDIRECT_REC_CITY,
      this.REDIRECT_REC_COUNTRY,
      this.REDIRECT_REC_STATE,
      this.REDIRECT_REC_PIN,
      this.REDIRECT_REC_MOB,
      this.REDIRECT_REC_EMAIL,
      this.REDIRECT_REC_FAX,
      this.REDIRECT_FROM_PIN,
      this.REDIRECT_FROM_BO_ID,
      this.BOOK_ID,
      this.BAG_ID,
      this.BO_SLIP) {
    _setDefaultValues();
  }
  Addres.withId(
      this.ART_NUMBER,
      this.SEND_CUST_N,
      this.SEND_ADD1,
      this.SEND_ADD2,
      this.SEND_ADD3,
      this.SEND_STREET,
      this.SEND_CITY,
      this.SEND_COUNTRY,
      this.SEND_STATE,
      this.SEND_EMAIL,
      this.SEND_PIN,
      this.SEND_FAX,
      this.SEND_MOB,
      this.REC_NAME,
      this.REC_ADDRESS1,
      this.REC_ADDRESS2,
      this.REC_ADDRESS3,
      this.REC_COUNTRY,
      this.REC_STATE,
      this.REC_STREET,
      this.REC_CITY,
      this.REC_PIN,
      this.MOD_PIN,
      this.REC_MOB,
      this.REC_EMAIL,
      this.REC_FAX,
      this.RECIPIENT_NAME,
      this.REDIRECT_REC_ADD1,
      this.REDIRECT_REC_ADD2,
      this.REDIRECT_REC_ADD3,
      this.REDIRECT_REC_STREET,
      this.REDIRECT_REC_CITY,
      this.REDIRECT_REC_COUNTRY,
      this.REDIRECT_REC_STATE,
      this.REDIRECT_REC_PIN,
      this.REDIRECT_REC_MOB,
      this.REDIRECT_REC_EMAIL,
      this.REDIRECT_REC_FAX,
      this.REDIRECT_FROM_PIN,
      this.REDIRECT_FROM_BO_ID,
      this.BOOK_ID,
      this.BAG_ID,
      this.BO_SLIP) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Addres.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ART_NUMBER = o['ART_NUMBER'].toString();
    if (o['SEND_CUST_N '] != null) {
      SEND_CUST_N = o['SEND_CUST_N '].toString();
    }
    if (o['SEND_ADD1'] != null) {
      SEND_ADD1 = o['SEND_ADD1'].toString();
    }
    if (o['SEND_ADD2'] != null) {
      SEND_ADD2 = o['SEND_ADD2'].toString();
    }
    if (o['SEND_ADD3'] != null) {
      SEND_ADD3 = o['SEND_ADD3'].toString();
    }
    if (o['SEND_STREET'] != null) {
      SEND_STREET = o['SEND_STREET'].toString();
    }
    if (o['SEND_CITY'] != null) {
      SEND_CITY = o['SEND_CITY'].toString();
    }
    if (o['SEND_COUNTRY'] != null) {
      SEND_COUNTRY = o['SEND_COUNTRY'].toString();
    }
    if (o['SEND_STATE'] != null) {
      SEND_STATE = o['SEND_STATE'].toString();
    }
    if (o['SEND_EMAIL'] != null) {
      SEND_EMAIL = o['SEND_EMAIL'].toString();
    }
    if (o['SEND_PIN'] != null) {
      SEND_PIN = int.tryParse(o['SEND_PIN'].toString());
    }
    if (o['SEND_FAX'] != null) {
      SEND_FAX = o['SEND_FAX'].toString();
    }
    if (o['SEND_MOB'] != null) {
      SEND_MOB = o['SEND_MOB'].toString();
    }
    if (o['REC_NAME'] != null) {
      REC_NAME = o['REC_NAME'].toString();
    }
    if (o['REC_ADDRESS1'] != null) {
      REC_ADDRESS1 = o['REC_ADDRESS1'].toString();
    }
    if (o['REC_ADDRESS2'] != null) {
      REC_ADDRESS2 = o['REC_ADDRESS2'].toString();
    }
    if (o['REC_ADDRESS3'] != null) {
      REC_ADDRESS3 = o['REC_ADDRESS3'].toString();
    }
    if (o['REC_COUNTRY'] != null) {
      REC_COUNTRY = o['REC_COUNTRY'].toString();
    }
    if (o['REC_STATE'] != null) {
      REC_STATE = o['REC_STATE'].toString();
    }
    if (o['REC_STREET'] != null) {
      REC_STREET = o['REC_STREET'].toString();
    }
    if (o['REC_CITY'] != null) {
      REC_CITY = o['REC_CITY'].toString();
    }
    if (o['REC_PIN'] != null) {
      REC_PIN = int.tryParse(o['REC_PIN'].toString());
    }
    if (o['MOD_PIN'] != null) {
      MOD_PIN = double.tryParse(o['MOD_PIN'].toString());
    }
    if (o['REC_MOB'] != null) {
      REC_MOB = o['REC_MOB'].toString();
    }
    if (o['REC_EMAIL'] != null) {
      REC_EMAIL = o['REC_EMAIL'].toString();
    }
    if (o['REC_FAX'] != null) {
      REC_FAX = o['REC_FAX'].toString();
    }
    if (o['RECIPIENT_NAME'] != null) {
      RECIPIENT_NAME = o['RECIPIENT_NAME'].toString();
    }
    if (o['REDIRECT_REC_ADD1'] != null) {
      REDIRECT_REC_ADD1 = o['REDIRECT_REC_ADD1'].toString();
    }
    if (o['REDIRECT_REC_ADD2'] != null) {
      REDIRECT_REC_ADD2 = o['REDIRECT_REC_ADD2'].toString();
    }
    if (o['REDIRECT_REC_ADD3'] != null) {
      REDIRECT_REC_ADD3 = o['REDIRECT_REC_ADD3'].toString();
    }
    if (o['REDIRECT_REC_STREET'] != null) {
      REDIRECT_REC_STREET = o['REDIRECT_REC_STREET'].toString();
    }
    if (o['REDIRECT_REC_CITY'] != null) {
      REDIRECT_REC_CITY = o['REDIRECT_REC_CITY'].toString();
    }
    if (o['REDIRECT_REC_COUNTRY'] != null) {
      REDIRECT_REC_COUNTRY = o['REDIRECT_REC_COUNTRY'].toString();
    }
    if (o['REDIRECT_REC_STATE'] != null) {
      REDIRECT_REC_STATE = o['REDIRECT_REC_STATE'].toString();
    }
    if (o['REDIRECT_REC_PIN'] != null) {
      REDIRECT_REC_PIN = double.tryParse(o['REDIRECT_REC_PIN'].toString());
    }
    if (o['REDIRECT_REC_MOB'] != null) {
      REDIRECT_REC_MOB = double.tryParse(o['REDIRECT_REC_MOB'].toString());
    }
    if (o['REDIRECT_REC_EMAIL'] != null) {
      REDIRECT_REC_EMAIL = o['REDIRECT_REC_EMAIL'].toString();
    }
    if (o['REDIRECT_REC_FAX'] != null) {
      REDIRECT_REC_FAX = o['REDIRECT_REC_FAX'].toString();
    }
    if (o['REDIRECT_FROM_PIN'] != null) {
      REDIRECT_FROM_PIN = double.tryParse(o['REDIRECT_FROM_PIN'].toString());
    }
    if (o['REDIRECT_FROM_BO_ID'] != null) {
      REDIRECT_FROM_BO_ID = o['REDIRECT_FROM_BO_ID'].toString();
    }
    if (o['BOOK_ID'] != null) {
      BOOK_ID = o['BOOK_ID'].toString();
    }
    if (o['BAG_ID'] != null) {
      BAG_ID = o['BAG_ID'].toString();
    }
    if (o['BO_SLIP'] != null) {
      BO_SLIP = o['BO_SLIP'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Addres)
  String? ART_NUMBER;
  String? SEND_CUST_N;
  String? SEND_ADD1;
  String? SEND_ADD2;
  String? SEND_ADD3;
  String? SEND_STREET;
  String? SEND_CITY;
  String? SEND_COUNTRY;
  String? SEND_STATE;
  String? SEND_EMAIL;
  int? SEND_PIN;
  String? SEND_FAX;
  String? SEND_MOB;
  String? REC_NAME;
  String? REC_ADDRESS1;
  String? REC_ADDRESS2;
  String? REC_ADDRESS3;
  String? REC_COUNTRY;
  String? REC_STATE;
  String? REC_STREET;
  String? REC_CITY;
  int? REC_PIN;
  double? MOD_PIN;
  String? REC_MOB;
  String? REC_EMAIL;
  String? REC_FAX;
  String? RECIPIENT_NAME;
  String? REDIRECT_REC_ADD1;
  String? REDIRECT_REC_ADD2;
  String? REDIRECT_REC_ADD3;
  String? REDIRECT_REC_STREET;
  String? REDIRECT_REC_CITY;
  String? REDIRECT_REC_COUNTRY;
  String? REDIRECT_REC_STATE;
  double? REDIRECT_REC_PIN;
  double? REDIRECT_REC_MOB;
  String? REDIRECT_REC_EMAIL;
  String? REDIRECT_REC_FAX;
  double? REDIRECT_FROM_PIN;
  String? REDIRECT_FROM_BO_ID;
  String? BOOK_ID;
  String? BAG_ID;
  String? BO_SLIP;
  bool? isSaved;
  // end FIELDS (Addres)

  static const bool _softDeleteActivated = false;
  AddresManager? __mnAddres;

  AddresManager get _mnAddres {
    return __mnAddres = __mnAddres ?? AddresManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ART_NUMBER'] = ART_NUMBER;
    if (SEND_CUST_N != null || !forView) {
      map['SEND_CUST_N '] = SEND_CUST_N;
    }
    if (SEND_ADD1 != null || !forView) {
      map['SEND_ADD1'] = SEND_ADD1;
    }
    if (SEND_ADD2 != null || !forView) {
      map['SEND_ADD2'] = SEND_ADD2;
    }
    if (SEND_ADD3 != null || !forView) {
      map['SEND_ADD3'] = SEND_ADD3;
    }
    if (SEND_STREET != null || !forView) {
      map['SEND_STREET'] = SEND_STREET;
    }
    if (SEND_CITY != null || !forView) {
      map['SEND_CITY'] = SEND_CITY;
    }
    if (SEND_COUNTRY != null || !forView) {
      map['SEND_COUNTRY'] = SEND_COUNTRY;
    }
    if (SEND_STATE != null || !forView) {
      map['SEND_STATE'] = SEND_STATE;
    }
    if (SEND_EMAIL != null || !forView) {
      map['SEND_EMAIL'] = SEND_EMAIL;
    }
    if (SEND_PIN != null || !forView) {
      map['SEND_PIN'] = SEND_PIN;
    }
    if (SEND_FAX != null || !forView) {
      map['SEND_FAX'] = SEND_FAX;
    }
    if (SEND_MOB != null || !forView) {
      map['SEND_MOB'] = SEND_MOB;
    }
    if (REC_NAME != null || !forView) {
      map['REC_NAME'] = REC_NAME;
    }
    if (REC_ADDRESS1 != null || !forView) {
      map['REC_ADDRESS1'] = REC_ADDRESS1;
    }
    if (REC_ADDRESS2 != null || !forView) {
      map['REC_ADDRESS2'] = REC_ADDRESS2;
    }
    if (REC_ADDRESS3 != null || !forView) {
      map['REC_ADDRESS3'] = REC_ADDRESS3;
    }
    if (REC_COUNTRY != null || !forView) {
      map['REC_COUNTRY'] = REC_COUNTRY;
    }
    if (REC_STATE != null || !forView) {
      map['REC_STATE'] = REC_STATE;
    }
    if (REC_STREET != null || !forView) {
      map['REC_STREET'] = REC_STREET;
    }
    if (REC_CITY != null || !forView) {
      map['REC_CITY'] = REC_CITY;
    }
    if (REC_PIN != null || !forView) {
      map['REC_PIN'] = REC_PIN;
    }
    if (MOD_PIN != null || !forView) {
      map['MOD_PIN'] = MOD_PIN;
    }
    if (REC_MOB != null || !forView) {
      map['REC_MOB'] = REC_MOB;
    }
    if (REC_EMAIL != null || !forView) {
      map['REC_EMAIL'] = REC_EMAIL;
    }
    if (REC_FAX != null || !forView) {
      map['REC_FAX'] = REC_FAX;
    }
    if (RECIPIENT_NAME != null || !forView) {
      map['RECIPIENT_NAME'] = RECIPIENT_NAME;
    }
    if (REDIRECT_REC_ADD1 != null || !forView) {
      map['REDIRECT_REC_ADD1'] = REDIRECT_REC_ADD1;
    }
    if (REDIRECT_REC_ADD2 != null || !forView) {
      map['REDIRECT_REC_ADD2'] = REDIRECT_REC_ADD2;
    }
    if (REDIRECT_REC_ADD3 != null || !forView) {
      map['REDIRECT_REC_ADD3'] = REDIRECT_REC_ADD3;
    }
    if (REDIRECT_REC_STREET != null || !forView) {
      map['REDIRECT_REC_STREET'] = REDIRECT_REC_STREET;
    }
    if (REDIRECT_REC_CITY != null || !forView) {
      map['REDIRECT_REC_CITY'] = REDIRECT_REC_CITY;
    }
    if (REDIRECT_REC_COUNTRY != null || !forView) {
      map['REDIRECT_REC_COUNTRY'] = REDIRECT_REC_COUNTRY;
    }
    if (REDIRECT_REC_STATE != null || !forView) {
      map['REDIRECT_REC_STATE'] = REDIRECT_REC_STATE;
    }
    if (REDIRECT_REC_PIN != null || !forView) {
      map['REDIRECT_REC_PIN'] = REDIRECT_REC_PIN;
    }
    if (REDIRECT_REC_MOB != null || !forView) {
      map['REDIRECT_REC_MOB'] = REDIRECT_REC_MOB;
    }
    if (REDIRECT_REC_EMAIL != null || !forView) {
      map['REDIRECT_REC_EMAIL'] = REDIRECT_REC_EMAIL;
    }
    if (REDIRECT_REC_FAX != null || !forView) {
      map['REDIRECT_REC_FAX'] = REDIRECT_REC_FAX;
    }
    if (REDIRECT_FROM_PIN != null || !forView) {
      map['REDIRECT_FROM_PIN'] = REDIRECT_FROM_PIN;
    }
    if (REDIRECT_FROM_BO_ID != null || !forView) {
      map['REDIRECT_FROM_BO_ID'] = REDIRECT_FROM_BO_ID;
    }
    if (BOOK_ID != null || !forView) {
      map['BOOK_ID'] = BOOK_ID;
    }
    if (BAG_ID != null || !forView) {
      map['BAG_ID'] = BAG_ID;
    }
    if (BO_SLIP != null || !forView) {
      map['BO_SLIP'] = BO_SLIP;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ART_NUMBER'] = ART_NUMBER;
    if (SEND_CUST_N != null || !forView) {
      map['SEND_CUST_N '] = SEND_CUST_N;
    }
    if (SEND_ADD1 != null || !forView) {
      map['SEND_ADD1'] = SEND_ADD1;
    }
    if (SEND_ADD2 != null || !forView) {
      map['SEND_ADD2'] = SEND_ADD2;
    }
    if (SEND_ADD3 != null || !forView) {
      map['SEND_ADD3'] = SEND_ADD3;
    }
    if (SEND_STREET != null || !forView) {
      map['SEND_STREET'] = SEND_STREET;
    }
    if (SEND_CITY != null || !forView) {
      map['SEND_CITY'] = SEND_CITY;
    }
    if (SEND_COUNTRY != null || !forView) {
      map['SEND_COUNTRY'] = SEND_COUNTRY;
    }
    if (SEND_STATE != null || !forView) {
      map['SEND_STATE'] = SEND_STATE;
    }
    if (SEND_EMAIL != null || !forView) {
      map['SEND_EMAIL'] = SEND_EMAIL;
    }
    if (SEND_PIN != null || !forView) {
      map['SEND_PIN'] = SEND_PIN;
    }
    if (SEND_FAX != null || !forView) {
      map['SEND_FAX'] = SEND_FAX;
    }
    if (SEND_MOB != null || !forView) {
      map['SEND_MOB'] = SEND_MOB;
    }
    if (REC_NAME != null || !forView) {
      map['REC_NAME'] = REC_NAME;
    }
    if (REC_ADDRESS1 != null || !forView) {
      map['REC_ADDRESS1'] = REC_ADDRESS1;
    }
    if (REC_ADDRESS2 != null || !forView) {
      map['REC_ADDRESS2'] = REC_ADDRESS2;
    }
    if (REC_ADDRESS3 != null || !forView) {
      map['REC_ADDRESS3'] = REC_ADDRESS3;
    }
    if (REC_COUNTRY != null || !forView) {
      map['REC_COUNTRY'] = REC_COUNTRY;
    }
    if (REC_STATE != null || !forView) {
      map['REC_STATE'] = REC_STATE;
    }
    if (REC_STREET != null || !forView) {
      map['REC_STREET'] = REC_STREET;
    }
    if (REC_CITY != null || !forView) {
      map['REC_CITY'] = REC_CITY;
    }
    if (REC_PIN != null || !forView) {
      map['REC_PIN'] = REC_PIN;
    }
    if (MOD_PIN != null || !forView) {
      map['MOD_PIN'] = MOD_PIN;
    }
    if (REC_MOB != null || !forView) {
      map['REC_MOB'] = REC_MOB;
    }
    if (REC_EMAIL != null || !forView) {
      map['REC_EMAIL'] = REC_EMAIL;
    }
    if (REC_FAX != null || !forView) {
      map['REC_FAX'] = REC_FAX;
    }
    if (RECIPIENT_NAME != null || !forView) {
      map['RECIPIENT_NAME'] = RECIPIENT_NAME;
    }
    if (REDIRECT_REC_ADD1 != null || !forView) {
      map['REDIRECT_REC_ADD1'] = REDIRECT_REC_ADD1;
    }
    if (REDIRECT_REC_ADD2 != null || !forView) {
      map['REDIRECT_REC_ADD2'] = REDIRECT_REC_ADD2;
    }
    if (REDIRECT_REC_ADD3 != null || !forView) {
      map['REDIRECT_REC_ADD3'] = REDIRECT_REC_ADD3;
    }
    if (REDIRECT_REC_STREET != null || !forView) {
      map['REDIRECT_REC_STREET'] = REDIRECT_REC_STREET;
    }
    if (REDIRECT_REC_CITY != null || !forView) {
      map['REDIRECT_REC_CITY'] = REDIRECT_REC_CITY;
    }
    if (REDIRECT_REC_COUNTRY != null || !forView) {
      map['REDIRECT_REC_COUNTRY'] = REDIRECT_REC_COUNTRY;
    }
    if (REDIRECT_REC_STATE != null || !forView) {
      map['REDIRECT_REC_STATE'] = REDIRECT_REC_STATE;
    }
    if (REDIRECT_REC_PIN != null || !forView) {
      map['REDIRECT_REC_PIN'] = REDIRECT_REC_PIN;
    }
    if (REDIRECT_REC_MOB != null || !forView) {
      map['REDIRECT_REC_MOB'] = REDIRECT_REC_MOB;
    }
    if (REDIRECT_REC_EMAIL != null || !forView) {
      map['REDIRECT_REC_EMAIL'] = REDIRECT_REC_EMAIL;
    }
    if (REDIRECT_REC_FAX != null || !forView) {
      map['REDIRECT_REC_FAX'] = REDIRECT_REC_FAX;
    }
    if (REDIRECT_FROM_PIN != null || !forView) {
      map['REDIRECT_FROM_PIN'] = REDIRECT_FROM_PIN;
    }
    if (REDIRECT_FROM_BO_ID != null || !forView) {
      map['REDIRECT_FROM_BO_ID'] = REDIRECT_FROM_BO_ID;
    }
    if (BOOK_ID != null || !forView) {
      map['BOOK_ID'] = BOOK_ID;
    }
    if (BAG_ID != null || !forView) {
      map['BAG_ID'] = BAG_ID;
    }
    if (BO_SLIP != null || !forView) {
      map['BO_SLIP'] = BO_SLIP;
    }

    return map;
  }

  /// This method returns Json String [Addres]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Addres]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ART_NUMBER,
      SEND_CUST_N,
      SEND_ADD1,
      SEND_ADD2,
      SEND_ADD3,
      SEND_STREET,
      SEND_CITY,
      SEND_COUNTRY,
      SEND_STATE,
      SEND_EMAIL,
      SEND_PIN,
      SEND_FAX,
      SEND_MOB,
      REC_NAME,
      REC_ADDRESS1,
      REC_ADDRESS2,
      REC_ADDRESS3,
      REC_COUNTRY,
      REC_STATE,
      REC_STREET,
      REC_CITY,
      REC_PIN,
      MOD_PIN,
      REC_MOB,
      REC_EMAIL,
      REC_FAX,
      RECIPIENT_NAME,
      REDIRECT_REC_ADD1,
      REDIRECT_REC_ADD2,
      REDIRECT_REC_ADD3,
      REDIRECT_REC_STREET,
      REDIRECT_REC_CITY,
      REDIRECT_REC_COUNTRY,
      REDIRECT_REC_STATE,
      REDIRECT_REC_PIN,
      REDIRECT_REC_MOB,
      REDIRECT_REC_EMAIL,
      REDIRECT_REC_FAX,
      REDIRECT_FROM_PIN,
      REDIRECT_FROM_BO_ID,
      BOOK_ID,
      BAG_ID,
      BO_SLIP
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ART_NUMBER,
      SEND_CUST_N,
      SEND_ADD1,
      SEND_ADD2,
      SEND_ADD3,
      SEND_STREET,
      SEND_CITY,
      SEND_COUNTRY,
      SEND_STATE,
      SEND_EMAIL,
      SEND_PIN,
      SEND_FAX,
      SEND_MOB,
      REC_NAME,
      REC_ADDRESS1,
      REC_ADDRESS2,
      REC_ADDRESS3,
      REC_COUNTRY,
      REC_STATE,
      REC_STREET,
      REC_CITY,
      REC_PIN,
      MOD_PIN,
      REC_MOB,
      REC_EMAIL,
      REC_FAX,
      RECIPIENT_NAME,
      REDIRECT_REC_ADD1,
      REDIRECT_REC_ADD2,
      REDIRECT_REC_ADD3,
      REDIRECT_REC_STREET,
      REDIRECT_REC_CITY,
      REDIRECT_REC_COUNTRY,
      REDIRECT_REC_STATE,
      REDIRECT_REC_PIN,
      REDIRECT_REC_MOB,
      REDIRECT_REC_EMAIL,
      REDIRECT_REC_FAX,
      REDIRECT_FROM_PIN,
      REDIRECT_FROM_BO_ID,
      BOOK_ID,
      BAG_ID,
      BO_SLIP
    ];
  }

  static Future<List<Addres>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Addres.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Addres>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Addres>[];
    try {
      objList = list
          .map((addres) => Addres.fromMap(addres as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Addres.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Addres>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Addres> objList = <Addres>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Addres.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Addres by ID if exist, otherwise returns null
  /// Primary Keys: String? ART_NUMBER
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Addres] if exist, otherwise returns null
  Future<Addres?> getById(String? ART_NUMBER,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ART_NUMBER == null) {
      return null;
    }
    Addres? obj;
    final data = await _mnAddres.getById([ART_NUMBER]);
    if (data.length != 0) {
      obj = Addres.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Addres) object. If the Primary Key (ART_NUMBER) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ART_NUMBER
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnAddres.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Address (ART_NUMBER, SEND_CUST_N , SEND_ADD1, SEND_ADD2, SEND_ADD3, SEND_STREET, SEND_CITY, SEND_COUNTRY, SEND_STATE, SEND_EMAIL, SEND_PIN, SEND_FAX, SEND_MOB, REC_NAME, REC_ADDRESS1, REC_ADDRESS2, REC_ADDRESS3, REC_COUNTRY, REC_STATE, REC_STREET, REC_CITY, REC_PIN, MOD_PIN, REC_MOB, REC_EMAIL, REC_FAX, RECIPIENT_NAME, REDIRECT_REC_ADD1, REDIRECT_REC_ADD2, REDIRECT_REC_ADD3, REDIRECT_REC_STREET, REDIRECT_REC_CITY, REDIRECT_REC_COUNTRY, REDIRECT_REC_STATE, REDIRECT_REC_PIN, REDIRECT_REC_MOB, REDIRECT_REC_EMAIL, REDIRECT_REC_FAX, REDIRECT_FROM_PIN, REDIRECT_FROM_BO_ID, BOOK_ID, BAG_ID, BO_SLIP)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Addres> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Addres> addreses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in addreses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAddres.rawInsert(
          'INSERT OR REPLACE INTO Address (ART_NUMBER, SEND_CUST_N , SEND_ADD1, SEND_ADD2, SEND_ADD3, SEND_STREET, SEND_CITY, SEND_COUNTRY, SEND_STATE, SEND_EMAIL, SEND_PIN, SEND_FAX, SEND_MOB, REC_NAME, REC_ADDRESS1, REC_ADDRESS2, REC_ADDRESS3, REC_COUNTRY, REC_STATE, REC_STREET, REC_CITY, REC_PIN, MOD_PIN, REC_MOB, REC_EMAIL, REC_FAX, RECIPIENT_NAME, REDIRECT_REC_ADD1, REDIRECT_REC_ADD2, REDIRECT_REC_ADD3, REDIRECT_REC_STREET, REDIRECT_REC_CITY, REDIRECT_REC_COUNTRY, REDIRECT_REC_STATE, REDIRECT_REC_PIN, REDIRECT_REC_MOB, REDIRECT_REC_EMAIL, REDIRECT_REC_FAX, REDIRECT_FROM_PIN, REDIRECT_FROM_BO_ID, BOOK_ID, BAG_ID, BO_SLIP)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ART_NUMBER,
            SEND_CUST_N,
            SEND_ADD1,
            SEND_ADD2,
            SEND_ADD3,
            SEND_STREET,
            SEND_CITY,
            SEND_COUNTRY,
            SEND_STATE,
            SEND_EMAIL,
            SEND_PIN,
            SEND_FAX,
            SEND_MOB,
            REC_NAME,
            REC_ADDRESS1,
            REC_ADDRESS2,
            REC_ADDRESS3,
            REC_COUNTRY,
            REC_STATE,
            REC_STREET,
            REC_CITY,
            REC_PIN,
            MOD_PIN,
            REC_MOB,
            REC_EMAIL,
            REC_FAX,
            RECIPIENT_NAME,
            REDIRECT_REC_ADD1,
            REDIRECT_REC_ADD2,
            REDIRECT_REC_ADD3,
            REDIRECT_REC_STREET,
            REDIRECT_REC_CITY,
            REDIRECT_REC_COUNTRY,
            REDIRECT_REC_STATE,
            REDIRECT_REC_PIN,
            REDIRECT_REC_MOB,
            REDIRECT_REC_EMAIL,
            REDIRECT_REC_FAX,
            REDIRECT_FROM_PIN,
            REDIRECT_FROM_BO_ID,
            BOOK_ID,
            BAG_ID,
            BO_SLIP
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Addres ART_NUMBER=$ART_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Addres ART_NUMBER=$ART_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Addres Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAddres.rawInsert(
          'INSERT OR IGNORE INTO Address (ART_NUMBER, SEND_CUST_N , SEND_ADD1, SEND_ADD2, SEND_ADD3, SEND_STREET, SEND_CITY, SEND_COUNTRY, SEND_STATE, SEND_EMAIL, SEND_PIN, SEND_FAX, SEND_MOB, REC_NAME, REC_ADDRESS1, REC_ADDRESS2, REC_ADDRESS3, REC_COUNTRY, REC_STATE, REC_STREET, REC_CITY, REC_PIN, MOD_PIN, REC_MOB, REC_EMAIL, REC_FAX, RECIPIENT_NAME, REDIRECT_REC_ADD1, REDIRECT_REC_ADD2, REDIRECT_REC_ADD3, REDIRECT_REC_STREET, REDIRECT_REC_CITY, REDIRECT_REC_COUNTRY, REDIRECT_REC_STATE, REDIRECT_REC_PIN, REDIRECT_REC_MOB, REDIRECT_REC_EMAIL, REDIRECT_REC_FAX, REDIRECT_FROM_PIN, REDIRECT_FROM_BO_ID, BOOK_ID, BAG_ID, BO_SLIP)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ART_NUMBER,
            SEND_CUST_N,
            SEND_ADD1,
            SEND_ADD2,
            SEND_ADD3,
            SEND_STREET,
            SEND_CITY,
            SEND_COUNTRY,
            SEND_STATE,
            SEND_EMAIL,
            SEND_PIN,
            SEND_FAX,
            SEND_MOB,
            REC_NAME,
            REC_ADDRESS1,
            REC_ADDRESS2,
            REC_ADDRESS3,
            REC_COUNTRY,
            REC_STATE,
            REC_STREET,
            REC_CITY,
            REC_PIN,
            MOD_PIN,
            REC_MOB,
            REC_EMAIL,
            REC_FAX,
            RECIPIENT_NAME,
            REDIRECT_REC_ADD1,
            REDIRECT_REC_ADD2,
            REDIRECT_REC_ADD3,
            REDIRECT_REC_STREET,
            REDIRECT_REC_CITY,
            REDIRECT_REC_COUNTRY,
            REDIRECT_REC_STATE,
            REDIRECT_REC_PIN,
            REDIRECT_REC_MOB,
            REDIRECT_REC_EMAIL,
            REDIRECT_REC_FAX,
            REDIRECT_FROM_PIN,
            REDIRECT_FROM_BO_ID,
            BOOK_ID,
            BAG_ID,
            BO_SLIP
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'Addres ART_NUMBER=$ART_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Addres ART_NUMBER=$ART_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Addres Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Addres

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Addres invoked (ART_NUMBER=$ART_NUMBER)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnAddres.delete(QueryParams(
          whereString: 'ART_NUMBER=?', whereArguments: [ART_NUMBER]));
    } else {
      return _mnAddres.updateBatch(
          QueryParams(
              whereString: 'ART_NUMBER=?', whereArguments: [ART_NUMBER]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Addres] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  AddresFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AddresFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  AddresFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AddresFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ART_NUMBER = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion addres

// region AddresField
class AddresField extends FilterBase {
  AddresField(AddresFilterBuilder addresFB) : super(addresFB);

  @override
  AddresFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder isNull() {
    return super.isNull() as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as AddresFilterBuilder;
  }

  @override
  AddresFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as AddresFilterBuilder;
  }

  @override
  AddresField get not {
    return super.not as AddresField;
  }
}
// endregion AddresField

// region AddresFilterBuilder
class AddresFilterBuilder extends ConjunctionBase {
  AddresFilterBuilder(Addres obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnAddres = obj._mnAddres;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  AddresManager? _mnAddres;

  /// put the sql keyword 'AND'
  @override
  AddresFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  AddresFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  AddresFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  AddresFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  AddresFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  AddresFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  AddresFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AddresFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AddresFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AddresFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AddresFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  AddresField _setField(AddresField? field, String colName, DbType dbtype) {
    return AddresField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  AddresField? _ART_NUMBER;
  AddresField get ART_NUMBER {
    return _ART_NUMBER = _setField(_ART_NUMBER, 'ART_NUMBER', DbType.integer);
  }

  AddresField? _SEND_CUST_N;
  AddresField get SEND_CUST_N {
    return _SEND_CUST_N = _setField(_SEND_CUST_N, 'SEND_CUST_N ', DbType.text);
  }

  AddresField? _SEND_ADD1;
  AddresField get SEND_ADD1 {
    return _SEND_ADD1 = _setField(_SEND_ADD1, 'SEND_ADD1', DbType.text);
  }

  AddresField? _SEND_ADD2;
  AddresField get SEND_ADD2 {
    return _SEND_ADD2 = _setField(_SEND_ADD2, 'SEND_ADD2', DbType.text);
  }

  AddresField? _SEND_ADD3;
  AddresField get SEND_ADD3 {
    return _SEND_ADD3 = _setField(_SEND_ADD3, 'SEND_ADD3', DbType.text);
  }

  AddresField? _SEND_STREET;
  AddresField get SEND_STREET {
    return _SEND_STREET = _setField(_SEND_STREET, 'SEND_STREET', DbType.text);
  }

  AddresField? _SEND_CITY;
  AddresField get SEND_CITY {
    return _SEND_CITY = _setField(_SEND_CITY, 'SEND_CITY', DbType.text);
  }

  AddresField? _SEND_COUNTRY;
  AddresField get SEND_COUNTRY {
    return _SEND_COUNTRY =
        _setField(_SEND_COUNTRY, 'SEND_COUNTRY', DbType.text);
  }

  AddresField? _SEND_STATE;
  AddresField get SEND_STATE {
    return _SEND_STATE = _setField(_SEND_STATE, 'SEND_STATE', DbType.text);
  }

  AddresField? _SEND_EMAIL;
  AddresField get SEND_EMAIL {
    return _SEND_EMAIL = _setField(_SEND_EMAIL, 'SEND_EMAIL', DbType.text);
  }

  AddresField? _SEND_PIN;
  AddresField get SEND_PIN {
    return _SEND_PIN = _setField(_SEND_PIN, 'SEND_PIN', DbType.integer);
  }

  AddresField? _SEND_FAX;
  AddresField get SEND_FAX {
    return _SEND_FAX = _setField(_SEND_FAX, 'SEND_FAX', DbType.text);
  }

  AddresField? _SEND_MOB;
  AddresField get SEND_MOB {
    return _SEND_MOB = _setField(_SEND_MOB, 'SEND_MOB', DbType.text);
  }

  AddresField? _REC_NAME;
  AddresField get REC_NAME {
    return _REC_NAME = _setField(_REC_NAME, 'REC_NAME', DbType.text);
  }

  AddresField? _REC_ADDRESS1;
  AddresField get REC_ADDRESS1 {
    return _REC_ADDRESS1 =
        _setField(_REC_ADDRESS1, 'REC_ADDRESS1', DbType.text);
  }

  AddresField? _REC_ADDRESS2;
  AddresField get REC_ADDRESS2 {
    return _REC_ADDRESS2 =
        _setField(_REC_ADDRESS2, 'REC_ADDRESS2', DbType.text);
  }

  AddresField? _REC_ADDRESS3;
  AddresField get REC_ADDRESS3 {
    return _REC_ADDRESS3 =
        _setField(_REC_ADDRESS3, 'REC_ADDRESS3', DbType.text);
  }

  AddresField? _REC_COUNTRY;
  AddresField get REC_COUNTRY {
    return _REC_COUNTRY = _setField(_REC_COUNTRY, 'REC_COUNTRY', DbType.text);
  }

  AddresField? _REC_STATE;
  AddresField get REC_STATE {
    return _REC_STATE = _setField(_REC_STATE, 'REC_STATE', DbType.text);
  }

  AddresField? _REC_STREET;
  AddresField get REC_STREET {
    return _REC_STREET = _setField(_REC_STREET, 'REC_STREET', DbType.text);
  }

  AddresField? _REC_CITY;
  AddresField get REC_CITY {
    return _REC_CITY = _setField(_REC_CITY, 'REC_CITY', DbType.text);
  }

  AddresField? _REC_PIN;
  AddresField get REC_PIN {
    return _REC_PIN = _setField(_REC_PIN, 'REC_PIN', DbType.integer);
  }

  AddresField? _MOD_PIN;
  AddresField get MOD_PIN {
    return _MOD_PIN = _setField(_MOD_PIN, 'MOD_PIN', DbType.real);
  }

  AddresField? _REC_MOB;
  AddresField get REC_MOB {
    return _REC_MOB = _setField(_REC_MOB, 'REC_MOB', DbType.text);
  }

  AddresField? _REC_EMAIL;
  AddresField get REC_EMAIL {
    return _REC_EMAIL = _setField(_REC_EMAIL, 'REC_EMAIL', DbType.text);
  }

  AddresField? _REC_FAX;
  AddresField get REC_FAX {
    return _REC_FAX = _setField(_REC_FAX, 'REC_FAX', DbType.text);
  }

  AddresField? _RECIPIENT_NAME;
  AddresField get RECIPIENT_NAME {
    return _RECIPIENT_NAME =
        _setField(_RECIPIENT_NAME, 'RECIPIENT_NAME', DbType.text);
  }

  AddresField? _REDIRECT_REC_ADD1;
  AddresField get REDIRECT_REC_ADD1 {
    return _REDIRECT_REC_ADD1 =
        _setField(_REDIRECT_REC_ADD1, 'REDIRECT_REC_ADD1', DbType.text);
  }

  AddresField? _REDIRECT_REC_ADD2;
  AddresField get REDIRECT_REC_ADD2 {
    return _REDIRECT_REC_ADD2 =
        _setField(_REDIRECT_REC_ADD2, 'REDIRECT_REC_ADD2', DbType.text);
  }

  AddresField? _REDIRECT_REC_ADD3;
  AddresField get REDIRECT_REC_ADD3 {
    return _REDIRECT_REC_ADD3 =
        _setField(_REDIRECT_REC_ADD3, 'REDIRECT_REC_ADD3', DbType.text);
  }

  AddresField? _REDIRECT_REC_STREET;
  AddresField get REDIRECT_REC_STREET {
    return _REDIRECT_REC_STREET =
        _setField(_REDIRECT_REC_STREET, 'REDIRECT_REC_STREET', DbType.text);
  }

  AddresField? _REDIRECT_REC_CITY;
  AddresField get REDIRECT_REC_CITY {
    return _REDIRECT_REC_CITY =
        _setField(_REDIRECT_REC_CITY, 'REDIRECT_REC_CITY', DbType.text);
  }

  AddresField? _REDIRECT_REC_COUNTRY;
  AddresField get REDIRECT_REC_COUNTRY {
    return _REDIRECT_REC_COUNTRY =
        _setField(_REDIRECT_REC_COUNTRY, 'REDIRECT_REC_COUNTRY', DbType.text);
  }

  AddresField? _REDIRECT_REC_STATE;
  AddresField get REDIRECT_REC_STATE {
    return _REDIRECT_REC_STATE =
        _setField(_REDIRECT_REC_STATE, 'REDIRECT_REC_STATE', DbType.text);
  }

  AddresField? _REDIRECT_REC_PIN;
  AddresField get REDIRECT_REC_PIN {
    return _REDIRECT_REC_PIN =
        _setField(_REDIRECT_REC_PIN, 'REDIRECT_REC_PIN', DbType.real);
  }

  AddresField? _REDIRECT_REC_MOB;
  AddresField get REDIRECT_REC_MOB {
    return _REDIRECT_REC_MOB =
        _setField(_REDIRECT_REC_MOB, 'REDIRECT_REC_MOB', DbType.real);
  }

  AddresField? _REDIRECT_REC_EMAIL;
  AddresField get REDIRECT_REC_EMAIL {
    return _REDIRECT_REC_EMAIL =
        _setField(_REDIRECT_REC_EMAIL, 'REDIRECT_REC_EMAIL', DbType.text);
  }

  AddresField? _REDIRECT_REC_FAX;
  AddresField get REDIRECT_REC_FAX {
    return _REDIRECT_REC_FAX =
        _setField(_REDIRECT_REC_FAX, 'REDIRECT_REC_FAX', DbType.text);
  }

  AddresField? _REDIRECT_FROM_PIN;
  AddresField get REDIRECT_FROM_PIN {
    return _REDIRECT_FROM_PIN =
        _setField(_REDIRECT_FROM_PIN, 'REDIRECT_FROM_PIN', DbType.real);
  }

  AddresField? _REDIRECT_FROM_BO_ID;
  AddresField get REDIRECT_FROM_BO_ID {
    return _REDIRECT_FROM_BO_ID =
        _setField(_REDIRECT_FROM_BO_ID, 'REDIRECT_FROM_BO_ID', DbType.text);
  }

  AddresField? _BOOK_ID;
  AddresField get BOOK_ID {
    return _BOOK_ID = _setField(_BOOK_ID, 'BOOK_ID', DbType.text);
  }

  AddresField? _BAG_ID;
  AddresField get BAG_ID {
    return _BAG_ID = _setField(_BAG_ID, 'BAG_ID', DbType.text);
  }

  AddresField? _BO_SLIP;
  AddresField get BO_SLIP {
    return _BO_SLIP = _setField(_BO_SLIP, 'BO_SLIP', DbType.text);
  }

  /// Deletes List<Addres> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnAddres!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnAddres!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ART_NUMBER IN (SELECT ART_NUMBER from Address ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnAddres!.updateBatch(qparams, values);
  }

  /// This method always returns [Addres] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Addres?
  @override
  Future<Addres?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnAddres!.toList(qparams);
    final data = await objFuture;
    Addres? obj;
    if (data.isNotEmpty) {
      obj = Addres.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Addres]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Addres?
  @override
  Future<Addres> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Addres();
  }

  /// This method returns int. [Addres]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? addresCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final addresesFuture = await _mnAddres!.toList(qparams);
    final int count = addresesFuture[0]['CNT'] as int;
    if (addresCount != null) {
      addresCount(count);
    }
    return count;
  }

  /// This method returns List<Addres> [Addres]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Addres>
  @override
  Future<List<Addres>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Addres> addresesData = await Addres.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return addresesData;
  }

  /// This method returns Json String [Addres]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Addres]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Addres]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnAddres!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Addres]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ART_NUMBER` FROM Address WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ART_NUMBERData = <String>[];
    qparams.selectColumns = ['ART_NUMBER'];
    final ART_NUMBERFuture = await _mnAddres!.toList(qparams);

    final int count = ART_NUMBERFuture.length;
    for (int i = 0; i < count; i++) {
      ART_NUMBERData.add(ART_NUMBERFuture[i]['ART_NUMBER'] as String);
    }
    return ART_NUMBERData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Addres]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnAddres!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Addres.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnAddres!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AddresFilterBuilder

// region AddresFields
class AddresFields {
  static TableField? _fART_NUMBER;
  static TableField get ART_NUMBER {
    return _fART_NUMBER = _fART_NUMBER ??
        SqlSyntax.setField(_fART_NUMBER, 'art_number', DbType.integer);
  }

  static TableField? _fSEND_CUST_N;
  static TableField get SEND_CUST_N {
    return _fSEND_CUST_N = _fSEND_CUST_N ??
        SqlSyntax.setField(_fSEND_CUST_N, 'SEND_CUST_N ', DbType.text);
  }

  static TableField? _fSEND_ADD1;
  static TableField get SEND_ADD1 {
    return _fSEND_ADD1 = _fSEND_ADD1 ??
        SqlSyntax.setField(_fSEND_ADD1, 'SEND_ADD1', DbType.text);
  }

  static TableField? _fSEND_ADD2;
  static TableField get SEND_ADD2 {
    return _fSEND_ADD2 = _fSEND_ADD2 ??
        SqlSyntax.setField(_fSEND_ADD2, 'SEND_ADD2', DbType.text);
  }

  static TableField? _fSEND_ADD3;
  static TableField get SEND_ADD3 {
    return _fSEND_ADD3 = _fSEND_ADD3 ??
        SqlSyntax.setField(_fSEND_ADD3, 'SEND_ADD3', DbType.text);
  }

  static TableField? _fSEND_STREET;
  static TableField get SEND_STREET {
    return _fSEND_STREET = _fSEND_STREET ??
        SqlSyntax.setField(_fSEND_STREET, 'SEND_STREET', DbType.text);
  }

  static TableField? _fSEND_CITY;
  static TableField get SEND_CITY {
    return _fSEND_CITY = _fSEND_CITY ??
        SqlSyntax.setField(_fSEND_CITY, 'SEND_CITY', DbType.text);
  }

  static TableField? _fSEND_COUNTRY;
  static TableField get SEND_COUNTRY {
    return _fSEND_COUNTRY = _fSEND_COUNTRY ??
        SqlSyntax.setField(_fSEND_COUNTRY, 'SEND_COUNTRY', DbType.text);
  }

  static TableField? _fSEND_STATE;
  static TableField get SEND_STATE {
    return _fSEND_STATE = _fSEND_STATE ??
        SqlSyntax.setField(_fSEND_STATE, 'SEND_STATE', DbType.text);
  }

  static TableField? _fSEND_EMAIL;
  static TableField get SEND_EMAIL {
    return _fSEND_EMAIL = _fSEND_EMAIL ??
        SqlSyntax.setField(_fSEND_EMAIL, 'SEND_EMAIL', DbType.text);
  }

  static TableField? _fSEND_PIN;
  static TableField get SEND_PIN {
    return _fSEND_PIN = _fSEND_PIN ??
        SqlSyntax.setField(_fSEND_PIN, 'SEND_PIN', DbType.integer);
  }

  static TableField? _fSEND_FAX;
  static TableField get SEND_FAX {
    return _fSEND_FAX =
        _fSEND_FAX ?? SqlSyntax.setField(_fSEND_FAX, 'SEND_FAX', DbType.text);
  }

  static TableField? _fSEND_MOB;
  static TableField get SEND_MOB {
    return _fSEND_MOB =
        _fSEND_MOB ?? SqlSyntax.setField(_fSEND_MOB, 'SEND_MOB', DbType.text);
  }

  static TableField? _fREC_NAME;
  static TableField get REC_NAME {
    return _fREC_NAME =
        _fREC_NAME ?? SqlSyntax.setField(_fREC_NAME, 'REC_NAME', DbType.text);
  }

  static TableField? _fREC_ADDRESS1;
  static TableField get REC_ADDRESS1 {
    return _fREC_ADDRESS1 = _fREC_ADDRESS1 ??
        SqlSyntax.setField(_fREC_ADDRESS1, 'REC_ADDRESS1', DbType.text);
  }

  static TableField? _fREC_ADDRESS2;
  static TableField get REC_ADDRESS2 {
    return _fREC_ADDRESS2 = _fREC_ADDRESS2 ??
        SqlSyntax.setField(_fREC_ADDRESS2, 'REC_ADDRESS2', DbType.text);
  }

  static TableField? _fREC_ADDRESS3;
  static TableField get REC_ADDRESS3 {
    return _fREC_ADDRESS3 = _fREC_ADDRESS3 ??
        SqlSyntax.setField(_fREC_ADDRESS3, 'REC_ADDRESS3', DbType.text);
  }

  static TableField? _fREC_COUNTRY;
  static TableField get REC_COUNTRY {
    return _fREC_COUNTRY = _fREC_COUNTRY ??
        SqlSyntax.setField(_fREC_COUNTRY, 'REC_COUNTRY', DbType.text);
  }

  static TableField? _fREC_STATE;
  static TableField get REC_STATE {
    return _fREC_STATE = _fREC_STATE ??
        SqlSyntax.setField(_fREC_STATE, 'REC_STATE', DbType.text);
  }

  static TableField? _fREC_STREET;
  static TableField get REC_STREET {
    return _fREC_STREET = _fREC_STREET ??
        SqlSyntax.setField(_fREC_STREET, 'REC_STREET', DbType.text);
  }

  static TableField? _fREC_CITY;
  static TableField get REC_CITY {
    return _fREC_CITY =
        _fREC_CITY ?? SqlSyntax.setField(_fREC_CITY, 'REC_CITY', DbType.text);
  }

  static TableField? _fREC_PIN;
  static TableField get REC_PIN {
    return _fREC_PIN =
        _fREC_PIN ?? SqlSyntax.setField(_fREC_PIN, 'REC_PIN', DbType.integer);
  }

  static TableField? _fMOD_PIN;
  static TableField get MOD_PIN {
    return _fMOD_PIN =
        _fMOD_PIN ?? SqlSyntax.setField(_fMOD_PIN, 'MOD_PIN', DbType.real);
  }

  static TableField? _fREC_MOB;
  static TableField get REC_MOB {
    return _fREC_MOB =
        _fREC_MOB ?? SqlSyntax.setField(_fREC_MOB, 'REC_MOB', DbType.text);
  }

  static TableField? _fREC_EMAIL;
  static TableField get REC_EMAIL {
    return _fREC_EMAIL = _fREC_EMAIL ??
        SqlSyntax.setField(_fREC_EMAIL, 'REC_EMAIL', DbType.text);
  }

  static TableField? _fREC_FAX;
  static TableField get REC_FAX {
    return _fREC_FAX =
        _fREC_FAX ?? SqlSyntax.setField(_fREC_FAX, 'REC_FAX', DbType.text);
  }

  static TableField? _fRECIPIENT_NAME;
  static TableField get RECIPIENT_NAME {
    return _fRECIPIENT_NAME = _fRECIPIENT_NAME ??
        SqlSyntax.setField(_fRECIPIENT_NAME, 'RECIPIENT_NAME', DbType.text);
  }

  static TableField? _fREDIRECT_REC_ADD1;
  static TableField get REDIRECT_REC_ADD1 {
    return _fREDIRECT_REC_ADD1 = _fREDIRECT_REC_ADD1 ??
        SqlSyntax.setField(
            _fREDIRECT_REC_ADD1, 'REDIRECT_REC_ADD1', DbType.text);
  }

  static TableField? _fREDIRECT_REC_ADD2;
  static TableField get REDIRECT_REC_ADD2 {
    return _fREDIRECT_REC_ADD2 = _fREDIRECT_REC_ADD2 ??
        SqlSyntax.setField(
            _fREDIRECT_REC_ADD2, 'REDIRECT_REC_ADD2', DbType.text);
  }

  static TableField? _fREDIRECT_REC_ADD3;
  static TableField get REDIRECT_REC_ADD3 {
    return _fREDIRECT_REC_ADD3 = _fREDIRECT_REC_ADD3 ??
        SqlSyntax.setField(
            _fREDIRECT_REC_ADD3, 'REDIRECT_REC_ADD3', DbType.text);
  }

  static TableField? _fREDIRECT_REC_STREET;
  static TableField get REDIRECT_REC_STREET {
    return _fREDIRECT_REC_STREET = _fREDIRECT_REC_STREET ??
        SqlSyntax.setField(
            _fREDIRECT_REC_STREET, 'REDIRECT_REC_STREET', DbType.text);
  }

  static TableField? _fREDIRECT_REC_CITY;
  static TableField get REDIRECT_REC_CITY {
    return _fREDIRECT_REC_CITY = _fREDIRECT_REC_CITY ??
        SqlSyntax.setField(
            _fREDIRECT_REC_CITY, 'REDIRECT_REC_CITY', DbType.text);
  }

  static TableField? _fREDIRECT_REC_COUNTRY;
  static TableField get REDIRECT_REC_COUNTRY {
    return _fREDIRECT_REC_COUNTRY = _fREDIRECT_REC_COUNTRY ??
        SqlSyntax.setField(
            _fREDIRECT_REC_COUNTRY, 'REDIRECT_REC_COUNTRY', DbType.text);
  }

  static TableField? _fREDIRECT_REC_STATE;
  static TableField get REDIRECT_REC_STATE {
    return _fREDIRECT_REC_STATE = _fREDIRECT_REC_STATE ??
        SqlSyntax.setField(
            _fREDIRECT_REC_STATE, 'REDIRECT_REC_STATE', DbType.text);
  }

  static TableField? _fREDIRECT_REC_PIN;
  static TableField get REDIRECT_REC_PIN {
    return _fREDIRECT_REC_PIN = _fREDIRECT_REC_PIN ??
        SqlSyntax.setField(_fREDIRECT_REC_PIN, 'REDIRECT_REC_PIN', DbType.real);
  }

  static TableField? _fREDIRECT_REC_MOB;
  static TableField get REDIRECT_REC_MOB {
    return _fREDIRECT_REC_MOB = _fREDIRECT_REC_MOB ??
        SqlSyntax.setField(_fREDIRECT_REC_MOB, 'REDIRECT_REC_MOB', DbType.real);
  }

  static TableField? _fREDIRECT_REC_EMAIL;
  static TableField get REDIRECT_REC_EMAIL {
    return _fREDIRECT_REC_EMAIL = _fREDIRECT_REC_EMAIL ??
        SqlSyntax.setField(
            _fREDIRECT_REC_EMAIL, 'REDIRECT_REC_EMAIL', DbType.text);
  }

  static TableField? _fREDIRECT_REC_FAX;
  static TableField get REDIRECT_REC_FAX {
    return _fREDIRECT_REC_FAX = _fREDIRECT_REC_FAX ??
        SqlSyntax.setField(_fREDIRECT_REC_FAX, 'REDIRECT_REC_FAX', DbType.text);
  }

  static TableField? _fREDIRECT_FROM_PIN;
  static TableField get REDIRECT_FROM_PIN {
    return _fREDIRECT_FROM_PIN = _fREDIRECT_FROM_PIN ??
        SqlSyntax.setField(
            _fREDIRECT_FROM_PIN, 'REDIRECT_FROM_PIN', DbType.real);
  }

  static TableField? _fREDIRECT_FROM_BO_ID;
  static TableField get REDIRECT_FROM_BO_ID {
    return _fREDIRECT_FROM_BO_ID = _fREDIRECT_FROM_BO_ID ??
        SqlSyntax.setField(
            _fREDIRECT_FROM_BO_ID, 'REDIRECT_FROM_BO_ID', DbType.text);
  }

  static TableField? _fBOOK_ID;
  static TableField get BOOK_ID {
    return _fBOOK_ID =
        _fBOOK_ID ?? SqlSyntax.setField(_fBOOK_ID, 'BOOK_ID', DbType.text);
  }

  static TableField? _fBAG_ID;
  static TableField get BAG_ID {
    return _fBAG_ID =
        _fBAG_ID ?? SqlSyntax.setField(_fBAG_ID, 'BAG_ID', DbType.text);
  }

  static TableField? _fBO_SLIP;
  static TableField get BO_SLIP {
    return _fBO_SLIP =
        _fBO_SLIP ?? SqlSyntax.setField(_fBO_SLIP, 'BO_SLIP', DbType.text);
  }
}
// endregion AddresFields

//region AddresManager
class AddresManager extends SqfEntityProvider {
  AddresManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Address';
  static const List<String> _primaryKeyList = ['ART_NUMBER'];
  static const String _whereStr = 'ART_NUMBER=?';
}

//endregion AddresManager
// region Reason
class Reason extends TableBase {
  Reason(
      {this.SNo,
      this.MANDT,
      this.SERIAL,
      this.REASON_FOR_NDELI,
      this.APPLICABLE_FOR,
      this.REASON_TYPE,
      this.ACTION,
      this.REASON_NDEL_TEXT,
      this.APPL_FOR_TEXT,
      this.REASON_TYPE_TEXT,
      this.ACTION_TEXT,
      this.DELE_FLAG}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Reason.withFields(
      this.MANDT,
      this.SERIAL,
      this.REASON_FOR_NDELI,
      this.APPLICABLE_FOR,
      this.REASON_TYPE,
      this.ACTION,
      this.REASON_NDEL_TEXT,
      this.APPL_FOR_TEXT,
      this.REASON_TYPE_TEXT,
      this.ACTION_TEXT,
      this.DELE_FLAG) {
    _setDefaultValues();
  }
  Reason.withId(
      this.SNo,
      this.MANDT,
      this.SERIAL,
      this.REASON_FOR_NDELI,
      this.APPLICABLE_FOR,
      this.REASON_TYPE,
      this.ACTION,
      this.REASON_NDEL_TEXT,
      this.APPL_FOR_TEXT,
      this.REASON_TYPE_TEXT,
      this.ACTION_TEXT,
      this.DELE_FLAG) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Reason.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['MANDT'] != null) {
      MANDT = o['MANDT'].toString();
    }
    if (o['SERIAL'] != null) {
      SERIAL = double.tryParse(o['SERIAL'].toString());
    }
    if (o['REASON_FOR_NDELI'] != null) {
      REASON_FOR_NDELI = o['REASON_FOR_NDELI'].toString();
    }
    if (o['APPLICABLE_FOR'] != null) {
      APPLICABLE_FOR = o['APPLICABLE_FOR'].toString();
    }
    if (o['REASON_TYPE'] != null) {
      REASON_TYPE = o['REASON_TYPE'].toString();
    }
    if (o['ACTION'] != null) {
      ACTION = o['ACTION'].toString();
    }
    if (o['REASON_NDEL_TEXT'] != null) {
      REASON_NDEL_TEXT = o['REASON_NDEL_TEXT'].toString();
    }
    if (o['APPL_FOR_TEXT'] != null) {
      APPL_FOR_TEXT = o['APPL_FOR_TEXT'].toString();
    }
    if (o['REASON_TYPE_TEXT'] != null) {
      REASON_TYPE_TEXT = o['REASON_TYPE_TEXT'].toString();
    }
    if (o['ACTION_TEXT'] != null) {
      ACTION_TEXT = o['ACTION_TEXT'].toString();
    }
    if (o['DELE_FLAG'] != null) {
      DELE_FLAG = o['DELE_FLAG'].toString();
    }
  }
  // FIELDS (Reason)
  int? SNo;
  String? MANDT;
  double? SERIAL;
  String? REASON_FOR_NDELI;
  String? APPLICABLE_FOR;
  String? REASON_TYPE;
  String? ACTION;
  String? REASON_NDEL_TEXT;
  String? APPL_FOR_TEXT;
  String? REASON_TYPE_TEXT;
  String? ACTION_TEXT;
  String? DELE_FLAG;

  // end FIELDS (Reason)

  static const bool _softDeleteActivated = false;
  ReasonManager? __mnReason;

  ReasonManager get _mnReason {
    return __mnReason = __mnReason ?? ReasonManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (MANDT != null || !forView) {
      map['MANDT'] = MANDT;
    }
    if (SERIAL != null || !forView) {
      map['SERIAL'] = SERIAL;
    }
    if (REASON_FOR_NDELI != null || !forView) {
      map['REASON_FOR_NDELI'] = REASON_FOR_NDELI;
    }
    if (APPLICABLE_FOR != null || !forView) {
      map['APPLICABLE_FOR'] = APPLICABLE_FOR;
    }
    if (REASON_TYPE != null || !forView) {
      map['REASON_TYPE'] = REASON_TYPE;
    }
    if (ACTION != null || !forView) {
      map['ACTION'] = ACTION;
    }
    if (REASON_NDEL_TEXT != null || !forView) {
      map['REASON_NDEL_TEXT'] = REASON_NDEL_TEXT;
    }
    if (APPL_FOR_TEXT != null || !forView) {
      map['APPL_FOR_TEXT'] = APPL_FOR_TEXT;
    }
    if (REASON_TYPE_TEXT != null || !forView) {
      map['REASON_TYPE_TEXT'] = REASON_TYPE_TEXT;
    }
    if (ACTION_TEXT != null || !forView) {
      map['ACTION_TEXT'] = ACTION_TEXT;
    }
    if (DELE_FLAG != null || !forView) {
      map['DELE_FLAG'] = DELE_FLAG;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (MANDT != null || !forView) {
      map['MANDT'] = MANDT;
    }
    if (SERIAL != null || !forView) {
      map['SERIAL'] = SERIAL;
    }
    if (REASON_FOR_NDELI != null || !forView) {
      map['REASON_FOR_NDELI'] = REASON_FOR_NDELI;
    }
    if (APPLICABLE_FOR != null || !forView) {
      map['APPLICABLE_FOR'] = APPLICABLE_FOR;
    }
    if (REASON_TYPE != null || !forView) {
      map['REASON_TYPE'] = REASON_TYPE;
    }
    if (ACTION != null || !forView) {
      map['ACTION'] = ACTION;
    }
    if (REASON_NDEL_TEXT != null || !forView) {
      map['REASON_NDEL_TEXT'] = REASON_NDEL_TEXT;
    }
    if (APPL_FOR_TEXT != null || !forView) {
      map['APPL_FOR_TEXT'] = APPL_FOR_TEXT;
    }
    if (REASON_TYPE_TEXT != null || !forView) {
      map['REASON_TYPE_TEXT'] = REASON_TYPE_TEXT;
    }
    if (ACTION_TEXT != null || !forView) {
      map['ACTION_TEXT'] = ACTION_TEXT;
    }
    if (DELE_FLAG != null || !forView) {
      map['DELE_FLAG'] = DELE_FLAG;
    }

    return map;
  }

  /// This method returns Json String [Reason]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Reason]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      MANDT,
      SERIAL,
      REASON_FOR_NDELI,
      APPLICABLE_FOR,
      REASON_TYPE,
      ACTION,
      REASON_NDEL_TEXT,
      APPL_FOR_TEXT,
      REASON_TYPE_TEXT,
      ACTION_TEXT,
      DELE_FLAG
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      MANDT,
      SERIAL,
      REASON_FOR_NDELI,
      APPLICABLE_FOR,
      REASON_TYPE,
      ACTION,
      REASON_NDEL_TEXT,
      APPL_FOR_TEXT,
      REASON_TYPE_TEXT,
      ACTION_TEXT,
      DELE_FLAG
    ];
  }

  static Future<List<Reason>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Reason.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Reason>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Reason>[];
    try {
      objList = list
          .map((reason) => Reason.fromMap(reason as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Reason.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Reason>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Reason> objList = <Reason>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Reason.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Reason by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Reason] if exist, otherwise returns null
  Future<Reason?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    Reason? obj;
    final data = await _mnReason.getById([SNo]);
    if (data.length != 0) {
      obj = Reason.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Reason) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnReason.insert(this, ignoreBatch);
    } else {
      await _mnReason.update(this);
    }

    return SNo;
  }

  /// Saves the (Reason) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnReason.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnReason.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs Reason. Returns a new Primary Key value of Reason

  /// <returns>Returns a new Primary Key value of Reason
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Reason> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Reason> reasons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in reasons) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < reasons.length; i++) {
        if (reasons[i].SNo == null) {
          reasons[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnReason.rawInsert(
          'INSERT OR REPLACE INTO Reason (SNo, MANDT, SERIAL, REASON_FOR_NDELI, APPLICABLE_FOR, REASON_TYPE, ACTION, REASON_NDEL_TEXT, APPL_FOR_TEXT, REASON_TYPE_TEXT, ACTION_TEXT, DELE_FLAG)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            MANDT,
            SERIAL,
            REASON_FOR_NDELI,
            APPLICABLE_FOR,
            REASON_TYPE,
            ACTION,
            REASON_NDEL_TEXT,
            APPL_FOR_TEXT,
            REASON_TYPE_TEXT,
            ACTION_TEXT,
            DELE_FLAG
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Reason SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Reason SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Reason Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnReason.rawInsert(
          'INSERT OR IGNORE INTO Reason (SNo, MANDT, SERIAL, REASON_FOR_NDELI, APPLICABLE_FOR, REASON_TYPE, ACTION, REASON_NDEL_TEXT, APPL_FOR_TEXT, REASON_TYPE_TEXT, ACTION_TEXT, DELE_FLAG)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            MANDT,
            SERIAL,
            REASON_FOR_NDELI,
            APPLICABLE_FOR,
            REASON_TYPE,
            ACTION,
            REASON_NDEL_TEXT,
            APPL_FOR_TEXT,
            REASON_TYPE_TEXT,
            ACTION_TEXT,
            DELE_FLAG
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Reason SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Reason SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Reason Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Reason>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Reason> reasons,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnReason.rawInsertAll(
        'INSERT OR REPLACE INTO Reason (SNo, MANDT, SERIAL, REASON_FOR_NDELI, APPLICABLE_FOR, REASON_TYPE, ACTION, REASON_NDEL_TEXT, APPL_FOR_TEXT, REASON_TYPE_TEXT, ACTION_TEXT, DELE_FLAG)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        reasons,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Reason

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Reason invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnReason
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnReason.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Reason] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ReasonFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ReasonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ReasonFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ReasonFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion reason

// region ReasonField
class ReasonField extends FilterBase {
  ReasonField(ReasonFilterBuilder reasonFB) : super(reasonFB);

  @override
  ReasonFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder isNull() {
    return super.isNull() as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ReasonFilterBuilder;
  }

  @override
  ReasonField get not {
    return super.not as ReasonField;
  }
}
// endregion ReasonField

// region ReasonFilterBuilder
class ReasonFilterBuilder extends ConjunctionBase {
  ReasonFilterBuilder(Reason obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnReason = obj._mnReason;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ReasonManager? _mnReason;

  /// put the sql keyword 'AND'
  @override
  ReasonFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ReasonFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ReasonFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ReasonFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ReasonFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ReasonFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ReasonFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ReasonFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ReasonFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ReasonFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ReasonFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ReasonField _setField(ReasonField? field, String colName, DbType dbtype) {
    return ReasonField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ReasonField? _SNo;
  ReasonField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  ReasonField? _MANDT;
  ReasonField get MANDT {
    return _MANDT = _setField(_MANDT, 'MANDT', DbType.text);
  }

  ReasonField? _SERIAL;
  ReasonField get SERIAL {
    return _SERIAL = _setField(_SERIAL, 'SERIAL', DbType.real);
  }

  ReasonField? _REASON_FOR_NDELI;
  ReasonField get REASON_FOR_NDELI {
    return _REASON_FOR_NDELI =
        _setField(_REASON_FOR_NDELI, 'REASON_FOR_NDELI', DbType.text);
  }

  ReasonField? _APPLICABLE_FOR;
  ReasonField get APPLICABLE_FOR {
    return _APPLICABLE_FOR =
        _setField(_APPLICABLE_FOR, 'APPLICABLE_FOR', DbType.text);
  }

  ReasonField? _REASON_TYPE;
  ReasonField get REASON_TYPE {
    return _REASON_TYPE = _setField(_REASON_TYPE, 'REASON_TYPE', DbType.text);
  }

  ReasonField? _ACTION;
  ReasonField get ACTION {
    return _ACTION = _setField(_ACTION, 'ACTION', DbType.text);
  }

  ReasonField? _REASON_NDEL_TEXT;
  ReasonField get REASON_NDEL_TEXT {
    return _REASON_NDEL_TEXT =
        _setField(_REASON_NDEL_TEXT, 'REASON_NDEL_TEXT', DbType.text);
  }

  ReasonField? _APPL_FOR_TEXT;
  ReasonField get APPL_FOR_TEXT {
    return _APPL_FOR_TEXT =
        _setField(_APPL_FOR_TEXT, 'APPL_FOR_TEXT', DbType.text);
  }

  ReasonField? _REASON_TYPE_TEXT;
  ReasonField get REASON_TYPE_TEXT {
    return _REASON_TYPE_TEXT =
        _setField(_REASON_TYPE_TEXT, 'REASON_TYPE_TEXT', DbType.text);
  }

  ReasonField? _ACTION_TEXT;
  ReasonField get ACTION_TEXT {
    return _ACTION_TEXT = _setField(_ACTION_TEXT, 'ACTION_TEXT', DbType.text);
  }

  ReasonField? _DELE_FLAG;
  ReasonField get DELE_FLAG {
    return _DELE_FLAG = _setField(_DELE_FLAG, 'DELE_FLAG', DbType.text);
  }

  /// Deletes List<Reason> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnReason!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnReason!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from Reason ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnReason!.updateBatch(qparams, values);
  }

  /// This method always returns [Reason] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Reason?
  @override
  Future<Reason?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnReason!.toList(qparams);
    final data = await objFuture;
    Reason? obj;
    if (data.isNotEmpty) {
      obj = Reason.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Reason]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Reason?
  @override
  Future<Reason> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Reason();
  }

  /// This method returns int. [Reason]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? reasonCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final reasonsFuture = await _mnReason!.toList(qparams);
    final int count = reasonsFuture[0]['CNT'] as int;
    if (reasonCount != null) {
      reasonCount(count);
    }
    return count;
  }

  /// This method returns List<Reason> [Reason]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Reason>
  @override
  Future<List<Reason>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Reason> reasonsData = await Reason.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return reasonsData;
  }

  /// This method returns Json String [Reason]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Reason]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Reason]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnReason!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Reason]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `SNo` FROM Reason WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnReason!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Reason]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnReason!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Reason.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnReason!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ReasonFilterBuilder

// region ReasonFields
class ReasonFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fMANDT;
  static TableField get MANDT {
    return _fMANDT =
        _fMANDT ?? SqlSyntax.setField(_fMANDT, 'MANDT', DbType.text);
  }

  static TableField? _fSERIAL;
  static TableField get SERIAL {
    return _fSERIAL =
        _fSERIAL ?? SqlSyntax.setField(_fSERIAL, 'SERIAL', DbType.real);
  }

  static TableField? _fREASON_FOR_NDELI;
  static TableField get REASON_FOR_NDELI {
    return _fREASON_FOR_NDELI = _fREASON_FOR_NDELI ??
        SqlSyntax.setField(_fREASON_FOR_NDELI, 'REASON_FOR_NDELI', DbType.text);
  }

  static TableField? _fAPPLICABLE_FOR;
  static TableField get APPLICABLE_FOR {
    return _fAPPLICABLE_FOR = _fAPPLICABLE_FOR ??
        SqlSyntax.setField(_fAPPLICABLE_FOR, 'APPLICABLE_FOR', DbType.text);
  }

  static TableField? _fREASON_TYPE;
  static TableField get REASON_TYPE {
    return _fREASON_TYPE = _fREASON_TYPE ??
        SqlSyntax.setField(_fREASON_TYPE, 'REASON_TYPE', DbType.text);
  }

  static TableField? _fACTION;
  static TableField get ACTION {
    return _fACTION =
        _fACTION ?? SqlSyntax.setField(_fACTION, 'ACTION', DbType.text);
  }

  static TableField? _fREASON_NDEL_TEXT;
  static TableField get REASON_NDEL_TEXT {
    return _fREASON_NDEL_TEXT = _fREASON_NDEL_TEXT ??
        SqlSyntax.setField(_fREASON_NDEL_TEXT, 'REASON_NDEL_TEXT', DbType.text);
  }

  static TableField? _fAPPL_FOR_TEXT;
  static TableField get APPL_FOR_TEXT {
    return _fAPPL_FOR_TEXT = _fAPPL_FOR_TEXT ??
        SqlSyntax.setField(_fAPPL_FOR_TEXT, 'APPL_FOR_TEXT', DbType.text);
  }

  static TableField? _fREASON_TYPE_TEXT;
  static TableField get REASON_TYPE_TEXT {
    return _fREASON_TYPE_TEXT = _fREASON_TYPE_TEXT ??
        SqlSyntax.setField(_fREASON_TYPE_TEXT, 'REASON_TYPE_TEXT', DbType.text);
  }

  static TableField? _fACTION_TEXT;
  static TableField get ACTION_TEXT {
    return _fACTION_TEXT = _fACTION_TEXT ??
        SqlSyntax.setField(_fACTION_TEXT, 'ACTION_TEXT', DbType.text);
  }

  static TableField? _fDELE_FLAG;
  static TableField get DELE_FLAG {
    return _fDELE_FLAG = _fDELE_FLAG ??
        SqlSyntax.setField(_fDELE_FLAG, 'DELE_FLAG', DbType.text);
  }
}
// endregion ReasonFields

//region ReasonManager
class ReasonManager extends SqfEntityProvider {
  ReasonManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Reason';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion ReasonManager
// region RECEIVEDARTDETAILS
class RECEIVEDARTDETAILS extends TableBase {
  RECEIVEDARTDETAILS(
      {this.SNo,
      this.ART_NUMBER,
      this.BAGNUMBER,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.MATNR,
      this.IS_COMMUNICATED,
      this.FILE_NAME}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  RECEIVEDARTDETAILS.withFields(
      this.ART_NUMBER,
      this.BAGNUMBER,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.MATNR,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  RECEIVEDARTDETAILS.withId(
      this.SNo,
      this.ART_NUMBER,
      this.BAGNUMBER,
      this.ART_RECEIVE_DATE,
      this.ART_RECEIVE_TIME,
      this.MATNR,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RECEIVEDARTDETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['ART_NUMBER'] != null) {
      ART_NUMBER = o['ART_NUMBER'].toString();
    }
    if (o['BAGNUMBER'] != null) {
      BAGNUMBER = o['BAGNUMBER'].toString();
    }
    if (o['ART_RECEIVE_DATE'] != null) {
      ART_RECEIVE_DATE = int.tryParse(o['ART_RECEIVE_DATE'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['ART_RECEIVE_DATE'].toString())!)
          : DateTime.tryParse(o['ART_RECEIVE_DATE'].toString());
    }
    if (o['ART_RECEIVE_TIME'] != null) {
      ART_RECEIVE_TIME = int.tryParse(o['ART_RECEIVE_TIME'].toString()) != null
          ? DateTime.fromMillisecondsSinceEpoch(
              int.tryParse(o['ART_RECEIVE_TIME'].toString())!)
          : DateTime.tryParse(o['ART_RECEIVE_TIME'].toString());
    }
    if (o['MATNR'] != null) {
      MATNR = o['MATNR'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
  }
  // FIELDS (RECEIVEDARTDETAILS)
  int? SNo;
  String? ART_NUMBER;
  String? BAGNUMBER;
  DateTime? ART_RECEIVE_DATE;
  DateTime? ART_RECEIVE_TIME;
  String? MATNR;
  String? IS_COMMUNICATED;
  String? FILE_NAME;

  // end FIELDS (RECEIVEDARTDETAILS)

  static const bool _softDeleteActivated = false;
  RECEIVEDARTDETAILSManager? __mnRECEIVEDARTDETAILS;

  RECEIVEDARTDETAILSManager get _mnRECEIVEDARTDETAILS {
    return __mnRECEIVEDARTDETAILS =
        __mnRECEIVEDARTDETAILS ?? RECEIVEDARTDETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (ART_NUMBER != null || !forView) {
      map['ART_NUMBER'] = ART_NUMBER;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (ART_RECEIVE_DATE != null) {
      map['ART_RECEIVE_DATE'] = forJson
          ? '$ART_RECEIVE_DATE!.year-$ART_RECEIVE_DATE!.month-$ART_RECEIVE_DATE!.day'
          : forQuery
              ? DateTime(ART_RECEIVE_DATE!.year, ART_RECEIVE_DATE!.month,
                      ART_RECEIVE_DATE!.day)
                  .millisecondsSinceEpoch
              : ART_RECEIVE_DATE;
    } else if (ART_RECEIVE_DATE != null || !forView) {
      map['ART_RECEIVE_DATE'] = null;
    }
    if (ART_RECEIVE_TIME != null) {
      map['ART_RECEIVE_TIME'] = forJson
          ? ART_RECEIVE_TIME!.toString()
          : forQuery
              ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
              : ART_RECEIVE_TIME;
    } else if (ART_RECEIVE_TIME != null || !forView) {
      map['ART_RECEIVE_TIME'] = null;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (ART_NUMBER != null || !forView) {
      map['ART_NUMBER'] = ART_NUMBER;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (ART_RECEIVE_DATE != null) {
      map['ART_RECEIVE_DATE'] = forJson
          ? '$ART_RECEIVE_DATE!.year-$ART_RECEIVE_DATE!.month-$ART_RECEIVE_DATE!.day'
          : forQuery
              ? DateTime(ART_RECEIVE_DATE!.year, ART_RECEIVE_DATE!.month,
                      ART_RECEIVE_DATE!.day)
                  .millisecondsSinceEpoch
              : ART_RECEIVE_DATE;
    } else if (ART_RECEIVE_DATE != null || !forView) {
      map['ART_RECEIVE_DATE'] = null;
    }
    if (ART_RECEIVE_TIME != null) {
      map['ART_RECEIVE_TIME'] = forJson
          ? ART_RECEIVE_TIME!.toString()
          : forQuery
              ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
              : ART_RECEIVE_TIME;
    } else if (ART_RECEIVE_TIME != null || !forView) {
      map['ART_RECEIVE_TIME'] = null;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  /// This method returns Json String [RECEIVEDARTDETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RECEIVEDARTDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ART_NUMBER,
      BAGNUMBER,
      ART_RECEIVE_DATE != null
          ? ART_RECEIVE_DATE!.millisecondsSinceEpoch
          : null,
      ART_RECEIVE_TIME != null
          ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
          : null,
      MATNR,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      ART_NUMBER,
      BAGNUMBER,
      ART_RECEIVE_DATE != null
          ? ART_RECEIVE_DATE!.millisecondsSinceEpoch
          : null,
      ART_RECEIVE_TIME != null
          ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
          : null,
      MATNR,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  static Future<List<RECEIVEDARTDETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RECEIVEDARTDETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RECEIVEDARTDETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RECEIVEDARTDETAILS>[];
    try {
      objList = list
          .map((receivedartdetails) => RECEIVEDARTDETAILS
              .fromMap(receivedartdetails as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RECEIVEDARTDETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RECEIVEDARTDETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RECEIVEDARTDETAILS> objList = <RECEIVEDARTDETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RECEIVEDARTDETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns RECEIVEDARTDETAILS by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [RECEIVEDARTDETAILS] if exist, otherwise returns null
  Future<RECEIVEDARTDETAILS?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    RECEIVEDARTDETAILS? obj;
    final data = await _mnRECEIVEDARTDETAILS.getById([SNo]);
    if (data.length != 0) {
      obj = RECEIVEDARTDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RECEIVEDARTDETAILS) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnRECEIVEDARTDETAILS.insert(this, ignoreBatch);
    } else {
      await _mnRECEIVEDARTDETAILS.update(this);
    }

    return SNo;
  }

  /// Saves the (RECEIVEDARTDETAILS) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnRECEIVEDARTDETAILS.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnRECEIVEDARTDETAILS.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs RECEIVEDARTDETAILS. Returns a new Primary Key value of RECEIVEDARTDETAILS

  /// <returns>Returns a new Primary Key value of RECEIVEDARTDETAILS
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<RECEIVEDARTDETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<RECEIVEDARTDETAILS> receivedartdetailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in receivedartdetailses) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < receivedartdetailses.length; i++) {
        if (receivedartdetailses[i].SNo == null) {
          receivedartdetailses[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRECEIVEDARTDETAILS.rawInsert(
          'INSERT OR REPLACE INTO RECEIVEDARTDETAILS (SNo, ART_NUMBER, BAGNUMBER, ART_RECEIVE_DATE, ART_RECEIVE_TIME, MATNR, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?)',
          [
            SNo,
            ART_NUMBER,
            BAGNUMBER,
            ART_RECEIVE_DATE != null
                ? ART_RECEIVE_DATE!.millisecondsSinceEpoch
                : null,
            ART_RECEIVE_TIME != null
                ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
                : null,
            MATNR,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'RECEIVEDARTDETAILS SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RECEIVEDARTDETAILS SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'RECEIVEDARTDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRECEIVEDARTDETAILS.rawInsert(
          'INSERT OR IGNORE INTO RECEIVEDARTDETAILS (SNo, ART_NUMBER, BAGNUMBER, ART_RECEIVE_DATE, ART_RECEIVE_TIME, MATNR, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?)',
          [
            SNo,
            ART_NUMBER,
            BAGNUMBER,
            ART_RECEIVE_DATE != null
                ? ART_RECEIVE_DATE!.millisecondsSinceEpoch
                : null,
            ART_RECEIVE_TIME != null
                ? ART_RECEIVE_TIME!.millisecondsSinceEpoch
                : null,
            MATNR,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'RECEIVEDARTDETAILS SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'RECEIVEDARTDETAILS SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'RECEIVEDARTDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<RECEIVEDARTDETAILS>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<RECEIVEDARTDETAILS> receivedartdetailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnRECEIVEDARTDETAILS.rawInsertAll(
        'INSERT OR REPLACE INTO RECEIVEDARTDETAILS (SNo, ART_NUMBER, BAGNUMBER, ART_RECEIVE_DATE, ART_RECEIVE_TIME, MATNR, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?)',
        receivedartdetailses,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes RECEIVEDARTDETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete RECEIVEDARTDETAILS invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnRECEIVEDARTDETAILS
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnRECEIVEDARTDETAILS.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [RECEIVEDARTDETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RECEIVEDARTDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RECEIVEDARTDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion receivedartdetails

// region RECEIVEDARTDETAILSField
class RECEIVEDARTDETAILSField extends FilterBase {
  RECEIVEDARTDETAILSField(RECEIVEDARTDETAILSFilterBuilder receivedartdetailsFB)
      : super(receivedartdetailsFB);

  @override
  RECEIVEDARTDETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder isNull() {
    return super.isNull() as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RECEIVEDARTDETAILSFilterBuilder;
  }

  @override
  RECEIVEDARTDETAILSField get not {
    return super.not as RECEIVEDARTDETAILSField;
  }
}
// endregion RECEIVEDARTDETAILSField

// region RECEIVEDARTDETAILSFilterBuilder
class RECEIVEDARTDETAILSFilterBuilder extends ConjunctionBase {
  RECEIVEDARTDETAILSFilterBuilder(RECEIVEDARTDETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnRECEIVEDARTDETAILS = obj._mnRECEIVEDARTDETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RECEIVEDARTDETAILSManager? _mnRECEIVEDARTDETAILS;

  /// put the sql keyword 'AND'
  @override
  RECEIVEDARTDETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RECEIVEDARTDETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RECEIVEDARTDETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RECEIVEDARTDETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RECEIVEDARTDETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RECEIVEDARTDETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RECEIVEDARTDETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RECEIVEDARTDETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RECEIVEDARTDETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RECEIVEDARTDETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RECEIVEDARTDETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RECEIVEDARTDETAILSField _setField(
      RECEIVEDARTDETAILSField? field, String colName, DbType dbtype) {
    return RECEIVEDARTDETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RECEIVEDARTDETAILSField? _SNo;
  RECEIVEDARTDETAILSField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  RECEIVEDARTDETAILSField? _ART_NUMBER;
  RECEIVEDARTDETAILSField get ART_NUMBER {
    return _ART_NUMBER = _setField(_ART_NUMBER, 'ART_NUMBER', DbType.text);
  }

  RECEIVEDARTDETAILSField? _BAGNUMBER;
  RECEIVEDARTDETAILSField get BAGNUMBER {
    return _BAGNUMBER = _setField(_BAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  RECEIVEDARTDETAILSField? _ART_RECEIVE_DATE;
  RECEIVEDARTDETAILSField get ART_RECEIVE_DATE {
    return _ART_RECEIVE_DATE =
        _setField(_ART_RECEIVE_DATE, 'ART_RECEIVE_DATE', DbType.date);
  }

  RECEIVEDARTDETAILSField? _ART_RECEIVE_TIME;
  RECEIVEDARTDETAILSField get ART_RECEIVE_TIME {
    return _ART_RECEIVE_TIME =
        _setField(_ART_RECEIVE_TIME, 'ART_RECEIVE_TIME', DbType.datetime);
  }

  RECEIVEDARTDETAILSField? _MATNR;
  RECEIVEDARTDETAILSField get MATNR {
    return _MATNR = _setField(_MATNR, 'MATNR', DbType.text);
  }

  RECEIVEDARTDETAILSField? _IS_COMMUNICATED;
  RECEIVEDARTDETAILSField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  RECEIVEDARTDETAILSField? _FILE_NAME;
  RECEIVEDARTDETAILSField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  /// Deletes List<RECEIVEDARTDETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRECEIVEDARTDETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRECEIVEDARTDETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from RECEIVEDARTDETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRECEIVEDARTDETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [RECEIVEDARTDETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RECEIVEDARTDETAILS?
  @override
  Future<RECEIVEDARTDETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRECEIVEDARTDETAILS!.toList(qparams);
    final data = await objFuture;
    RECEIVEDARTDETAILS? obj;
    if (data.isNotEmpty) {
      obj = RECEIVEDARTDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RECEIVEDARTDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RECEIVEDARTDETAILS?
  @override
  Future<RECEIVEDARTDETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RECEIVEDARTDETAILS();
  }

  /// This method returns int. [RECEIVEDARTDETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? receivedartdetailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final receivedartdetailsesFuture =
        await _mnRECEIVEDARTDETAILS!.toList(qparams);
    final int count = receivedartdetailsesFuture[0]['CNT'] as int;
    if (receivedartdetailsCount != null) {
      receivedartdetailsCount(count);
    }
    return count;
  }

  /// This method returns List<RECEIVEDARTDETAILS> [RECEIVEDARTDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<RECEIVEDARTDETAILS>
  @override
  Future<List<RECEIVEDARTDETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RECEIVEDARTDETAILS> receivedartdetailsesData =
        await RECEIVEDARTDETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return receivedartdetailsesData;
  }

  /// This method returns Json String [RECEIVEDARTDETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RECEIVEDARTDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RECEIVEDARTDETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRECEIVEDARTDETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RECEIVEDARTDETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM RECEIVEDARTDETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnRECEIVEDARTDETAILS!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RECEIVEDARTDETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRECEIVEDARTDETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await RECEIVEDARTDETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRECEIVEDARTDETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RECEIVEDARTDETAILSFilterBuilder

// region RECEIVEDARTDETAILSFields
class RECEIVEDARTDETAILSFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fART_NUMBER;
  static TableField get ART_NUMBER {
    return _fART_NUMBER = _fART_NUMBER ??
        SqlSyntax.setField(_fART_NUMBER, 'ART_NUMBER', DbType.text);
  }

  static TableField? _fBAGNUMBER;
  static TableField get BAGNUMBER {
    return _fBAGNUMBER = _fBAGNUMBER ??
        SqlSyntax.setField(_fBAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  static TableField? _fART_RECEIVE_DATE;
  static TableField get ART_RECEIVE_DATE {
    return _fART_RECEIVE_DATE = _fART_RECEIVE_DATE ??
        SqlSyntax.setField(_fART_RECEIVE_DATE, 'ART_RECEIVE_DATE', DbType.date);
  }

  static TableField? _fART_RECEIVE_TIME;
  static TableField get ART_RECEIVE_TIME {
    return _fART_RECEIVE_TIME = _fART_RECEIVE_TIME ??
        SqlSyntax.setField(
            _fART_RECEIVE_TIME, 'ART_RECEIVE_TIME', DbType.datetime);
  }

  static TableField? _fMATNR;
  static TableField get MATNR {
    return _fMATNR =
        _fMATNR ?? SqlSyntax.setField(_fMATNR, 'MATNR', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }
}
// endregion RECEIVEDARTDETAILSFields

//region RECEIVEDARTDETAILSManager
class RECEIVEDARTDETAILSManager extends SqfEntityProvider {
  RECEIVEDARTDETAILSManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'RECEIVEDARTDETAILS';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion RECEIVEDARTDETAILSManager
// region ARTICLEMASTER
class ARTICLEMASTER extends TableBase {
  ARTICLEMASTER({this.SNo, this.ARTICLETYPE, this.ARTICLECODE}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ARTICLEMASTER.withFields(this.ARTICLETYPE, this.ARTICLECODE) {
    _setDefaultValues();
  }
  ARTICLEMASTER.withId(this.SNo, this.ARTICLETYPE, this.ARTICLECODE) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ARTICLEMASTER.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['ARTICLETYPE'] != null) {
      ARTICLETYPE = o['ARTICLETYPE'].toString();
    }
    if (o['ARTICLECODE'] != null) {
      ARTICLECODE = o['ARTICLECODE'].toString();
    }
  }
  // FIELDS (ARTICLEMASTER)
  int? SNo;
  String? ARTICLETYPE;
  String? ARTICLECODE;

  // end FIELDS (ARTICLEMASTER)

  static const bool _softDeleteActivated = false;
  ARTICLEMASTERManager? __mnARTICLEMASTER;

  ARTICLEMASTERManager get _mnARTICLEMASTER {
    return __mnARTICLEMASTER = __mnARTICLEMASTER ?? ARTICLEMASTERManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (ARTICLETYPE != null || !forView) {
      map['ARTICLETYPE'] = ARTICLETYPE;
    }
    if (ARTICLECODE != null || !forView) {
      map['ARTICLECODE'] = ARTICLECODE;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (ARTICLETYPE != null || !forView) {
      map['ARTICLETYPE'] = ARTICLETYPE;
    }
    if (ARTICLECODE != null || !forView) {
      map['ARTICLECODE'] = ARTICLECODE;
    }

    return map;
  }

  /// This method returns Json String [ARTICLEMASTER]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ARTICLEMASTER]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [ARTICLETYPE, ARTICLECODE];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [SNo, ARTICLETYPE, ARTICLECODE];
  }

  static Future<List<ARTICLEMASTER>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ARTICLEMASTER.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ARTICLEMASTER>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ARTICLEMASTER>[];
    try {
      objList = list
          .map((articlemaster) =>
              ARTICLEMASTER.fromMap(articlemaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ARTICLEMASTER.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ARTICLEMASTER>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ARTICLEMASTER> objList = <ARTICLEMASTER>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ARTICLEMASTER.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ARTICLEMASTER by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ARTICLEMASTER] if exist, otherwise returns null
  Future<ARTICLEMASTER?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    ARTICLEMASTER? obj;
    final data = await _mnARTICLEMASTER.getById([SNo]);
    if (data.length != 0) {
      obj = ARTICLEMASTER.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ARTICLEMASTER) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnARTICLEMASTER.insert(this, ignoreBatch);
    } else {
      await _mnARTICLEMASTER.update(this);
    }

    return SNo;
  }

  /// Saves the (ARTICLEMASTER) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnARTICLEMASTER.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnARTICLEMASTER.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs ARTICLEMASTER. Returns a new Primary Key value of ARTICLEMASTER

  /// <returns>Returns a new Primary Key value of ARTICLEMASTER
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ARTICLEMASTER> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ARTICLEMASTER> articlemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in articlemasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < articlemasters.length; i++) {
        if (articlemasters[i].SNo == null) {
          articlemasters[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnARTICLEMASTER.rawInsert(
          'INSERT OR REPLACE INTO ARTICLEMASTER (SNo, ARTICLETYPE, ARTICLECODE)  VALUES (?,?,?)',
          [SNo, ARTICLETYPE, ARTICLECODE],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ARTICLEMASTER SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ARTICLEMASTER SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ARTICLEMASTER Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnARTICLEMASTER.rawInsert(
          'INSERT OR IGNORE INTO ARTICLEMASTER (SNo, ARTICLETYPE, ARTICLECODE)  VALUES (?,?,?)',
          [SNo, ARTICLETYPE, ARTICLECODE],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ARTICLEMASTER SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ARTICLEMASTER SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ARTICLEMASTER Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ARTICLEMASTER>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ARTICLEMASTER> articlemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnARTICLEMASTER.rawInsertAll(
        'INSERT OR REPLACE INTO ARTICLEMASTER (SNo, ARTICLETYPE, ARTICLECODE)  VALUES (?,?,?)',
        articlemasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ARTICLEMASTER

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ARTICLEMASTER invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnARTICLEMASTER
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnARTICLEMASTER.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ARTICLEMASTER] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ARTICLEMASTERFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ARTICLEMASTERFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ARTICLEMASTERFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ARTICLEMASTERFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion articlemaster

// region ARTICLEMASTERField
class ARTICLEMASTERField extends FilterBase {
  ARTICLEMASTERField(ARTICLEMASTERFilterBuilder articlemasterFB)
      : super(articlemasterFB);

  @override
  ARTICLEMASTERFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder isNull() {
    return super.isNull() as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ARTICLEMASTERFilterBuilder;
  }

  @override
  ARTICLEMASTERField get not {
    return super.not as ARTICLEMASTERField;
  }
}
// endregion ARTICLEMASTERField

// region ARTICLEMASTERFilterBuilder
class ARTICLEMASTERFilterBuilder extends ConjunctionBase {
  ARTICLEMASTERFilterBuilder(ARTICLEMASTER obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnARTICLEMASTER = obj._mnARTICLEMASTER;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ARTICLEMASTERManager? _mnARTICLEMASTER;

  /// put the sql keyword 'AND'
  @override
  ARTICLEMASTERFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ARTICLEMASTERFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ARTICLEMASTERFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ARTICLEMASTERFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ARTICLEMASTERFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ARTICLEMASTERFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ARTICLEMASTERFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ARTICLEMASTERFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ARTICLEMASTERFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ARTICLEMASTERFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ARTICLEMASTERFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ARTICLEMASTERField _setField(
      ARTICLEMASTERField? field, String colName, DbType dbtype) {
    return ARTICLEMASTERField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ARTICLEMASTERField? _SNo;
  ARTICLEMASTERField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  ARTICLEMASTERField? _ARTICLETYPE;
  ARTICLEMASTERField get ARTICLETYPE {
    return _ARTICLETYPE = _setField(_ARTICLETYPE, 'ARTICLETYPE', DbType.text);
  }

  ARTICLEMASTERField? _ARTICLECODE;
  ARTICLEMASTERField get ARTICLECODE {
    return _ARTICLECODE = _setField(_ARTICLECODE, 'ARTICLECODE', DbType.text);
  }

  /// Deletes List<ARTICLEMASTER> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnARTICLEMASTER!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnARTICLEMASTER!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from ARTICLEMASTER ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnARTICLEMASTER!.updateBatch(qparams, values);
  }

  /// This method always returns [ARTICLEMASTER] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ARTICLEMASTER?
  @override
  Future<ARTICLEMASTER?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnARTICLEMASTER!.toList(qparams);
    final data = await objFuture;
    ARTICLEMASTER? obj;
    if (data.isNotEmpty) {
      obj = ARTICLEMASTER.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ARTICLEMASTER]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ARTICLEMASTER?
  @override
  Future<ARTICLEMASTER> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ARTICLEMASTER();
  }

  /// This method returns int. [ARTICLEMASTER]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? articlemasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final articlemastersFuture = await _mnARTICLEMASTER!.toList(qparams);
    final int count = articlemastersFuture[0]['CNT'] as int;
    if (articlemasterCount != null) {
      articlemasterCount(count);
    }
    return count;
  }

  /// This method returns List<ARTICLEMASTER> [ARTICLEMASTER]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ARTICLEMASTER>
  @override
  Future<List<ARTICLEMASTER>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ARTICLEMASTER> articlemastersData =
        await ARTICLEMASTER.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return articlemastersData;
  }

  /// This method returns Json String [ARTICLEMASTER]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ARTICLEMASTER]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ARTICLEMASTER]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnARTICLEMASTER!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ARTICLEMASTER]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM ARTICLEMASTER WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnARTICLEMASTER!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ARTICLEMASTER]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnARTICLEMASTER!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ARTICLEMASTER.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnARTICLEMASTER!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ARTICLEMASTERFilterBuilder

// region ARTICLEMASTERFields
class ARTICLEMASTERFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fARTICLETYPE;
  static TableField get ARTICLETYPE {
    return _fARTICLETYPE = _fARTICLETYPE ??
        SqlSyntax.setField(_fARTICLETYPE, 'ARTICLETYPE', DbType.text);
  }

  static TableField? _fARTICLECODE;
  static TableField get ARTICLECODE {
    return _fARTICLECODE = _fARTICLECODE ??
        SqlSyntax.setField(_fARTICLECODE, 'ARTICLECODE', DbType.text);
  }
}
// endregion ARTICLEMASTERFields

//region ARTICLEMASTERManager
class ARTICLEMASTERManager extends SqfEntityProvider {
  ARTICLEMASTERManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ARTICLEMASTER';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion ARTICLEMASTERManager
// region Login
class Login extends TableBase {
  Login(
      {this.SNo,
      this.IMEI,
      this.empName,
      this.empId,
      this.mobile,
      this.pincode,
      this.facilityID,
      this.digitalToken}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Login.withFields(this.IMEI, this.empName, this.empId, this.mobile,
      this.pincode, this.facilityID, this.digitalToken) {
    _setDefaultValues();
  }
  Login.withId(this.SNo, this.IMEI, this.empName, this.empId, this.mobile,
      this.pincode, this.facilityID, this.digitalToken) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Login.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['IMEI'] != null) {
      IMEI = o['IMEI'].toString();
    }
    if (o['empName'] != null) {
      empName = o['empName'].toString();
    }
    if (o['empId'] != null) {
      empId = o['empId'].toString();
    }
    if (o['mobile'] != null) {
      mobile = o['mobile'].toString();
    }
    if (o['pincode'] != null) {
      pincode = o['pincode'].toString();
    }
    if (o['facilityID'] != null) {
      facilityID = o['facilityID'].toString();
    }
    if (o['digitalToken'] != null) {
      digitalToken = o['digitalToken'].toString();
    }
  }
  // FIELDS (Login)
  int? SNo;
  String? IMEI;
  String? empName;
  String? empId;
  String? mobile;
  String? pincode;
  String? facilityID;
  String? digitalToken;

  // end FIELDS (Login)

  static const bool _softDeleteActivated = false;
  LoginManager? __mnLogin;

  LoginManager get _mnLogin {
    return __mnLogin = __mnLogin ?? LoginManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (IMEI != null || !forView) {
      map['IMEI'] = IMEI;
    }
    if (empName != null || !forView) {
      map['empName'] = empName;
    }
    if (empId != null || !forView) {
      map['empId'] = empId;
    }
    if (mobile != null || !forView) {
      map['mobile'] = mobile;
    }
    if (pincode != null || !forView) {
      map['pincode'] = pincode;
    }
    if (facilityID != null || !forView) {
      map['facilityID'] = facilityID;
    }
    if (digitalToken != null || !forView) {
      map['digitalToken'] = digitalToken;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (IMEI != null || !forView) {
      map['IMEI'] = IMEI;
    }
    if (empName != null || !forView) {
      map['empName'] = empName;
    }
    if (empId != null || !forView) {
      map['empId'] = empId;
    }
    if (mobile != null || !forView) {
      map['mobile'] = mobile;
    }
    if (pincode != null || !forView) {
      map['pincode'] = pincode;
    }
    if (facilityID != null || !forView) {
      map['facilityID'] = facilityID;
    }
    if (digitalToken != null || !forView) {
      map['digitalToken'] = digitalToken;
    }

    return map;
  }

  /// This method returns Json String [Login]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Login]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [IMEI, empName, empId, mobile, pincode, facilityID, digitalToken];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      IMEI,
      empName,
      empId,
      mobile,
      pincode,
      facilityID,
      digitalToken
    ];
  }

  static Future<List<Login>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Login.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Login>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Login>[];
    try {
      objList = list
          .map((login) => Login.fromMap(login as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Login.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Login>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Login> objList = <Login>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Login.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Login by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Login] if exist, otherwise returns null
  Future<Login?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    Login? obj;
    final data = await _mnLogin.getById([SNo]);
    if (data.length != 0) {
      obj = Login.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Login) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnLogin.insert(this, ignoreBatch);
    } else {
      await _mnLogin.update(this);
    }

    return SNo;
  }

  /// Saves the (Login) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnLogin.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnLogin.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs Login. Returns a new Primary Key value of Login

  /// <returns>Returns a new Primary Key value of Login
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<Login> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Login> logins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in logins) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < logins.length; i++) {
        if (logins[i].SNo == null) {
          logins[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLogin.rawInsert(
          'INSERT OR REPLACE INTO Login (SNo, IMEI, empName, empId, mobile, pincode, facilityID, digitalToken)  VALUES (?,?,?,?,?,?,?,?)',
          [
            SNo,
            IMEI,
            empName,
            empId,
            mobile,
            pincode,
            facilityID,
            digitalToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Login SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Login SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Login Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLogin.rawInsert(
          'INSERT OR IGNORE INTO Login (SNo, IMEI, empName, empId, mobile, pincode, facilityID, digitalToken)  VALUES (?,?,?,?,?,?,?,?)',
          [
            SNo,
            IMEI,
            empName,
            empId,
            mobile,
            pincode,
            facilityID,
            digitalToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Login SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'Login SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Login Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<Login>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<Login> logins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnLogin.rawInsertAll(
        'INSERT OR REPLACE INTO Login (SNo, IMEI, empName, empId, mobile, pincode, facilityID, digitalToken)  VALUES (?,?,?,?,?,?,?,?)',
        logins,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes Login

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Login invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLogin
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnLogin.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Login] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LoginFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LoginFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LoginFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LoginFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion login

// region LoginField
class LoginField extends FilterBase {
  LoginField(LoginFilterBuilder loginFB) : super(loginFB);

  @override
  LoginFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder isNull() {
    return super.isNull() as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LoginFilterBuilder;
  }

  @override
  LoginFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LoginFilterBuilder;
  }

  @override
  LoginField get not {
    return super.not as LoginField;
  }
}
// endregion LoginField

// region LoginFilterBuilder
class LoginFilterBuilder extends ConjunctionBase {
  LoginFilterBuilder(Login obj, bool? getIsDeleted) : super(obj, getIsDeleted) {
    _mnLogin = obj._mnLogin;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LoginManager? _mnLogin;

  /// put the sql keyword 'AND'
  @override
  LoginFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LoginFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LoginFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LoginFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LoginFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LoginFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LoginFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LoginFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LoginFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LoginFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LoginFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LoginField _setField(LoginField? field, String colName, DbType dbtype) {
    return LoginField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LoginField? _SNo;
  LoginField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  LoginField? _IMEI;
  LoginField get IMEI {
    return _IMEI = _setField(_IMEI, 'IMEI', DbType.text);
  }

  LoginField? _empName;
  LoginField get empName {
    return _empName = _setField(_empName, 'empName', DbType.text);
  }

  LoginField? _empId;
  LoginField get empId {
    return _empId = _setField(_empId, 'empId', DbType.text);
  }

  LoginField? _mobile;
  LoginField get mobile {
    return _mobile = _setField(_mobile, 'mobile', DbType.text);
  }

  LoginField? _pincode;
  LoginField get pincode {
    return _pincode = _setField(_pincode, 'pincode', DbType.text);
  }

  LoginField? _facilityID;
  LoginField get facilityID {
    return _facilityID = _setField(_facilityID, 'facilityID', DbType.text);
  }

  LoginField? _digitalToken;
  LoginField get digitalToken {
    return _digitalToken =
        _setField(_digitalToken, 'digitalToken', DbType.text);
  }

  /// Deletes List<Login> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLogin!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLogin!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from Login ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLogin!.updateBatch(qparams, values);
  }

  /// This method always returns [Login] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Login?
  @override
  Future<Login?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLogin!.toList(qparams);
    final data = await objFuture;
    Login? obj;
    if (data.isNotEmpty) {
      obj = Login.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Login]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Login?
  @override
  Future<Login> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Login();
  }

  /// This method returns int. [Login]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? loginCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final loginsFuture = await _mnLogin!.toList(qparams);
    final int count = loginsFuture[0]['CNT'] as int;
    if (loginCount != null) {
      loginCount(count);
    }
    return count;
  }

  /// This method returns List<Login> [Login]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Login>
  @override
  Future<List<Login>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Login> loginsData = await Login.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return loginsData;
  }

  /// This method returns Json String [Login]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Login]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Login]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLogin!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Login]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `SNo` FROM Login WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnLogin!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Login]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLogin!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Login.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLogin!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LoginFilterBuilder

// region LoginFields
class LoginFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fIMEI;
  static TableField get IMEI {
    return _fIMEI = _fIMEI ?? SqlSyntax.setField(_fIMEI, 'IMEI', DbType.text);
  }

  static TableField? _fEmpName;
  static TableField get empName {
    return _fEmpName =
        _fEmpName ?? SqlSyntax.setField(_fEmpName, 'empName', DbType.text);
  }

  static TableField? _fEmpId;
  static TableField get empId {
    return _fEmpId =
        _fEmpId ?? SqlSyntax.setField(_fEmpId, 'empId', DbType.text);
  }

  static TableField? _fMobile;
  static TableField get mobile {
    return _fMobile =
        _fMobile ?? SqlSyntax.setField(_fMobile, 'mobile', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'pincode', DbType.text);
  }

  static TableField? _fFacilityID;
  static TableField get facilityID {
    return _fFacilityID = _fFacilityID ??
        SqlSyntax.setField(_fFacilityID, 'facilityID', DbType.text);
  }

  static TableField? _fDigitalToken;
  static TableField get digitalToken {
    return _fDigitalToken = _fDigitalToken ??
        SqlSyntax.setField(_fDigitalToken, 'digitalToken', DbType.text);
  }
}
// endregion LoginFields

//region LoginManager
class LoginManager extends SqfEntityProvider {
  LoginManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Login';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion LoginManager
// region DESPATCHBAG
class DESPATCHBAG extends TableBase {
  DESPATCHBAG(
      {this.SNo,
      this.SCHEDULE,
      this.SCHEDULED_TIME,
      this.MAILLIST_TO_OFFICE,
      this.BAGNUMBER,
      this.FROM_OFFICE,
      this.TO_OFFICE,
      this.CLOSING_DATE,
      this.REMARKS,
      this.IS_COMMUNICATED,
      this.IS_RCVD}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DESPATCHBAG.withFields(
      this.SCHEDULE,
      this.SCHEDULED_TIME,
      this.MAILLIST_TO_OFFICE,
      this.BAGNUMBER,
      this.FROM_OFFICE,
      this.TO_OFFICE,
      this.CLOSING_DATE,
      this.REMARKS,
      this.IS_COMMUNICATED,
      this.IS_RCVD) {
    _setDefaultValues();
  }
  DESPATCHBAG.withId(
      this.SNo,
      this.SCHEDULE,
      this.SCHEDULED_TIME,
      this.MAILLIST_TO_OFFICE,
      this.BAGNUMBER,
      this.FROM_OFFICE,
      this.TO_OFFICE,
      this.CLOSING_DATE,
      this.REMARKS,
      this.IS_COMMUNICATED,
      this.IS_RCVD) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DESPATCHBAG.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['SCHEDULE'] != null) {
      SCHEDULE = o['SCHEDULE'].toString();
    }
    if (o['SCHEDULED_TIME'] != null) {
      SCHEDULED_TIME = o['SCHEDULED_TIME'].toString();
    }
    if (o['MAILLIST_TO_OFFICE'] != null) {
      MAILLIST_TO_OFFICE = o['MAILLIST_TO_OFFICE'].toString();
    }
    if (o['BAGNUMBER'] != null) {
      BAGNUMBER = o['BAGNUMBER'].toString();
    }
    if (o['FROM_OFFICE'] != null) {
      FROM_OFFICE = o['FROM_OFFICE'].toString();
    }
    if (o['TO_OFFICE'] != null) {
      TO_OFFICE = o['TO_OFFICE'].toString();
    }
    if (o['CLOSING_DATE'] != null) {
      CLOSING_DATE = o['CLOSING_DATE'].toString();
    }
    if (o['REMARKS'] != null) {
      REMARKS = o['REMARKS'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['IS_RCVD'] != null) {
      IS_RCVD = o['IS_RCVD'].toString();
    }
  }
  // FIELDS (DESPATCHBAG)
  int? SNo;
  String? SCHEDULE;
  String? SCHEDULED_TIME;
  String? MAILLIST_TO_OFFICE;
  String? BAGNUMBER;
  String? FROM_OFFICE;
  String? TO_OFFICE;
  String? CLOSING_DATE;
  String? REMARKS;
  String? IS_COMMUNICATED;
  String? IS_RCVD;

  // end FIELDS (DESPATCHBAG)

  static const bool _softDeleteActivated = false;
  DESPATCHBAGManager? __mnDESPATCHBAG;

  DESPATCHBAGManager get _mnDESPATCHBAG {
    return __mnDESPATCHBAG = __mnDESPATCHBAG ?? DESPATCHBAGManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (SCHEDULE != null || !forView) {
      map['SCHEDULE'] = SCHEDULE;
    }
    if (SCHEDULED_TIME != null || !forView) {
      map['SCHEDULED_TIME'] = SCHEDULED_TIME;
    }
    if (MAILLIST_TO_OFFICE != null || !forView) {
      map['MAILLIST_TO_OFFICE'] = MAILLIST_TO_OFFICE;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (FROM_OFFICE != null || !forView) {
      map['FROM_OFFICE'] = FROM_OFFICE;
    }
    if (TO_OFFICE != null || !forView) {
      map['TO_OFFICE'] = TO_OFFICE;
    }
    if (CLOSING_DATE != null || !forView) {
      map['CLOSING_DATE'] = CLOSING_DATE;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (SCHEDULE != null || !forView) {
      map['SCHEDULE'] = SCHEDULE;
    }
    if (SCHEDULED_TIME != null || !forView) {
      map['SCHEDULED_TIME'] = SCHEDULED_TIME;
    }
    if (MAILLIST_TO_OFFICE != null || !forView) {
      map['MAILLIST_TO_OFFICE'] = MAILLIST_TO_OFFICE;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (FROM_OFFICE != null || !forView) {
      map['FROM_OFFICE'] = FROM_OFFICE;
    }
    if (TO_OFFICE != null || !forView) {
      map['TO_OFFICE'] = TO_OFFICE;
    }
    if (CLOSING_DATE != null || !forView) {
      map['CLOSING_DATE'] = CLOSING_DATE;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }

    return map;
  }

  /// This method returns Json String [DESPATCHBAG]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DESPATCHBAG]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      SCHEDULE,
      SCHEDULED_TIME,
      MAILLIST_TO_OFFICE,
      BAGNUMBER,
      FROM_OFFICE,
      TO_OFFICE,
      CLOSING_DATE,
      REMARKS,
      IS_COMMUNICATED,
      IS_RCVD
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      SCHEDULE,
      SCHEDULED_TIME,
      MAILLIST_TO_OFFICE,
      BAGNUMBER,
      FROM_OFFICE,
      TO_OFFICE,
      CLOSING_DATE,
      REMARKS,
      IS_COMMUNICATED,
      IS_RCVD
    ];
  }

  static Future<List<DESPATCHBAG>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DESPATCHBAG.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DESPATCHBAG>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DESPATCHBAG>[];
    try {
      objList = list
          .map((despatchbag) =>
              DESPATCHBAG.fromMap(despatchbag as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DESPATCHBAG.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DESPATCHBAG>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DESPATCHBAG> objList = <DESPATCHBAG>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DESPATCHBAG.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DESPATCHBAG by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DESPATCHBAG] if exist, otherwise returns null
  Future<DESPATCHBAG?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    DESPATCHBAG? obj;
    final data = await _mnDESPATCHBAG.getById([SNo]);
    if (data.length != 0) {
      obj = DESPATCHBAG.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DESPATCHBAG) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnDESPATCHBAG.insert(this, ignoreBatch);
    } else {
      await _mnDESPATCHBAG.update(this);
    }

    return SNo;
  }

  /// Saves the (DESPATCHBAG) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnDESPATCHBAG.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDESPATCHBAG.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs DESPATCHBAG. Returns a new Primary Key value of DESPATCHBAG

  /// <returns>Returns a new Primary Key value of DESPATCHBAG
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<DESPATCHBAG> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DESPATCHBAG> despatchbags,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in despatchbags) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < despatchbags.length; i++) {
        if (despatchbags[i].SNo == null) {
          despatchbags[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDESPATCHBAG.rawInsert(
          'INSERT OR REPLACE INTO DESPATCHBAG (SNo, SCHEDULE, SCHEDULED_TIME, MAILLIST_TO_OFFICE, BAGNUMBER, FROM_OFFICE, TO_OFFICE, CLOSING_DATE, REMARKS, IS_COMMUNICATED, IS_RCVD)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            SCHEDULE,
            SCHEDULED_TIME,
            MAILLIST_TO_OFFICE,
            BAGNUMBER,
            FROM_OFFICE,
            TO_OFFICE,
            CLOSING_DATE,
            REMARKS,
            IS_COMMUNICATED,
            IS_RCVD
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DESPATCHBAG SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DESPATCHBAG SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DESPATCHBAG Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDESPATCHBAG.rawInsert(
          'INSERT OR IGNORE INTO DESPATCHBAG (SNo, SCHEDULE, SCHEDULED_TIME, MAILLIST_TO_OFFICE, BAGNUMBER, FROM_OFFICE, TO_OFFICE, CLOSING_DATE, REMARKS, IS_COMMUNICATED, IS_RCVD)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            SCHEDULE,
            SCHEDULED_TIME,
            MAILLIST_TO_OFFICE,
            BAGNUMBER,
            FROM_OFFICE,
            TO_OFFICE,
            CLOSING_DATE,
            REMARKS,
            IS_COMMUNICATED,
            IS_RCVD
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DESPATCHBAG SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DESPATCHBAG SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DESPATCHBAG Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<DESPATCHBAG>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<DESPATCHBAG> despatchbags,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnDESPATCHBAG.rawInsertAll(
        'INSERT OR REPLACE INTO DESPATCHBAG (SNo, SCHEDULE, SCHEDULED_TIME, MAILLIST_TO_OFFICE, BAGNUMBER, FROM_OFFICE, TO_OFFICE, CLOSING_DATE, REMARKS, IS_COMMUNICATED, IS_RCVD)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        despatchbags,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes DESPATCHBAG

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete DESPATCHBAG invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDESPATCHBAG
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnDESPATCHBAG.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DESPATCHBAG] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DESPATCHBAGFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DESPATCHBAGFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DESPATCHBAGFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DESPATCHBAGFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion despatchbag

// region DESPATCHBAGField
class DESPATCHBAGField extends FilterBase {
  DESPATCHBAGField(DESPATCHBAGFilterBuilder despatchbagFB)
      : super(despatchbagFB);

  @override
  DESPATCHBAGFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder isNull() {
    return super.isNull() as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DESPATCHBAGFilterBuilder;
  }

  @override
  DESPATCHBAGField get not {
    return super.not as DESPATCHBAGField;
  }
}
// endregion DESPATCHBAGField

// region DESPATCHBAGFilterBuilder
class DESPATCHBAGFilterBuilder extends ConjunctionBase {
  DESPATCHBAGFilterBuilder(DESPATCHBAG obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDESPATCHBAG = obj._mnDESPATCHBAG;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DESPATCHBAGManager? _mnDESPATCHBAG;

  /// put the sql keyword 'AND'
  @override
  DESPATCHBAGFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DESPATCHBAGFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DESPATCHBAGFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DESPATCHBAGFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DESPATCHBAGFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DESPATCHBAGFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DESPATCHBAGFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DESPATCHBAGFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DESPATCHBAGFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DESPATCHBAGFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DESPATCHBAGFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DESPATCHBAGField _setField(
      DESPATCHBAGField? field, String colName, DbType dbtype) {
    return DESPATCHBAGField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DESPATCHBAGField? _SNo;
  DESPATCHBAGField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  DESPATCHBAGField? _SCHEDULE;
  DESPATCHBAGField get SCHEDULE {
    return _SCHEDULE = _setField(_SCHEDULE, 'SCHEDULE', DbType.text);
  }

  DESPATCHBAGField? _SCHEDULED_TIME;
  DESPATCHBAGField get SCHEDULED_TIME {
    return _SCHEDULED_TIME =
        _setField(_SCHEDULED_TIME, 'SCHEDULED_TIME', DbType.text);
  }

  DESPATCHBAGField? _MAILLIST_TO_OFFICE;
  DESPATCHBAGField get MAILLIST_TO_OFFICE {
    return _MAILLIST_TO_OFFICE =
        _setField(_MAILLIST_TO_OFFICE, 'MAILLIST_TO_OFFICE', DbType.text);
  }

  DESPATCHBAGField? _BAGNUMBER;
  DESPATCHBAGField get BAGNUMBER {
    return _BAGNUMBER = _setField(_BAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  DESPATCHBAGField? _FROM_OFFICE;
  DESPATCHBAGField get FROM_OFFICE {
    return _FROM_OFFICE = _setField(_FROM_OFFICE, 'FROM_OFFICE', DbType.text);
  }

  DESPATCHBAGField? _TO_OFFICE;
  DESPATCHBAGField get TO_OFFICE {
    return _TO_OFFICE = _setField(_TO_OFFICE, 'TO_OFFICE', DbType.text);
  }

  DESPATCHBAGField? _CLOSING_DATE;
  DESPATCHBAGField get CLOSING_DATE {
    return _CLOSING_DATE =
        _setField(_CLOSING_DATE, 'CLOSING_DATE', DbType.text);
  }

  DESPATCHBAGField? _REMARKS;
  DESPATCHBAGField get REMARKS {
    return _REMARKS = _setField(_REMARKS, 'REMARKS', DbType.text);
  }

  DESPATCHBAGField? _IS_COMMUNICATED;
  DESPATCHBAGField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  DESPATCHBAGField? _IS_RCVD;
  DESPATCHBAGField get IS_RCVD {
    return _IS_RCVD = _setField(_IS_RCVD, 'IS_RCVD', DbType.text);
  }

  /// Deletes List<DESPATCHBAG> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDESPATCHBAG!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDESPATCHBAG!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from DESPATCHBAG ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDESPATCHBAG!.updateBatch(qparams, values);
  }

  /// This method always returns [DESPATCHBAG] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DESPATCHBAG?
  @override
  Future<DESPATCHBAG?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDESPATCHBAG!.toList(qparams);
    final data = await objFuture;
    DESPATCHBAG? obj;
    if (data.isNotEmpty) {
      obj = DESPATCHBAG.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DESPATCHBAG]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DESPATCHBAG?
  @override
  Future<DESPATCHBAG> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DESPATCHBAG();
  }

  /// This method returns int. [DESPATCHBAG]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? despatchbagCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final despatchbagsFuture = await _mnDESPATCHBAG!.toList(qparams);
    final int count = despatchbagsFuture[0]['CNT'] as int;
    if (despatchbagCount != null) {
      despatchbagCount(count);
    }
    return count;
  }

  /// This method returns List<DESPATCHBAG> [DESPATCHBAG]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DESPATCHBAG>
  @override
  Future<List<DESPATCHBAG>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DESPATCHBAG> despatchbagsData = await DESPATCHBAG.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return despatchbagsData;
  }

  /// This method returns Json String [DESPATCHBAG]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DESPATCHBAG]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DESPATCHBAG]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDESPATCHBAG!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DESPATCHBAG]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM DESPATCHBAG WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnDESPATCHBAG!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DESPATCHBAG]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDESPATCHBAG!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DESPATCHBAG.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDESPATCHBAG!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DESPATCHBAGFilterBuilder

// region DESPATCHBAGFields
class DESPATCHBAGFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fSCHEDULE;
  static TableField get SCHEDULE {
    return _fSCHEDULE =
        _fSCHEDULE ?? SqlSyntax.setField(_fSCHEDULE, 'SCHEDULE', DbType.text);
  }

  static TableField? _fSCHEDULED_TIME;
  static TableField get SCHEDULED_TIME {
    return _fSCHEDULED_TIME = _fSCHEDULED_TIME ??
        SqlSyntax.setField(_fSCHEDULED_TIME, 'SCHEDULED_TIME', DbType.text);
  }

  static TableField? _fMAILLIST_TO_OFFICE;
  static TableField get MAILLIST_TO_OFFICE {
    return _fMAILLIST_TO_OFFICE = _fMAILLIST_TO_OFFICE ??
        SqlSyntax.setField(
            _fMAILLIST_TO_OFFICE, 'MAILLIST_TO_OFFICE', DbType.text);
  }

  static TableField? _fBAGNUMBER;
  static TableField get BAGNUMBER {
    return _fBAGNUMBER = _fBAGNUMBER ??
        SqlSyntax.setField(_fBAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  static TableField? _fFROM_OFFICE;
  static TableField get FROM_OFFICE {
    return _fFROM_OFFICE = _fFROM_OFFICE ??
        SqlSyntax.setField(_fFROM_OFFICE, 'FROM_OFFICE', DbType.text);
  }

  static TableField? _fTO_OFFICE;
  static TableField get TO_OFFICE {
    return _fTO_OFFICE = _fTO_OFFICE ??
        SqlSyntax.setField(_fTO_OFFICE, 'TO_OFFICE', DbType.text);
  }

  static TableField? _fCLOSING_DATE;
  static TableField get CLOSING_DATE {
    return _fCLOSING_DATE = _fCLOSING_DATE ??
        SqlSyntax.setField(_fCLOSING_DATE, 'CLOSING_DATE', DbType.text);
  }

  static TableField? _fREMARKS;
  static TableField get REMARKS {
    return _fREMARKS =
        _fREMARKS ?? SqlSyntax.setField(_fREMARKS, 'REMARKS', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fIS_RCVD;
  static TableField get IS_RCVD {
    return _fIS_RCVD =
        _fIS_RCVD ?? SqlSyntax.setField(_fIS_RCVD, 'IS_RCVD', DbType.text);
  }
}
// endregion DESPATCHBAGFields

//region DESPATCHBAGManager
class DESPATCHBAGManager extends SqfEntityProvider {
  DESPATCHBAGManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'DESPATCHBAG';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion DESPATCHBAGManager
// region BOSLIP_STAMP1
class BOSLIP_STAMP1 extends TableBase {
  BOSLIP_STAMP1(
      {this.SNo,
      this.BO_SLIP_NO,
      this.ZMOFACILITYID,
      this.MATNR,
      this.ZINV_PARTICULAR,
      this.MENGE_D,
      this.ZCREATEDT,
      this.ZMOCREATEDBY,
      this.IS_RCVD,
      this.IS_COMMUNICATED}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BOSLIP_STAMP1.withFields(
      this.BO_SLIP_NO,
      this.ZMOFACILITYID,
      this.MATNR,
      this.ZINV_PARTICULAR,
      this.MENGE_D,
      this.ZCREATEDT,
      this.ZMOCREATEDBY,
      this.IS_RCVD,
      this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  BOSLIP_STAMP1.withId(
      this.SNo,
      this.BO_SLIP_NO,
      this.ZMOFACILITYID,
      this.MATNR,
      this.ZINV_PARTICULAR,
      this.MENGE_D,
      this.ZCREATEDT,
      this.ZMOCREATEDBY,
      this.IS_RCVD,
      this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BOSLIP_STAMP1.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['BO_SLIP_NO'] != null) {
      BO_SLIP_NO = o['BO_SLIP_NO'].toString();
    }
    if (o['ZMOFACILITYID'] != null) {
      ZMOFACILITYID = o['ZMOFACILITYID'].toString();
    }
    if (o['MATNR'] != null) {
      MATNR = o['MATNR'].toString();
    }
    if (o['ZINV_PARTICULAR'] != null) {
      ZINV_PARTICULAR = o['ZINV_PARTICULAR'].toString();
    }
    if (o['MENGE_D'] != null) {
      MENGE_D = o['MENGE_D'].toString();
    }
    if (o['ZCREATEDT'] != null) {
      ZCREATEDT = o['ZCREATEDT'].toString();
    }
    if (o['ZMOCREATEDBY'] != null) {
      ZMOCREATEDBY = o['ZMOCREATEDBY'].toString();
    }
    if (o['IS_RCVD'] != null) {
      IS_RCVD = o['IS_RCVD'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
  }
  // FIELDS (BOSLIP_STAMP1)
  int? SNo;
  String? BO_SLIP_NO;
  String? ZMOFACILITYID;
  String? MATNR;
  String? ZINV_PARTICULAR;
  String? MENGE_D;
  String? ZCREATEDT;
  String? ZMOCREATEDBY;
  String? IS_RCVD;
  String? IS_COMMUNICATED;

  // end FIELDS (BOSLIP_STAMP1)

  static const bool _softDeleteActivated = false;
  BOSLIP_STAMP1Manager? __mnBOSLIP_STAMP1;

  BOSLIP_STAMP1Manager get _mnBOSLIP_STAMP1 {
    return __mnBOSLIP_STAMP1 = __mnBOSLIP_STAMP1 ?? BOSLIP_STAMP1Manager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (ZMOFACILITYID != null || !forView) {
      map['ZMOFACILITYID'] = ZMOFACILITYID;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (ZINV_PARTICULAR != null || !forView) {
      map['ZINV_PARTICULAR'] = ZINV_PARTICULAR;
    }
    if (MENGE_D != null || !forView) {
      map['MENGE_D'] = MENGE_D;
    }
    if (ZCREATEDT != null || !forView) {
      map['ZCREATEDT'] = ZCREATEDT;
    }
    if (ZMOCREATEDBY != null || !forView) {
      map['ZMOCREATEDBY'] = ZMOCREATEDBY;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (ZMOFACILITYID != null || !forView) {
      map['ZMOFACILITYID'] = ZMOFACILITYID;
    }
    if (MATNR != null || !forView) {
      map['MATNR'] = MATNR;
    }
    if (ZINV_PARTICULAR != null || !forView) {
      map['ZINV_PARTICULAR'] = ZINV_PARTICULAR;
    }
    if (MENGE_D != null || !forView) {
      map['MENGE_D'] = MENGE_D;
    }
    if (ZCREATEDT != null || !forView) {
      map['ZCREATEDT'] = ZCREATEDT;
    }
    if (ZMOCREATEDBY != null || !forView) {
      map['ZMOCREATEDBY'] = ZMOCREATEDBY;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  /// This method returns Json String [BOSLIP_STAMP1]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BOSLIP_STAMP1]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BO_SLIP_NO,
      ZMOFACILITYID,
      MATNR,
      ZINV_PARTICULAR,
      MENGE_D,
      ZCREATEDT,
      ZMOCREATEDBY,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      BO_SLIP_NO,
      ZMOFACILITYID,
      MATNR,
      ZINV_PARTICULAR,
      MENGE_D,
      ZCREATEDT,
      ZMOCREATEDBY,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  static Future<List<BOSLIP_STAMP1>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_STAMP1.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BOSLIP_STAMP1>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BOSLIP_STAMP1>[];
    try {
      objList = list
          .map((boslip_stamp1) =>
              BOSLIP_STAMP1.fromMap(boslip_stamp1 as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_STAMP1.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BOSLIP_STAMP1>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BOSLIP_STAMP1> objList = <BOSLIP_STAMP1>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BOSLIP_STAMP1.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BOSLIP_STAMP1 by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BOSLIP_STAMP1] if exist, otherwise returns null
  Future<BOSLIP_STAMP1?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    BOSLIP_STAMP1? obj;
    final data = await _mnBOSLIP_STAMP1.getById([SNo]);
    if (data.length != 0) {
      obj = BOSLIP_STAMP1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BOSLIP_STAMP1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_STAMP1.insert(this, ignoreBatch);
    } else {
      await _mnBOSLIP_STAMP1.update(this);
    }

    return SNo;
  }

  /// Saves the (BOSLIP_STAMP1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_STAMP1.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBOSLIP_STAMP1.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs BOSLIP_STAMP1. Returns a new Primary Key value of BOSLIP_STAMP1

  /// <returns>Returns a new Primary Key value of BOSLIP_STAMP1
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BOSLIP_STAMP1> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BOSLIP_STAMP1> boslip_stamp1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in boslip_stamp1s) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < boslip_stamp1s.length; i++) {
        if (boslip_stamp1s[i].SNo == null) {
          boslip_stamp1s[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_STAMP1.rawInsert(
          'INSERT OR REPLACE INTO BOSLIP_STAMP1 (SNo, BO_SLIP_NO, ZMOFACILITYID, MATNR, ZINV_PARTICULAR, MENGE_D, ZCREATEDT, ZMOCREATEDBY, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            ZMOFACILITYID,
            MATNR,
            ZINV_PARTICULAR,
            MENGE_D,
            ZCREATEDT,
            ZMOCREATEDBY,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_STAMP1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_STAMP1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_STAMP1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_STAMP1.rawInsert(
          'INSERT OR IGNORE INTO BOSLIP_STAMP1 (SNo, BO_SLIP_NO, ZMOFACILITYID, MATNR, ZINV_PARTICULAR, MENGE_D, ZCREATEDT, ZMOCREATEDBY, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            ZMOFACILITYID,
            MATNR,
            ZINV_PARTICULAR,
            MENGE_D,
            ZCREATEDT,
            ZMOCREATEDBY,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_STAMP1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_STAMP1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_STAMP1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BOSLIP_STAMP1>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BOSLIP_STAMP1> boslip_stamp1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBOSLIP_STAMP1.rawInsertAll(
        'INSERT OR REPLACE INTO BOSLIP_STAMP1 (SNo, BO_SLIP_NO, ZMOFACILITYID, MATNR, ZINV_PARTICULAR, MENGE_D, ZCREATEDT, ZMOCREATEDBY, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        boslip_stamp1s,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BOSLIP_STAMP1

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BOSLIP_STAMP1 invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBOSLIP_STAMP1
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnBOSLIP_STAMP1.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BOSLIP_STAMP1] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BOSLIP_STAMP1FilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_STAMP1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BOSLIP_STAMP1FilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_STAMP1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion boslip_stamp1

// region BOSLIP_STAMP1Field
class BOSLIP_STAMP1Field extends FilterBase {
  BOSLIP_STAMP1Field(BOSLIP_STAMP1FilterBuilder boslip_stamp1FB)
      : super(boslip_stamp1FB);

  @override
  BOSLIP_STAMP1FilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder isNull() {
    return super.isNull() as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1FilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BOSLIP_STAMP1FilterBuilder;
  }

  @override
  BOSLIP_STAMP1Field get not {
    return super.not as BOSLIP_STAMP1Field;
  }
}
// endregion BOSLIP_STAMP1Field

// region BOSLIP_STAMP1FilterBuilder
class BOSLIP_STAMP1FilterBuilder extends ConjunctionBase {
  BOSLIP_STAMP1FilterBuilder(BOSLIP_STAMP1 obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBOSLIP_STAMP1 = obj._mnBOSLIP_STAMP1;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BOSLIP_STAMP1Manager? _mnBOSLIP_STAMP1;

  /// put the sql keyword 'AND'
  @override
  BOSLIP_STAMP1FilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BOSLIP_STAMP1FilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BOSLIP_STAMP1FilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BOSLIP_STAMP1FilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BOSLIP_STAMP1FilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BOSLIP_STAMP1FilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BOSLIP_STAMP1FilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_STAMP1FilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_STAMP1FilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_STAMP1FilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_STAMP1FilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BOSLIP_STAMP1Field _setField(
      BOSLIP_STAMP1Field? field, String colName, DbType dbtype) {
    return BOSLIP_STAMP1Field(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BOSLIP_STAMP1Field? _SNo;
  BOSLIP_STAMP1Field get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  BOSLIP_STAMP1Field? _BO_SLIP_NO;
  BOSLIP_STAMP1Field get BO_SLIP_NO {
    return _BO_SLIP_NO = _setField(_BO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  BOSLIP_STAMP1Field? _ZMOFACILITYID;
  BOSLIP_STAMP1Field get ZMOFACILITYID {
    return _ZMOFACILITYID =
        _setField(_ZMOFACILITYID, 'ZMOFACILITYID', DbType.text);
  }

  BOSLIP_STAMP1Field? _MATNR;
  BOSLIP_STAMP1Field get MATNR {
    return _MATNR = _setField(_MATNR, 'MATNR', DbType.text);
  }

  BOSLIP_STAMP1Field? _ZINV_PARTICULAR;
  BOSLIP_STAMP1Field get ZINV_PARTICULAR {
    return _ZINV_PARTICULAR =
        _setField(_ZINV_PARTICULAR, 'ZINV_PARTICULAR', DbType.text);
  }

  BOSLIP_STAMP1Field? _MENGE_D;
  BOSLIP_STAMP1Field get MENGE_D {
    return _MENGE_D = _setField(_MENGE_D, 'MENGE_D', DbType.text);
  }

  BOSLIP_STAMP1Field? _ZCREATEDT;
  BOSLIP_STAMP1Field get ZCREATEDT {
    return _ZCREATEDT = _setField(_ZCREATEDT, 'ZCREATEDT', DbType.text);
  }

  BOSLIP_STAMP1Field? _ZMOCREATEDBY;
  BOSLIP_STAMP1Field get ZMOCREATEDBY {
    return _ZMOCREATEDBY =
        _setField(_ZMOCREATEDBY, 'ZMOCREATEDBY', DbType.text);
  }

  BOSLIP_STAMP1Field? _IS_RCVD;
  BOSLIP_STAMP1Field get IS_RCVD {
    return _IS_RCVD = _setField(_IS_RCVD, 'IS_RCVD', DbType.text);
  }

  BOSLIP_STAMP1Field? _IS_COMMUNICATED;
  BOSLIP_STAMP1Field get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  /// Deletes List<BOSLIP_STAMP1> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBOSLIP_STAMP1!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBOSLIP_STAMP1!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from BOSLIP_STAMP1 ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBOSLIP_STAMP1!.updateBatch(qparams, values);
  }

  /// This method always returns [BOSLIP_STAMP1] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_STAMP1?
  @override
  Future<BOSLIP_STAMP1?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBOSLIP_STAMP1!.toList(qparams);
    final data = await objFuture;
    BOSLIP_STAMP1? obj;
    if (data.isNotEmpty) {
      obj = BOSLIP_STAMP1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BOSLIP_STAMP1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_STAMP1?
  @override
  Future<BOSLIP_STAMP1> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BOSLIP_STAMP1();
  }

  /// This method returns int. [BOSLIP_STAMP1]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? boslip_stamp1Count]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final boslip_stamp1sFuture = await _mnBOSLIP_STAMP1!.toList(qparams);
    final int count = boslip_stamp1sFuture[0]['CNT'] as int;
    if (boslip_stamp1Count != null) {
      boslip_stamp1Count(count);
    }
    return count;
  }

  /// This method returns List<BOSLIP_STAMP1> [BOSLIP_STAMP1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BOSLIP_STAMP1>
  @override
  Future<List<BOSLIP_STAMP1>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BOSLIP_STAMP1> boslip_stamp1sData =
        await BOSLIP_STAMP1.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return boslip_stamp1sData;
  }

  /// This method returns Json String [BOSLIP_STAMP1]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BOSLIP_STAMP1]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BOSLIP_STAMP1]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBOSLIP_STAMP1!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BOSLIP_STAMP1]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM BOSLIP_STAMP1 WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnBOSLIP_STAMP1!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BOSLIP_STAMP1]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBOSLIP_STAMP1!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BOSLIP_STAMP1.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBOSLIP_STAMP1!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BOSLIP_STAMP1FilterBuilder

// region BOSLIP_STAMP1Fields
class BOSLIP_STAMP1Fields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fBO_SLIP_NO;
  static TableField get BO_SLIP_NO {
    return _fBO_SLIP_NO = _fBO_SLIP_NO ??
        SqlSyntax.setField(_fBO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  static TableField? _fZMOFACILITYID;
  static TableField get ZMOFACILITYID {
    return _fZMOFACILITYID = _fZMOFACILITYID ??
        SqlSyntax.setField(_fZMOFACILITYID, 'ZMOFACILITYID', DbType.text);
  }

  static TableField? _fMATNR;
  static TableField get MATNR {
    return _fMATNR =
        _fMATNR ?? SqlSyntax.setField(_fMATNR, 'MATNR', DbType.text);
  }

  static TableField? _fZINV_PARTICULAR;
  static TableField get ZINV_PARTICULAR {
    return _fZINV_PARTICULAR = _fZINV_PARTICULAR ??
        SqlSyntax.setField(_fZINV_PARTICULAR, 'ZINV_PARTICULAR', DbType.text);
  }

  static TableField? _fMENGE_D;
  static TableField get MENGE_D {
    return _fMENGE_D =
        _fMENGE_D ?? SqlSyntax.setField(_fMENGE_D, 'MENGE_D', DbType.text);
  }

  static TableField? _fZCREATEDT;
  static TableField get ZCREATEDT {
    return _fZCREATEDT = _fZCREATEDT ??
        SqlSyntax.setField(_fZCREATEDT, 'ZCREATEDT', DbType.text);
  }

  static TableField? _fZMOCREATEDBY;
  static TableField get ZMOCREATEDBY {
    return _fZMOCREATEDBY = _fZMOCREATEDBY ??
        SqlSyntax.setField(_fZMOCREATEDBY, 'ZMOCREATEDBY', DbType.text);
  }

  static TableField? _fIS_RCVD;
  static TableField get IS_RCVD {
    return _fIS_RCVD =
        _fIS_RCVD ?? SqlSyntax.setField(_fIS_RCVD, 'IS_RCVD', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }
}
// endregion BOSLIP_STAMP1Fields

//region BOSLIP_STAMP1Manager
class BOSLIP_STAMP1Manager extends SqfEntityProvider {
  BOSLIP_STAMP1Manager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'BOSLIP_STAMP1';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion BOSLIP_STAMP1Manager
// region BOSLIP_CASH1
class BOSLIP_CASH1 extends TableBase {
  BOSLIP_CASH1(
      {this.SNo,
      this.BO_SLIP_NO,
      this.DATE_OF_SENT,
      this.SO_PROFIT_CENTER,
      this.BO_PROFIT_CENTER,
      this.AMOUNT,
      this.WEIGHT_OF_CASH_BAG,
      this.CHEQUE_NO,
      this.CHEQUE_AMOUNT,
      this.CASHORCHEQUE,
      this.LESS_CASH,
      this.OVER_CASH,
      this.ACTUAL_CASH,
      this.IS_RCVD,
      this.IS_COMMUNICATED}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BOSLIP_CASH1.withFields(
      this.BO_SLIP_NO,
      this.DATE_OF_SENT,
      this.SO_PROFIT_CENTER,
      this.BO_PROFIT_CENTER,
      this.AMOUNT,
      this.WEIGHT_OF_CASH_BAG,
      this.CHEQUE_NO,
      this.CHEQUE_AMOUNT,
      this.CASHORCHEQUE,
      this.LESS_CASH,
      this.OVER_CASH,
      this.ACTUAL_CASH,
      this.IS_RCVD,
      this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  BOSLIP_CASH1.withId(
      this.SNo,
      this.BO_SLIP_NO,
      this.DATE_OF_SENT,
      this.SO_PROFIT_CENTER,
      this.BO_PROFIT_CENTER,
      this.AMOUNT,
      this.WEIGHT_OF_CASH_BAG,
      this.CHEQUE_NO,
      this.CHEQUE_AMOUNT,
      this.CASHORCHEQUE,
      this.LESS_CASH,
      this.OVER_CASH,
      this.ACTUAL_CASH,
      this.IS_RCVD,
      this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BOSLIP_CASH1.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['BO_SLIP_NO'] != null) {
      BO_SLIP_NO = o['BO_SLIP_NO'].toString();
    }
    if (o['DATE_OF_SENT'] != null) {
      DATE_OF_SENT = o['DATE_OF_SENT'].toString();
    }
    if (o['SO_PROFIT_CENTER'] != null) {
      SO_PROFIT_CENTER = o['SO_PROFIT_CENTER'].toString();
    }
    if (o['BO_PROFIT_CENTER'] != null) {
      BO_PROFIT_CENTER = o['BO_PROFIT_CENTER'].toString();
    }
    if (o['AMOUNT'] != null) {
      AMOUNT = o['AMOUNT'].toString();
    }
    if (o['WEIGHT_OF_CASH_BAG'] != null) {
      WEIGHT_OF_CASH_BAG = o['WEIGHT_OF_CASH_BAG'].toString();
    }
    if (o['CHEQUE_NO'] != null) {
      CHEQUE_NO = o['CHEQUE_NO'].toString();
    }
    if (o['CHEQUE_AMOUNT'] != null) {
      CHEQUE_AMOUNT = o['CHEQUE_AMOUNT'].toString();
    }
    if (o['CASHORCHEQUE'] != null) {
      CASHORCHEQUE = o['CASHORCHEQUE'].toString();
    }
    if (o['LESS_CASH'] != null) {
      LESS_CASH = o['LESS_CASH'].toString();
    }
    if (o['OVER_CASH'] != null) {
      OVER_CASH = o['OVER_CASH'].toString();
    }
    if (o['ACTUAL_CASH'] != null) {
      ACTUAL_CASH = o['ACTUAL_CASH'].toString();
    }
    if (o['IS_RCVD'] != null) {
      IS_RCVD = o['IS_RCVD'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
  }
  // FIELDS (BOSLIP_CASH1)
  int? SNo;
  String? BO_SLIP_NO;
  String? DATE_OF_SENT;
  String? SO_PROFIT_CENTER;
  String? BO_PROFIT_CENTER;
  String? AMOUNT;
  String? WEIGHT_OF_CASH_BAG;
  String? CHEQUE_NO;
  String? CHEQUE_AMOUNT;
  String? CASHORCHEQUE;
  String? LESS_CASH;
  String? OVER_CASH;
  String? ACTUAL_CASH;
  String? IS_RCVD;
  String? IS_COMMUNICATED;

  // end FIELDS (BOSLIP_CASH1)

  static const bool _softDeleteActivated = false;
  BOSLIP_CASH1Manager? __mnBOSLIP_CASH1;

  BOSLIP_CASH1Manager get _mnBOSLIP_CASH1 {
    return __mnBOSLIP_CASH1 = __mnBOSLIP_CASH1 ?? BOSLIP_CASH1Manager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (DATE_OF_SENT != null || !forView) {
      map['DATE_OF_SENT'] = DATE_OF_SENT;
    }
    if (SO_PROFIT_CENTER != null || !forView) {
      map['SO_PROFIT_CENTER'] = SO_PROFIT_CENTER;
    }
    if (BO_PROFIT_CENTER != null || !forView) {
      map['BO_PROFIT_CENTER'] = BO_PROFIT_CENTER;
    }
    if (AMOUNT != null || !forView) {
      map['AMOUNT'] = AMOUNT;
    }
    if (WEIGHT_OF_CASH_BAG != null || !forView) {
      map['WEIGHT_OF_CASH_BAG'] = WEIGHT_OF_CASH_BAG;
    }
    if (CHEQUE_NO != null || !forView) {
      map['CHEQUE_NO'] = CHEQUE_NO;
    }
    if (CHEQUE_AMOUNT != null || !forView) {
      map['CHEQUE_AMOUNT'] = CHEQUE_AMOUNT;
    }
    if (CASHORCHEQUE != null || !forView) {
      map['CASHORCHEQUE'] = CASHORCHEQUE;
    }
    if (LESS_CASH != null || !forView) {
      map['LESS_CASH'] = LESS_CASH;
    }
    if (OVER_CASH != null || !forView) {
      map['OVER_CASH'] = OVER_CASH;
    }
    if (ACTUAL_CASH != null || !forView) {
      map['ACTUAL_CASH'] = ACTUAL_CASH;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (DATE_OF_SENT != null || !forView) {
      map['DATE_OF_SENT'] = DATE_OF_SENT;
    }
    if (SO_PROFIT_CENTER != null || !forView) {
      map['SO_PROFIT_CENTER'] = SO_PROFIT_CENTER;
    }
    if (BO_PROFIT_CENTER != null || !forView) {
      map['BO_PROFIT_CENTER'] = BO_PROFIT_CENTER;
    }
    if (AMOUNT != null || !forView) {
      map['AMOUNT'] = AMOUNT;
    }
    if (WEIGHT_OF_CASH_BAG != null || !forView) {
      map['WEIGHT_OF_CASH_BAG'] = WEIGHT_OF_CASH_BAG;
    }
    if (CHEQUE_NO != null || !forView) {
      map['CHEQUE_NO'] = CHEQUE_NO;
    }
    if (CHEQUE_AMOUNT != null || !forView) {
      map['CHEQUE_AMOUNT'] = CHEQUE_AMOUNT;
    }
    if (CASHORCHEQUE != null || !forView) {
      map['CASHORCHEQUE'] = CASHORCHEQUE;
    }
    if (LESS_CASH != null || !forView) {
      map['LESS_CASH'] = LESS_CASH;
    }
    if (OVER_CASH != null || !forView) {
      map['OVER_CASH'] = OVER_CASH;
    }
    if (ACTUAL_CASH != null || !forView) {
      map['ACTUAL_CASH'] = ACTUAL_CASH;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  /// This method returns Json String [BOSLIP_CASH1]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BOSLIP_CASH1]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BO_SLIP_NO,
      DATE_OF_SENT,
      SO_PROFIT_CENTER,
      BO_PROFIT_CENTER,
      AMOUNT,
      WEIGHT_OF_CASH_BAG,
      CHEQUE_NO,
      CHEQUE_AMOUNT,
      CASHORCHEQUE,
      LESS_CASH,
      OVER_CASH,
      ACTUAL_CASH,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      BO_SLIP_NO,
      DATE_OF_SENT,
      SO_PROFIT_CENTER,
      BO_PROFIT_CENTER,
      AMOUNT,
      WEIGHT_OF_CASH_BAG,
      CHEQUE_NO,
      CHEQUE_AMOUNT,
      CASHORCHEQUE,
      LESS_CASH,
      OVER_CASH,
      ACTUAL_CASH,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  static Future<List<BOSLIP_CASH1>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_CASH1.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BOSLIP_CASH1>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BOSLIP_CASH1>[];
    try {
      objList = list
          .map((boslip_cash1) =>
              BOSLIP_CASH1.fromMap(boslip_cash1 as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_CASH1.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BOSLIP_CASH1>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BOSLIP_CASH1> objList = <BOSLIP_CASH1>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BOSLIP_CASH1.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BOSLIP_CASH1 by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BOSLIP_CASH1] if exist, otherwise returns null
  Future<BOSLIP_CASH1?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    BOSLIP_CASH1? obj;
    final data = await _mnBOSLIP_CASH1.getById([SNo]);
    if (data.length != 0) {
      obj = BOSLIP_CASH1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BOSLIP_CASH1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_CASH1.insert(this, ignoreBatch);
    } else {
      await _mnBOSLIP_CASH1.update(this);
    }

    return SNo;
  }

  /// Saves the (BOSLIP_CASH1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_CASH1.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBOSLIP_CASH1.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs BOSLIP_CASH1. Returns a new Primary Key value of BOSLIP_CASH1

  /// <returns>Returns a new Primary Key value of BOSLIP_CASH1
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BOSLIP_CASH1> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BOSLIP_CASH1> boslip_cash1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in boslip_cash1s) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < boslip_cash1s.length; i++) {
        if (boslip_cash1s[i].SNo == null) {
          boslip_cash1s[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_CASH1.rawInsert(
          'INSERT OR REPLACE INTO BOSLIP_CASH1 (SNo, BO_SLIP_NO, DATE_OF_SENT, SO_PROFIT_CENTER, BO_PROFIT_CENTER, AMOUNT, WEIGHT_OF_CASH_BAG, CHEQUE_NO, CHEQUE_AMOUNT, CASHORCHEQUE, LESS_CASH, OVER_CASH, ACTUAL_CASH, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            DATE_OF_SENT,
            SO_PROFIT_CENTER,
            BO_PROFIT_CENTER,
            AMOUNT,
            WEIGHT_OF_CASH_BAG,
            CHEQUE_NO,
            CHEQUE_AMOUNT,
            CASHORCHEQUE,
            LESS_CASH,
            OVER_CASH,
            ACTUAL_CASH,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_CASH1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_CASH1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_CASH1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_CASH1.rawInsert(
          'INSERT OR IGNORE INTO BOSLIP_CASH1 (SNo, BO_SLIP_NO, DATE_OF_SENT, SO_PROFIT_CENTER, BO_PROFIT_CENTER, AMOUNT, WEIGHT_OF_CASH_BAG, CHEQUE_NO, CHEQUE_AMOUNT, CASHORCHEQUE, LESS_CASH, OVER_CASH, ACTUAL_CASH, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            DATE_OF_SENT,
            SO_PROFIT_CENTER,
            BO_PROFIT_CENTER,
            AMOUNT,
            WEIGHT_OF_CASH_BAG,
            CHEQUE_NO,
            CHEQUE_AMOUNT,
            CASHORCHEQUE,
            LESS_CASH,
            OVER_CASH,
            ACTUAL_CASH,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_CASH1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_CASH1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_CASH1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BOSLIP_CASH1>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BOSLIP_CASH1> boslip_cash1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBOSLIP_CASH1.rawInsertAll(
        'INSERT OR REPLACE INTO BOSLIP_CASH1 (SNo, BO_SLIP_NO, DATE_OF_SENT, SO_PROFIT_CENTER, BO_PROFIT_CENTER, AMOUNT, WEIGHT_OF_CASH_BAG, CHEQUE_NO, CHEQUE_AMOUNT, CASHORCHEQUE, LESS_CASH, OVER_CASH, ACTUAL_CASH, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        boslip_cash1s,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BOSLIP_CASH1

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BOSLIP_CASH1 invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBOSLIP_CASH1
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnBOSLIP_CASH1.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BOSLIP_CASH1] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BOSLIP_CASH1FilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_CASH1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BOSLIP_CASH1FilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_CASH1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion boslip_cash1

// region BOSLIP_CASH1Field
class BOSLIP_CASH1Field extends FilterBase {
  BOSLIP_CASH1Field(BOSLIP_CASH1FilterBuilder boslip_cash1FB)
      : super(boslip_cash1FB);

  @override
  BOSLIP_CASH1FilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder isNull() {
    return super.isNull() as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1FilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BOSLIP_CASH1FilterBuilder;
  }

  @override
  BOSLIP_CASH1Field get not {
    return super.not as BOSLIP_CASH1Field;
  }
}
// endregion BOSLIP_CASH1Field

// region BOSLIP_CASH1FilterBuilder
class BOSLIP_CASH1FilterBuilder extends ConjunctionBase {
  BOSLIP_CASH1FilterBuilder(BOSLIP_CASH1 obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBOSLIP_CASH1 = obj._mnBOSLIP_CASH1;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BOSLIP_CASH1Manager? _mnBOSLIP_CASH1;

  /// put the sql keyword 'AND'
  @override
  BOSLIP_CASH1FilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BOSLIP_CASH1FilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BOSLIP_CASH1FilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BOSLIP_CASH1FilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BOSLIP_CASH1FilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BOSLIP_CASH1FilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BOSLIP_CASH1FilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_CASH1FilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_CASH1FilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_CASH1FilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_CASH1FilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BOSLIP_CASH1Field _setField(
      BOSLIP_CASH1Field? field, String colName, DbType dbtype) {
    return BOSLIP_CASH1Field(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BOSLIP_CASH1Field? _SNo;
  BOSLIP_CASH1Field get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  BOSLIP_CASH1Field? _BO_SLIP_NO;
  BOSLIP_CASH1Field get BO_SLIP_NO {
    return _BO_SLIP_NO = _setField(_BO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  BOSLIP_CASH1Field? _DATE_OF_SENT;
  BOSLIP_CASH1Field get DATE_OF_SENT {
    return _DATE_OF_SENT =
        _setField(_DATE_OF_SENT, 'DATE_OF_SENT', DbType.text);
  }

  BOSLIP_CASH1Field? _SO_PROFIT_CENTER;
  BOSLIP_CASH1Field get SO_PROFIT_CENTER {
    return _SO_PROFIT_CENTER =
        _setField(_SO_PROFIT_CENTER, 'SO_PROFIT_CENTER', DbType.text);
  }

  BOSLIP_CASH1Field? _BO_PROFIT_CENTER;
  BOSLIP_CASH1Field get BO_PROFIT_CENTER {
    return _BO_PROFIT_CENTER =
        _setField(_BO_PROFIT_CENTER, 'BO_PROFIT_CENTER', DbType.text);
  }

  BOSLIP_CASH1Field? _AMOUNT;
  BOSLIP_CASH1Field get AMOUNT {
    return _AMOUNT = _setField(_AMOUNT, 'AMOUNT', DbType.text);
  }

  BOSLIP_CASH1Field? _WEIGHT_OF_CASH_BAG;
  BOSLIP_CASH1Field get WEIGHT_OF_CASH_BAG {
    return _WEIGHT_OF_CASH_BAG =
        _setField(_WEIGHT_OF_CASH_BAG, 'WEIGHT_OF_CASH_BAG', DbType.text);
  }

  BOSLIP_CASH1Field? _CHEQUE_NO;
  BOSLIP_CASH1Field get CHEQUE_NO {
    return _CHEQUE_NO = _setField(_CHEQUE_NO, 'CHEQUE_NO', DbType.text);
  }

  BOSLIP_CASH1Field? _CHEQUE_AMOUNT;
  BOSLIP_CASH1Field get CHEQUE_AMOUNT {
    return _CHEQUE_AMOUNT =
        _setField(_CHEQUE_AMOUNT, 'CHEQUE_AMOUNT', DbType.text);
  }

  BOSLIP_CASH1Field? _CASHORCHEQUE;
  BOSLIP_CASH1Field get CASHORCHEQUE {
    return _CASHORCHEQUE =
        _setField(_CASHORCHEQUE, 'CASHORCHEQUE', DbType.text);
  }

  BOSLIP_CASH1Field? _LESS_CASH;
  BOSLIP_CASH1Field get LESS_CASH {
    return _LESS_CASH = _setField(_LESS_CASH, 'LESS_CASH', DbType.text);
  }

  BOSLIP_CASH1Field? _OVER_CASH;
  BOSLIP_CASH1Field get OVER_CASH {
    return _OVER_CASH = _setField(_OVER_CASH, 'OVER_CASH', DbType.text);
  }

  BOSLIP_CASH1Field? _ACTUAL_CASH;
  BOSLIP_CASH1Field get ACTUAL_CASH {
    return _ACTUAL_CASH = _setField(_ACTUAL_CASH, 'ACTUAL_CASH', DbType.text);
  }

  BOSLIP_CASH1Field? _IS_RCVD;
  BOSLIP_CASH1Field get IS_RCVD {
    return _IS_RCVD = _setField(_IS_RCVD, 'IS_RCVD', DbType.text);
  }

  BOSLIP_CASH1Field? _IS_COMMUNICATED;
  BOSLIP_CASH1Field get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  /// Deletes List<BOSLIP_CASH1> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBOSLIP_CASH1!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBOSLIP_CASH1!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from BOSLIP_CASH1 ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBOSLIP_CASH1!.updateBatch(qparams, values);
  }

  /// This method always returns [BOSLIP_CASH1] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_CASH1?
  @override
  Future<BOSLIP_CASH1?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBOSLIP_CASH1!.toList(qparams);
    final data = await objFuture;
    BOSLIP_CASH1? obj;
    if (data.isNotEmpty) {
      obj = BOSLIP_CASH1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BOSLIP_CASH1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_CASH1?
  @override
  Future<BOSLIP_CASH1> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BOSLIP_CASH1();
  }

  /// This method returns int. [BOSLIP_CASH1]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? boslip_cash1Count]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final boslip_cash1sFuture = await _mnBOSLIP_CASH1!.toList(qparams);
    final int count = boslip_cash1sFuture[0]['CNT'] as int;
    if (boslip_cash1Count != null) {
      boslip_cash1Count(count);
    }
    return count;
  }

  /// This method returns List<BOSLIP_CASH1> [BOSLIP_CASH1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BOSLIP_CASH1>
  @override
  Future<List<BOSLIP_CASH1>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BOSLIP_CASH1> boslip_cash1sData = await BOSLIP_CASH1.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return boslip_cash1sData;
  }

  /// This method returns Json String [BOSLIP_CASH1]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BOSLIP_CASH1]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BOSLIP_CASH1]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBOSLIP_CASH1!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BOSLIP_CASH1]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM BOSLIP_CASH1 WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnBOSLIP_CASH1!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BOSLIP_CASH1]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBOSLIP_CASH1!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BOSLIP_CASH1.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBOSLIP_CASH1!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BOSLIP_CASH1FilterBuilder

// region BOSLIP_CASH1Fields
class BOSLIP_CASH1Fields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fBO_SLIP_NO;
  static TableField get BO_SLIP_NO {
    return _fBO_SLIP_NO = _fBO_SLIP_NO ??
        SqlSyntax.setField(_fBO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  static TableField? _fDATE_OF_SENT;
  static TableField get DATE_OF_SENT {
    return _fDATE_OF_SENT = _fDATE_OF_SENT ??
        SqlSyntax.setField(_fDATE_OF_SENT, 'DATE_OF_SENT', DbType.text);
  }

  static TableField? _fSO_PROFIT_CENTER;
  static TableField get SO_PROFIT_CENTER {
    return _fSO_PROFIT_CENTER = _fSO_PROFIT_CENTER ??
        SqlSyntax.setField(_fSO_PROFIT_CENTER, 'SO_PROFIT_CENTER', DbType.text);
  }

  static TableField? _fBO_PROFIT_CENTER;
  static TableField get BO_PROFIT_CENTER {
    return _fBO_PROFIT_CENTER = _fBO_PROFIT_CENTER ??
        SqlSyntax.setField(_fBO_PROFIT_CENTER, 'BO_PROFIT_CENTER', DbType.text);
  }

  static TableField? _fAMOUNT;
  static TableField get AMOUNT {
    return _fAMOUNT =
        _fAMOUNT ?? SqlSyntax.setField(_fAMOUNT, 'AMOUNT', DbType.text);
  }

  static TableField? _fWEIGHT_OF_CASH_BAG;
  static TableField get WEIGHT_OF_CASH_BAG {
    return _fWEIGHT_OF_CASH_BAG = _fWEIGHT_OF_CASH_BAG ??
        SqlSyntax.setField(
            _fWEIGHT_OF_CASH_BAG, 'WEIGHT_OF_CASH_BAG', DbType.text);
  }

  static TableField? _fCHEQUE_NO;
  static TableField get CHEQUE_NO {
    return _fCHEQUE_NO = _fCHEQUE_NO ??
        SqlSyntax.setField(_fCHEQUE_NO, 'CHEQUE_NO', DbType.text);
  }

  static TableField? _fCHEQUE_AMOUNT;
  static TableField get CHEQUE_AMOUNT {
    return _fCHEQUE_AMOUNT = _fCHEQUE_AMOUNT ??
        SqlSyntax.setField(_fCHEQUE_AMOUNT, 'CHEQUE_AMOUNT', DbType.text);
  }

  static TableField? _fCASHORCHEQUE;
  static TableField get CASHORCHEQUE {
    return _fCASHORCHEQUE = _fCASHORCHEQUE ??
        SqlSyntax.setField(_fCASHORCHEQUE, 'CASHORCHEQUE', DbType.text);
  }

  static TableField? _fLESS_CASH;
  static TableField get LESS_CASH {
    return _fLESS_CASH = _fLESS_CASH ??
        SqlSyntax.setField(_fLESS_CASH, 'LESS_CASH', DbType.text);
  }

  static TableField? _fOVER_CASH;
  static TableField get OVER_CASH {
    return _fOVER_CASH = _fOVER_CASH ??
        SqlSyntax.setField(_fOVER_CASH, 'OVER_CASH', DbType.text);
  }

  static TableField? _fACTUAL_CASH;
  static TableField get ACTUAL_CASH {
    return _fACTUAL_CASH = _fACTUAL_CASH ??
        SqlSyntax.setField(_fACTUAL_CASH, 'ACTUAL_CASH', DbType.text);
  }

  static TableField? _fIS_RCVD;
  static TableField get IS_RCVD {
    return _fIS_RCVD =
        _fIS_RCVD ?? SqlSyntax.setField(_fIS_RCVD, 'IS_RCVD', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }
}
// endregion BOSLIP_CASH1Fields

//region BOSLIP_CASH1Manager
class BOSLIP_CASH1Manager extends SqfEntityProvider {
  BOSLIP_CASH1Manager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'BOSLIP_CASH1';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion BOSLIP_CASH1Manager
// region BOSLIP_DOCUMENT1
class BOSLIP_DOCUMENT1 extends TableBase {
  BOSLIP_DOCUMENT1(
      {this.SNo,
      this.BO_SLIP_NO,
      this.DOCUMENT_DETAILS,
      this.FROMOFFICE,
      this.TOOFFICE,
      this.IS_RCVD,
      this.IS_COMMUNICATED}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BOSLIP_DOCUMENT1.withFields(this.BO_SLIP_NO, this.DOCUMENT_DETAILS,
      this.FROMOFFICE, this.TOOFFICE, this.IS_RCVD, this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  BOSLIP_DOCUMENT1.withId(this.SNo, this.BO_SLIP_NO, this.DOCUMENT_DETAILS,
      this.FROMOFFICE, this.TOOFFICE, this.IS_RCVD, this.IS_COMMUNICATED) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BOSLIP_DOCUMENT1.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['BO_SLIP_NO'] != null) {
      BO_SLIP_NO = o['BO_SLIP_NO'].toString();
    }
    if (o['DOCUMENT_DETAILS'] != null) {
      DOCUMENT_DETAILS = o['DOCUMENT_DETAILS'].toString();
    }
    if (o['FROMOFFICE'] != null) {
      FROMOFFICE = o['FROMOFFICE'].toString();
    }
    if (o['TOOFFICE'] != null) {
      TOOFFICE = o['TOOFFICE'].toString();
    }
    if (o['IS_RCVD'] != null) {
      IS_RCVD = o['IS_RCVD'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
  }
  // FIELDS (BOSLIP_DOCUMENT1)
  int? SNo;
  String? BO_SLIP_NO;
  String? DOCUMENT_DETAILS;
  String? FROMOFFICE;
  String? TOOFFICE;
  String? IS_RCVD;
  String? IS_COMMUNICATED;

  // end FIELDS (BOSLIP_DOCUMENT1)

  static const bool _softDeleteActivated = false;
  BOSLIP_DOCUMENT1Manager? __mnBOSLIP_DOCUMENT1;

  BOSLIP_DOCUMENT1Manager get _mnBOSLIP_DOCUMENT1 {
    return __mnBOSLIP_DOCUMENT1 =
        __mnBOSLIP_DOCUMENT1 ?? BOSLIP_DOCUMENT1Manager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (DOCUMENT_DETAILS != null || !forView) {
      map['DOCUMENT_DETAILS'] = DOCUMENT_DETAILS;
    }
    if (FROMOFFICE != null || !forView) {
      map['FROMOFFICE'] = FROMOFFICE;
    }
    if (TOOFFICE != null || !forView) {
      map['TOOFFICE'] = TOOFFICE;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BO_SLIP_NO != null || !forView) {
      map['BO_SLIP_NO'] = BO_SLIP_NO;
    }
    if (DOCUMENT_DETAILS != null || !forView) {
      map['DOCUMENT_DETAILS'] = DOCUMENT_DETAILS;
    }
    if (FROMOFFICE != null || !forView) {
      map['FROMOFFICE'] = FROMOFFICE;
    }
    if (TOOFFICE != null || !forView) {
      map['TOOFFICE'] = TOOFFICE;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }

    return map;
  }

  /// This method returns Json String [BOSLIP_DOCUMENT1]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BOSLIP_DOCUMENT1]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BO_SLIP_NO,
      DOCUMENT_DETAILS,
      FROMOFFICE,
      TOOFFICE,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      BO_SLIP_NO,
      DOCUMENT_DETAILS,
      FROMOFFICE,
      TOOFFICE,
      IS_RCVD,
      IS_COMMUNICATED
    ];
  }

  static Future<List<BOSLIP_DOCUMENT1>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_DOCUMENT1.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BOSLIP_DOCUMENT1>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BOSLIP_DOCUMENT1>[];
    try {
      objList = list
          .map((boslip_document1) => BOSLIP_DOCUMENT1
              .fromMap(boslip_document1 as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BOSLIP_DOCUMENT1.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BOSLIP_DOCUMENT1>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BOSLIP_DOCUMENT1> objList = <BOSLIP_DOCUMENT1>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BOSLIP_DOCUMENT1.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BOSLIP_DOCUMENT1 by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BOSLIP_DOCUMENT1] if exist, otherwise returns null
  Future<BOSLIP_DOCUMENT1?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    BOSLIP_DOCUMENT1? obj;
    final data = await _mnBOSLIP_DOCUMENT1.getById([SNo]);
    if (data.length != 0) {
      obj = BOSLIP_DOCUMENT1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BOSLIP_DOCUMENT1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_DOCUMENT1.insert(this, ignoreBatch);
    } else {
      await _mnBOSLIP_DOCUMENT1.update(this);
    }

    return SNo;
  }

  /// Saves the (BOSLIP_DOCUMENT1) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBOSLIP_DOCUMENT1.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBOSLIP_DOCUMENT1.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs BOSLIP_DOCUMENT1. Returns a new Primary Key value of BOSLIP_DOCUMENT1

  /// <returns>Returns a new Primary Key value of BOSLIP_DOCUMENT1
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BOSLIP_DOCUMENT1> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BOSLIP_DOCUMENT1> boslip_document1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in boslip_document1s) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < boslip_document1s.length; i++) {
        if (boslip_document1s[i].SNo == null) {
          boslip_document1s[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_DOCUMENT1.rawInsert(
          'INSERT OR REPLACE INTO BOSLIP_DOCUMENT1 (SNo, BO_SLIP_NO, DOCUMENT_DETAILS, FROMOFFICE, TOOFFICE, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            DOCUMENT_DETAILS,
            FROMOFFICE,
            TOOFFICE,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_DOCUMENT1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_DOCUMENT1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_DOCUMENT1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBOSLIP_DOCUMENT1.rawInsert(
          'INSERT OR IGNORE INTO BOSLIP_DOCUMENT1 (SNo, BO_SLIP_NO, DOCUMENT_DETAILS, FROMOFFICE, TOOFFICE, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?)',
          [
            SNo,
            BO_SLIP_NO,
            DOCUMENT_DETAILS,
            FROMOFFICE,
            TOOFFICE,
            IS_RCVD,
            IS_COMMUNICATED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BOSLIP_DOCUMENT1 SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BOSLIP_DOCUMENT1 SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BOSLIP_DOCUMENT1 Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BOSLIP_DOCUMENT1>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BOSLIP_DOCUMENT1> boslip_document1s,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBOSLIP_DOCUMENT1.rawInsertAll(
        'INSERT OR REPLACE INTO BOSLIP_DOCUMENT1 (SNo, BO_SLIP_NO, DOCUMENT_DETAILS, FROMOFFICE, TOOFFICE, IS_RCVD, IS_COMMUNICATED)  VALUES (?,?,?,?,?,?,?)',
        boslip_document1s,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BOSLIP_DOCUMENT1

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BOSLIP_DOCUMENT1 invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBOSLIP_DOCUMENT1
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnBOSLIP_DOCUMENT1.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BOSLIP_DOCUMENT1] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_DOCUMENT1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BOSLIP_DOCUMENT1FilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion boslip_document1

// region BOSLIP_DOCUMENT1Field
class BOSLIP_DOCUMENT1Field extends FilterBase {
  BOSLIP_DOCUMENT1Field(BOSLIP_DOCUMENT1FilterBuilder boslip_document1FB)
      : super(boslip_document1FB);

  @override
  BOSLIP_DOCUMENT1FilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder isNull() {
    return super.isNull() as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1FilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BOSLIP_DOCUMENT1FilterBuilder;
  }

  @override
  BOSLIP_DOCUMENT1Field get not {
    return super.not as BOSLIP_DOCUMENT1Field;
  }
}
// endregion BOSLIP_DOCUMENT1Field

// region BOSLIP_DOCUMENT1FilterBuilder
class BOSLIP_DOCUMENT1FilterBuilder extends ConjunctionBase {
  BOSLIP_DOCUMENT1FilterBuilder(BOSLIP_DOCUMENT1 obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBOSLIP_DOCUMENT1 = obj._mnBOSLIP_DOCUMENT1;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BOSLIP_DOCUMENT1Manager? _mnBOSLIP_DOCUMENT1;

  /// put the sql keyword 'AND'
  @override
  BOSLIP_DOCUMENT1FilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BOSLIP_DOCUMENT1FilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BOSLIP_DOCUMENT1FilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BOSLIP_DOCUMENT1FilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BOSLIP_DOCUMENT1FilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BOSLIP_DOCUMENT1FilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BOSLIP_DOCUMENT1FilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_DOCUMENT1FilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_DOCUMENT1FilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BOSLIP_DOCUMENT1FilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BOSLIP_DOCUMENT1FilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BOSLIP_DOCUMENT1Field _setField(
      BOSLIP_DOCUMENT1Field? field, String colName, DbType dbtype) {
    return BOSLIP_DOCUMENT1Field(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BOSLIP_DOCUMENT1Field? _SNo;
  BOSLIP_DOCUMENT1Field get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  BOSLIP_DOCUMENT1Field? _BO_SLIP_NO;
  BOSLIP_DOCUMENT1Field get BO_SLIP_NO {
    return _BO_SLIP_NO = _setField(_BO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  BOSLIP_DOCUMENT1Field? _DOCUMENT_DETAILS;
  BOSLIP_DOCUMENT1Field get DOCUMENT_DETAILS {
    return _DOCUMENT_DETAILS =
        _setField(_DOCUMENT_DETAILS, 'DOCUMENT_DETAILS', DbType.text);
  }

  BOSLIP_DOCUMENT1Field? _FROMOFFICE;
  BOSLIP_DOCUMENT1Field get FROMOFFICE {
    return _FROMOFFICE = _setField(_FROMOFFICE, 'FROMOFFICE', DbType.text);
  }

  BOSLIP_DOCUMENT1Field? _TOOFFICE;
  BOSLIP_DOCUMENT1Field get TOOFFICE {
    return _TOOFFICE = _setField(_TOOFFICE, 'TOOFFICE', DbType.text);
  }

  BOSLIP_DOCUMENT1Field? _IS_RCVD;
  BOSLIP_DOCUMENT1Field get IS_RCVD {
    return _IS_RCVD = _setField(_IS_RCVD, 'IS_RCVD', DbType.text);
  }

  BOSLIP_DOCUMENT1Field? _IS_COMMUNICATED;
  BOSLIP_DOCUMENT1Field get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  /// Deletes List<BOSLIP_DOCUMENT1> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBOSLIP_DOCUMENT1!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBOSLIP_DOCUMENT1!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from BOSLIP_DOCUMENT1 ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBOSLIP_DOCUMENT1!.updateBatch(qparams, values);
  }

  /// This method always returns [BOSLIP_DOCUMENT1] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_DOCUMENT1?
  @override
  Future<BOSLIP_DOCUMENT1?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBOSLIP_DOCUMENT1!.toList(qparams);
    final data = await objFuture;
    BOSLIP_DOCUMENT1? obj;
    if (data.isNotEmpty) {
      obj = BOSLIP_DOCUMENT1.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BOSLIP_DOCUMENT1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BOSLIP_DOCUMENT1?
  @override
  Future<BOSLIP_DOCUMENT1> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BOSLIP_DOCUMENT1();
  }

  /// This method returns int. [BOSLIP_DOCUMENT1]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? boslip_document1Count]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final boslip_document1sFuture = await _mnBOSLIP_DOCUMENT1!.toList(qparams);
    final int count = boslip_document1sFuture[0]['CNT'] as int;
    if (boslip_document1Count != null) {
      boslip_document1Count(count);
    }
    return count;
  }

  /// This method returns List<BOSLIP_DOCUMENT1> [BOSLIP_DOCUMENT1]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BOSLIP_DOCUMENT1>
  @override
  Future<List<BOSLIP_DOCUMENT1>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BOSLIP_DOCUMENT1> boslip_document1sData =
        await BOSLIP_DOCUMENT1.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return boslip_document1sData;
  }

  /// This method returns Json String [BOSLIP_DOCUMENT1]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BOSLIP_DOCUMENT1]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BOSLIP_DOCUMENT1]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBOSLIP_DOCUMENT1!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BOSLIP_DOCUMENT1]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM BOSLIP_DOCUMENT1 WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnBOSLIP_DOCUMENT1!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BOSLIP_DOCUMENT1]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBOSLIP_DOCUMENT1!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BOSLIP_DOCUMENT1.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBOSLIP_DOCUMENT1!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BOSLIP_DOCUMENT1FilterBuilder

// region BOSLIP_DOCUMENT1Fields
class BOSLIP_DOCUMENT1Fields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fBO_SLIP_NO;
  static TableField get BO_SLIP_NO {
    return _fBO_SLIP_NO = _fBO_SLIP_NO ??
        SqlSyntax.setField(_fBO_SLIP_NO, 'BO_SLIP_NO', DbType.text);
  }

  static TableField? _fDOCUMENT_DETAILS;
  static TableField get DOCUMENT_DETAILS {
    return _fDOCUMENT_DETAILS = _fDOCUMENT_DETAILS ??
        SqlSyntax.setField(_fDOCUMENT_DETAILS, 'DOCUMENT_DETAILS', DbType.text);
  }

  static TableField? _fFROMOFFICE;
  static TableField get FROMOFFICE {
    return _fFROMOFFICE = _fFROMOFFICE ??
        SqlSyntax.setField(_fFROMOFFICE, 'FROMOFFICE', DbType.text);
  }

  static TableField? _fTOOFFICE;
  static TableField get TOOFFICE {
    return _fTOOFFICE =
        _fTOOFFICE ?? SqlSyntax.setField(_fTOOFFICE, 'TOOFFICE', DbType.text);
  }

  static TableField? _fIS_RCVD;
  static TableField get IS_RCVD {
    return _fIS_RCVD =
        _fIS_RCVD ?? SqlSyntax.setField(_fIS_RCVD, 'IS_RCVD', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }
}
// endregion BOSLIP_DOCUMENT1Fields

//region BOSLIP_DOCUMENT1Manager
class BOSLIP_DOCUMENT1Manager extends SqfEntityProvider {
  BOSLIP_DOCUMENT1Manager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'BOSLIP_DOCUMENT1';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion BOSLIP_DOCUMENT1Manager
// region BSRDETAILS_NEW
class BSRDETAILS_NEW extends TableBase {
  BSRDETAILS_NEW(
      {this.SNo,
      this.BOSLIPID,
      this.BAGNUMBER,
      this.RECEIVEDATE,
      this.BO_SLIP_DATE,
      this.CLOSING_BALANCE,
      this.CB_DATE,
      this.IS_COMMUNICATED,
      this.CASH_STATUS,
      this.STAMP_STATUS,
      this.DOCUMENT_STATUS}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BSRDETAILS_NEW.withFields(
      this.BOSLIPID,
      this.BAGNUMBER,
      this.RECEIVEDATE,
      this.BO_SLIP_DATE,
      this.CLOSING_BALANCE,
      this.CB_DATE,
      this.IS_COMMUNICATED,
      this.CASH_STATUS,
      this.STAMP_STATUS,
      this.DOCUMENT_STATUS) {
    _setDefaultValues();
  }
  BSRDETAILS_NEW.withId(
      this.SNo,
      this.BOSLIPID,
      this.BAGNUMBER,
      this.RECEIVEDATE,
      this.BO_SLIP_DATE,
      this.CLOSING_BALANCE,
      this.CB_DATE,
      this.IS_COMMUNICATED,
      this.CASH_STATUS,
      this.STAMP_STATUS,
      this.DOCUMENT_STATUS) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BSRDETAILS_NEW.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['BOSLIPID'] != null) {
      BOSLIPID = o['BOSLIPID'].toString();
    }
    if (o['BAGNUMBER'] != null) {
      BAGNUMBER = o['BAGNUMBER'].toString();
    }
    if (o['RECEIVEDATE'] != null) {
      RECEIVEDATE = o['RECEIVEDATE'].toString();
    }
    if (o['BO_SLIP_DATE'] != null) {
      BO_SLIP_DATE = o['BO_SLIP_DATE'].toString();
    }
    if (o['CLOSING_BALANCE'] != null) {
      CLOSING_BALANCE = o['CLOSING_BALANCE'].toString();
    }
    if (o['CB_DATE'] != null) {
      CB_DATE = o['CB_DATE'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['CASH_STATUS'] != null) {
      CASH_STATUS = o['CASH_STATUS'].toString();
    }
    if (o['STAMP_STATUS'] != null) {
      STAMP_STATUS = o['STAMP_STATUS'].toString();
    }
    if (o['DOCUMENT_STATUS'] != null) {
      DOCUMENT_STATUS = o['DOCUMENT_STATUS'].toString();
    }
  }
  // FIELDS (BSRDETAILS_NEW)
  int? SNo;
  String? BOSLIPID;
  String? BAGNUMBER;
  String? RECEIVEDATE;
  String? BO_SLIP_DATE;
  String? CLOSING_BALANCE;
  String? CB_DATE;
  String? IS_COMMUNICATED;
  String? CASH_STATUS;
  String? STAMP_STATUS;
  String? DOCUMENT_STATUS;

  // end FIELDS (BSRDETAILS_NEW)

  static const bool _softDeleteActivated = false;
  BSRDETAILS_NEWManager? __mnBSRDETAILS_NEW;

  BSRDETAILS_NEWManager get _mnBSRDETAILS_NEW {
    return __mnBSRDETAILS_NEW = __mnBSRDETAILS_NEW ?? BSRDETAILS_NEWManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BOSLIPID != null || !forView) {
      map['BOSLIPID'] = BOSLIPID;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (RECEIVEDATE != null || !forView) {
      map['RECEIVEDATE'] = RECEIVEDATE;
    }
    if (BO_SLIP_DATE != null || !forView) {
      map['BO_SLIP_DATE'] = BO_SLIP_DATE;
    }
    if (CLOSING_BALANCE != null || !forView) {
      map['CLOSING_BALANCE'] = CLOSING_BALANCE;
    }
    if (CB_DATE != null || !forView) {
      map['CB_DATE'] = CB_DATE;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (CASH_STATUS != null || !forView) {
      map['CASH_STATUS'] = CASH_STATUS;
    }
    if (STAMP_STATUS != null || !forView) {
      map['STAMP_STATUS'] = STAMP_STATUS;
    }
    if (DOCUMENT_STATUS != null || !forView) {
      map['DOCUMENT_STATUS'] = DOCUMENT_STATUS;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (BOSLIPID != null || !forView) {
      map['BOSLIPID'] = BOSLIPID;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (RECEIVEDATE != null || !forView) {
      map['RECEIVEDATE'] = RECEIVEDATE;
    }
    if (BO_SLIP_DATE != null || !forView) {
      map['BO_SLIP_DATE'] = BO_SLIP_DATE;
    }
    if (CLOSING_BALANCE != null || !forView) {
      map['CLOSING_BALANCE'] = CLOSING_BALANCE;
    }
    if (CB_DATE != null || !forView) {
      map['CB_DATE'] = CB_DATE;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (CASH_STATUS != null || !forView) {
      map['CASH_STATUS'] = CASH_STATUS;
    }
    if (STAMP_STATUS != null || !forView) {
      map['STAMP_STATUS'] = STAMP_STATUS;
    }
    if (DOCUMENT_STATUS != null || !forView) {
      map['DOCUMENT_STATUS'] = DOCUMENT_STATUS;
    }

    return map;
  }

  /// This method returns Json String [BSRDETAILS_NEW]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BSRDETAILS_NEW]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BOSLIPID,
      BAGNUMBER,
      RECEIVEDATE,
      BO_SLIP_DATE,
      CLOSING_BALANCE,
      CB_DATE,
      IS_COMMUNICATED,
      CASH_STATUS,
      STAMP_STATUS,
      DOCUMENT_STATUS
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      BOSLIPID,
      BAGNUMBER,
      RECEIVEDATE,
      BO_SLIP_DATE,
      CLOSING_BALANCE,
      CB_DATE,
      IS_COMMUNICATED,
      CASH_STATUS,
      STAMP_STATUS,
      DOCUMENT_STATUS
    ];
  }

  static Future<List<BSRDETAILS_NEW>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BSRDETAILS_NEW.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BSRDETAILS_NEW>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BSRDETAILS_NEW>[];
    try {
      objList = list
          .map((bsrdetails_new) =>
              BSRDETAILS_NEW.fromMap(bsrdetails_new as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BSRDETAILS_NEW.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BSRDETAILS_NEW>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BSRDETAILS_NEW> objList = <BSRDETAILS_NEW>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BSRDETAILS_NEW.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BSRDETAILS_NEW by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BSRDETAILS_NEW] if exist, otherwise returns null
  Future<BSRDETAILS_NEW?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    BSRDETAILS_NEW? obj;
    final data = await _mnBSRDETAILS_NEW.getById([SNo]);
    if (data.length != 0) {
      obj = BSRDETAILS_NEW.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BSRDETAILS_NEW) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBSRDETAILS_NEW.insert(this, ignoreBatch);
    } else {
      await _mnBSRDETAILS_NEW.update(this);
    }

    return SNo;
  }

  /// Saves the (BSRDETAILS_NEW) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBSRDETAILS_NEW.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBSRDETAILS_NEW.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs BSRDETAILS_NEW. Returns a new Primary Key value of BSRDETAILS_NEW

  /// <returns>Returns a new Primary Key value of BSRDETAILS_NEW
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BSRDETAILS_NEW> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BSRDETAILS_NEW> bsrdetails_news,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in bsrdetails_news) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < bsrdetails_news.length; i++) {
        if (bsrdetails_news[i].SNo == null) {
          bsrdetails_news[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBSRDETAILS_NEW.rawInsert(
          'INSERT OR REPLACE INTO BSRDETAILS_NEW (SNo, BOSLIPID, BAGNUMBER, RECEIVEDATE, BO_SLIP_DATE, CLOSING_BALANCE, CB_DATE, IS_COMMUNICATED, CASH_STATUS, STAMP_STATUS, DOCUMENT_STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BOSLIPID,
            BAGNUMBER,
            RECEIVEDATE,
            BO_SLIP_DATE,
            CLOSING_BALANCE,
            CB_DATE,
            IS_COMMUNICATED,
            CASH_STATUS,
            STAMP_STATUS,
            DOCUMENT_STATUS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BSRDETAILS_NEW SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BSRDETAILS_NEW SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BSRDETAILS_NEW Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBSRDETAILS_NEW.rawInsert(
          'INSERT OR IGNORE INTO BSRDETAILS_NEW (SNo, BOSLIPID, BAGNUMBER, RECEIVEDATE, BO_SLIP_DATE, CLOSING_BALANCE, CB_DATE, IS_COMMUNICATED, CASH_STATUS, STAMP_STATUS, DOCUMENT_STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            BOSLIPID,
            BAGNUMBER,
            RECEIVEDATE,
            BO_SLIP_DATE,
            CLOSING_BALANCE,
            CB_DATE,
            IS_COMMUNICATED,
            CASH_STATUS,
            STAMP_STATUS,
            DOCUMENT_STATUS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BSRDETAILS_NEW SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BSRDETAILS_NEW SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BSRDETAILS_NEW Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BSRDETAILS_NEW>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BSRDETAILS_NEW> bsrdetails_news,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBSRDETAILS_NEW.rawInsertAll(
        'INSERT OR REPLACE INTO BSRDETAILS_NEW (SNo, BOSLIPID, BAGNUMBER, RECEIVEDATE, BO_SLIP_DATE, CLOSING_BALANCE, CB_DATE, IS_COMMUNICATED, CASH_STATUS, STAMP_STATUS, DOCUMENT_STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        bsrdetails_news,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BSRDETAILS_NEW

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BSRDETAILS_NEW invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBSRDETAILS_NEW
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnBSRDETAILS_NEW.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BSRDETAILS_NEW] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BSRDETAILS_NEWFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BSRDETAILS_NEWFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BSRDETAILS_NEWFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BSRDETAILS_NEWFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bsrdetails_new

// region BSRDETAILS_NEWField
class BSRDETAILS_NEWField extends FilterBase {
  BSRDETAILS_NEWField(BSRDETAILS_NEWFilterBuilder bsrdetails_newFB)
      : super(bsrdetails_newFB);

  @override
  BSRDETAILS_NEWFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder isNull() {
    return super.isNull() as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BSRDETAILS_NEWFilterBuilder;
  }

  @override
  BSRDETAILS_NEWField get not {
    return super.not as BSRDETAILS_NEWField;
  }
}
// endregion BSRDETAILS_NEWField

// region BSRDETAILS_NEWFilterBuilder
class BSRDETAILS_NEWFilterBuilder extends ConjunctionBase {
  BSRDETAILS_NEWFilterBuilder(BSRDETAILS_NEW obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBSRDETAILS_NEW = obj._mnBSRDETAILS_NEW;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BSRDETAILS_NEWManager? _mnBSRDETAILS_NEW;

  /// put the sql keyword 'AND'
  @override
  BSRDETAILS_NEWFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BSRDETAILS_NEWFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BSRDETAILS_NEWFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BSRDETAILS_NEWFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BSRDETAILS_NEWFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BSRDETAILS_NEWFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BSRDETAILS_NEWFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BSRDETAILS_NEWFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BSRDETAILS_NEWFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BSRDETAILS_NEWFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BSRDETAILS_NEWFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BSRDETAILS_NEWField _setField(
      BSRDETAILS_NEWField? field, String colName, DbType dbtype) {
    return BSRDETAILS_NEWField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BSRDETAILS_NEWField? _SNo;
  BSRDETAILS_NEWField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  BSRDETAILS_NEWField? _BOSLIPID;
  BSRDETAILS_NEWField get BOSLIPID {
    return _BOSLIPID = _setField(_BOSLIPID, 'BOSLIPID', DbType.text);
  }

  BSRDETAILS_NEWField? _BAGNUMBER;
  BSRDETAILS_NEWField get BAGNUMBER {
    return _BAGNUMBER = _setField(_BAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  BSRDETAILS_NEWField? _RECEIVEDATE;
  BSRDETAILS_NEWField get RECEIVEDATE {
    return _RECEIVEDATE = _setField(_RECEIVEDATE, 'RECEIVEDATE', DbType.text);
  }

  BSRDETAILS_NEWField? _BO_SLIP_DATE;
  BSRDETAILS_NEWField get BO_SLIP_DATE {
    return _BO_SLIP_DATE =
        _setField(_BO_SLIP_DATE, 'BO_SLIP_DATE', DbType.text);
  }

  BSRDETAILS_NEWField? _CLOSING_BALANCE;
  BSRDETAILS_NEWField get CLOSING_BALANCE {
    return _CLOSING_BALANCE =
        _setField(_CLOSING_BALANCE, 'CLOSING_BALANCE', DbType.text);
  }

  BSRDETAILS_NEWField? _CB_DATE;
  BSRDETAILS_NEWField get CB_DATE {
    return _CB_DATE = _setField(_CB_DATE, 'CB_DATE', DbType.text);
  }

  BSRDETAILS_NEWField? _IS_COMMUNICATED;
  BSRDETAILS_NEWField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  BSRDETAILS_NEWField? _CASH_STATUS;
  BSRDETAILS_NEWField get CASH_STATUS {
    return _CASH_STATUS = _setField(_CASH_STATUS, 'CASH_STATUS', DbType.text);
  }

  BSRDETAILS_NEWField? _STAMP_STATUS;
  BSRDETAILS_NEWField get STAMP_STATUS {
    return _STAMP_STATUS =
        _setField(_STAMP_STATUS, 'STAMP_STATUS', DbType.text);
  }

  BSRDETAILS_NEWField? _DOCUMENT_STATUS;
  BSRDETAILS_NEWField get DOCUMENT_STATUS {
    return _DOCUMENT_STATUS =
        _setField(_DOCUMENT_STATUS, 'DOCUMENT_STATUS', DbType.text);
  }

  /// Deletes List<BSRDETAILS_NEW> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBSRDETAILS_NEW!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBSRDETAILS_NEW!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from BSRDETAILS_NEW ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBSRDETAILS_NEW!.updateBatch(qparams, values);
  }

  /// This method always returns [BSRDETAILS_NEW] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BSRDETAILS_NEW?
  @override
  Future<BSRDETAILS_NEW?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBSRDETAILS_NEW!.toList(qparams);
    final data = await objFuture;
    BSRDETAILS_NEW? obj;
    if (data.isNotEmpty) {
      obj = BSRDETAILS_NEW.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BSRDETAILS_NEW]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BSRDETAILS_NEW?
  @override
  Future<BSRDETAILS_NEW> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BSRDETAILS_NEW();
  }

  /// This method returns int. [BSRDETAILS_NEW]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bsrdetails_newCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bsrdetails_newsFuture = await _mnBSRDETAILS_NEW!.toList(qparams);
    final int count = bsrdetails_newsFuture[0]['CNT'] as int;
    if (bsrdetails_newCount != null) {
      bsrdetails_newCount(count);
    }
    return count;
  }

  /// This method returns List<BSRDETAILS_NEW> [BSRDETAILS_NEW]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BSRDETAILS_NEW>
  @override
  Future<List<BSRDETAILS_NEW>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BSRDETAILS_NEW> bsrdetails_newsData =
        await BSRDETAILS_NEW.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bsrdetails_newsData;
  }

  /// This method returns Json String [BSRDETAILS_NEW]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BSRDETAILS_NEW]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BSRDETAILS_NEW]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBSRDETAILS_NEW!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BSRDETAILS_NEW]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM BSRDETAILS_NEW WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnBSRDETAILS_NEW!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BSRDETAILS_NEW]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBSRDETAILS_NEW!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BSRDETAILS_NEW.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBSRDETAILS_NEW!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BSRDETAILS_NEWFilterBuilder

// region BSRDETAILS_NEWFields
class BSRDETAILS_NEWFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fBOSLIPID;
  static TableField get BOSLIPID {
    return _fBOSLIPID =
        _fBOSLIPID ?? SqlSyntax.setField(_fBOSLIPID, 'BOSLIPID', DbType.text);
  }

  static TableField? _fBAGNUMBER;
  static TableField get BAGNUMBER {
    return _fBAGNUMBER = _fBAGNUMBER ??
        SqlSyntax.setField(_fBAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  static TableField? _fRECEIVEDATE;
  static TableField get RECEIVEDATE {
    return _fRECEIVEDATE = _fRECEIVEDATE ??
        SqlSyntax.setField(_fRECEIVEDATE, 'RECEIVEDATE', DbType.text);
  }

  static TableField? _fBO_SLIP_DATE;
  static TableField get BO_SLIP_DATE {
    return _fBO_SLIP_DATE = _fBO_SLIP_DATE ??
        SqlSyntax.setField(_fBO_SLIP_DATE, 'BO_SLIP_DATE', DbType.text);
  }

  static TableField? _fCLOSING_BALANCE;
  static TableField get CLOSING_BALANCE {
    return _fCLOSING_BALANCE = _fCLOSING_BALANCE ??
        SqlSyntax.setField(_fCLOSING_BALANCE, 'CLOSING_BALANCE', DbType.text);
  }

  static TableField? _fCB_DATE;
  static TableField get CB_DATE {
    return _fCB_DATE =
        _fCB_DATE ?? SqlSyntax.setField(_fCB_DATE, 'CB_DATE', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fCASH_STATUS;
  static TableField get CASH_STATUS {
    return _fCASH_STATUS = _fCASH_STATUS ??
        SqlSyntax.setField(_fCASH_STATUS, 'CASH_STATUS', DbType.text);
  }

  static TableField? _fSTAMP_STATUS;
  static TableField get STAMP_STATUS {
    return _fSTAMP_STATUS = _fSTAMP_STATUS ??
        SqlSyntax.setField(_fSTAMP_STATUS, 'STAMP_STATUS', DbType.text);
  }

  static TableField? _fDOCUMENT_STATUS;
  static TableField get DOCUMENT_STATUS {
    return _fDOCUMENT_STATUS = _fDOCUMENT_STATUS ??
        SqlSyntax.setField(_fDOCUMENT_STATUS, 'DOCUMENT_STATUS', DbType.text);
  }
}
// endregion BSRDETAILS_NEWFields

//region BSRDETAILS_NEWManager
class BSRDETAILS_NEWManager extends SqfEntityProvider {
  BSRDETAILS_NEWManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'BSRDETAILS_NEW';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion BSRDETAILS_NEWManager
// region BAGDETAILS_NEW
class BAGDETAILS_NEW extends TableBase {
  BAGDETAILS_NEW(
      {this.SNo,
      this.FROMOFFICE,
      this.TOOFFICE,
      this.TDATE,
      this.TIME,
      this.USERID,
      this.BAGNUMBER,
      this.BAGSTATUS,
      this.BOTDATE,
      this.IS_RCVD,
      this.IS_COMMUNICATED,
      this.BOSLIPNO,
      this.NO_OF_ARTICLES}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BAGDETAILS_NEW.withFields(
      this.FROMOFFICE,
      this.TOOFFICE,
      this.TDATE,
      this.TIME,
      this.USERID,
      this.BAGNUMBER,
      this.BAGSTATUS,
      this.BOTDATE,
      this.IS_RCVD,
      this.IS_COMMUNICATED,
      this.BOSLIPNO,
      this.NO_OF_ARTICLES) {
    _setDefaultValues();
  }
  BAGDETAILS_NEW.withId(
      this.SNo,
      this.FROMOFFICE,
      this.TOOFFICE,
      this.TDATE,
      this.TIME,
      this.USERID,
      this.BAGNUMBER,
      this.BAGSTATUS,
      this.BOTDATE,
      this.IS_RCVD,
      this.IS_COMMUNICATED,
      this.BOSLIPNO,
      this.NO_OF_ARTICLES) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BAGDETAILS_NEW.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SNo = int.tryParse(o['SNo'].toString());
    if (o['FROMOFFICE'] != null) {
      FROMOFFICE = o['FROMOFFICE'].toString();
    }
    if (o['TOOFFICE'] != null) {
      TOOFFICE = o['TOOFFICE'].toString();
    }
    if (o['TDATE'] != null) {
      TDATE = o['TDATE'].toString();
    }
    if (o['TIME'] != null) {
      TIME = o['TIME'].toString();
    }
    if (o['USERID'] != null) {
      USERID = o['USERID'].toString();
    }
    if (o['BAGNUMBER'] != null) {
      BAGNUMBER = o['BAGNUMBER'].toString();
    }
    if (o['BAGSTATUS'] != null) {
      BAGSTATUS = o['BAGSTATUS'].toString();
    }
    if (o['BOTDATE'] != null) {
      BOTDATE = o['BOTDATE'].toString();
    }
    if (o['IS_RCVD'] != null) {
      IS_RCVD = o['IS_RCVD'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['BOSLIPNO'] != null) {
      BOSLIPNO = o['BOSLIPNO'].toString();
    }
    if (o['NO_OF_ARTICLES'] != null) {
      NO_OF_ARTICLES = o['NO_OF_ARTICLES'].toString();
    }
  }
  // FIELDS (BAGDETAILS_NEW)
  int? SNo;
  String? FROMOFFICE;
  String? TOOFFICE;
  String? TDATE;
  String? TIME;
  String? USERID;
  String? BAGNUMBER;
  String? BAGSTATUS;
  String? BOTDATE;
  String? IS_RCVD;
  String? IS_COMMUNICATED;
  String? BOSLIPNO;
  String? NO_OF_ARTICLES;

  // end FIELDS (BAGDETAILS_NEW)

  static const bool _softDeleteActivated = false;
  BAGDETAILS_NEWManager? __mnBAGDETAILS_NEW;

  BAGDETAILS_NEWManager get _mnBAGDETAILS_NEW {
    return __mnBAGDETAILS_NEW = __mnBAGDETAILS_NEW ?? BAGDETAILS_NEWManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (FROMOFFICE != null || !forView) {
      map['FROMOFFICE'] = FROMOFFICE;
    }
    if (TOOFFICE != null || !forView) {
      map['TOOFFICE'] = TOOFFICE;
    }
    if (TDATE != null || !forView) {
      map['TDATE'] = TDATE;
    }
    if (TIME != null || !forView) {
      map['TIME'] = TIME;
    }
    if (USERID != null || !forView) {
      map['USERID'] = USERID;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (BAGSTATUS != null || !forView) {
      map['BAGSTATUS'] = BAGSTATUS;
    }
    if (BOTDATE != null || !forView) {
      map['BOTDATE'] = BOTDATE;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (BOSLIPNO != null || !forView) {
      map['BOSLIPNO'] = BOSLIPNO;
    }
    if (NO_OF_ARTICLES != null || !forView) {
      map['NO_OF_ARTICLES'] = NO_OF_ARTICLES;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SNo'] = SNo;
    if (FROMOFFICE != null || !forView) {
      map['FROMOFFICE'] = FROMOFFICE;
    }
    if (TOOFFICE != null || !forView) {
      map['TOOFFICE'] = TOOFFICE;
    }
    if (TDATE != null || !forView) {
      map['TDATE'] = TDATE;
    }
    if (TIME != null || !forView) {
      map['TIME'] = TIME;
    }
    if (USERID != null || !forView) {
      map['USERID'] = USERID;
    }
    if (BAGNUMBER != null || !forView) {
      map['BAGNUMBER'] = BAGNUMBER;
    }
    if (BAGSTATUS != null || !forView) {
      map['BAGSTATUS'] = BAGSTATUS;
    }
    if (BOTDATE != null || !forView) {
      map['BOTDATE'] = BOTDATE;
    }
    if (IS_RCVD != null || !forView) {
      map['IS_RCVD'] = IS_RCVD;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (BOSLIPNO != null || !forView) {
      map['BOSLIPNO'] = BOSLIPNO;
    }
    if (NO_OF_ARTICLES != null || !forView) {
      map['NO_OF_ARTICLES'] = NO_OF_ARTICLES;
    }

    return map;
  }

  /// This method returns Json String [BAGDETAILS_NEW]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BAGDETAILS_NEW]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FROMOFFICE,
      TOOFFICE,
      TDATE,
      TIME,
      USERID,
      BAGNUMBER,
      BAGSTATUS,
      BOTDATE,
      IS_RCVD,
      IS_COMMUNICATED,
      BOSLIPNO,
      NO_OF_ARTICLES
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SNo,
      FROMOFFICE,
      TOOFFICE,
      TDATE,
      TIME,
      USERID,
      BAGNUMBER,
      BAGSTATUS,
      BOTDATE,
      IS_RCVD,
      IS_COMMUNICATED,
      BOSLIPNO,
      NO_OF_ARTICLES
    ];
  }

  static Future<List<BAGDETAILS_NEW>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BAGDETAILS_NEW.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BAGDETAILS_NEW>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BAGDETAILS_NEW>[];
    try {
      objList = list
          .map((bagdetails_new) =>
              BAGDETAILS_NEW.fromMap(bagdetails_new as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BAGDETAILS_NEW.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BAGDETAILS_NEW>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BAGDETAILS_NEW> objList = <BAGDETAILS_NEW>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BAGDETAILS_NEW.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BAGDETAILS_NEW by ID if exist, otherwise returns null
  /// Primary Keys: int? SNo
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BAGDETAILS_NEW] if exist, otherwise returns null
  Future<BAGDETAILS_NEW?> getById(int? SNo,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SNo == null) {
      return null;
    }
    BAGDETAILS_NEW? obj;
    final data = await _mnBAGDETAILS_NEW.getById([SNo]);
    if (data.length != 0) {
      obj = BAGDETAILS_NEW.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BAGDETAILS_NEW) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBAGDETAILS_NEW.insert(this, ignoreBatch);
    } else {
      await _mnBAGDETAILS_NEW.update(this);
    }

    return SNo;
  }

  /// Saves the (BAGDETAILS_NEW) object. If the SNo field is null, saves as a new record and returns new SNo, if SNo is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns SNo
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (SNo == null || SNo == 0) {
      SNo = await _mnBAGDETAILS_NEW.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // SNo= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBAGDETAILS_NEW.updateOrThrow(this);
    }

    return SNo;
  }

  /// saveAs BAGDETAILS_NEW. Returns a new Primary Key value of BAGDETAILS_NEW

  /// <returns>Returns a new Primary Key value of BAGDETAILS_NEW
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    SNo = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BAGDETAILS_NEW> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BAGDETAILS_NEW> bagdetails_news,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in bagdetails_news) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < bagdetails_news.length; i++) {
        if (bagdetails_news[i].SNo == null) {
          bagdetails_news[i].SNo = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBAGDETAILS_NEW.rawInsert(
          'INSERT OR REPLACE INTO BAGDETAILS_NEW (SNo, FROMOFFICE, TOOFFICE, TDATE, TIME, USERID, BAGNUMBER, BAGSTATUS, BOTDATE, IS_RCVD, IS_COMMUNICATED, BOSLIPNO, NO_OF_ARTICLES)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            FROMOFFICE,
            TOOFFICE,
            TDATE,
            TIME,
            USERID,
            BAGNUMBER,
            BAGSTATUS,
            BOTDATE,
            IS_RCVD,
            IS_COMMUNICATED,
            BOSLIPNO,
            NO_OF_ARTICLES
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BAGDETAILS_NEW SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BAGDETAILS_NEW SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BAGDETAILS_NEW Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns SNo
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBAGDETAILS_NEW.rawInsert(
          'INSERT OR IGNORE INTO BAGDETAILS_NEW (SNo, FROMOFFICE, TOOFFICE, TDATE, TIME, USERID, BAGNUMBER, BAGSTATUS, BOTDATE, IS_RCVD, IS_COMMUNICATED, BOSLIPNO, NO_OF_ARTICLES)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SNo,
            FROMOFFICE,
            TOOFFICE,
            TDATE,
            TIME,
            USERID,
            BAGNUMBER,
            BAGSTATUS,
            BOTDATE,
            IS_RCVD,
            IS_COMMUNICATED,
            BOSLIPNO,
            NO_OF_ARTICLES
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BAGDETAILS_NEW SNo=$SNo updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BAGDETAILS_NEW SNo=$SNo did not update');
      }
      return SNo;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BAGDETAILS_NEW Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BAGDETAILS_NEW>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BAGDETAILS_NEW> bagdetails_news,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBAGDETAILS_NEW.rawInsertAll(
        'INSERT OR REPLACE INTO BAGDETAILS_NEW (SNo, FROMOFFICE, TOOFFICE, TDATE, TIME, USERID, BAGNUMBER, BAGSTATUS, BOTDATE, IS_RCVD, IS_COMMUNICATED, BOSLIPNO, NO_OF_ARTICLES)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
        bagdetails_news,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BAGDETAILS_NEW

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BAGDETAILS_NEW invoked (SNo=$SNo)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBAGDETAILS_NEW
          .delete(QueryParams(whereString: 'SNo=?', whereArguments: [SNo]));
    } else {
      return _mnBAGDETAILS_NEW.updateBatch(
          QueryParams(whereString: 'SNo=?', whereArguments: [SNo]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BAGDETAILS_NEW] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BAGDETAILS_NEWFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BAGDETAILS_NEWFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BAGDETAILS_NEWFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BAGDETAILS_NEWFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SNo = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagdetails_new

// region BAGDETAILS_NEWField
class BAGDETAILS_NEWField extends FilterBase {
  BAGDETAILS_NEWField(BAGDETAILS_NEWFilterBuilder bagdetails_newFB)
      : super(bagdetails_newFB);

  @override
  BAGDETAILS_NEWFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder isNull() {
    return super.isNull() as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BAGDETAILS_NEWFilterBuilder;
  }

  @override
  BAGDETAILS_NEWField get not {
    return super.not as BAGDETAILS_NEWField;
  }
}
// endregion BAGDETAILS_NEWField

// region BAGDETAILS_NEWFilterBuilder
class BAGDETAILS_NEWFilterBuilder extends ConjunctionBase {
  BAGDETAILS_NEWFilterBuilder(BAGDETAILS_NEW obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBAGDETAILS_NEW = obj._mnBAGDETAILS_NEW;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BAGDETAILS_NEWManager? _mnBAGDETAILS_NEW;

  /// put the sql keyword 'AND'
  @override
  BAGDETAILS_NEWFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BAGDETAILS_NEWFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BAGDETAILS_NEWFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BAGDETAILS_NEWFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BAGDETAILS_NEWFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BAGDETAILS_NEWFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BAGDETAILS_NEWFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BAGDETAILS_NEWFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BAGDETAILS_NEWFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BAGDETAILS_NEWFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BAGDETAILS_NEWFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BAGDETAILS_NEWField _setField(
      BAGDETAILS_NEWField? field, String colName, DbType dbtype) {
    return BAGDETAILS_NEWField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BAGDETAILS_NEWField? _SNo;
  BAGDETAILS_NEWField get SNo {
    return _SNo = _setField(_SNo, 'SNo', DbType.integer);
  }

  BAGDETAILS_NEWField? _FROMOFFICE;
  BAGDETAILS_NEWField get FROMOFFICE {
    return _FROMOFFICE = _setField(_FROMOFFICE, 'FROMOFFICE', DbType.text);
  }

  BAGDETAILS_NEWField? _TOOFFICE;
  BAGDETAILS_NEWField get TOOFFICE {
    return _TOOFFICE = _setField(_TOOFFICE, 'TOOFFICE', DbType.text);
  }

  BAGDETAILS_NEWField? _TDATE;
  BAGDETAILS_NEWField get TDATE {
    return _TDATE = _setField(_TDATE, 'TDATE', DbType.text);
  }

  BAGDETAILS_NEWField? _TIME;
  BAGDETAILS_NEWField get TIME {
    return _TIME = _setField(_TIME, 'TIME', DbType.text);
  }

  BAGDETAILS_NEWField? _USERID;
  BAGDETAILS_NEWField get USERID {
    return _USERID = _setField(_USERID, 'USERID', DbType.text);
  }

  BAGDETAILS_NEWField? _BAGNUMBER;
  BAGDETAILS_NEWField get BAGNUMBER {
    return _BAGNUMBER = _setField(_BAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  BAGDETAILS_NEWField? _BAGSTATUS;
  BAGDETAILS_NEWField get BAGSTATUS {
    return _BAGSTATUS = _setField(_BAGSTATUS, 'BAGSTATUS', DbType.text);
  }

  BAGDETAILS_NEWField? _BOTDATE;
  BAGDETAILS_NEWField get BOTDATE {
    return _BOTDATE = _setField(_BOTDATE, 'BOTDATE', DbType.text);
  }

  BAGDETAILS_NEWField? _IS_RCVD;
  BAGDETAILS_NEWField get IS_RCVD {
    return _IS_RCVD = _setField(_IS_RCVD, 'IS_RCVD', DbType.text);
  }

  BAGDETAILS_NEWField? _IS_COMMUNICATED;
  BAGDETAILS_NEWField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  BAGDETAILS_NEWField? _BOSLIPNO;
  BAGDETAILS_NEWField get BOSLIPNO {
    return _BOSLIPNO = _setField(_BOSLIPNO, 'BOSLIPNO', DbType.text);
  }

  BAGDETAILS_NEWField? _NO_OF_ARTICLES;
  BAGDETAILS_NEWField get NO_OF_ARTICLES {
    return _NO_OF_ARTICLES =
        _setField(_NO_OF_ARTICLES, 'NO_OF_ARTICLES', DbType.text);
  }

  /// Deletes List<BAGDETAILS_NEW> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBAGDETAILS_NEW!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBAGDETAILS_NEW!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SNo IN (SELECT SNo from BAGDETAILS_NEW ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBAGDETAILS_NEW!.updateBatch(qparams, values);
  }

  /// This method always returns [BAGDETAILS_NEW] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BAGDETAILS_NEW?
  @override
  Future<BAGDETAILS_NEW?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBAGDETAILS_NEW!.toList(qparams);
    final data = await objFuture;
    BAGDETAILS_NEW? obj;
    if (data.isNotEmpty) {
      obj = BAGDETAILS_NEW.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BAGDETAILS_NEW]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BAGDETAILS_NEW?
  @override
  Future<BAGDETAILS_NEW> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BAGDETAILS_NEW();
  }

  /// This method returns int. [BAGDETAILS_NEW]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagdetails_newCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagdetails_newsFuture = await _mnBAGDETAILS_NEW!.toList(qparams);
    final int count = bagdetails_newsFuture[0]['CNT'] as int;
    if (bagdetails_newCount != null) {
      bagdetails_newCount(count);
    }
    return count;
  }

  /// This method returns List<BAGDETAILS_NEW> [BAGDETAILS_NEW]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BAGDETAILS_NEW>
  @override
  Future<List<BAGDETAILS_NEW>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BAGDETAILS_NEW> bagdetails_newsData =
        await BAGDETAILS_NEW.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagdetails_newsData;
  }

  /// This method returns Json String [BAGDETAILS_NEW]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BAGDETAILS_NEW]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BAGDETAILS_NEW]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBAGDETAILS_NEW!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BAGDETAILS_NEW]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SNo` FROM BAGDETAILS_NEW WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SNoData = <int>[];
    qparams.selectColumns = ['SNo'];
    final SNoFuture = await _mnBAGDETAILS_NEW!.toList(qparams);

    final int count = SNoFuture.length;
    for (int i = 0; i < count; i++) {
      SNoData.add(SNoFuture[i]['SNo'] as int);
    }
    return SNoData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BAGDETAILS_NEW]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBAGDETAILS_NEW!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BAGDETAILS_NEW.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBAGDETAILS_NEW!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BAGDETAILS_NEWFilterBuilder

// region BAGDETAILS_NEWFields
class BAGDETAILS_NEWFields {
  static TableField? _fSNo;
  static TableField get SNo {
    return _fSNo = _fSNo ?? SqlSyntax.setField(_fSNo, 'sno', DbType.integer);
  }

  static TableField? _fFROMOFFICE;
  static TableField get FROMOFFICE {
    return _fFROMOFFICE = _fFROMOFFICE ??
        SqlSyntax.setField(_fFROMOFFICE, 'FROMOFFICE', DbType.text);
  }

  static TableField? _fTOOFFICE;
  static TableField get TOOFFICE {
    return _fTOOFFICE =
        _fTOOFFICE ?? SqlSyntax.setField(_fTOOFFICE, 'TOOFFICE', DbType.text);
  }

  static TableField? _fTDATE;
  static TableField get TDATE {
    return _fTDATE =
        _fTDATE ?? SqlSyntax.setField(_fTDATE, 'TDATE', DbType.text);
  }

  static TableField? _fTIME;
  static TableField get TIME {
    return _fTIME = _fTIME ?? SqlSyntax.setField(_fTIME, 'TIME', DbType.text);
  }

  static TableField? _fUSERID;
  static TableField get USERID {
    return _fUSERID =
        _fUSERID ?? SqlSyntax.setField(_fUSERID, 'USERID', DbType.text);
  }

  static TableField? _fBAGNUMBER;
  static TableField get BAGNUMBER {
    return _fBAGNUMBER = _fBAGNUMBER ??
        SqlSyntax.setField(_fBAGNUMBER, 'BAGNUMBER', DbType.text);
  }

  static TableField? _fBAGSTATUS;
  static TableField get BAGSTATUS {
    return _fBAGSTATUS = _fBAGSTATUS ??
        SqlSyntax.setField(_fBAGSTATUS, 'BAGSTATUS', DbType.text);
  }

  static TableField? _fBOTDATE;
  static TableField get BOTDATE {
    return _fBOTDATE =
        _fBOTDATE ?? SqlSyntax.setField(_fBOTDATE, 'BOTDATE', DbType.text);
  }

  static TableField? _fIS_RCVD;
  static TableField get IS_RCVD {
    return _fIS_RCVD =
        _fIS_RCVD ?? SqlSyntax.setField(_fIS_RCVD, 'IS_RCVD', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fBOSLIPNO;
  static TableField get BOSLIPNO {
    return _fBOSLIPNO =
        _fBOSLIPNO ?? SqlSyntax.setField(_fBOSLIPNO, 'BOSLIPNO', DbType.text);
  }

  static TableField? _fNO_OF_ARTICLES;
  static TableField get NO_OF_ARTICLES {
    return _fNO_OF_ARTICLES = _fNO_OF_ARTICLES ??
        SqlSyntax.setField(_fNO_OF_ARTICLES, 'NO_OF_ARTICLES', DbType.text);
  }
}
// endregion BAGDETAILS_NEWFields

//region BAGDETAILS_NEWManager
class BAGDETAILS_NEWManager extends SqfEntityProvider {
  BAGDETAILS_NEWManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'BAGDETAILS_NEW';
  static const List<String> _primaryKeyList = ['SNo'];
  static const String _whereStr = 'SNo=?';
}

//endregion BAGDETAILS_NEWManager
// region FILE_SYNC_DETAILS
class FILE_SYNC_DETAILS extends TableBase {
  FILE_SYNC_DETAILS(
      {this.CLIENT_TRANSACTION_ID,
      this.FILE_NAME,
      this.ZIP_FILE_NAME,
      this.FILE_PATH,
      this.SERVICE,
      this.STATUS,
      this.LAST_UPDATED_DT,
      this.PROCESSED}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  FILE_SYNC_DETAILS.withFields(
      this.CLIENT_TRANSACTION_ID,
      this.FILE_NAME,
      this.ZIP_FILE_NAME,
      this.FILE_PATH,
      this.SERVICE,
      this.STATUS,
      this.LAST_UPDATED_DT,
      this.PROCESSED) {
    _setDefaultValues();
  }
  FILE_SYNC_DETAILS.withId(
      this.CLIENT_TRANSACTION_ID,
      this.FILE_NAME,
      this.ZIP_FILE_NAME,
      this.FILE_PATH,
      this.SERVICE,
      this.STATUS,
      this.LAST_UPDATED_DT,
      this.PROCESSED) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FILE_SYNC_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CLIENT_TRANSACTION_ID = o['CLIENT_TRANSACTION_ID'].toString();
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
    if (o['ZIP_FILE_NAME'] != null) {
      ZIP_FILE_NAME = o['ZIP_FILE_NAME'].toString();
    }
    if (o['FILE_PATH'] != null) {
      FILE_PATH = o['FILE_PATH'].toString();
    }
    if (o['SERVICE'] != null) {
      SERVICE = o['SERVICE'].toString();
    }
    if (o['STATUS'] != null) {
      STATUS = o['STATUS'].toString();
    }
    if (o['LAST_UPDATED_DT'] != null) {
      LAST_UPDATED_DT = o['LAST_UPDATED_DT'].toString();
    }
    if (o['PROCESSED'] != null) {
      PROCESSED = o['PROCESSED'].toString();
    }

    isSaved = true;
  }
  // FIELDS (FILE_SYNC_DETAILS)
  String? CLIENT_TRANSACTION_ID;
  String? FILE_NAME;
  String? ZIP_FILE_NAME;
  String? FILE_PATH;
  String? SERVICE;
  String? STATUS;
  String? LAST_UPDATED_DT;
  String? PROCESSED;
  bool? isSaved;
  // end FIELDS (FILE_SYNC_DETAILS)

  static const bool _softDeleteActivated = false;
  FILE_SYNC_DETAILSManager? __mnFILE_SYNC_DETAILS;

  FILE_SYNC_DETAILSManager get _mnFILE_SYNC_DETAILS {
    return __mnFILE_SYNC_DETAILS =
        __mnFILE_SYNC_DETAILS ?? FILE_SYNC_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['CLIENT_TRANSACTION_ID'] = CLIENT_TRANSACTION_ID;
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }
    if (ZIP_FILE_NAME != null || !forView) {
      map['ZIP_FILE_NAME'] = ZIP_FILE_NAME;
    }
    if (FILE_PATH != null || !forView) {
      map['FILE_PATH'] = FILE_PATH;
    }
    if (SERVICE != null || !forView) {
      map['SERVICE'] = SERVICE;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }
    if (LAST_UPDATED_DT != null || !forView) {
      map['LAST_UPDATED_DT'] = LAST_UPDATED_DT;
    }
    if (PROCESSED != null || !forView) {
      map['PROCESSED'] = PROCESSED;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['CLIENT_TRANSACTION_ID'] = CLIENT_TRANSACTION_ID;
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }
    if (ZIP_FILE_NAME != null || !forView) {
      map['ZIP_FILE_NAME'] = ZIP_FILE_NAME;
    }
    if (FILE_PATH != null || !forView) {
      map['FILE_PATH'] = FILE_PATH;
    }
    if (SERVICE != null || !forView) {
      map['SERVICE'] = SERVICE;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }
    if (LAST_UPDATED_DT != null || !forView) {
      map['LAST_UPDATED_DT'] = LAST_UPDATED_DT;
    }
    if (PROCESSED != null || !forView) {
      map['PROCESSED'] = PROCESSED;
    }

    return map;
  }

  /// This method returns Json String [FILE_SYNC_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FILE_SYNC_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      CLIENT_TRANSACTION_ID,
      FILE_NAME,
      ZIP_FILE_NAME,
      FILE_PATH,
      SERVICE,
      STATUS,
      LAST_UPDATED_DT,
      PROCESSED
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      CLIENT_TRANSACTION_ID,
      FILE_NAME,
      ZIP_FILE_NAME,
      FILE_PATH,
      SERVICE,
      STATUS,
      LAST_UPDATED_DT,
      PROCESSED
    ];
  }

  static Future<List<FILE_SYNC_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FILE_SYNC_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FILE_SYNC_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FILE_SYNC_DETAILS>[];
    try {
      objList = list
          .map((file_sync_details) => FILE_SYNC_DETAILS
              .fromMap(file_sync_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FILE_SYNC_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FILE_SYNC_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FILE_SYNC_DETAILS> objList = <FILE_SYNC_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FILE_SYNC_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns FILE_SYNC_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? CLIENT_TRANSACTION_ID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [FILE_SYNC_DETAILS] if exist, otherwise returns null
  Future<FILE_SYNC_DETAILS?> getById(String? CLIENT_TRANSACTION_ID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (CLIENT_TRANSACTION_ID == null) {
      return null;
    }
    FILE_SYNC_DETAILS? obj;
    final data = await _mnFILE_SYNC_DETAILS.getById([CLIENT_TRANSACTION_ID]);
    if (data.length != 0) {
      obj = FILE_SYNC_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FILE_SYNC_DETAILS) object. If the Primary Key (CLIENT_TRANSACTION_ID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same CLIENT_TRANSACTION_ID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnFILE_SYNC_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO FILE_SYNC_DETAILS (CLIENT_TRANSACTION_ID, FILE_NAME, ZIP_FILE_NAME, FILE_PATH, SERVICE, STATUS, LAST_UPDATED_DT, PROCESSED)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<FILE_SYNC_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<FILE_SYNC_DETAILS> file_sync_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in file_sync_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFILE_SYNC_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO FILE_SYNC_DETAILS (CLIENT_TRANSACTION_ID, FILE_NAME, ZIP_FILE_NAME, FILE_PATH, SERVICE, STATUS, LAST_UPDATED_DT, PROCESSED)  VALUES (?,?,?,?,?,?,?,?)',
          [
            CLIENT_TRANSACTION_ID,
            FILE_NAME,
            ZIP_FILE_NAME,
            FILE_PATH,
            SERVICE,
            STATUS,
            LAST_UPDATED_DT,
            PROCESSED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FILE_SYNC_DETAILS CLIENT_TRANSACTION_ID=$CLIENT_TRANSACTION_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FILE_SYNC_DETAILS CLIENT_TRANSACTION_ID=$CLIENT_TRANSACTION_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'FILE_SYNC_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFILE_SYNC_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO FILE_SYNC_DETAILS (CLIENT_TRANSACTION_ID, FILE_NAME, ZIP_FILE_NAME, FILE_PATH, SERVICE, STATUS, LAST_UPDATED_DT, PROCESSED)  VALUES (?,?,?,?,?,?,?,?)',
          [
            CLIENT_TRANSACTION_ID,
            FILE_NAME,
            ZIP_FILE_NAME,
            FILE_PATH,
            SERVICE,
            STATUS,
            LAST_UPDATED_DT,
            PROCESSED
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FILE_SYNC_DETAILS CLIENT_TRANSACTION_ID=$CLIENT_TRANSACTION_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'FILE_SYNC_DETAILS CLIENT_TRANSACTION_ID=$CLIENT_TRANSACTION_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'FILE_SYNC_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes FILE_SYNC_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete FILE_SYNC_DETAILS invoked (CLIENT_TRANSACTION_ID=$CLIENT_TRANSACTION_ID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnFILE_SYNC_DETAILS.delete(QueryParams(
          whereString: 'CLIENT_TRANSACTION_ID=?',
          whereArguments: [CLIENT_TRANSACTION_ID]));
    } else {
      return _mnFILE_SYNC_DETAILS.updateBatch(
          QueryParams(
              whereString: 'CLIENT_TRANSACTION_ID=?',
              whereArguments: [CLIENT_TRANSACTION_ID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [FILE_SYNC_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FILE_SYNC_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FILE_SYNC_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      CLIENT_TRANSACTION_ID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion file_sync_details

// region FILE_SYNC_DETAILSField
class FILE_SYNC_DETAILSField extends FilterBase {
  FILE_SYNC_DETAILSField(FILE_SYNC_DETAILSFilterBuilder file_sync_detailsFB)
      : super(file_sync_detailsFB);

  @override
  FILE_SYNC_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder isNull() {
    return super.isNull() as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as FILE_SYNC_DETAILSFilterBuilder;
  }

  @override
  FILE_SYNC_DETAILSField get not {
    return super.not as FILE_SYNC_DETAILSField;
  }
}
// endregion FILE_SYNC_DETAILSField

// region FILE_SYNC_DETAILSFilterBuilder
class FILE_SYNC_DETAILSFilterBuilder extends ConjunctionBase {
  FILE_SYNC_DETAILSFilterBuilder(FILE_SYNC_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnFILE_SYNC_DETAILS = obj._mnFILE_SYNC_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  FILE_SYNC_DETAILSManager? _mnFILE_SYNC_DETAILS;

  /// put the sql keyword 'AND'
  @override
  FILE_SYNC_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  FILE_SYNC_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  FILE_SYNC_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  FILE_SYNC_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  FILE_SYNC_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  FILE_SYNC_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  FILE_SYNC_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FILE_SYNC_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FILE_SYNC_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FILE_SYNC_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FILE_SYNC_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  FILE_SYNC_DETAILSField _setField(
      FILE_SYNC_DETAILSField? field, String colName, DbType dbtype) {
    return FILE_SYNC_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  FILE_SYNC_DETAILSField? _CLIENT_TRANSACTION_ID;
  FILE_SYNC_DETAILSField get CLIENT_TRANSACTION_ID {
    return _CLIENT_TRANSACTION_ID = _setField(
        _CLIENT_TRANSACTION_ID, 'CLIENT_TRANSACTION_ID', DbType.integer);
  }

  FILE_SYNC_DETAILSField? _FILE_NAME;
  FILE_SYNC_DETAILSField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  FILE_SYNC_DETAILSField? _ZIP_FILE_NAME;
  FILE_SYNC_DETAILSField get ZIP_FILE_NAME {
    return _ZIP_FILE_NAME =
        _setField(_ZIP_FILE_NAME, 'ZIP_FILE_NAME', DbType.text);
  }

  FILE_SYNC_DETAILSField? _FILE_PATH;
  FILE_SYNC_DETAILSField get FILE_PATH {
    return _FILE_PATH = _setField(_FILE_PATH, 'FILE_PATH', DbType.text);
  }

  FILE_SYNC_DETAILSField? _SERVICE;
  FILE_SYNC_DETAILSField get SERVICE {
    return _SERVICE = _setField(_SERVICE, 'SERVICE', DbType.text);
  }

  FILE_SYNC_DETAILSField? _STATUS;
  FILE_SYNC_DETAILSField get STATUS {
    return _STATUS = _setField(_STATUS, 'STATUS', DbType.text);
  }

  FILE_SYNC_DETAILSField? _LAST_UPDATED_DT;
  FILE_SYNC_DETAILSField get LAST_UPDATED_DT {
    return _LAST_UPDATED_DT =
        _setField(_LAST_UPDATED_DT, 'LAST_UPDATED_DT', DbType.text);
  }

  FILE_SYNC_DETAILSField? _PROCESSED;
  FILE_SYNC_DETAILSField get PROCESSED {
    return _PROCESSED = _setField(_PROCESSED, 'PROCESSED', DbType.text);
  }

  /// Deletes List<FILE_SYNC_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnFILE_SYNC_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnFILE_SYNC_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'CLIENT_TRANSACTION_ID IN (SELECT CLIENT_TRANSACTION_ID from FILE_SYNC_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnFILE_SYNC_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [FILE_SYNC_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FILE_SYNC_DETAILS?
  @override
  Future<FILE_SYNC_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnFILE_SYNC_DETAILS!.toList(qparams);
    final data = await objFuture;
    FILE_SYNC_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = FILE_SYNC_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FILE_SYNC_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FILE_SYNC_DETAILS?
  @override
  Future<FILE_SYNC_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FILE_SYNC_DETAILS();
  }

  /// This method returns int. [FILE_SYNC_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? file_sync_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final file_sync_detailsesFuture =
        await _mnFILE_SYNC_DETAILS!.toList(qparams);
    final int count = file_sync_detailsesFuture[0]['CNT'] as int;
    if (file_sync_detailsCount != null) {
      file_sync_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<FILE_SYNC_DETAILS> [FILE_SYNC_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<FILE_SYNC_DETAILS>
  @override
  Future<List<FILE_SYNC_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FILE_SYNC_DETAILS> file_sync_detailsesData =
        await FILE_SYNC_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return file_sync_detailsesData;
  }

  /// This method returns Json String [FILE_SYNC_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FILE_SYNC_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FILE_SYNC_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnFILE_SYNC_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FILE_SYNC_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CLIENT_TRANSACTION_ID` FROM FILE_SYNC_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> CLIENT_TRANSACTION_IDData = <String>[];
    qparams.selectColumns = ['CLIENT_TRANSACTION_ID'];
    final CLIENT_TRANSACTION_IDFuture =
        await _mnFILE_SYNC_DETAILS!.toList(qparams);

    final int count = CLIENT_TRANSACTION_IDFuture.length;
    for (int i = 0; i < count; i++) {
      CLIENT_TRANSACTION_IDData.add(
          CLIENT_TRANSACTION_IDFuture[i]['CLIENT_TRANSACTION_ID'] as String);
    }
    return CLIENT_TRANSACTION_IDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FILE_SYNC_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnFILE_SYNC_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await FILE_SYNC_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnFILE_SYNC_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FILE_SYNC_DETAILSFilterBuilder

// region FILE_SYNC_DETAILSFields
class FILE_SYNC_DETAILSFields {
  static TableField? _fCLIENT_TRANSACTION_ID;
  static TableField get CLIENT_TRANSACTION_ID {
    return _fCLIENT_TRANSACTION_ID = _fCLIENT_TRANSACTION_ID ??
        SqlSyntax.setField(
            _fCLIENT_TRANSACTION_ID, 'client_transaction_id', DbType.integer);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }

  static TableField? _fZIP_FILE_NAME;
  static TableField get ZIP_FILE_NAME {
    return _fZIP_FILE_NAME = _fZIP_FILE_NAME ??
        SqlSyntax.setField(_fZIP_FILE_NAME, 'ZIP_FILE_NAME', DbType.text);
  }

  static TableField? _fFILE_PATH;
  static TableField get FILE_PATH {
    return _fFILE_PATH = _fFILE_PATH ??
        SqlSyntax.setField(_fFILE_PATH, 'FILE_PATH', DbType.text);
  }

  static TableField? _fSERVICE;
  static TableField get SERVICE {
    return _fSERVICE =
        _fSERVICE ?? SqlSyntax.setField(_fSERVICE, 'SERVICE', DbType.text);
  }

  static TableField? _fSTATUS;
  static TableField get STATUS {
    return _fSTATUS =
        _fSTATUS ?? SqlSyntax.setField(_fSTATUS, 'STATUS', DbType.text);
  }

  static TableField? _fLAST_UPDATED_DT;
  static TableField get LAST_UPDATED_DT {
    return _fLAST_UPDATED_DT = _fLAST_UPDATED_DT ??
        SqlSyntax.setField(_fLAST_UPDATED_DT, 'LAST_UPDATED_DT', DbType.text);
  }

  static TableField? _fPROCESSED;
  static TableField get PROCESSED {
    return _fPROCESSED = _fPROCESSED ??
        SqlSyntax.setField(_fPROCESSED, 'PROCESSED', DbType.text);
  }
}
// endregion FILE_SYNC_DETAILSFields

//region FILE_SYNC_DETAILSManager
class FILE_SYNC_DETAILSManager extends SqfEntityProvider {
  FILE_SYNC_DETAILSManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'FILE_SYNC_DETAILS';
  static const List<String> _primaryKeyList = ['CLIENT_TRANSACTION_ID'];
  static const String _whereStr = 'CLIENT_TRANSACTION_ID=?';
}

//endregion FILE_SYNC_DETAILSManager
// region VPPEMO
class VPPEMO extends TableBase {
  VPPEMO(
      {this.Sl,
      this.VP_ART,
      this.MONEY_TO_BE_COLLECTED,
      this.COMMISSION,
      this.DATE_OF_DELIVERY,
      this.EMO_NUMBER,
      this.REMARKS}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  VPPEMO.withFields(this.VP_ART, this.MONEY_TO_BE_COLLECTED, this.COMMISSION,
      this.DATE_OF_DELIVERY, this.EMO_NUMBER, this.REMARKS) {
    _setDefaultValues();
  }
  VPPEMO.withId(this.Sl, this.VP_ART, this.MONEY_TO_BE_COLLECTED,
      this.COMMISSION, this.DATE_OF_DELIVERY, this.EMO_NUMBER, this.REMARKS) {
    _setDefaultValues();
  }
  // fromMap v2.0
  VPPEMO.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['VP_ART'] != null) {
      VP_ART = o['VP_ART'].toString();
    }
    if (o['MONEY_TO_BE_COLLECTED'] != null) {
      MONEY_TO_BE_COLLECTED =
          double.tryParse(o['MONEY_TO_BE_COLLECTED'].toString());
    }
    if (o['COMMISSION'] != null) {
      COMMISSION = double.tryParse(o['COMMISSION'].toString());
    }
    if (o['DATE_OF_DELIVERY'] != null) {
      DATE_OF_DELIVERY = o['DATE_OF_DELIVERY'].toString();
    }
    if (o['EMO_NUMBER'] != null) {
      EMO_NUMBER = o['EMO_NUMBER'].toString();
    }
    if (o['REMARKS'] != null) {
      REMARKS = o['REMARKS'].toString();
    }
  }
  // FIELDS (VPPEMO)
  int? Sl;
  String? VP_ART;
  double? MONEY_TO_BE_COLLECTED;
  double? COMMISSION;
  String? DATE_OF_DELIVERY;
  String? EMO_NUMBER;
  String? REMARKS;

  // end FIELDS (VPPEMO)

  static const bool _softDeleteActivated = false;
  VPPEMOManager? __mnVPPEMO;

  VPPEMOManager get _mnVPPEMO {
    return __mnVPPEMO = __mnVPPEMO ?? VPPEMOManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (VP_ART != null || !forView) {
      map['VP_ART'] = VP_ART;
    }
    if (MONEY_TO_BE_COLLECTED != null || !forView) {
      map['MONEY_TO_BE_COLLECTED'] = MONEY_TO_BE_COLLECTED;
    }
    if (COMMISSION != null || !forView) {
      map['COMMISSION'] = COMMISSION;
    }
    if (DATE_OF_DELIVERY != null || !forView) {
      map['DATE_OF_DELIVERY'] = DATE_OF_DELIVERY;
    }
    if (EMO_NUMBER != null || !forView) {
      map['EMO_NUMBER'] = EMO_NUMBER;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (VP_ART != null || !forView) {
      map['VP_ART'] = VP_ART;
    }
    if (MONEY_TO_BE_COLLECTED != null || !forView) {
      map['MONEY_TO_BE_COLLECTED'] = MONEY_TO_BE_COLLECTED;
    }
    if (COMMISSION != null || !forView) {
      map['COMMISSION'] = COMMISSION;
    }
    if (DATE_OF_DELIVERY != null || !forView) {
      map['DATE_OF_DELIVERY'] = DATE_OF_DELIVERY;
    }
    if (EMO_NUMBER != null || !forView) {
      map['EMO_NUMBER'] = EMO_NUMBER;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }

    return map;
  }

  /// This method returns Json String [VPPEMO]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VPPEMO]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      VP_ART,
      MONEY_TO_BE_COLLECTED,
      COMMISSION,
      DATE_OF_DELIVERY,
      EMO_NUMBER,
      REMARKS
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      VP_ART,
      MONEY_TO_BE_COLLECTED,
      COMMISSION,
      DATE_OF_DELIVERY,
      EMO_NUMBER,
      REMARKS
    ];
  }

  static Future<List<VPPEMO>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VPPEMO.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<VPPEMO>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VPPEMO>[];
    try {
      objList = list
          .map((vppemo) => VPPEMO.fromMap(vppemo as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VPPEMO.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VPPEMO>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<VPPEMO> objList = <VPPEMO>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VPPEMO.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns VPPEMO by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [VPPEMO] if exist, otherwise returns null
  Future<VPPEMO?> getById(int? Sl,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    VPPEMO? obj;
    final data = await _mnVPPEMO.getById([Sl]);
    if (data.length != 0) {
      obj = VPPEMO.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (VPPEMO) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnVPPEMO.insert(this, ignoreBatch);
    } else {
      await _mnVPPEMO.update(this);
    }

    return Sl;
  }

  /// Saves the (VPPEMO) object. If the Sl field is null, saves as a new record and returns new Sl, if Sl is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns Sl
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (Sl == null || Sl == 0) {
      Sl = await _mnVPPEMO.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // Sl= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVPPEMO.updateOrThrow(this);
    }

    return Sl;
  }

  /// saveAs VPPEMO. Returns a new Primary Key value of VPPEMO

  /// <returns>Returns a new Primary Key value of VPPEMO
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    Sl = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<VPPEMO> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<VPPEMO> vppemos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await DeliveryModel().batchStart();
    for (final obj in vppemos) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await DeliveryModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < vppemos.length; i++) {
        if (vppemos[i].Sl == null) {
          vppemos[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVPPEMO.rawInsert(
          'INSERT OR REPLACE INTO VPPEMO (Sl, VP_ART, MONEY_TO_BE_COLLECTED, COMMISSION, DATE_OF_DELIVERY, EMO_NUMBER, REMARKS)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            VP_ART,
            MONEY_TO_BE_COLLECTED,
            COMMISSION,
            DATE_OF_DELIVERY,
            EMO_NUMBER,
            REMARKS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'VPPEMO Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'VPPEMO Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'VPPEMO Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVPPEMO.rawInsert(
          'INSERT OR IGNORE INTO VPPEMO (Sl, VP_ART, MONEY_TO_BE_COLLECTED, COMMISSION, DATE_OF_DELIVERY, EMO_NUMBER, REMARKS)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            VP_ART,
            MONEY_TO_BE_COLLECTED,
            COMMISSION,
            DATE_OF_DELIVERY,
            EMO_NUMBER,
            REMARKS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'VPPEMO Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'VPPEMO Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'VPPEMO Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<VPPEMO>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<VPPEMO> vppemos,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnVPPEMO.rawInsertAll(
        'INSERT OR REPLACE INTO VPPEMO (Sl, VP_ART, MONEY_TO_BE_COLLECTED, COMMISSION, DATE_OF_DELIVERY, EMO_NUMBER, REMARKS)  VALUES (?,?,?,?,?,?,?)',
        vppemos,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes VPPEMO

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete VPPEMO invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnVPPEMO
          .delete(QueryParams(whereString: 'Sl=?', whereArguments: [Sl]));
    } else {
      return _mnVPPEMO.updateBatch(
          QueryParams(whereString: 'Sl=?', whereArguments: [Sl]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [VPPEMO] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  VPPEMOFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VPPEMOFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VPPEMOFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VPPEMOFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vppemo

// region VPPEMOField
class VPPEMOField extends FilterBase {
  VPPEMOField(VPPEMOFilterBuilder vppemoFB) : super(vppemoFB);

  @override
  VPPEMOFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder isNull() {
    return super.isNull() as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VPPEMOFilterBuilder;
  }

  @override
  VPPEMOField get not {
    return super.not as VPPEMOField;
  }
}
// endregion VPPEMOField

// region VPPEMOFilterBuilder
class VPPEMOFilterBuilder extends ConjunctionBase {
  VPPEMOFilterBuilder(VPPEMO obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnVPPEMO = obj._mnVPPEMO;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  VPPEMOManager? _mnVPPEMO;

  /// put the sql keyword 'AND'
  @override
  VPPEMOFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VPPEMOFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VPPEMOFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VPPEMOFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VPPEMOFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VPPEMOFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VPPEMOFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VPPEMOFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VPPEMOFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VPPEMOFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VPPEMOFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VPPEMOField _setField(VPPEMOField? field, String colName, DbType dbtype) {
    return VPPEMOField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VPPEMOField? _Sl;
  VPPEMOField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  VPPEMOField? _VP_ART;
  VPPEMOField get VP_ART {
    return _VP_ART = _setField(_VP_ART, 'VP_ART', DbType.text);
  }

  VPPEMOField? _MONEY_TO_BE_COLLECTED;
  VPPEMOField get MONEY_TO_BE_COLLECTED {
    return _MONEY_TO_BE_COLLECTED =
        _setField(_MONEY_TO_BE_COLLECTED, 'MONEY_TO_BE_COLLECTED', DbType.real);
  }

  VPPEMOField? _COMMISSION;
  VPPEMOField get COMMISSION {
    return _COMMISSION = _setField(_COMMISSION, 'COMMISSION', DbType.real);
  }

  VPPEMOField? _DATE_OF_DELIVERY;
  VPPEMOField get DATE_OF_DELIVERY {
    return _DATE_OF_DELIVERY =
        _setField(_DATE_OF_DELIVERY, 'DATE_OF_DELIVERY', DbType.text);
  }

  VPPEMOField? _EMO_NUMBER;
  VPPEMOField get EMO_NUMBER {
    return _EMO_NUMBER = _setField(_EMO_NUMBER, 'EMO_NUMBER', DbType.text);
  }

  VPPEMOField? _REMARKS;
  VPPEMOField get REMARKS {
    return _REMARKS = _setField(_REMARKS, 'REMARKS', DbType.text);
  }

  /// Deletes List<VPPEMO> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnVPPEMO!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnVPPEMO!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from VPPEMO ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnVPPEMO!.updateBatch(qparams, values);
  }

  /// This method always returns [VPPEMO] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VPPEMO?
  @override
  Future<VPPEMO?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVPPEMO!.toList(qparams);
    final data = await objFuture;
    VPPEMO? obj;
    if (data.isNotEmpty) {
      obj = VPPEMO.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [VPPEMO]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VPPEMO?
  @override
  Future<VPPEMO> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        VPPEMO();
  }

  /// This method returns int. [VPPEMO]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? vppemoCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vppemosFuture = await _mnVPPEMO!.toList(qparams);
    final int count = vppemosFuture[0]['CNT'] as int;
    if (vppemoCount != null) {
      vppemoCount(count);
    }
    return count;
  }

  /// This method returns List<VPPEMO> [VPPEMO]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<VPPEMO>
  @override
  Future<List<VPPEMO>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<VPPEMO> vppemosData = await VPPEMO.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return vppemosData;
  }

  /// This method returns Json String [VPPEMO]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VPPEMO]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VPPEMO]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVPPEMO!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VPPEMO]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `Sl` FROM VPPEMO WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> SlData = <int>[];
    qparams.selectColumns = ['Sl'];
    final SlFuture = await _mnVPPEMO!.toList(qparams);

    final int count = SlFuture.length;
    for (int i = 0; i < count; i++) {
      SlData.add(SlFuture[i]['Sl'] as int);
    }
    return SlData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VPPEMO]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVPPEMO!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await VPPEMO.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVPPEMO!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VPPEMOFilterBuilder

// region VPPEMOFields
class VPPEMOFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fVP_ART;
  static TableField get VP_ART {
    return _fVP_ART =
        _fVP_ART ?? SqlSyntax.setField(_fVP_ART, 'VP_ART', DbType.text);
  }

  static TableField? _fMONEY_TO_BE_COLLECTED;
  static TableField get MONEY_TO_BE_COLLECTED {
    return _fMONEY_TO_BE_COLLECTED = _fMONEY_TO_BE_COLLECTED ??
        SqlSyntax.setField(
            _fMONEY_TO_BE_COLLECTED, 'MONEY_TO_BE_COLLECTED', DbType.real);
  }

  static TableField? _fCOMMISSION;
  static TableField get COMMISSION {
    return _fCOMMISSION = _fCOMMISSION ??
        SqlSyntax.setField(_fCOMMISSION, 'COMMISSION', DbType.real);
  }

  static TableField? _fDATE_OF_DELIVERY;
  static TableField get DATE_OF_DELIVERY {
    return _fDATE_OF_DELIVERY = _fDATE_OF_DELIVERY ??
        SqlSyntax.setField(_fDATE_OF_DELIVERY, 'DATE_OF_DELIVERY', DbType.text);
  }

  static TableField? _fEMO_NUMBER;
  static TableField get EMO_NUMBER {
    return _fEMO_NUMBER = _fEMO_NUMBER ??
        SqlSyntax.setField(_fEMO_NUMBER, 'EMO_NUMBER', DbType.text);
  }

  static TableField? _fREMARKS;
  static TableField get REMARKS {
    return _fREMARKS =
        _fREMARKS ?? SqlSyntax.setField(_fREMARKS, 'REMARKS', DbType.text);
  }
}
// endregion VPPEMOFields

//region VPPEMOManager
class VPPEMOManager extends SqfEntityProvider {
  VPPEMOManager()
      : super(DeliveryModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'VPPEMO';
  static const List<String> _primaryKeyList = ['Sl'];
  static const String _whereStr = 'Sl=?';
}

//endregion VPPEMOManager
class DeliveryModelSequenceManager extends SqfEntityProvider {
  DeliveryModelSequenceManager() : super(DeliveryModel());
}
// END OF ENTITIES
