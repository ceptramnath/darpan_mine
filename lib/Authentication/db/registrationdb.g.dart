// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'registrationdb.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:USERDETAILS.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// USERDETAILS TABLE
class TableUSERDETAILS extends SqfEntityTableBase {
  TableUSERDETAILS() {
    // declare properties of EntityTable
    tableName = 'USERDETAILS';
    primaryKeyName = 'EMPID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MobileNumber', DbType.text),
      SqfEntityFieldBase('IMEINumber', DbType.text),
      SqfEntityFieldBase('DeviceID', DbType.text),
      SqfEntityFieldBase('EmployeeEmail', DbType.text),
      SqfEntityFieldBase('EmployeeName', DbType.text),
      SqfEntityFieldBase('DOB', DbType.text),
      SqfEntityFieldBase('BOFacilityID', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.text),
      SqfEntityFieldBase('DOName', DbType.text),
      SqfEntityFieldBase('DOCode', DbType.text),
      SqfEntityFieldBase('ClientID', DbType.text),
      SqfEntityFieldBase('AppToken', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUSERDETAILS();
  }
}

// USERLOGINDETAILS TABLE
class TableUSERLOGINDETAILS extends SqfEntityTableBase {
  TableUSERLOGINDETAILS() {
    // declare properties of EntityTable
    tableName = 'USERLOGINDETAILS';
    primaryKeyName = 'EMPID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MobileNumber', DbType.text),
      SqfEntityFieldBase('IMEINumber', DbType.text),
      SqfEntityFieldBase('DeviceID', DbType.text),
      SqfEntityFieldBase('EmployeeEmail', DbType.text),
      SqfEntityFieldBase('EmployeeName', DbType.text),
      SqfEntityFieldBase('Password', DbType.text),
      SqfEntityFieldBase('AccessToken', DbType.text),
      SqfEntityFieldBase('RefreshToken', DbType.text),
      SqfEntityFieldBase('Validity', DbType.text),
      SqfEntityFieldBase('DOVerified', DbType.text),
      SqfEntityFieldBase('Active', DbType.bool, defaultValue: false),
      SqfEntityFieldBase('ClientID', DbType.text),
      SqfEntityFieldBase('AppToken', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUSERLOGINDETAILS();
  }
}

// USERVALIDATION TABLE
class TableUSERVALIDATION extends SqfEntityTableBase {
  TableUSERVALIDATION() {
    // declare properties of EntityTable
    tableName = 'USERVALIDATION';
    primaryKeyName = 'EMPID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MobileNumber', DbType.text),
      SqfEntityFieldBase('IMEINumber', DbType.text),
      SqfEntityFieldBase('DeviceID', DbType.text),
      SqfEntityFieldBase('EmployeeEmail', DbType.text),
      SqfEntityFieldBase('EmployeeName', DbType.text),
      SqfEntityFieldBase('Password', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.text),
      SqfEntityFieldBase('OTPVerified', DbType.text),
      SqfEntityFieldBase('Active', DbType.bool, defaultValue: false),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableUSERVALIDATION();
  }
}

// OFCMASTERDATA TABLE
class TableOFCMASTERDATA extends SqfEntityTableBase {
  TableOFCMASTERDATA() {
    // declare properties of EntityTable
    tableName = 'OFCMASTERDATA';
    primaryKeyName = 'EMPID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('MobileNumber', DbType.text),
      SqfEntityFieldBase('EmployeeEmail', DbType.text),
      SqfEntityFieldBase('EmployeeName', DbType.text),
      SqfEntityFieldBase('DOB', DbType.text),
      SqfEntityFieldBase('BOFacilityID', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('EMOCODE', DbType.text),
      SqfEntityFieldBase('SOLID', DbType.text),
      SqfEntityFieldBase('Pincode', DbType.text),
      SqfEntityFieldBase('AOName', DbType.text),
      SqfEntityFieldBase('AOCode', DbType.text),
      SqfEntityFieldBase('DOName', DbType.text),
      SqfEntityFieldBase('DOCode', DbType.text),
      SqfEntityFieldBase('OB', DbType.text),
      SqfEntityFieldBase('CASHINHAND', DbType.text),
      SqfEntityFieldBase('MINBAL', DbType.text),
      SqfEntityFieldBase('MAXBAL', DbType.text),
      SqfEntityFieldBase('POSTAMPBAL', DbType.text),
      SqfEntityFieldBase('REVSTAMPBAL', DbType.text),
      SqfEntityFieldBase('CRFSTAMPBAL', DbType.text),
      SqfEntityFieldBase('MAILSCHEDULE', DbType.text),
      SqfEntityFieldBase('PAIDLEAVE', DbType.text),
      SqfEntityFieldBase('EMGLEAVE', DbType.text),
      SqfEntityFieldBase('MATERNITYLEAVE', DbType.text),
      SqfEntityFieldBase('ONETIMECUSTCODE', DbType.text),
      SqfEntityFieldBase('FUTURE_USE1', DbType.text),
      SqfEntityFieldBase('FUTURE_USE2', DbType.text),
      SqfEntityFieldBase('FUTURE_USE3', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableOFCMASTERDATA();
  }
}

// FILEMASTERDATA TABLE
class TableFILEMASTERDATA extends SqfEntityTableBase {
  TableFILEMASTERDATA() {
    // declare properties of EntityTable
    tableName = 'FILEMASTERDATA';
    primaryKeyName = 'FILETYPE';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('DIVISION', DbType.text),
      SqfEntityFieldBase('ORDERTYPE_SP', DbType.text),
      SqfEntityFieldBase('ORDERTYPE_LETTERPARCEL', DbType.text),
      SqfEntityFieldBase('ORDERTYPE_EMO', DbType.text),
      SqfEntityFieldBase('PRODUCT_TYPE', DbType.text),
      SqfEntityFieldBase('MATERIALGROUP_SP', DbType.text),
      SqfEntityFieldBase('MATERIALGROUP_LETTER', DbType.text),
      SqfEntityFieldBase('MATERIALGROUP_EMO', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableFILEMASTERDATA();
  }
}

// PaySlipData TABLE
class TablePaySlipData extends SqfEntityTableBase {
  TablePaySlipData() {
    // declare properties of EntityTable
    tableName = 'PaySlipData';

    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('EMPLOYEE_ID', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('EMPLOYEE_NAME', DbType.text),
      SqfEntityFieldBase('OFFICE', DbType.text),
      SqfEntityFieldBase('POSITION', DbType.text),
      SqfEntityFieldBase('MONTH', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('YEAR', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('ACCOUNT_NUMBER', DbType.text),
      SqfEntityFieldBase('TRCA', DbType.text),
      SqfEntityFieldBase('DEARNESS_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('FIXED_STATIONERY_CHARGES', DbType.text),
      SqfEntityFieldBase('BOAT_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('CYCLE_MAINTENANCE_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('OFFICE_MAINTENANCE_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('CDA', DbType.text),
      SqfEntityFieldBase('COMBINATION_DELIVERY_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('COMPENSATION_MAIL_CARRIER', DbType.text),
      SqfEntityFieldBase('RETAINERSHIP_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('CASH_CONVEYANCE_ALLOWANCE', DbType.text),
      SqfEntityFieldBase('PERSONAL_ALLOWANCE_GDS', DbType.text),
      SqfEntityFieldBase('BONUS_GDS', DbType.text),
      SqfEntityFieldBase('EXGRATIA_GRATUITY', DbType.text),
      SqfEntityFieldBase('SEVERANCE_AMOUNT', DbType.text),
      SqfEntityFieldBase('INCENTIVES', DbType.text),
      SqfEntityFieldBase('DA_ARREARS_GDS', DbType.text),
      SqfEntityFieldBase('TOTAL_EARNINGS', DbType.text),
      SqfEntityFieldBase('TRCA_ALLOWANCE_ARREARS', DbType.text),
      SqfEntityFieldBase('DEARNESS_ALLOWANCE_ARREAR', DbType.text),
      SqfEntityFieldBase('DEARNESS_RELIEF_CDAARREAR', DbType.text),
      SqfEntityFieldBase('TOTAL_ARREARS', DbType.text),
      SqfEntityFieldBase('COURT_ATTACHMENT_ODFM', DbType.text),
      SqfEntityFieldBase('RD', DbType.text),
      SqfEntityFieldBase('COURT_ATTACHMENT_DFM', DbType.text),
      SqfEntityFieldBase('LICENSE_FEE', DbType.text),
      SqfEntityFieldBase('SDBS', DbType.text),
      SqfEntityFieldBase('AUDIT_OFFICE_RECOVERY', DbType.text),
      SqfEntityFieldBase('COOP_CREDIT_SOCIETY', DbType.text),
      SqfEntityFieldBase('RELIEF_FUND', DbType.text),
      SqfEntityFieldBase('DEATH_RELIEF_FUND', DbType.text),
      SqfEntityFieldBase('WATER_TAX', DbType.text),
      SqfEntityFieldBase('ELECTRICITY_CHARGES', DbType.text),
      SqfEntityFieldBase('AOR_NONTAX', DbType.text),
      SqfEntityFieldBase('POSTAL_RELIEF_FUND', DbType.text),
      SqfEntityFieldBase('PLI_PREMIUM', DbType.text),
      SqfEntityFieldBase('RECREATION_CLUB', DbType.text),
      SqfEntityFieldBase('UNION_ASSOCIATION', DbType.text),
      SqfEntityFieldBase('WELFARE_FUND', DbType.text),
      SqfEntityFieldBase('CGEGIS', DbType.text),
      SqfEntityFieldBase('CGHS', DbType.text),
      SqfEntityFieldBase('EDAGIS_92', DbType.text),
      SqfEntityFieldBase('LIC_PREMIUM', DbType.text),
      SqfEntityFieldBase('CGIS', DbType.text),
      SqfEntityFieldBase('RPLI', DbType.text),
      SqfEntityFieldBase('PLI_SERVICE_TAX', DbType.text),
      SqfEntityFieldBase('CONNECTIONS', DbType.text),
      SqfEntityFieldBase('CGEWCC', DbType.text),
      SqfEntityFieldBase('SOCIETIES', DbType.text),
      SqfEntityFieldBase('FNPO', DbType.text),
      SqfEntityFieldBase('ED_GIS', DbType.text),
      SqfEntityFieldBase('SECURITY_BONDS', DbType.text),
      SqfEntityFieldBase('EXTRA_DEPARTMENTAL_UNIONS', DbType.text),
      SqfEntityFieldBase('CGEGIS_INSURANCE_FUND', DbType.text),
      SqfEntityFieldBase('POSTAL_COOP_SOCIETY', DbType.text),
      SqfEntityFieldBase('COOP_BANK_REC', DbType.text),
      SqfEntityFieldBase('DIVISION_SPORTS_BOARD', DbType.text),
      SqfEntityFieldBase('MISC_DEDUCTIONS', DbType.text),
      SqfEntityFieldBase('BONDS', DbType.text),
      SqfEntityFieldBase('CWFGDS', DbType.text),
      SqfEntityFieldBase('FESTIVAL_ADVANCE_SPECIAL', DbType.text),
      SqfEntityFieldBase('TOTAL_DEDUCTIONS', DbType.text),
      SqfEntityFieldBase('TOTAL_GROSS_AMOUNT', DbType.text),
      SqfEntityFieldBase('NET_PAY', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TablePaySlipData();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class UserDB extends SqfEntityModelProvider {
  UserDB() {
    databaseName = formUserModel.databaseName;
    password = formUserModel.password;
    dbVersion = formUserModel.dbVersion;
    preSaveAction = formUserModel.preSaveAction;
    logFunction = formUserModel.logFunction;
    databaseTables = [
      TableUSERDETAILS.getInstance,
      TableUSERLOGINDETAILS.getInstance,
      TableUSERVALIDATION.getInstance,
      TableOFCMASTERDATA.getInstance,
      TableFILEMASTERDATA.getInstance,
      TablePaySlipData.getInstance,
    ];

    bundledDatabasePath = formUserModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = formUserModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region USERDETAILS
class USERDETAILS extends TableBase {
  USERDETAILS(
      {this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.Pincode,
      this.DOName,
      this.DOCode,
      this.ClientID,
      this.AppToken}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  USERDETAILS.withFields(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.Pincode,
      this.DOName,
      this.DOCode,
      this.ClientID,
      this.AppToken) {
    _setDefaultValues();
  }
  USERDETAILS.withId(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.Pincode,
      this.DOName,
      this.DOCode,
      this.ClientID,
      this.AppToken) {
    _setDefaultValues();
  }
  // fromMap v2.0
  USERDETAILS.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EMPID = o['EMPID'].toString();
    if (o['MobileNumber'] != null) {
      MobileNumber = o['MobileNumber'].toString();
    }
    if (o['IMEINumber'] != null) {
      IMEINumber = o['IMEINumber'].toString();
    }
    if (o['DeviceID'] != null) {
      DeviceID = o['DeviceID'].toString();
    }
    if (o['EmployeeEmail'] != null) {
      EmployeeEmail = o['EmployeeEmail'].toString();
    }
    if (o['EmployeeName'] != null) {
      EmployeeName = o['EmployeeName'].toString();
    }
    if (o['DOB'] != null) {
      DOB = o['DOB'].toString();
    }
    if (o['BOFacilityID'] != null) {
      BOFacilityID = o['BOFacilityID'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = o['Pincode'].toString();
    }
    if (o['DOName'] != null) {
      DOName = o['DOName'].toString();
    }
    if (o['DOCode'] != null) {
      DOCode = o['DOCode'].toString();
    }
    if (o['ClientID'] != null) {
      ClientID = o['ClientID'].toString();
    }
    if (o['AppToken'] != null) {
      AppToken = o['AppToken'].toString();
    }

    isSaved = true;
  }
  // FIELDS (USERDETAILS)
  String? EMPID;
  String? MobileNumber;
  String? IMEINumber;
  String? DeviceID;
  String? EmployeeEmail;
  String? EmployeeName;
  String? DOB;
  String? BOFacilityID;
  String? BOName;
  String? Pincode;
  String? DOName;
  String? DOCode;
  String? ClientID;
  String? AppToken;
  bool? isSaved;
  // end FIELDS (USERDETAILS)

  static const bool _softDeleteActivated = false;
  USERDETAILSManager? __mnUSERDETAILS;

  USERDETAILSManager get _mnUSERDETAILS {
    return __mnUSERDETAILS = __mnUSERDETAILS ?? USERDETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (DOB != null || !forView) {
      map['DOB'] = DOB;
    }
    if (BOFacilityID != null || !forView) {
      map['BOFacilityID'] = BOFacilityID;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (DOCode != null || !forView) {
      map['DOCode'] = DOCode;
    }
    if (ClientID != null || !forView) {
      map['ClientID'] = ClientID;
    }
    if (AppToken != null || !forView) {
      map['AppToken'] = AppToken;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (DOB != null || !forView) {
      map['DOB'] = DOB;
    }
    if (BOFacilityID != null || !forView) {
      map['BOFacilityID'] = BOFacilityID;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (DOCode != null || !forView) {
      map['DOCode'] = DOCode;
    }
    if (ClientID != null || !forView) {
      map['ClientID'] = ClientID;
    }
    if (AppToken != null || !forView) {
      map['AppToken'] = AppToken;
    }

    return map;
  }

  /// This method returns Json String [USERDETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [USERDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      DOB,
      BOFacilityID,
      BOName,
      Pincode,
      DOName,
      DOCode,
      ClientID,
      AppToken
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      DOB,
      BOFacilityID,
      BOName,
      Pincode,
      DOName,
      DOCode,
      ClientID,
      AppToken
    ];
  }

  static Future<List<USERDETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERDETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<USERDETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <USERDETAILS>[];
    try {
      objList = list
          .map((userdetails) =>
              USERDETAILS.fromMap(userdetails as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERDETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<USERDETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<USERDETAILS> objList = <USERDETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = USERDETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns USERDETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? EMPID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [USERDETAILS] if exist, otherwise returns null
  Future<USERDETAILS?> getById(String? EMPID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EMPID == null) {
      return null;
    }
    USERDETAILS? obj;
    final data = await _mnUSERDETAILS.getById([EMPID]);
    if (data.length != 0) {
      obj = USERDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (USERDETAILS) object. If the Primary Key (EMPID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EMPID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnUSERDETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO USERDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, Pincode, DOName, DOCode, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<USERDETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<USERDETAILS> userdetailses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in userdetailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERDETAILS.rawInsert(
          'INSERT OR REPLACE INTO USERDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, Pincode, DOName, DOCode, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            DOB,
            BOFacilityID,
            BOName,
            Pincode,
            DOName,
            DOCode,
            ClientID,
            AppToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'USERDETAILS EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERDETAILS EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERDETAILS.rawInsert(
          'INSERT OR IGNORE INTO USERDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, Pincode, DOName, DOCode, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            DOB,
            BOFacilityID,
            BOName,
            Pincode,
            DOName,
            DOCode,
            ClientID,
            AppToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'USERDETAILS EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERDETAILS EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes USERDETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete USERDETAILS invoked (EMPID=$EMPID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUSERDETAILS
          .delete(QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]));
    } else {
      return _mnUSERDETAILS.updateBatch(
          QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [USERDETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  USERDETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  USERDETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EMPID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion userdetails

// region USERDETAILSField
class USERDETAILSField extends FilterBase {
  USERDETAILSField(USERDETAILSFilterBuilder userdetailsFB)
      : super(userdetailsFB);

  @override
  USERDETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder isNull() {
    return super.isNull() as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as USERDETAILSFilterBuilder;
  }

  @override
  USERDETAILSField get not {
    return super.not as USERDETAILSField;
  }
}
// endregion USERDETAILSField

// region USERDETAILSFilterBuilder
class USERDETAILSFilterBuilder extends ConjunctionBase {
  USERDETAILSFilterBuilder(USERDETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUSERDETAILS = obj._mnUSERDETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  USERDETAILSManager? _mnUSERDETAILS;

  /// put the sql keyword 'AND'
  @override
  USERDETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  USERDETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  USERDETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  USERDETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  USERDETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  USERDETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  USERDETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERDETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERDETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERDETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERDETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  USERDETAILSField _setField(
      USERDETAILSField? field, String colName, DbType dbtype) {
    return USERDETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  USERDETAILSField? _EMPID;
  USERDETAILSField get EMPID {
    return _EMPID = _setField(_EMPID, 'EMPID', DbType.integer);
  }

  USERDETAILSField? _MobileNumber;
  USERDETAILSField get MobileNumber {
    return _MobileNumber =
        _setField(_MobileNumber, 'MobileNumber', DbType.text);
  }

  USERDETAILSField? _IMEINumber;
  USERDETAILSField get IMEINumber {
    return _IMEINumber = _setField(_IMEINumber, 'IMEINumber', DbType.text);
  }

  USERDETAILSField? _DeviceID;
  USERDETAILSField get DeviceID {
    return _DeviceID = _setField(_DeviceID, 'DeviceID', DbType.text);
  }

  USERDETAILSField? _EmployeeEmail;
  USERDETAILSField get EmployeeEmail {
    return _EmployeeEmail =
        _setField(_EmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  USERDETAILSField? _EmployeeName;
  USERDETAILSField get EmployeeName {
    return _EmployeeName =
        _setField(_EmployeeName, 'EmployeeName', DbType.text);
  }

  USERDETAILSField? _DOB;
  USERDETAILSField get DOB {
    return _DOB = _setField(_DOB, 'DOB', DbType.text);
  }

  USERDETAILSField? _BOFacilityID;
  USERDETAILSField get BOFacilityID {
    return _BOFacilityID =
        _setField(_BOFacilityID, 'BOFacilityID', DbType.text);
  }

  USERDETAILSField? _BOName;
  USERDETAILSField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  USERDETAILSField? _Pincode;
  USERDETAILSField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.text);
  }

  USERDETAILSField? _DOName;
  USERDETAILSField get DOName {
    return _DOName = _setField(_DOName, 'DOName', DbType.text);
  }

  USERDETAILSField? _DOCode;
  USERDETAILSField get DOCode {
    return _DOCode = _setField(_DOCode, 'DOCode', DbType.text);
  }

  USERDETAILSField? _ClientID;
  USERDETAILSField get ClientID {
    return _ClientID = _setField(_ClientID, 'ClientID', DbType.text);
  }

  USERDETAILSField? _AppToken;
  USERDETAILSField get AppToken {
    return _AppToken = _setField(_AppToken, 'AppToken', DbType.text);
  }

  /// Deletes List<USERDETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUSERDETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUSERDETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EMPID IN (SELECT EMPID from USERDETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUSERDETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [USERDETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERDETAILS?
  @override
  Future<USERDETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUSERDETAILS!.toList(qparams);
    final data = await objFuture;
    USERDETAILS? obj;
    if (data.isNotEmpty) {
      obj = USERDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [USERDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERDETAILS?
  @override
  Future<USERDETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        USERDETAILS();
  }

  /// This method returns int. [USERDETAILS]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? userdetailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final userdetailsesFuture = await _mnUSERDETAILS!.toList(qparams);
    final int count = userdetailsesFuture[0]['CNT'] as int;
    if (userdetailsCount != null) {
      userdetailsCount(count);
    }
    return count;
  }

  /// This method returns List<USERDETAILS> [USERDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<USERDETAILS>
  @override
  Future<List<USERDETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<USERDETAILS> userdetailsesData = await USERDETAILS.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return userdetailsesData;
  }

  /// This method returns Json String [USERDETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [USERDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [USERDETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUSERDETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [USERDETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EMPID` FROM USERDETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> EMPIDData = <String>[];
    qparams.selectColumns = ['EMPID'];
    final EMPIDFuture = await _mnUSERDETAILS!.toList(qparams);

    final int count = EMPIDFuture.length;
    for (int i = 0; i < count; i++) {
      EMPIDData.add(EMPIDFuture[i]['EMPID'] as String);
    }
    return EMPIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [USERDETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUSERDETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await USERDETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUSERDETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion USERDETAILSFilterBuilder

// region USERDETAILSFields
class USERDETAILSFields {
  static TableField? _fEMPID;
  static TableField get EMPID {
    return _fEMPID =
        _fEMPID ?? SqlSyntax.setField(_fEMPID, 'empid', DbType.integer);
  }

  static TableField? _fMobileNumber;
  static TableField get MobileNumber {
    return _fMobileNumber = _fMobileNumber ??
        SqlSyntax.setField(_fMobileNumber, 'MobileNumber', DbType.text);
  }

  static TableField? _fIMEINumber;
  static TableField get IMEINumber {
    return _fIMEINumber = _fIMEINumber ??
        SqlSyntax.setField(_fIMEINumber, 'IMEINumber', DbType.text);
  }

  static TableField? _fDeviceID;
  static TableField get DeviceID {
    return _fDeviceID =
        _fDeviceID ?? SqlSyntax.setField(_fDeviceID, 'DeviceID', DbType.text);
  }

  static TableField? _fEmployeeEmail;
  static TableField get EmployeeEmail {
    return _fEmployeeEmail = _fEmployeeEmail ??
        SqlSyntax.setField(_fEmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  static TableField? _fEmployeeName;
  static TableField get EmployeeName {
    return _fEmployeeName = _fEmployeeName ??
        SqlSyntax.setField(_fEmployeeName, 'EmployeeName', DbType.text);
  }

  static TableField? _fDOB;
  static TableField get DOB {
    return _fDOB = _fDOB ?? SqlSyntax.setField(_fDOB, 'DOB', DbType.text);
  }

  static TableField? _fBOFacilityID;
  static TableField get BOFacilityID {
    return _fBOFacilityID = _fBOFacilityID ??
        SqlSyntax.setField(_fBOFacilityID, 'BOFacilityID', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.text);
  }

  static TableField? _fDOName;
  static TableField get DOName {
    return _fDOName =
        _fDOName ?? SqlSyntax.setField(_fDOName, 'DOName', DbType.text);
  }

  static TableField? _fDOCode;
  static TableField get DOCode {
    return _fDOCode =
        _fDOCode ?? SqlSyntax.setField(_fDOCode, 'DOCode', DbType.text);
  }

  static TableField? _fClientID;
  static TableField get ClientID {
    return _fClientID =
        _fClientID ?? SqlSyntax.setField(_fClientID, 'ClientID', DbType.text);
  }

  static TableField? _fAppToken;
  static TableField get AppToken {
    return _fAppToken =
        _fAppToken ?? SqlSyntax.setField(_fAppToken, 'AppToken', DbType.text);
  }
}
// endregion USERDETAILSFields

//region USERDETAILSManager
class USERDETAILSManager extends SqfEntityProvider {
  USERDETAILSManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'USERDETAILS';
  static const List<String> _primaryKeyList = ['EMPID'];
  static const String _whereStr = 'EMPID=?';
}

//endregion USERDETAILSManager
// region USERLOGINDETAILS
class USERLOGINDETAILS extends TableBase {
  USERLOGINDETAILS(
      {this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.AccessToken,
      this.RefreshToken,
      this.Validity,
      this.DOVerified,
      this.Active,
      this.ClientID,
      this.AppToken}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  USERLOGINDETAILS.withFields(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.AccessToken,
      this.RefreshToken,
      this.Validity,
      this.DOVerified,
      this.Active,
      this.ClientID,
      this.AppToken) {
    _setDefaultValues();
  }
  USERLOGINDETAILS.withId(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.AccessToken,
      this.RefreshToken,
      this.Validity,
      this.DOVerified,
      this.Active,
      this.ClientID,
      this.AppToken) {
    _setDefaultValues();
  }
  // fromMap v2.0
  USERLOGINDETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EMPID = o['EMPID'].toString();
    if (o['MobileNumber'] != null) {
      MobileNumber = o['MobileNumber'].toString();
    }
    if (o['IMEINumber'] != null) {
      IMEINumber = o['IMEINumber'].toString();
    }
    if (o['DeviceID'] != null) {
      DeviceID = o['DeviceID'].toString();
    }
    if (o['EmployeeEmail'] != null) {
      EmployeeEmail = o['EmployeeEmail'].toString();
    }
    if (o['EmployeeName'] != null) {
      EmployeeName = o['EmployeeName'].toString();
    }
    if (o['Password'] != null) {
      Password = o['Password'].toString();
    }
    if (o['AccessToken'] != null) {
      AccessToken = o['AccessToken'].toString();
    }
    if (o['RefreshToken'] != null) {
      RefreshToken = o['RefreshToken'].toString();
    }
    if (o['Validity'] != null) {
      Validity = o['Validity'].toString();
    }
    if (o['DOVerified'] != null) {
      DOVerified = o['DOVerified'].toString();
    }
    if (o['Active'] != null) {
      Active =
          o['Active'].toString() == '1' || o['Active'].toString() == 'true';
    }
    if (o['ClientID'] != null) {
      ClientID = o['ClientID'].toString();
    }
    if (o['AppToken'] != null) {
      AppToken = o['AppToken'].toString();
    }

    isSaved = true;
  }
  // FIELDS (USERLOGINDETAILS)
  String? EMPID;
  String? MobileNumber;
  String? IMEINumber;
  String? DeviceID;
  String? EmployeeEmail;
  String? EmployeeName;
  String? Password;
  String? AccessToken;
  String? RefreshToken;
  String? Validity;
  String? DOVerified;
  bool? Active;
  String? ClientID;
  String? AppToken;
  bool? isSaved;
  // end FIELDS (USERLOGINDETAILS)

  static const bool _softDeleteActivated = false;
  USERLOGINDETAILSManager? __mnUSERLOGINDETAILS;

  USERLOGINDETAILSManager get _mnUSERLOGINDETAILS {
    return __mnUSERLOGINDETAILS =
        __mnUSERLOGINDETAILS ?? USERLOGINDETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (Password != null || !forView) {
      map['Password'] = Password;
    }
    if (AccessToken != null || !forView) {
      map['AccessToken'] = AccessToken;
    }
    if (RefreshToken != null || !forView) {
      map['RefreshToken'] = RefreshToken;
    }
    if (Validity != null || !forView) {
      map['Validity'] = Validity;
    }
    if (DOVerified != null || !forView) {
      map['DOVerified'] = DOVerified;
    }
    if (Active != null) {
      map['Active'] = forQuery ? (Active! ? 1 : 0) : Active;
    } else if (Active != null || !forView) {
      map['Active'] = null;
    }
    if (ClientID != null || !forView) {
      map['ClientID'] = ClientID;
    }
    if (AppToken != null || !forView) {
      map['AppToken'] = AppToken;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (Password != null || !forView) {
      map['Password'] = Password;
    }
    if (AccessToken != null || !forView) {
      map['AccessToken'] = AccessToken;
    }
    if (RefreshToken != null || !forView) {
      map['RefreshToken'] = RefreshToken;
    }
    if (Validity != null || !forView) {
      map['Validity'] = Validity;
    }
    if (DOVerified != null || !forView) {
      map['DOVerified'] = DOVerified;
    }
    if (Active != null) {
      map['Active'] = forQuery ? (Active! ? 1 : 0) : Active;
    } else if (Active != null || !forView) {
      map['Active'] = null;
    }
    if (ClientID != null || !forView) {
      map['ClientID'] = ClientID;
    }
    if (AppToken != null || !forView) {
      map['AppToken'] = AppToken;
    }

    return map;
  }

  /// This method returns Json String [USERLOGINDETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [USERLOGINDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      Password,
      AccessToken,
      RefreshToken,
      Validity,
      DOVerified,
      Active,
      ClientID,
      AppToken
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      Password,
      AccessToken,
      RefreshToken,
      Validity,
      DOVerified,
      Active,
      ClientID,
      AppToken
    ];
  }

  static Future<List<USERLOGINDETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERLOGINDETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<USERLOGINDETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <USERLOGINDETAILS>[];
    try {
      objList = list
          .map((userlogindetails) => USERLOGINDETAILS
              .fromMap(userlogindetails as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERLOGINDETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<USERLOGINDETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<USERLOGINDETAILS> objList = <USERLOGINDETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = USERLOGINDETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns USERLOGINDETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? EMPID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [USERLOGINDETAILS] if exist, otherwise returns null
  Future<USERLOGINDETAILS?> getById(String? EMPID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EMPID == null) {
      return null;
    }
    USERLOGINDETAILS? obj;
    final data = await _mnUSERLOGINDETAILS.getById([EMPID]);
    if (data.length != 0) {
      obj = USERLOGINDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (USERLOGINDETAILS) object. If the Primary Key (EMPID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EMPID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnUSERLOGINDETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO USERLOGINDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, AccessToken, RefreshToken, Validity, DOVerified, Active, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<USERLOGINDETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<USERLOGINDETAILS> userlogindetailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in userlogindetailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERLOGINDETAILS.rawInsert(
          'INSERT OR REPLACE INTO USERLOGINDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, AccessToken, RefreshToken, Validity, DOVerified, Active, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            Password,
            AccessToken,
            RefreshToken,
            Validity,
            DOVerified,
            Active,
            ClientID,
            AppToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'USERLOGINDETAILS EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERLOGINDETAILS EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERLOGINDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERLOGINDETAILS.rawInsert(
          'INSERT OR IGNORE INTO USERLOGINDETAILS (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, AccessToken, RefreshToken, Validity, DOVerified, Active, ClientID, AppToken)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            Password,
            AccessToken,
            RefreshToken,
            Validity,
            DOVerified,
            Active,
            ClientID,
            AppToken
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'USERLOGINDETAILS EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERLOGINDETAILS EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERLOGINDETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes USERLOGINDETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete USERLOGINDETAILS invoked (EMPID=$EMPID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUSERLOGINDETAILS
          .delete(QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]));
    } else {
      return _mnUSERLOGINDETAILS.updateBatch(
          QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [USERLOGINDETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  USERLOGINDETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERLOGINDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  USERLOGINDETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERLOGINDETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    Active = Active ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EMPID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion userlogindetails

// region USERLOGINDETAILSField
class USERLOGINDETAILSField extends FilterBase {
  USERLOGINDETAILSField(USERLOGINDETAILSFilterBuilder userlogindetailsFB)
      : super(userlogindetailsFB);

  @override
  USERLOGINDETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder isNull() {
    return super.isNull() as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as USERLOGINDETAILSFilterBuilder;
  }

  @override
  USERLOGINDETAILSField get not {
    return super.not as USERLOGINDETAILSField;
  }
}
// endregion USERLOGINDETAILSField

// region USERLOGINDETAILSFilterBuilder
class USERLOGINDETAILSFilterBuilder extends ConjunctionBase {
  USERLOGINDETAILSFilterBuilder(USERLOGINDETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUSERLOGINDETAILS = obj._mnUSERLOGINDETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  USERLOGINDETAILSManager? _mnUSERLOGINDETAILS;

  /// put the sql keyword 'AND'
  @override
  USERLOGINDETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  USERLOGINDETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  USERLOGINDETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  USERLOGINDETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  USERLOGINDETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  USERLOGINDETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  USERLOGINDETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERLOGINDETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERLOGINDETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERLOGINDETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERLOGINDETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  USERLOGINDETAILSField _setField(
      USERLOGINDETAILSField? field, String colName, DbType dbtype) {
    return USERLOGINDETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  USERLOGINDETAILSField? _EMPID;
  USERLOGINDETAILSField get EMPID {
    return _EMPID = _setField(_EMPID, 'EMPID', DbType.integer);
  }

  USERLOGINDETAILSField? _MobileNumber;
  USERLOGINDETAILSField get MobileNumber {
    return _MobileNumber =
        _setField(_MobileNumber, 'MobileNumber', DbType.text);
  }

  USERLOGINDETAILSField? _IMEINumber;
  USERLOGINDETAILSField get IMEINumber {
    return _IMEINumber = _setField(_IMEINumber, 'IMEINumber', DbType.text);
  }

  USERLOGINDETAILSField? _DeviceID;
  USERLOGINDETAILSField get DeviceID {
    return _DeviceID = _setField(_DeviceID, 'DeviceID', DbType.text);
  }

  USERLOGINDETAILSField? _EmployeeEmail;
  USERLOGINDETAILSField get EmployeeEmail {
    return _EmployeeEmail =
        _setField(_EmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  USERLOGINDETAILSField? _EmployeeName;
  USERLOGINDETAILSField get EmployeeName {
    return _EmployeeName =
        _setField(_EmployeeName, 'EmployeeName', DbType.text);
  }

  USERLOGINDETAILSField? _Password;
  USERLOGINDETAILSField get Password {
    return _Password = _setField(_Password, 'Password', DbType.text);
  }

  USERLOGINDETAILSField? _AccessToken;
  USERLOGINDETAILSField get AccessToken {
    return _AccessToken = _setField(_AccessToken, 'AccessToken', DbType.text);
  }

  USERLOGINDETAILSField? _RefreshToken;
  USERLOGINDETAILSField get RefreshToken {
    return _RefreshToken =
        _setField(_RefreshToken, 'RefreshToken', DbType.text);
  }

  USERLOGINDETAILSField? _Validity;
  USERLOGINDETAILSField get Validity {
    return _Validity = _setField(_Validity, 'Validity', DbType.text);
  }

  USERLOGINDETAILSField? _DOVerified;
  USERLOGINDETAILSField get DOVerified {
    return _DOVerified = _setField(_DOVerified, 'DOVerified', DbType.text);
  }

  USERLOGINDETAILSField? _Active;
  USERLOGINDETAILSField get Active {
    return _Active = _setField(_Active, 'Active', DbType.bool);
  }

  USERLOGINDETAILSField? _ClientID;
  USERLOGINDETAILSField get ClientID {
    return _ClientID = _setField(_ClientID, 'ClientID', DbType.text);
  }

  USERLOGINDETAILSField? _AppToken;
  USERLOGINDETAILSField get AppToken {
    return _AppToken = _setField(_AppToken, 'AppToken', DbType.text);
  }

  /// Deletes List<USERLOGINDETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUSERLOGINDETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUSERLOGINDETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EMPID IN (SELECT EMPID from USERLOGINDETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUSERLOGINDETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [USERLOGINDETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERLOGINDETAILS?
  @override
  Future<USERLOGINDETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUSERLOGINDETAILS!.toList(qparams);
    final data = await objFuture;
    USERLOGINDETAILS? obj;
    if (data.isNotEmpty) {
      obj = USERLOGINDETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [USERLOGINDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERLOGINDETAILS?
  @override
  Future<USERLOGINDETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        USERLOGINDETAILS();
  }

  /// This method returns int. [USERLOGINDETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? userlogindetailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final userlogindetailsesFuture = await _mnUSERLOGINDETAILS!.toList(qparams);
    final int count = userlogindetailsesFuture[0]['CNT'] as int;
    if (userlogindetailsCount != null) {
      userlogindetailsCount(count);
    }
    return count;
  }

  /// This method returns List<USERLOGINDETAILS> [USERLOGINDETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<USERLOGINDETAILS>
  @override
  Future<List<USERLOGINDETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<USERLOGINDETAILS> userlogindetailsesData =
        await USERLOGINDETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return userlogindetailsesData;
  }

  /// This method returns Json String [USERLOGINDETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [USERLOGINDETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [USERLOGINDETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUSERLOGINDETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [USERLOGINDETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EMPID` FROM USERLOGINDETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> EMPIDData = <String>[];
    qparams.selectColumns = ['EMPID'];
    final EMPIDFuture = await _mnUSERLOGINDETAILS!.toList(qparams);

    final int count = EMPIDFuture.length;
    for (int i = 0; i < count; i++) {
      EMPIDData.add(EMPIDFuture[i]['EMPID'] as String);
    }
    return EMPIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [USERLOGINDETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUSERLOGINDETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await USERLOGINDETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUSERLOGINDETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion USERLOGINDETAILSFilterBuilder

// region USERLOGINDETAILSFields
class USERLOGINDETAILSFields {
  static TableField? _fEMPID;
  static TableField get EMPID {
    return _fEMPID =
        _fEMPID ?? SqlSyntax.setField(_fEMPID, 'empid', DbType.integer);
  }

  static TableField? _fMobileNumber;
  static TableField get MobileNumber {
    return _fMobileNumber = _fMobileNumber ??
        SqlSyntax.setField(_fMobileNumber, 'MobileNumber', DbType.text);
  }

  static TableField? _fIMEINumber;
  static TableField get IMEINumber {
    return _fIMEINumber = _fIMEINumber ??
        SqlSyntax.setField(_fIMEINumber, 'IMEINumber', DbType.text);
  }

  static TableField? _fDeviceID;
  static TableField get DeviceID {
    return _fDeviceID =
        _fDeviceID ?? SqlSyntax.setField(_fDeviceID, 'DeviceID', DbType.text);
  }

  static TableField? _fEmployeeEmail;
  static TableField get EmployeeEmail {
    return _fEmployeeEmail = _fEmployeeEmail ??
        SqlSyntax.setField(_fEmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  static TableField? _fEmployeeName;
  static TableField get EmployeeName {
    return _fEmployeeName = _fEmployeeName ??
        SqlSyntax.setField(_fEmployeeName, 'EmployeeName', DbType.text);
  }

  static TableField? _fPassword;
  static TableField get Password {
    return _fPassword =
        _fPassword ?? SqlSyntax.setField(_fPassword, 'Password', DbType.text);
  }

  static TableField? _fAccessToken;
  static TableField get AccessToken {
    return _fAccessToken = _fAccessToken ??
        SqlSyntax.setField(_fAccessToken, 'AccessToken', DbType.text);
  }

  static TableField? _fRefreshToken;
  static TableField get RefreshToken {
    return _fRefreshToken = _fRefreshToken ??
        SqlSyntax.setField(_fRefreshToken, 'RefreshToken', DbType.text);
  }

  static TableField? _fValidity;
  static TableField get Validity {
    return _fValidity =
        _fValidity ?? SqlSyntax.setField(_fValidity, 'Validity', DbType.text);
  }

  static TableField? _fDOVerified;
  static TableField get DOVerified {
    return _fDOVerified = _fDOVerified ??
        SqlSyntax.setField(_fDOVerified, 'DOVerified', DbType.text);
  }

  static TableField? _fActive;
  static TableField get Active {
    return _fActive =
        _fActive ?? SqlSyntax.setField(_fActive, 'Active', DbType.bool);
  }

  static TableField? _fClientID;
  static TableField get ClientID {
    return _fClientID =
        _fClientID ?? SqlSyntax.setField(_fClientID, 'ClientID', DbType.text);
  }

  static TableField? _fAppToken;
  static TableField get AppToken {
    return _fAppToken =
        _fAppToken ?? SqlSyntax.setField(_fAppToken, 'AppToken', DbType.text);
  }
}
// endregion USERLOGINDETAILSFields

//region USERLOGINDETAILSManager
class USERLOGINDETAILSManager extends SqfEntityProvider {
  USERLOGINDETAILSManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'USERLOGINDETAILS';
  static const List<String> _primaryKeyList = ['EMPID'];
  static const String _whereStr = 'EMPID=?';
}

//endregion USERLOGINDETAILSManager
// region USERVALIDATION
class USERVALIDATION extends TableBase {
  USERVALIDATION(
      {this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.Pincode,
      this.OTPVerified,
      this.Active}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  USERVALIDATION.withFields(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.Pincode,
      this.OTPVerified,
      this.Active) {
    _setDefaultValues();
  }
  USERVALIDATION.withId(
      this.EMPID,
      this.MobileNumber,
      this.IMEINumber,
      this.DeviceID,
      this.EmployeeEmail,
      this.EmployeeName,
      this.Password,
      this.Pincode,
      this.OTPVerified,
      this.Active) {
    _setDefaultValues();
  }
  // fromMap v2.0
  USERVALIDATION.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EMPID = o['EMPID'].toString();
    if (o['MobileNumber'] != null) {
      MobileNumber = o['MobileNumber'].toString();
    }
    if (o['IMEINumber'] != null) {
      IMEINumber = o['IMEINumber'].toString();
    }
    if (o['DeviceID'] != null) {
      DeviceID = o['DeviceID'].toString();
    }
    if (o['EmployeeEmail'] != null) {
      EmployeeEmail = o['EmployeeEmail'].toString();
    }
    if (o['EmployeeName'] != null) {
      EmployeeName = o['EmployeeName'].toString();
    }
    if (o['Password'] != null) {
      Password = o['Password'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = o['Pincode'].toString();
    }
    if (o['OTPVerified'] != null) {
      OTPVerified = o['OTPVerified'].toString();
    }
    if (o['Active'] != null) {
      Active =
          o['Active'].toString() == '1' || o['Active'].toString() == 'true';
    }

    isSaved = true;
  }
  // FIELDS (USERVALIDATION)
  String? EMPID;
  String? MobileNumber;
  String? IMEINumber;
  String? DeviceID;
  String? EmployeeEmail;
  String? EmployeeName;
  String? Password;
  String? Pincode;
  String? OTPVerified;
  bool? Active;
  bool? isSaved;
  // end FIELDS (USERVALIDATION)

  static const bool _softDeleteActivated = false;
  USERVALIDATIONManager? __mnUSERVALIDATION;

  USERVALIDATIONManager get _mnUSERVALIDATION {
    return __mnUSERVALIDATION = __mnUSERVALIDATION ?? USERVALIDATIONManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (Password != null || !forView) {
      map['Password'] = Password;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (OTPVerified != null || !forView) {
      map['OTPVerified'] = OTPVerified;
    }
    if (Active != null) {
      map['Active'] = forQuery ? (Active! ? 1 : 0) : Active;
    } else if (Active != null || !forView) {
      map['Active'] = null;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (IMEINumber != null || !forView) {
      map['IMEINumber'] = IMEINumber;
    }
    if (DeviceID != null || !forView) {
      map['DeviceID'] = DeviceID;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (Password != null || !forView) {
      map['Password'] = Password;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (OTPVerified != null || !forView) {
      map['OTPVerified'] = OTPVerified;
    }
    if (Active != null) {
      map['Active'] = forQuery ? (Active! ? 1 : 0) : Active;
    } else if (Active != null || !forView) {
      map['Active'] = null;
    }

    return map;
  }

  /// This method returns Json String [USERVALIDATION]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [USERVALIDATION]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      Password,
      Pincode,
      OTPVerified,
      Active
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EMPID,
      MobileNumber,
      IMEINumber,
      DeviceID,
      EmployeeEmail,
      EmployeeName,
      Password,
      Pincode,
      OTPVerified,
      Active
    ];
  }

  static Future<List<USERVALIDATION>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERVALIDATION.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<USERVALIDATION>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <USERVALIDATION>[];
    try {
      objList = list
          .map((uservalidation) =>
              USERVALIDATION.fromMap(uservalidation as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR USERVALIDATION.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<USERVALIDATION>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<USERVALIDATION> objList = <USERVALIDATION>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = USERVALIDATION.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns USERVALIDATION by ID if exist, otherwise returns null
  /// Primary Keys: String? EMPID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [USERVALIDATION] if exist, otherwise returns null
  Future<USERVALIDATION?> getById(String? EMPID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EMPID == null) {
      return null;
    }
    USERVALIDATION? obj;
    final data = await _mnUSERVALIDATION.getById([EMPID]);
    if (data.length != 0) {
      obj = USERVALIDATION.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (USERVALIDATION) object. If the Primary Key (EMPID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EMPID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnUSERVALIDATION.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO USERVALIDATION (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, Pincode, OTPVerified, Active)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<USERVALIDATION> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<USERVALIDATION> uservalidations,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in uservalidations) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERVALIDATION.rawInsert(
          'INSERT OR REPLACE INTO USERVALIDATION (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, Pincode, OTPVerified, Active)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            Password,
            Pincode,
            OTPVerified,
            Active
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'USERVALIDATION EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERVALIDATION EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERVALIDATION Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnUSERVALIDATION.rawInsert(
          'INSERT OR IGNORE INTO USERVALIDATION (EMPID, MobileNumber, IMEINumber, DeviceID, EmployeeEmail, EmployeeName, Password, Pincode, OTPVerified, Active)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            IMEINumber,
            DeviceID,
            EmployeeEmail,
            EmployeeName,
            Password,
            Pincode,
            OTPVerified,
            Active
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'USERVALIDATION EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'USERVALIDATION EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'USERVALIDATION Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes USERVALIDATION

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete USERVALIDATION invoked (EMPID=$EMPID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnUSERVALIDATION
          .delete(QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]));
    } else {
      return _mnUSERVALIDATION.updateBatch(
          QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [USERVALIDATION] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  USERVALIDATIONFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERVALIDATIONFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  USERVALIDATIONFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return USERVALIDATIONFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
    Active = Active ?? false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EMPID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion uservalidation

// region USERVALIDATIONField
class USERVALIDATIONField extends FilterBase {
  USERVALIDATIONField(USERVALIDATIONFilterBuilder uservalidationFB)
      : super(uservalidationFB);

  @override
  USERVALIDATIONFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder isNull() {
    return super.isNull() as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as USERVALIDATIONFilterBuilder;
  }

  @override
  USERVALIDATIONField get not {
    return super.not as USERVALIDATIONField;
  }
}
// endregion USERVALIDATIONField

// region USERVALIDATIONFilterBuilder
class USERVALIDATIONFilterBuilder extends ConjunctionBase {
  USERVALIDATIONFilterBuilder(USERVALIDATION obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnUSERVALIDATION = obj._mnUSERVALIDATION;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  USERVALIDATIONManager? _mnUSERVALIDATION;

  /// put the sql keyword 'AND'
  @override
  USERVALIDATIONFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  USERVALIDATIONFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  USERVALIDATIONFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  USERVALIDATIONFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  USERVALIDATIONFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  USERVALIDATIONFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  USERVALIDATIONFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERVALIDATIONFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERVALIDATIONFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  USERVALIDATIONFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  USERVALIDATIONFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  USERVALIDATIONField _setField(
      USERVALIDATIONField? field, String colName, DbType dbtype) {
    return USERVALIDATIONField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  USERVALIDATIONField? _EMPID;
  USERVALIDATIONField get EMPID {
    return _EMPID = _setField(_EMPID, 'EMPID', DbType.integer);
  }

  USERVALIDATIONField? _MobileNumber;
  USERVALIDATIONField get MobileNumber {
    return _MobileNumber =
        _setField(_MobileNumber, 'MobileNumber', DbType.text);
  }

  USERVALIDATIONField? _IMEINumber;
  USERVALIDATIONField get IMEINumber {
    return _IMEINumber = _setField(_IMEINumber, 'IMEINumber', DbType.text);
  }

  USERVALIDATIONField? _DeviceID;
  USERVALIDATIONField get DeviceID {
    return _DeviceID = _setField(_DeviceID, 'DeviceID', DbType.text);
  }

  USERVALIDATIONField? _EmployeeEmail;
  USERVALIDATIONField get EmployeeEmail {
    return _EmployeeEmail =
        _setField(_EmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  USERVALIDATIONField? _EmployeeName;
  USERVALIDATIONField get EmployeeName {
    return _EmployeeName =
        _setField(_EmployeeName, 'EmployeeName', DbType.text);
  }

  USERVALIDATIONField? _Password;
  USERVALIDATIONField get Password {
    return _Password = _setField(_Password, 'Password', DbType.text);
  }

  USERVALIDATIONField? _Pincode;
  USERVALIDATIONField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.text);
  }

  USERVALIDATIONField? _OTPVerified;
  USERVALIDATIONField get OTPVerified {
    return _OTPVerified = _setField(_OTPVerified, 'OTPVerified', DbType.text);
  }

  USERVALIDATIONField? _Active;
  USERVALIDATIONField get Active {
    return _Active = _setField(_Active, 'Active', DbType.bool);
  }

  /// Deletes List<USERVALIDATION> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnUSERVALIDATION!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnUSERVALIDATION!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EMPID IN (SELECT EMPID from USERVALIDATION ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnUSERVALIDATION!.updateBatch(qparams, values);
  }

  /// This method always returns [USERVALIDATION] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERVALIDATION?
  @override
  Future<USERVALIDATION?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnUSERVALIDATION!.toList(qparams);
    final data = await objFuture;
    USERVALIDATION? obj;
    if (data.isNotEmpty) {
      obj = USERVALIDATION.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [USERVALIDATION]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> USERVALIDATION?
  @override
  Future<USERVALIDATION> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        USERVALIDATION();
  }

  /// This method returns int. [USERVALIDATION]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? uservalidationCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final uservalidationsFuture = await _mnUSERVALIDATION!.toList(qparams);
    final int count = uservalidationsFuture[0]['CNT'] as int;
    if (uservalidationCount != null) {
      uservalidationCount(count);
    }
    return count;
  }

  /// This method returns List<USERVALIDATION> [USERVALIDATION]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<USERVALIDATION>
  @override
  Future<List<USERVALIDATION>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<USERVALIDATION> uservalidationsData =
        await USERVALIDATION.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return uservalidationsData;
  }

  /// This method returns Json String [USERVALIDATION]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [USERVALIDATION]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [USERVALIDATION]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnUSERVALIDATION!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [USERVALIDATION]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EMPID` FROM USERVALIDATION WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> EMPIDData = <String>[];
    qparams.selectColumns = ['EMPID'];
    final EMPIDFuture = await _mnUSERVALIDATION!.toList(qparams);

    final int count = EMPIDFuture.length;
    for (int i = 0; i < count; i++) {
      EMPIDData.add(EMPIDFuture[i]['EMPID'] as String);
    }
    return EMPIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [USERVALIDATION]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnUSERVALIDATION!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await USERVALIDATION.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnUSERVALIDATION!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion USERVALIDATIONFilterBuilder

// region USERVALIDATIONFields
class USERVALIDATIONFields {
  static TableField? _fEMPID;
  static TableField get EMPID {
    return _fEMPID =
        _fEMPID ?? SqlSyntax.setField(_fEMPID, 'empid', DbType.integer);
  }

  static TableField? _fMobileNumber;
  static TableField get MobileNumber {
    return _fMobileNumber = _fMobileNumber ??
        SqlSyntax.setField(_fMobileNumber, 'MobileNumber', DbType.text);
  }

  static TableField? _fIMEINumber;
  static TableField get IMEINumber {
    return _fIMEINumber = _fIMEINumber ??
        SqlSyntax.setField(_fIMEINumber, 'IMEINumber', DbType.text);
  }

  static TableField? _fDeviceID;
  static TableField get DeviceID {
    return _fDeviceID =
        _fDeviceID ?? SqlSyntax.setField(_fDeviceID, 'DeviceID', DbType.text);
  }

  static TableField? _fEmployeeEmail;
  static TableField get EmployeeEmail {
    return _fEmployeeEmail = _fEmployeeEmail ??
        SqlSyntax.setField(_fEmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  static TableField? _fEmployeeName;
  static TableField get EmployeeName {
    return _fEmployeeName = _fEmployeeName ??
        SqlSyntax.setField(_fEmployeeName, 'EmployeeName', DbType.text);
  }

  static TableField? _fPassword;
  static TableField get Password {
    return _fPassword =
        _fPassword ?? SqlSyntax.setField(_fPassword, 'Password', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.text);
  }

  static TableField? _fOTPVerified;
  static TableField get OTPVerified {
    return _fOTPVerified = _fOTPVerified ??
        SqlSyntax.setField(_fOTPVerified, 'OTPVerified', DbType.text);
  }

  static TableField? _fActive;
  static TableField get Active {
    return _fActive =
        _fActive ?? SqlSyntax.setField(_fActive, 'Active', DbType.bool);
  }
}
// endregion USERVALIDATIONFields

//region USERVALIDATIONManager
class USERVALIDATIONManager extends SqfEntityProvider {
  USERVALIDATIONManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'USERVALIDATION';
  static const List<String> _primaryKeyList = ['EMPID'];
  static const String _whereStr = 'EMPID=?';
}

//endregion USERVALIDATIONManager
// region OFCMASTERDATA
class OFCMASTERDATA extends TableBase {
  OFCMASTERDATA(
      {this.EMPID,
      this.MobileNumber,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.EMOCODE,
      this.SOLID,
      this.Pincode,
      this.AOName,
      this.AOCode,
      this.DOName,
      this.DOCode,
      this.OB,
      this.CASHINHAND,
      this.MINBAL,
      this.MAXBAL,
      this.POSTAMPBAL,
      this.REVSTAMPBAL,
      this.CRFSTAMPBAL,
      this.MAILSCHEDULE,
      this.PAIDLEAVE,
      this.EMGLEAVE,
      this.MATERNITYLEAVE,
      this.ONETIMECUSTCODE,
      this.FUTURE_USE1,
      this.FUTURE_USE2,
      this.FUTURE_USE3}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  OFCMASTERDATA.withFields(
      this.EMPID,
      this.MobileNumber,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.EMOCODE,
      this.SOLID,
      this.Pincode,
      this.AOName,
      this.AOCode,
      this.DOName,
      this.DOCode,
      this.OB,
      this.CASHINHAND,
      this.MINBAL,
      this.MAXBAL,
      this.POSTAMPBAL,
      this.REVSTAMPBAL,
      this.CRFSTAMPBAL,
      this.MAILSCHEDULE,
      this.PAIDLEAVE,
      this.EMGLEAVE,
      this.MATERNITYLEAVE,
      this.ONETIMECUSTCODE,
      this.FUTURE_USE1,
      this.FUTURE_USE2,
      this.FUTURE_USE3) {
    _setDefaultValues();
  }
  OFCMASTERDATA.withId(
      this.EMPID,
      this.MobileNumber,
      this.EmployeeEmail,
      this.EmployeeName,
      this.DOB,
      this.BOFacilityID,
      this.BOName,
      this.EMOCODE,
      this.SOLID,
      this.Pincode,
      this.AOName,
      this.AOCode,
      this.DOName,
      this.DOCode,
      this.OB,
      this.CASHINHAND,
      this.MINBAL,
      this.MAXBAL,
      this.POSTAMPBAL,
      this.REVSTAMPBAL,
      this.CRFSTAMPBAL,
      this.MAILSCHEDULE,
      this.PAIDLEAVE,
      this.EMGLEAVE,
      this.MATERNITYLEAVE,
      this.ONETIMECUSTCODE,
      this.FUTURE_USE1,
      this.FUTURE_USE2,
      this.FUTURE_USE3) {
    _setDefaultValues();
  }
  // fromMap v2.0
  OFCMASTERDATA.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EMPID = o['EMPID'].toString();
    if (o['MobileNumber'] != null) {
      MobileNumber = o['MobileNumber'].toString();
    }
    if (o['EmployeeEmail'] != null) {
      EmployeeEmail = o['EmployeeEmail'].toString();
    }
    if (o['EmployeeName'] != null) {
      EmployeeName = o['EmployeeName'].toString();
    }
    if (o['DOB'] != null) {
      DOB = o['DOB'].toString();
    }
    if (o['BOFacilityID'] != null) {
      BOFacilityID = o['BOFacilityID'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['EMOCODE'] != null) {
      EMOCODE = o['EMOCODE'].toString();
    }
    if (o['SOLID'] != null) {
      SOLID = o['SOLID'].toString();
    }
    if (o['Pincode'] != null) {
      Pincode = o['Pincode'].toString();
    }
    if (o['AOName'] != null) {
      AOName = o['AOName'].toString();
    }
    if (o['AOCode'] != null) {
      AOCode = o['AOCode'].toString();
    }
    if (o['DOName'] != null) {
      DOName = o['DOName'].toString();
    }
    if (o['DOCode'] != null) {
      DOCode = o['DOCode'].toString();
    }
    if (o['OB'] != null) {
      OB = o['OB'].toString();
    }
    if (o['CASHINHAND'] != null) {
      CASHINHAND = o['CASHINHAND'].toString();
    }
    if (o['MINBAL'] != null) {
      MINBAL = o['MINBAL'].toString();
    }
    if (o['MAXBAL'] != null) {
      MAXBAL = o['MAXBAL'].toString();
    }
    if (o['POSTAMPBAL'] != null) {
      POSTAMPBAL = o['POSTAMPBAL'].toString();
    }
    if (o['REVSTAMPBAL'] != null) {
      REVSTAMPBAL = o['REVSTAMPBAL'].toString();
    }
    if (o['CRFSTAMPBAL'] != null) {
      CRFSTAMPBAL = o['CRFSTAMPBAL'].toString();
    }
    if (o['MAILSCHEDULE'] != null) {
      MAILSCHEDULE = o['MAILSCHEDULE'].toString();
    }
    if (o['PAIDLEAVE'] != null) {
      PAIDLEAVE = o['PAIDLEAVE'].toString();
    }
    if (o['EMGLEAVE'] != null) {
      EMGLEAVE = o['EMGLEAVE'].toString();
    }
    if (o['MATERNITYLEAVE'] != null) {
      MATERNITYLEAVE = o['MATERNITYLEAVE'].toString();
    }
    if (o['ONETIMECUSTCODE'] != null) {
      ONETIMECUSTCODE = o['ONETIMECUSTCODE'].toString();
    }
    if (o['FUTURE_USE1'] != null) {
      FUTURE_USE1 = o['FUTURE_USE1'].toString();
    }
    if (o['FUTURE_USE2'] != null) {
      FUTURE_USE2 = o['FUTURE_USE2'].toString();
    }
    if (o['FUTURE_USE3'] != null) {
      FUTURE_USE3 = o['FUTURE_USE3'].toString();
    }

    isSaved = true;
  }
  // FIELDS (OFCMASTERDATA)
  String? EMPID;
  String? MobileNumber;
  String? EmployeeEmail;
  String? EmployeeName;
  String? DOB;
  String? BOFacilityID;
  String? BOName;
  String? EMOCODE;
  String? SOLID;
  String? Pincode;
  String? AOName;
  String? AOCode;
  String? DOName;
  String? DOCode;
  String? OB;
  String? CASHINHAND;
  String? MINBAL;
  String? MAXBAL;
  String? POSTAMPBAL;
  String? REVSTAMPBAL;
  String? CRFSTAMPBAL;
  String? MAILSCHEDULE;
  String? PAIDLEAVE;
  String? EMGLEAVE;
  String? MATERNITYLEAVE;
  String? ONETIMECUSTCODE;
  String? FUTURE_USE1;
  String? FUTURE_USE2;
  String? FUTURE_USE3;
  bool? isSaved;
  // end FIELDS (OFCMASTERDATA)

  static const bool _softDeleteActivated = false;
  OFCMASTERDATAManager? __mnOFCMASTERDATA;

  OFCMASTERDATAManager get _mnOFCMASTERDATA {
    return __mnOFCMASTERDATA = __mnOFCMASTERDATA ?? OFCMASTERDATAManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (DOB != null || !forView) {
      map['DOB'] = DOB;
    }
    if (BOFacilityID != null || !forView) {
      map['BOFacilityID'] = BOFacilityID;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (EMOCODE != null || !forView) {
      map['EMOCODE'] = EMOCODE;
    }
    if (SOLID != null || !forView) {
      map['SOLID'] = SOLID;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (AOName != null || !forView) {
      map['AOName'] = AOName;
    }
    if (AOCode != null || !forView) {
      map['AOCode'] = AOCode;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (DOCode != null || !forView) {
      map['DOCode'] = DOCode;
    }
    if (OB != null || !forView) {
      map['OB'] = OB;
    }
    if (CASHINHAND != null || !forView) {
      map['CASHINHAND'] = CASHINHAND;
    }
    if (MINBAL != null || !forView) {
      map['MINBAL'] = MINBAL;
    }
    if (MAXBAL != null || !forView) {
      map['MAXBAL'] = MAXBAL;
    }
    if (POSTAMPBAL != null || !forView) {
      map['POSTAMPBAL'] = POSTAMPBAL;
    }
    if (REVSTAMPBAL != null || !forView) {
      map['REVSTAMPBAL'] = REVSTAMPBAL;
    }
    if (CRFSTAMPBAL != null || !forView) {
      map['CRFSTAMPBAL'] = CRFSTAMPBAL;
    }
    if (MAILSCHEDULE != null || !forView) {
      map['MAILSCHEDULE'] = MAILSCHEDULE;
    }
    if (PAIDLEAVE != null || !forView) {
      map['PAIDLEAVE'] = PAIDLEAVE;
    }
    if (EMGLEAVE != null || !forView) {
      map['EMGLEAVE'] = EMGLEAVE;
    }
    if (MATERNITYLEAVE != null || !forView) {
      map['MATERNITYLEAVE'] = MATERNITYLEAVE;
    }
    if (ONETIMECUSTCODE != null || !forView) {
      map['ONETIMECUSTCODE'] = ONETIMECUSTCODE;
    }
    if (FUTURE_USE1 != null || !forView) {
      map['FUTURE_USE1'] = FUTURE_USE1;
    }
    if (FUTURE_USE2 != null || !forView) {
      map['FUTURE_USE2'] = FUTURE_USE2;
    }
    if (FUTURE_USE3 != null || !forView) {
      map['FUTURE_USE3'] = FUTURE_USE3;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EMPID'] = EMPID;
    if (MobileNumber != null || !forView) {
      map['MobileNumber'] = MobileNumber;
    }
    if (EmployeeEmail != null || !forView) {
      map['EmployeeEmail'] = EmployeeEmail;
    }
    if (EmployeeName != null || !forView) {
      map['EmployeeName'] = EmployeeName;
    }
    if (DOB != null || !forView) {
      map['DOB'] = DOB;
    }
    if (BOFacilityID != null || !forView) {
      map['BOFacilityID'] = BOFacilityID;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (EMOCODE != null || !forView) {
      map['EMOCODE'] = EMOCODE;
    }
    if (SOLID != null || !forView) {
      map['SOLID'] = SOLID;
    }
    if (Pincode != null || !forView) {
      map['Pincode'] = Pincode;
    }
    if (AOName != null || !forView) {
      map['AOName'] = AOName;
    }
    if (AOCode != null || !forView) {
      map['AOCode'] = AOCode;
    }
    if (DOName != null || !forView) {
      map['DOName'] = DOName;
    }
    if (DOCode != null || !forView) {
      map['DOCode'] = DOCode;
    }
    if (OB != null || !forView) {
      map['OB'] = OB;
    }
    if (CASHINHAND != null || !forView) {
      map['CASHINHAND'] = CASHINHAND;
    }
    if (MINBAL != null || !forView) {
      map['MINBAL'] = MINBAL;
    }
    if (MAXBAL != null || !forView) {
      map['MAXBAL'] = MAXBAL;
    }
    if (POSTAMPBAL != null || !forView) {
      map['POSTAMPBAL'] = POSTAMPBAL;
    }
    if (REVSTAMPBAL != null || !forView) {
      map['REVSTAMPBAL'] = REVSTAMPBAL;
    }
    if (CRFSTAMPBAL != null || !forView) {
      map['CRFSTAMPBAL'] = CRFSTAMPBAL;
    }
    if (MAILSCHEDULE != null || !forView) {
      map['MAILSCHEDULE'] = MAILSCHEDULE;
    }
    if (PAIDLEAVE != null || !forView) {
      map['PAIDLEAVE'] = PAIDLEAVE;
    }
    if (EMGLEAVE != null || !forView) {
      map['EMGLEAVE'] = EMGLEAVE;
    }
    if (MATERNITYLEAVE != null || !forView) {
      map['MATERNITYLEAVE'] = MATERNITYLEAVE;
    }
    if (ONETIMECUSTCODE != null || !forView) {
      map['ONETIMECUSTCODE'] = ONETIMECUSTCODE;
    }
    if (FUTURE_USE1 != null || !forView) {
      map['FUTURE_USE1'] = FUTURE_USE1;
    }
    if (FUTURE_USE2 != null || !forView) {
      map['FUTURE_USE2'] = FUTURE_USE2;
    }
    if (FUTURE_USE3 != null || !forView) {
      map['FUTURE_USE3'] = FUTURE_USE3;
    }

    return map;
  }

  /// This method returns Json String [OFCMASTERDATA]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [OFCMASTERDATA]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      EMPID,
      MobileNumber,
      EmployeeEmail,
      EmployeeName,
      DOB,
      BOFacilityID,
      BOName,
      EMOCODE,
      SOLID,
      Pincode,
      AOName,
      AOCode,
      DOName,
      DOCode,
      OB,
      CASHINHAND,
      MINBAL,
      MAXBAL,
      POSTAMPBAL,
      REVSTAMPBAL,
      CRFSTAMPBAL,
      MAILSCHEDULE,
      PAIDLEAVE,
      EMGLEAVE,
      MATERNITYLEAVE,
      ONETIMECUSTCODE,
      FUTURE_USE1,
      FUTURE_USE2,
      FUTURE_USE3
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EMPID,
      MobileNumber,
      EmployeeEmail,
      EmployeeName,
      DOB,
      BOFacilityID,
      BOName,
      EMOCODE,
      SOLID,
      Pincode,
      AOName,
      AOCode,
      DOName,
      DOCode,
      OB,
      CASHINHAND,
      MINBAL,
      MAXBAL,
      POSTAMPBAL,
      REVSTAMPBAL,
      CRFSTAMPBAL,
      MAILSCHEDULE,
      PAIDLEAVE,
      EMGLEAVE,
      MATERNITYLEAVE,
      ONETIMECUSTCODE,
      FUTURE_USE1,
      FUTURE_USE2,
      FUTURE_USE3
    ];
  }

  static Future<List<OFCMASTERDATA>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OFCMASTERDATA.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<OFCMASTERDATA>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <OFCMASTERDATA>[];
    try {
      objList = list
          .map((ofcmasterdata) =>
              OFCMASTERDATA.fromMap(ofcmasterdata as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR OFCMASTERDATA.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<OFCMASTERDATA>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<OFCMASTERDATA> objList = <OFCMASTERDATA>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = OFCMASTERDATA.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns OFCMASTERDATA by ID if exist, otherwise returns null
  /// Primary Keys: String? EMPID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [OFCMASTERDATA] if exist, otherwise returns null
  Future<OFCMASTERDATA?> getById(String? EMPID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EMPID == null) {
      return null;
    }
    OFCMASTERDATA? obj;
    final data = await _mnOFCMASTERDATA.getById([EMPID]);
    if (data.length != 0) {
      obj = OFCMASTERDATA.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (OFCMASTERDATA) object. If the Primary Key (EMPID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EMPID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnOFCMASTERDATA.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO OFCMASTERDATA (EMPID, MobileNumber, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, EMOCODE, SOLID, Pincode, AOName, AOCode, DOName, DOCode, OB, CASHINHAND, MINBAL, MAXBAL, POSTAMPBAL, REVSTAMPBAL, CRFSTAMPBAL, MAILSCHEDULE, PAIDLEAVE, EMGLEAVE, MATERNITYLEAVE, ONETIMECUSTCODE, FUTURE_USE1, FUTURE_USE2, FUTURE_USE3)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<OFCMASTERDATA> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<OFCMASTERDATA> ofcmasterdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in ofcmasterdatas) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOFCMASTERDATA.rawInsert(
          'INSERT OR REPLACE INTO OFCMASTERDATA (EMPID, MobileNumber, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, EMOCODE, SOLID, Pincode, AOName, AOCode, DOName, DOCode, OB, CASHINHAND, MINBAL, MAXBAL, POSTAMPBAL, REVSTAMPBAL, CRFSTAMPBAL, MAILSCHEDULE, PAIDLEAVE, EMGLEAVE, MATERNITYLEAVE, ONETIMECUSTCODE, FUTURE_USE1, FUTURE_USE2, FUTURE_USE3)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            EmployeeEmail,
            EmployeeName,
            DOB,
            BOFacilityID,
            BOName,
            EMOCODE,
            SOLID,
            Pincode,
            AOName,
            AOCode,
            DOName,
            DOCode,
            OB,
            CASHINHAND,
            MINBAL,
            MAXBAL,
            POSTAMPBAL,
            REVSTAMPBAL,
            CRFSTAMPBAL,
            MAILSCHEDULE,
            PAIDLEAVE,
            EMGLEAVE,
            MATERNITYLEAVE,
            ONETIMECUSTCODE,
            FUTURE_USE1,
            FUTURE_USE2,
            FUTURE_USE3
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'OFCMASTERDATA EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'OFCMASTERDATA EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'OFCMASTERDATA Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnOFCMASTERDATA.rawInsert(
          'INSERT OR IGNORE INTO OFCMASTERDATA (EMPID, MobileNumber, EmployeeEmail, EmployeeName, DOB, BOFacilityID, BOName, EMOCODE, SOLID, Pincode, AOName, AOCode, DOName, DOCode, OB, CASHINHAND, MINBAL, MAXBAL, POSTAMPBAL, REVSTAMPBAL, CRFSTAMPBAL, MAILSCHEDULE, PAIDLEAVE, EMGLEAVE, MATERNITYLEAVE, ONETIMECUSTCODE, FUTURE_USE1, FUTURE_USE2, FUTURE_USE3)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPID,
            MobileNumber,
            EmployeeEmail,
            EmployeeName,
            DOB,
            BOFacilityID,
            BOName,
            EMOCODE,
            SOLID,
            Pincode,
            AOName,
            AOCode,
            DOName,
            DOCode,
            OB,
            CASHINHAND,
            MINBAL,
            MAXBAL,
            POSTAMPBAL,
            REVSTAMPBAL,
            CRFSTAMPBAL,
            MAILSCHEDULE,
            PAIDLEAVE,
            EMGLEAVE,
            MATERNITYLEAVE,
            ONETIMECUSTCODE,
            FUTURE_USE1,
            FUTURE_USE2,
            FUTURE_USE3
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'OFCMASTERDATA EMPID=$EMPID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'OFCMASTERDATA EMPID=$EMPID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'OFCMASTERDATA Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes OFCMASTERDATA

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete OFCMASTERDATA invoked (EMPID=$EMPID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnOFCMASTERDATA
          .delete(QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]));
    } else {
      return _mnOFCMASTERDATA.updateBatch(
          QueryParams(whereString: 'EMPID=?', whereArguments: [EMPID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [OFCMASTERDATA] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  OFCMASTERDATAFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OFCMASTERDATAFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  OFCMASTERDATAFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return OFCMASTERDATAFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EMPID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion ofcmasterdata

// region OFCMASTERDATAField
class OFCMASTERDATAField extends FilterBase {
  OFCMASTERDATAField(OFCMASTERDATAFilterBuilder ofcmasterdataFB)
      : super(ofcmasterdataFB);

  @override
  OFCMASTERDATAFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder isNull() {
    return super.isNull() as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as OFCMASTERDATAFilterBuilder;
  }

  @override
  OFCMASTERDATAField get not {
    return super.not as OFCMASTERDATAField;
  }
}
// endregion OFCMASTERDATAField

// region OFCMASTERDATAFilterBuilder
class OFCMASTERDATAFilterBuilder extends ConjunctionBase {
  OFCMASTERDATAFilterBuilder(OFCMASTERDATA obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnOFCMASTERDATA = obj._mnOFCMASTERDATA;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  OFCMASTERDATAManager? _mnOFCMASTERDATA;

  /// put the sql keyword 'AND'
  @override
  OFCMASTERDATAFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  OFCMASTERDATAFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  OFCMASTERDATAFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  OFCMASTERDATAFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  OFCMASTERDATAFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  OFCMASTERDATAFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  OFCMASTERDATAFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OFCMASTERDATAFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OFCMASTERDATAFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  OFCMASTERDATAFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  OFCMASTERDATAFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  OFCMASTERDATAField _setField(
      OFCMASTERDATAField? field, String colName, DbType dbtype) {
    return OFCMASTERDATAField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  OFCMASTERDATAField? _EMPID;
  OFCMASTERDATAField get EMPID {
    return _EMPID = _setField(_EMPID, 'EMPID', DbType.integer);
  }

  OFCMASTERDATAField? _MobileNumber;
  OFCMASTERDATAField get MobileNumber {
    return _MobileNumber =
        _setField(_MobileNumber, 'MobileNumber', DbType.text);
  }

  OFCMASTERDATAField? _EmployeeEmail;
  OFCMASTERDATAField get EmployeeEmail {
    return _EmployeeEmail =
        _setField(_EmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  OFCMASTERDATAField? _EmployeeName;
  OFCMASTERDATAField get EmployeeName {
    return _EmployeeName =
        _setField(_EmployeeName, 'EmployeeName', DbType.text);
  }

  OFCMASTERDATAField? _DOB;
  OFCMASTERDATAField get DOB {
    return _DOB = _setField(_DOB, 'DOB', DbType.text);
  }

  OFCMASTERDATAField? _BOFacilityID;
  OFCMASTERDATAField get BOFacilityID {
    return _BOFacilityID =
        _setField(_BOFacilityID, 'BOFacilityID', DbType.text);
  }

  OFCMASTERDATAField? _BOName;
  OFCMASTERDATAField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  OFCMASTERDATAField? _EMOCODE;
  OFCMASTERDATAField get EMOCODE {
    return _EMOCODE = _setField(_EMOCODE, 'EMOCODE', DbType.text);
  }

  OFCMASTERDATAField? _SOLID;
  OFCMASTERDATAField get SOLID {
    return _SOLID = _setField(_SOLID, 'SOLID', DbType.text);
  }

  OFCMASTERDATAField? _Pincode;
  OFCMASTERDATAField get Pincode {
    return _Pincode = _setField(_Pincode, 'Pincode', DbType.text);
  }

  OFCMASTERDATAField? _AOName;
  OFCMASTERDATAField get AOName {
    return _AOName = _setField(_AOName, 'AOName', DbType.text);
  }

  OFCMASTERDATAField? _AOCode;
  OFCMASTERDATAField get AOCode {
    return _AOCode = _setField(_AOCode, 'AOCode', DbType.text);
  }

  OFCMASTERDATAField? _DOName;
  OFCMASTERDATAField get DOName {
    return _DOName = _setField(_DOName, 'DOName', DbType.text);
  }

  OFCMASTERDATAField? _DOCode;
  OFCMASTERDATAField get DOCode {
    return _DOCode = _setField(_DOCode, 'DOCode', DbType.text);
  }

  OFCMASTERDATAField? _OB;
  OFCMASTERDATAField get OB {
    return _OB = _setField(_OB, 'OB', DbType.text);
  }

  OFCMASTERDATAField? _CASHINHAND;
  OFCMASTERDATAField get CASHINHAND {
    return _CASHINHAND = _setField(_CASHINHAND, 'CASHINHAND', DbType.text);
  }

  OFCMASTERDATAField? _MINBAL;
  OFCMASTERDATAField get MINBAL {
    return _MINBAL = _setField(_MINBAL, 'MINBAL', DbType.text);
  }

  OFCMASTERDATAField? _MAXBAL;
  OFCMASTERDATAField get MAXBAL {
    return _MAXBAL = _setField(_MAXBAL, 'MAXBAL', DbType.text);
  }

  OFCMASTERDATAField? _POSTAMPBAL;
  OFCMASTERDATAField get POSTAMPBAL {
    return _POSTAMPBAL = _setField(_POSTAMPBAL, 'POSTAMPBAL', DbType.text);
  }

  OFCMASTERDATAField? _REVSTAMPBAL;
  OFCMASTERDATAField get REVSTAMPBAL {
    return _REVSTAMPBAL = _setField(_REVSTAMPBAL, 'REVSTAMPBAL', DbType.text);
  }

  OFCMASTERDATAField? _CRFSTAMPBAL;
  OFCMASTERDATAField get CRFSTAMPBAL {
    return _CRFSTAMPBAL = _setField(_CRFSTAMPBAL, 'CRFSTAMPBAL', DbType.text);
  }

  OFCMASTERDATAField? _MAILSCHEDULE;
  OFCMASTERDATAField get MAILSCHEDULE {
    return _MAILSCHEDULE =
        _setField(_MAILSCHEDULE, 'MAILSCHEDULE', DbType.text);
  }

  OFCMASTERDATAField? _PAIDLEAVE;
  OFCMASTERDATAField get PAIDLEAVE {
    return _PAIDLEAVE = _setField(_PAIDLEAVE, 'PAIDLEAVE', DbType.text);
  }

  OFCMASTERDATAField? _EMGLEAVE;
  OFCMASTERDATAField get EMGLEAVE {
    return _EMGLEAVE = _setField(_EMGLEAVE, 'EMGLEAVE', DbType.text);
  }

  OFCMASTERDATAField? _MATERNITYLEAVE;
  OFCMASTERDATAField get MATERNITYLEAVE {
    return _MATERNITYLEAVE =
        _setField(_MATERNITYLEAVE, 'MATERNITYLEAVE', DbType.text);
  }

  OFCMASTERDATAField? _ONETIMECUSTCODE;
  OFCMASTERDATAField get ONETIMECUSTCODE {
    return _ONETIMECUSTCODE =
        _setField(_ONETIMECUSTCODE, 'ONETIMECUSTCODE', DbType.text);
  }

  OFCMASTERDATAField? _FUTURE_USE1;
  OFCMASTERDATAField get FUTURE_USE1 {
    return _FUTURE_USE1 = _setField(_FUTURE_USE1, 'FUTURE_USE1', DbType.text);
  }

  OFCMASTERDATAField? _FUTURE_USE2;
  OFCMASTERDATAField get FUTURE_USE2 {
    return _FUTURE_USE2 = _setField(_FUTURE_USE2, 'FUTURE_USE2', DbType.text);
  }

  OFCMASTERDATAField? _FUTURE_USE3;
  OFCMASTERDATAField get FUTURE_USE3 {
    return _FUTURE_USE3 = _setField(_FUTURE_USE3, 'FUTURE_USE3', DbType.text);
  }

  /// Deletes List<OFCMASTERDATA> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnOFCMASTERDATA!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnOFCMASTERDATA!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EMPID IN (SELECT EMPID from OFCMASTERDATA ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnOFCMASTERDATA!.updateBatch(qparams, values);
  }

  /// This method always returns [OFCMASTERDATA] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OFCMASTERDATA?
  @override
  Future<OFCMASTERDATA?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnOFCMASTERDATA!.toList(qparams);
    final data = await objFuture;
    OFCMASTERDATA? obj;
    if (data.isNotEmpty) {
      obj = OFCMASTERDATA.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [OFCMASTERDATA]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> OFCMASTERDATA?
  @override
  Future<OFCMASTERDATA> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        OFCMASTERDATA();
  }

  /// This method returns int. [OFCMASTERDATA]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? ofcmasterdataCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final ofcmasterdatasFuture = await _mnOFCMASTERDATA!.toList(qparams);
    final int count = ofcmasterdatasFuture[0]['CNT'] as int;
    if (ofcmasterdataCount != null) {
      ofcmasterdataCount(count);
    }
    return count;
  }

  /// This method returns List<OFCMASTERDATA> [OFCMASTERDATA]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<OFCMASTERDATA>
  @override
  Future<List<OFCMASTERDATA>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<OFCMASTERDATA> ofcmasterdatasData =
        await OFCMASTERDATA.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return ofcmasterdatasData;
  }

  /// This method returns Json String [OFCMASTERDATA]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [OFCMASTERDATA]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [OFCMASTERDATA]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnOFCMASTERDATA!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [OFCMASTERDATA]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EMPID` FROM OFCMASTERDATA WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> EMPIDData = <String>[];
    qparams.selectColumns = ['EMPID'];
    final EMPIDFuture = await _mnOFCMASTERDATA!.toList(qparams);

    final int count = EMPIDFuture.length;
    for (int i = 0; i < count; i++) {
      EMPIDData.add(EMPIDFuture[i]['EMPID'] as String);
    }
    return EMPIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [OFCMASTERDATA]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnOFCMASTERDATA!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await OFCMASTERDATA.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnOFCMASTERDATA!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion OFCMASTERDATAFilterBuilder

// region OFCMASTERDATAFields
class OFCMASTERDATAFields {
  static TableField? _fEMPID;
  static TableField get EMPID {
    return _fEMPID =
        _fEMPID ?? SqlSyntax.setField(_fEMPID, 'empid', DbType.integer);
  }

  static TableField? _fMobileNumber;
  static TableField get MobileNumber {
    return _fMobileNumber = _fMobileNumber ??
        SqlSyntax.setField(_fMobileNumber, 'MobileNumber', DbType.text);
  }

  static TableField? _fEmployeeEmail;
  static TableField get EmployeeEmail {
    return _fEmployeeEmail = _fEmployeeEmail ??
        SqlSyntax.setField(_fEmployeeEmail, 'EmployeeEmail', DbType.text);
  }

  static TableField? _fEmployeeName;
  static TableField get EmployeeName {
    return _fEmployeeName = _fEmployeeName ??
        SqlSyntax.setField(_fEmployeeName, 'EmployeeName', DbType.text);
  }

  static TableField? _fDOB;
  static TableField get DOB {
    return _fDOB = _fDOB ?? SqlSyntax.setField(_fDOB, 'DOB', DbType.text);
  }

  static TableField? _fBOFacilityID;
  static TableField get BOFacilityID {
    return _fBOFacilityID = _fBOFacilityID ??
        SqlSyntax.setField(_fBOFacilityID, 'BOFacilityID', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fEMOCODE;
  static TableField get EMOCODE {
    return _fEMOCODE =
        _fEMOCODE ?? SqlSyntax.setField(_fEMOCODE, 'EMOCODE', DbType.text);
  }

  static TableField? _fSOLID;
  static TableField get SOLID {
    return _fSOLID =
        _fSOLID ?? SqlSyntax.setField(_fSOLID, 'SOLID', DbType.text);
  }

  static TableField? _fPincode;
  static TableField get Pincode {
    return _fPincode =
        _fPincode ?? SqlSyntax.setField(_fPincode, 'Pincode', DbType.text);
  }

  static TableField? _fAOName;
  static TableField get AOName {
    return _fAOName =
        _fAOName ?? SqlSyntax.setField(_fAOName, 'AOName', DbType.text);
  }

  static TableField? _fAOCode;
  static TableField get AOCode {
    return _fAOCode =
        _fAOCode ?? SqlSyntax.setField(_fAOCode, 'AOCode', DbType.text);
  }

  static TableField? _fDOName;
  static TableField get DOName {
    return _fDOName =
        _fDOName ?? SqlSyntax.setField(_fDOName, 'DOName', DbType.text);
  }

  static TableField? _fDOCode;
  static TableField get DOCode {
    return _fDOCode =
        _fDOCode ?? SqlSyntax.setField(_fDOCode, 'DOCode', DbType.text);
  }

  static TableField? _fOB;
  static TableField get OB {
    return _fOB = _fOB ?? SqlSyntax.setField(_fOB, 'OB', DbType.text);
  }

  static TableField? _fCASHINHAND;
  static TableField get CASHINHAND {
    return _fCASHINHAND = _fCASHINHAND ??
        SqlSyntax.setField(_fCASHINHAND, 'CASHINHAND', DbType.text);
  }

  static TableField? _fMINBAL;
  static TableField get MINBAL {
    return _fMINBAL =
        _fMINBAL ?? SqlSyntax.setField(_fMINBAL, 'MINBAL', DbType.text);
  }

  static TableField? _fMAXBAL;
  static TableField get MAXBAL {
    return _fMAXBAL =
        _fMAXBAL ?? SqlSyntax.setField(_fMAXBAL, 'MAXBAL', DbType.text);
  }

  static TableField? _fPOSTAMPBAL;
  static TableField get POSTAMPBAL {
    return _fPOSTAMPBAL = _fPOSTAMPBAL ??
        SqlSyntax.setField(_fPOSTAMPBAL, 'POSTAMPBAL', DbType.text);
  }

  static TableField? _fREVSTAMPBAL;
  static TableField get REVSTAMPBAL {
    return _fREVSTAMPBAL = _fREVSTAMPBAL ??
        SqlSyntax.setField(_fREVSTAMPBAL, 'REVSTAMPBAL', DbType.text);
  }

  static TableField? _fCRFSTAMPBAL;
  static TableField get CRFSTAMPBAL {
    return _fCRFSTAMPBAL = _fCRFSTAMPBAL ??
        SqlSyntax.setField(_fCRFSTAMPBAL, 'CRFSTAMPBAL', DbType.text);
  }

  static TableField? _fMAILSCHEDULE;
  static TableField get MAILSCHEDULE {
    return _fMAILSCHEDULE = _fMAILSCHEDULE ??
        SqlSyntax.setField(_fMAILSCHEDULE, 'MAILSCHEDULE', DbType.text);
  }

  static TableField? _fPAIDLEAVE;
  static TableField get PAIDLEAVE {
    return _fPAIDLEAVE = _fPAIDLEAVE ??
        SqlSyntax.setField(_fPAIDLEAVE, 'PAIDLEAVE', DbType.text);
  }

  static TableField? _fEMGLEAVE;
  static TableField get EMGLEAVE {
    return _fEMGLEAVE =
        _fEMGLEAVE ?? SqlSyntax.setField(_fEMGLEAVE, 'EMGLEAVE', DbType.text);
  }

  static TableField? _fMATERNITYLEAVE;
  static TableField get MATERNITYLEAVE {
    return _fMATERNITYLEAVE = _fMATERNITYLEAVE ??
        SqlSyntax.setField(_fMATERNITYLEAVE, 'MATERNITYLEAVE', DbType.text);
  }

  static TableField? _fONETIMECUSTCODE;
  static TableField get ONETIMECUSTCODE {
    return _fONETIMECUSTCODE = _fONETIMECUSTCODE ??
        SqlSyntax.setField(_fONETIMECUSTCODE, 'ONETIMECUSTCODE', DbType.text);
  }

  static TableField? _fFUTURE_USE1;
  static TableField get FUTURE_USE1 {
    return _fFUTURE_USE1 = _fFUTURE_USE1 ??
        SqlSyntax.setField(_fFUTURE_USE1, 'FUTURE_USE1', DbType.text);
  }

  static TableField? _fFUTURE_USE2;
  static TableField get FUTURE_USE2 {
    return _fFUTURE_USE2 = _fFUTURE_USE2 ??
        SqlSyntax.setField(_fFUTURE_USE2, 'FUTURE_USE2', DbType.text);
  }

  static TableField? _fFUTURE_USE3;
  static TableField get FUTURE_USE3 {
    return _fFUTURE_USE3 = _fFUTURE_USE3 ??
        SqlSyntax.setField(_fFUTURE_USE3, 'FUTURE_USE3', DbType.text);
  }
}
// endregion OFCMASTERDATAFields

//region OFCMASTERDATAManager
class OFCMASTERDATAManager extends SqfEntityProvider {
  OFCMASTERDATAManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'OFCMASTERDATA';
  static const List<String> _primaryKeyList = ['EMPID'];
  static const String _whereStr = 'EMPID=?';
}

//endregion OFCMASTERDATAManager
// region FILEMASTERDATA
class FILEMASTERDATA extends TableBase {
  FILEMASTERDATA(
      {this.FILETYPE,
      this.DIVISION,
      this.ORDERTYPE_SP,
      this.ORDERTYPE_LETTERPARCEL,
      this.ORDERTYPE_EMO,
      this.PRODUCT_TYPE,
      this.MATERIALGROUP_SP,
      this.MATERIALGROUP_LETTER,
      this.MATERIALGROUP_EMO}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  FILEMASTERDATA.withFields(
      this.FILETYPE,
      this.DIVISION,
      this.ORDERTYPE_SP,
      this.ORDERTYPE_LETTERPARCEL,
      this.ORDERTYPE_EMO,
      this.PRODUCT_TYPE,
      this.MATERIALGROUP_SP,
      this.MATERIALGROUP_LETTER,
      this.MATERIALGROUP_EMO) {
    _setDefaultValues();
  }
  FILEMASTERDATA.withId(
      this.FILETYPE,
      this.DIVISION,
      this.ORDERTYPE_SP,
      this.ORDERTYPE_LETTERPARCEL,
      this.ORDERTYPE_EMO,
      this.PRODUCT_TYPE,
      this.MATERIALGROUP_SP,
      this.MATERIALGROUP_LETTER,
      this.MATERIALGROUP_EMO) {
    _setDefaultValues();
  }
  // fromMap v2.0
  FILEMASTERDATA.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    FILETYPE = o['FILETYPE'].toString();
    if (o['DIVISION'] != null) {
      DIVISION = o['DIVISION'].toString();
    }
    if (o['ORDERTYPE_SP'] != null) {
      ORDERTYPE_SP = o['ORDERTYPE_SP'].toString();
    }
    if (o['ORDERTYPE_LETTERPARCEL'] != null) {
      ORDERTYPE_LETTERPARCEL = o['ORDERTYPE_LETTERPARCEL'].toString();
    }
    if (o['ORDERTYPE_EMO'] != null) {
      ORDERTYPE_EMO = o['ORDERTYPE_EMO'].toString();
    }
    if (o['PRODUCT_TYPE'] != null) {
      PRODUCT_TYPE = o['PRODUCT_TYPE'].toString();
    }
    if (o['MATERIALGROUP_SP'] != null) {
      MATERIALGROUP_SP = o['MATERIALGROUP_SP'].toString();
    }
    if (o['MATERIALGROUP_LETTER'] != null) {
      MATERIALGROUP_LETTER = o['MATERIALGROUP_LETTER'].toString();
    }
    if (o['MATERIALGROUP_EMO'] != null) {
      MATERIALGROUP_EMO = o['MATERIALGROUP_EMO'].toString();
    }

    isSaved = true;
  }
  // FIELDS (FILEMASTERDATA)
  String? FILETYPE;
  String? DIVISION;
  String? ORDERTYPE_SP;
  String? ORDERTYPE_LETTERPARCEL;
  String? ORDERTYPE_EMO;
  String? PRODUCT_TYPE;
  String? MATERIALGROUP_SP;
  String? MATERIALGROUP_LETTER;
  String? MATERIALGROUP_EMO;
  bool? isSaved;
  // end FIELDS (FILEMASTERDATA)

  static const bool _softDeleteActivated = false;
  FILEMASTERDATAManager? __mnFILEMASTERDATA;

  FILEMASTERDATAManager get _mnFILEMASTERDATA {
    return __mnFILEMASTERDATA = __mnFILEMASTERDATA ?? FILEMASTERDATAManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['FILETYPE'] = FILETYPE;
    if (DIVISION != null || !forView) {
      map['DIVISION'] = DIVISION;
    }
    if (ORDERTYPE_SP != null || !forView) {
      map['ORDERTYPE_SP'] = ORDERTYPE_SP;
    }
    if (ORDERTYPE_LETTERPARCEL != null || !forView) {
      map['ORDERTYPE_LETTERPARCEL'] = ORDERTYPE_LETTERPARCEL;
    }
    if (ORDERTYPE_EMO != null || !forView) {
      map['ORDERTYPE_EMO'] = ORDERTYPE_EMO;
    }
    if (PRODUCT_TYPE != null || !forView) {
      map['PRODUCT_TYPE'] = PRODUCT_TYPE;
    }
    if (MATERIALGROUP_SP != null || !forView) {
      map['MATERIALGROUP_SP'] = MATERIALGROUP_SP;
    }
    if (MATERIALGROUP_LETTER != null || !forView) {
      map['MATERIALGROUP_LETTER'] = MATERIALGROUP_LETTER;
    }
    if (MATERIALGROUP_EMO != null || !forView) {
      map['MATERIALGROUP_EMO'] = MATERIALGROUP_EMO;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['FILETYPE'] = FILETYPE;
    if (DIVISION != null || !forView) {
      map['DIVISION'] = DIVISION;
    }
    if (ORDERTYPE_SP != null || !forView) {
      map['ORDERTYPE_SP'] = ORDERTYPE_SP;
    }
    if (ORDERTYPE_LETTERPARCEL != null || !forView) {
      map['ORDERTYPE_LETTERPARCEL'] = ORDERTYPE_LETTERPARCEL;
    }
    if (ORDERTYPE_EMO != null || !forView) {
      map['ORDERTYPE_EMO'] = ORDERTYPE_EMO;
    }
    if (PRODUCT_TYPE != null || !forView) {
      map['PRODUCT_TYPE'] = PRODUCT_TYPE;
    }
    if (MATERIALGROUP_SP != null || !forView) {
      map['MATERIALGROUP_SP'] = MATERIALGROUP_SP;
    }
    if (MATERIALGROUP_LETTER != null || !forView) {
      map['MATERIALGROUP_LETTER'] = MATERIALGROUP_LETTER;
    }
    if (MATERIALGROUP_EMO != null || !forView) {
      map['MATERIALGROUP_EMO'] = MATERIALGROUP_EMO;
    }

    return map;
  }

  /// This method returns Json String [FILEMASTERDATA]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [FILEMASTERDATA]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FILETYPE,
      DIVISION,
      ORDERTYPE_SP,
      ORDERTYPE_LETTERPARCEL,
      ORDERTYPE_EMO,
      PRODUCT_TYPE,
      MATERIALGROUP_SP,
      MATERIALGROUP_LETTER,
      MATERIALGROUP_EMO
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      FILETYPE,
      DIVISION,
      ORDERTYPE_SP,
      ORDERTYPE_LETTERPARCEL,
      ORDERTYPE_EMO,
      PRODUCT_TYPE,
      MATERIALGROUP_SP,
      MATERIALGROUP_LETTER,
      MATERIALGROUP_EMO
    ];
  }

  static Future<List<FILEMASTERDATA>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FILEMASTERDATA.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<FILEMASTERDATA>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <FILEMASTERDATA>[];
    try {
      objList = list
          .map((filemasterdata) =>
              FILEMASTERDATA.fromMap(filemasterdata as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR FILEMASTERDATA.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<FILEMASTERDATA>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<FILEMASTERDATA> objList = <FILEMASTERDATA>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = FILEMASTERDATA.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns FILEMASTERDATA by ID if exist, otherwise returns null
  /// Primary Keys: String? FILETYPE
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [FILEMASTERDATA] if exist, otherwise returns null
  Future<FILEMASTERDATA?> getById(String? FILETYPE,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (FILETYPE == null) {
      return null;
    }
    FILEMASTERDATA? obj;
    final data = await _mnFILEMASTERDATA.getById([FILETYPE]);
    if (data.length != 0) {
      obj = FILEMASTERDATA.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (FILEMASTERDATA) object. If the Primary Key (FILETYPE) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same FILETYPE
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnFILEMASTERDATA.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO FILEMASTERDATA (FILETYPE, DIVISION, ORDERTYPE_SP, ORDERTYPE_LETTERPARCEL, ORDERTYPE_EMO, PRODUCT_TYPE, MATERIALGROUP_SP, MATERIALGROUP_LETTER, MATERIALGROUP_EMO)  VALUES (?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<FILEMASTERDATA> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<FILEMASTERDATA> filemasterdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in filemasterdatas) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFILEMASTERDATA.rawInsert(
          'INSERT OR REPLACE INTO FILEMASTERDATA (FILETYPE, DIVISION, ORDERTYPE_SP, ORDERTYPE_LETTERPARCEL, ORDERTYPE_EMO, PRODUCT_TYPE, MATERIALGROUP_SP, MATERIALGROUP_LETTER, MATERIALGROUP_EMO)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            FILETYPE,
            DIVISION,
            ORDERTYPE_SP,
            ORDERTYPE_LETTERPARCEL,
            ORDERTYPE_EMO,
            PRODUCT_TYPE,
            MATERIALGROUP_SP,
            MATERIALGROUP_LETTER,
            MATERIALGROUP_EMO
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FILEMASTERDATA FILETYPE=$FILETYPE updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'FILEMASTERDATA FILETYPE=$FILETYPE did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FILEMASTERDATA Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnFILEMASTERDATA.rawInsert(
          'INSERT OR IGNORE INTO FILEMASTERDATA (FILETYPE, DIVISION, ORDERTYPE_SP, ORDERTYPE_LETTERPARCEL, ORDERTYPE_EMO, PRODUCT_TYPE, MATERIALGROUP_SP, MATERIALGROUP_LETTER, MATERIALGROUP_EMO)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            FILETYPE,
            DIVISION,
            ORDERTYPE_SP,
            ORDERTYPE_LETTERPARCEL,
            ORDERTYPE_EMO,
            PRODUCT_TYPE,
            MATERIALGROUP_SP,
            MATERIALGROUP_LETTER,
            MATERIALGROUP_EMO
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'FILEMASTERDATA FILETYPE=$FILETYPE updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'FILEMASTERDATA FILETYPE=$FILETYPE did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'FILEMASTERDATA Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes FILEMASTERDATA

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete FILEMASTERDATA invoked (FILETYPE=$FILETYPE)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnFILEMASTERDATA.delete(
          QueryParams(whereString: 'FILETYPE=?', whereArguments: [FILETYPE]));
    } else {
      return _mnFILEMASTERDATA.updateBatch(
          QueryParams(whereString: 'FILETYPE=?', whereArguments: [FILETYPE]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [FILEMASTERDATA] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  FILEMASTERDATAFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FILEMASTERDATAFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  FILEMASTERDATAFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return FILEMASTERDATAFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      FILETYPE = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion filemasterdata

// region FILEMASTERDATAField
class FILEMASTERDATAField extends FilterBase {
  FILEMASTERDATAField(FILEMASTERDATAFilterBuilder filemasterdataFB)
      : super(filemasterdataFB);

  @override
  FILEMASTERDATAFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder isNull() {
    return super.isNull() as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as FILEMASTERDATAFilterBuilder;
  }

  @override
  FILEMASTERDATAField get not {
    return super.not as FILEMASTERDATAField;
  }
}
// endregion FILEMASTERDATAField

// region FILEMASTERDATAFilterBuilder
class FILEMASTERDATAFilterBuilder extends ConjunctionBase {
  FILEMASTERDATAFilterBuilder(FILEMASTERDATA obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnFILEMASTERDATA = obj._mnFILEMASTERDATA;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  FILEMASTERDATAManager? _mnFILEMASTERDATA;

  /// put the sql keyword 'AND'
  @override
  FILEMASTERDATAFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  FILEMASTERDATAFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  FILEMASTERDATAFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  FILEMASTERDATAFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  FILEMASTERDATAFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  FILEMASTERDATAFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  FILEMASTERDATAFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FILEMASTERDATAFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FILEMASTERDATAFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  FILEMASTERDATAFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  FILEMASTERDATAFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  FILEMASTERDATAField _setField(
      FILEMASTERDATAField? field, String colName, DbType dbtype) {
    return FILEMASTERDATAField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  FILEMASTERDATAField? _FILETYPE;
  FILEMASTERDATAField get FILETYPE {
    return _FILETYPE = _setField(_FILETYPE, 'FILETYPE', DbType.integer);
  }

  FILEMASTERDATAField? _DIVISION;
  FILEMASTERDATAField get DIVISION {
    return _DIVISION = _setField(_DIVISION, 'DIVISION', DbType.text);
  }

  FILEMASTERDATAField? _ORDERTYPE_SP;
  FILEMASTERDATAField get ORDERTYPE_SP {
    return _ORDERTYPE_SP =
        _setField(_ORDERTYPE_SP, 'ORDERTYPE_SP', DbType.text);
  }

  FILEMASTERDATAField? _ORDERTYPE_LETTERPARCEL;
  FILEMASTERDATAField get ORDERTYPE_LETTERPARCEL {
    return _ORDERTYPE_LETTERPARCEL = _setField(
        _ORDERTYPE_LETTERPARCEL, 'ORDERTYPE_LETTERPARCEL', DbType.text);
  }

  FILEMASTERDATAField? _ORDERTYPE_EMO;
  FILEMASTERDATAField get ORDERTYPE_EMO {
    return _ORDERTYPE_EMO =
        _setField(_ORDERTYPE_EMO, 'ORDERTYPE_EMO', DbType.text);
  }

  FILEMASTERDATAField? _PRODUCT_TYPE;
  FILEMASTERDATAField get PRODUCT_TYPE {
    return _PRODUCT_TYPE =
        _setField(_PRODUCT_TYPE, 'PRODUCT_TYPE', DbType.text);
  }

  FILEMASTERDATAField? _MATERIALGROUP_SP;
  FILEMASTERDATAField get MATERIALGROUP_SP {
    return _MATERIALGROUP_SP =
        _setField(_MATERIALGROUP_SP, 'MATERIALGROUP_SP', DbType.text);
  }

  FILEMASTERDATAField? _MATERIALGROUP_LETTER;
  FILEMASTERDATAField get MATERIALGROUP_LETTER {
    return _MATERIALGROUP_LETTER =
        _setField(_MATERIALGROUP_LETTER, 'MATERIALGROUP_LETTER', DbType.text);
  }

  FILEMASTERDATAField? _MATERIALGROUP_EMO;
  FILEMASTERDATAField get MATERIALGROUP_EMO {
    return _MATERIALGROUP_EMO =
        _setField(_MATERIALGROUP_EMO, 'MATERIALGROUP_EMO', DbType.text);
  }

  /// Deletes List<FILEMASTERDATA> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnFILEMASTERDATA!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnFILEMASTERDATA!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'FILETYPE IN (SELECT FILETYPE from FILEMASTERDATA ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnFILEMASTERDATA!.updateBatch(qparams, values);
  }

  /// This method always returns [FILEMASTERDATA] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FILEMASTERDATA?
  @override
  Future<FILEMASTERDATA?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnFILEMASTERDATA!.toList(qparams);
    final data = await objFuture;
    FILEMASTERDATA? obj;
    if (data.isNotEmpty) {
      obj = FILEMASTERDATA.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [FILEMASTERDATA]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> FILEMASTERDATA?
  @override
  Future<FILEMASTERDATA> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        FILEMASTERDATA();
  }

  /// This method returns int. [FILEMASTERDATA]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? filemasterdataCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final filemasterdatasFuture = await _mnFILEMASTERDATA!.toList(qparams);
    final int count = filemasterdatasFuture[0]['CNT'] as int;
    if (filemasterdataCount != null) {
      filemasterdataCount(count);
    }
    return count;
  }

  /// This method returns List<FILEMASTERDATA> [FILEMASTERDATA]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<FILEMASTERDATA>
  @override
  Future<List<FILEMASTERDATA>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<FILEMASTERDATA> filemasterdatasData =
        await FILEMASTERDATA.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return filemasterdatasData;
  }

  /// This method returns Json String [FILEMASTERDATA]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [FILEMASTERDATA]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [FILEMASTERDATA]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnFILEMASTERDATA!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [FILEMASTERDATA]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `FILETYPE` FROM FILEMASTERDATA WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> FILETYPEData = <String>[];
    qparams.selectColumns = ['FILETYPE'];
    final FILETYPEFuture = await _mnFILEMASTERDATA!.toList(qparams);

    final int count = FILETYPEFuture.length;
    for (int i = 0; i < count; i++) {
      FILETYPEData.add(FILETYPEFuture[i]['FILETYPE'] as String);
    }
    return FILETYPEData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [FILEMASTERDATA]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnFILEMASTERDATA!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await FILEMASTERDATA.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnFILEMASTERDATA!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion FILEMASTERDATAFilterBuilder

// region FILEMASTERDATAFields
class FILEMASTERDATAFields {
  static TableField? _fFILETYPE;
  static TableField get FILETYPE {
    return _fFILETYPE = _fFILETYPE ??
        SqlSyntax.setField(_fFILETYPE, 'filetype', DbType.integer);
  }

  static TableField? _fDIVISION;
  static TableField get DIVISION {
    return _fDIVISION =
        _fDIVISION ?? SqlSyntax.setField(_fDIVISION, 'DIVISION', DbType.text);
  }

  static TableField? _fORDERTYPE_SP;
  static TableField get ORDERTYPE_SP {
    return _fORDERTYPE_SP = _fORDERTYPE_SP ??
        SqlSyntax.setField(_fORDERTYPE_SP, 'ORDERTYPE_SP', DbType.text);
  }

  static TableField? _fORDERTYPE_LETTERPARCEL;
  static TableField get ORDERTYPE_LETTERPARCEL {
    return _fORDERTYPE_LETTERPARCEL = _fORDERTYPE_LETTERPARCEL ??
        SqlSyntax.setField(
            _fORDERTYPE_LETTERPARCEL, 'ORDERTYPE_LETTERPARCEL', DbType.text);
  }

  static TableField? _fORDERTYPE_EMO;
  static TableField get ORDERTYPE_EMO {
    return _fORDERTYPE_EMO = _fORDERTYPE_EMO ??
        SqlSyntax.setField(_fORDERTYPE_EMO, 'ORDERTYPE_EMO', DbType.text);
  }

  static TableField? _fPRODUCT_TYPE;
  static TableField get PRODUCT_TYPE {
    return _fPRODUCT_TYPE = _fPRODUCT_TYPE ??
        SqlSyntax.setField(_fPRODUCT_TYPE, 'PRODUCT_TYPE', DbType.text);
  }

  static TableField? _fMATERIALGROUP_SP;
  static TableField get MATERIALGROUP_SP {
    return _fMATERIALGROUP_SP = _fMATERIALGROUP_SP ??
        SqlSyntax.setField(_fMATERIALGROUP_SP, 'MATERIALGROUP_SP', DbType.text);
  }

  static TableField? _fMATERIALGROUP_LETTER;
  static TableField get MATERIALGROUP_LETTER {
    return _fMATERIALGROUP_LETTER = _fMATERIALGROUP_LETTER ??
        SqlSyntax.setField(
            _fMATERIALGROUP_LETTER, 'MATERIALGROUP_LETTER', DbType.text);
  }

  static TableField? _fMATERIALGROUP_EMO;
  static TableField get MATERIALGROUP_EMO {
    return _fMATERIALGROUP_EMO = _fMATERIALGROUP_EMO ??
        SqlSyntax.setField(
            _fMATERIALGROUP_EMO, 'MATERIALGROUP_EMO', DbType.text);
  }
}
// endregion FILEMASTERDATAFields

//region FILEMASTERDATAManager
class FILEMASTERDATAManager extends SqfEntityProvider {
  FILEMASTERDATAManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'FILEMASTERDATA';
  static const List<String> _primaryKeyList = ['FILETYPE'];
  static const String _whereStr = 'FILETYPE=?';
}

//endregion FILEMASTERDATAManager
// region PaySlipData
class PaySlipData extends TableBase {
  PaySlipData(
      {this.EMPLOYEE_ID,
      this.EMPLOYEE_NAME,
      this.OFFICE,
      this.POSITION,
      this.MONTH,
      this.YEAR,
      this.ACCOUNT_NUMBER,
      this.TRCA,
      this.DEARNESS_ALLOWANCE,
      this.FIXED_STATIONERY_CHARGES,
      this.BOAT_ALLOWANCE,
      this.CYCLE_MAINTENANCE_ALLOWANCE,
      this.OFFICE_MAINTENANCE_ALLOWANCE,
      this.CDA,
      this.COMBINATION_DELIVERY_ALLOWANCE,
      this.COMPENSATION_MAIL_CARRIER,
      this.RETAINERSHIP_ALLOWANCE,
      this.CASH_CONVEYANCE_ALLOWANCE,
      this.PERSONAL_ALLOWANCE_GDS,
      this.BONUS_GDS,
      this.EXGRATIA_GRATUITY,
      this.SEVERANCE_AMOUNT,
      this.INCENTIVES,
      this.DA_ARREARS_GDS,
      this.TOTAL_EARNINGS,
      this.TRCA_ALLOWANCE_ARREARS,
      this.DEARNESS_ALLOWANCE_ARREAR,
      this.DEARNESS_RELIEF_CDAARREAR,
      this.TOTAL_ARREARS,
      this.COURT_ATTACHMENT_ODFM,
      this.RD,
      this.COURT_ATTACHMENT_DFM,
      this.LICENSE_FEE,
      this.SDBS,
      this.AUDIT_OFFICE_RECOVERY,
      this.COOP_CREDIT_SOCIETY,
      this.RELIEF_FUND,
      this.DEATH_RELIEF_FUND,
      this.WATER_TAX,
      this.ELECTRICITY_CHARGES,
      this.AOR_NONTAX,
      this.POSTAL_RELIEF_FUND,
      this.PLI_PREMIUM,
      this.RECREATION_CLUB,
      this.UNION_ASSOCIATION,
      this.WELFARE_FUND,
      this.CGEGIS,
      this.CGHS,
      this.EDAGIS_92,
      this.LIC_PREMIUM,
      this.CGIS,
      this.RPLI,
      this.PLI_SERVICE_TAX,
      this.CONNECTIONS,
      this.CGEWCC,
      this.SOCIETIES,
      this.FNPO,
      this.ED_GIS,
      this.SECURITY_BONDS,
      this.EXTRA_DEPARTMENTAL_UNIONS,
      this.CGEGIS_INSURANCE_FUND,
      this.POSTAL_COOP_SOCIETY,
      this.COOP_BANK_REC,
      this.DIVISION_SPORTS_BOARD,
      this.MISC_DEDUCTIONS,
      this.BONDS,
      this.CWFGDS,
      this.FESTIVAL_ADVANCE_SPECIAL,
      this.TOTAL_DEDUCTIONS,
      this.TOTAL_GROSS_AMOUNT,
      this.NET_PAY}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  PaySlipData.withFields(
      this.EMPLOYEE_ID,
      this.EMPLOYEE_NAME,
      this.OFFICE,
      this.POSITION,
      this.MONTH,
      this.YEAR,
      this.ACCOUNT_NUMBER,
      this.TRCA,
      this.DEARNESS_ALLOWANCE,
      this.FIXED_STATIONERY_CHARGES,
      this.BOAT_ALLOWANCE,
      this.CYCLE_MAINTENANCE_ALLOWANCE,
      this.OFFICE_MAINTENANCE_ALLOWANCE,
      this.CDA,
      this.COMBINATION_DELIVERY_ALLOWANCE,
      this.COMPENSATION_MAIL_CARRIER,
      this.RETAINERSHIP_ALLOWANCE,
      this.CASH_CONVEYANCE_ALLOWANCE,
      this.PERSONAL_ALLOWANCE_GDS,
      this.BONUS_GDS,
      this.EXGRATIA_GRATUITY,
      this.SEVERANCE_AMOUNT,
      this.INCENTIVES,
      this.DA_ARREARS_GDS,
      this.TOTAL_EARNINGS,
      this.TRCA_ALLOWANCE_ARREARS,
      this.DEARNESS_ALLOWANCE_ARREAR,
      this.DEARNESS_RELIEF_CDAARREAR,
      this.TOTAL_ARREARS,
      this.COURT_ATTACHMENT_ODFM,
      this.RD,
      this.COURT_ATTACHMENT_DFM,
      this.LICENSE_FEE,
      this.SDBS,
      this.AUDIT_OFFICE_RECOVERY,
      this.COOP_CREDIT_SOCIETY,
      this.RELIEF_FUND,
      this.DEATH_RELIEF_FUND,
      this.WATER_TAX,
      this.ELECTRICITY_CHARGES,
      this.AOR_NONTAX,
      this.POSTAL_RELIEF_FUND,
      this.PLI_PREMIUM,
      this.RECREATION_CLUB,
      this.UNION_ASSOCIATION,
      this.WELFARE_FUND,
      this.CGEGIS,
      this.CGHS,
      this.EDAGIS_92,
      this.LIC_PREMIUM,
      this.CGIS,
      this.RPLI,
      this.PLI_SERVICE_TAX,
      this.CONNECTIONS,
      this.CGEWCC,
      this.SOCIETIES,
      this.FNPO,
      this.ED_GIS,
      this.SECURITY_BONDS,
      this.EXTRA_DEPARTMENTAL_UNIONS,
      this.CGEGIS_INSURANCE_FUND,
      this.POSTAL_COOP_SOCIETY,
      this.COOP_BANK_REC,
      this.DIVISION_SPORTS_BOARD,
      this.MISC_DEDUCTIONS,
      this.BONDS,
      this.CWFGDS,
      this.FESTIVAL_ADVANCE_SPECIAL,
      this.TOTAL_DEDUCTIONS,
      this.TOTAL_GROSS_AMOUNT,
      this.NET_PAY) {
    _setDefaultValues();
  }
  PaySlipData.withId(
      this.EMPLOYEE_ID,
      this.EMPLOYEE_NAME,
      this.OFFICE,
      this.POSITION,
      this.MONTH,
      this.YEAR,
      this.ACCOUNT_NUMBER,
      this.TRCA,
      this.DEARNESS_ALLOWANCE,
      this.FIXED_STATIONERY_CHARGES,
      this.BOAT_ALLOWANCE,
      this.CYCLE_MAINTENANCE_ALLOWANCE,
      this.OFFICE_MAINTENANCE_ALLOWANCE,
      this.CDA,
      this.COMBINATION_DELIVERY_ALLOWANCE,
      this.COMPENSATION_MAIL_CARRIER,
      this.RETAINERSHIP_ALLOWANCE,
      this.CASH_CONVEYANCE_ALLOWANCE,
      this.PERSONAL_ALLOWANCE_GDS,
      this.BONUS_GDS,
      this.EXGRATIA_GRATUITY,
      this.SEVERANCE_AMOUNT,
      this.INCENTIVES,
      this.DA_ARREARS_GDS,
      this.TOTAL_EARNINGS,
      this.TRCA_ALLOWANCE_ARREARS,
      this.DEARNESS_ALLOWANCE_ARREAR,
      this.DEARNESS_RELIEF_CDAARREAR,
      this.TOTAL_ARREARS,
      this.COURT_ATTACHMENT_ODFM,
      this.RD,
      this.COURT_ATTACHMENT_DFM,
      this.LICENSE_FEE,
      this.SDBS,
      this.AUDIT_OFFICE_RECOVERY,
      this.COOP_CREDIT_SOCIETY,
      this.RELIEF_FUND,
      this.DEATH_RELIEF_FUND,
      this.WATER_TAX,
      this.ELECTRICITY_CHARGES,
      this.AOR_NONTAX,
      this.POSTAL_RELIEF_FUND,
      this.PLI_PREMIUM,
      this.RECREATION_CLUB,
      this.UNION_ASSOCIATION,
      this.WELFARE_FUND,
      this.CGEGIS,
      this.CGHS,
      this.EDAGIS_92,
      this.LIC_PREMIUM,
      this.CGIS,
      this.RPLI,
      this.PLI_SERVICE_TAX,
      this.CONNECTIONS,
      this.CGEWCC,
      this.SOCIETIES,
      this.FNPO,
      this.ED_GIS,
      this.SECURITY_BONDS,
      this.EXTRA_DEPARTMENTAL_UNIONS,
      this.CGEGIS_INSURANCE_FUND,
      this.POSTAL_COOP_SOCIETY,
      this.COOP_BANK_REC,
      this.DIVISION_SPORTS_BOARD,
      this.MISC_DEDUCTIONS,
      this.BONDS,
      this.CWFGDS,
      this.FESTIVAL_ADVANCE_SPECIAL,
      this.TOTAL_DEDUCTIONS,
      this.TOTAL_GROSS_AMOUNT,
      this.NET_PAY) {
    _setDefaultValues();
  }
  // fromMap v2.0
  PaySlipData.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    if (o['EMPLOYEE_ID'] != null) {
      EMPLOYEE_ID = o['EMPLOYEE_ID'].toString();
    }
    if (o['EMPLOYEE_NAME'] != null) {
      EMPLOYEE_NAME = o['EMPLOYEE_NAME'].toString();
    }
    if (o['OFFICE'] != null) {
      OFFICE = o['OFFICE'].toString();
    }
    if (o['POSITION'] != null) {
      POSITION = o['POSITION'].toString();
    }
    if (o['MONTH'] != null) {
      MONTH = o['MONTH'].toString();
    }
    if (o['YEAR'] != null) {
      YEAR = o['YEAR'].toString();
    }
    if (o['ACCOUNT_NUMBER'] != null) {
      ACCOUNT_NUMBER = o['ACCOUNT_NUMBER'].toString();
    }
    if (o['TRCA'] != null) {
      TRCA = o['TRCA'].toString();
    }
    if (o['DEARNESS_ALLOWANCE'] != null) {
      DEARNESS_ALLOWANCE = o['DEARNESS_ALLOWANCE'].toString();
    }
    if (o['FIXED_STATIONERY_CHARGES'] != null) {
      FIXED_STATIONERY_CHARGES = o['FIXED_STATIONERY_CHARGES'].toString();
    }
    if (o['BOAT_ALLOWANCE'] != null) {
      BOAT_ALLOWANCE = o['BOAT_ALLOWANCE'].toString();
    }
    if (o['CYCLE_MAINTENANCE_ALLOWANCE'] != null) {
      CYCLE_MAINTENANCE_ALLOWANCE = o['CYCLE_MAINTENANCE_ALLOWANCE'].toString();
    }
    if (o['OFFICE_MAINTENANCE_ALLOWANCE'] != null) {
      OFFICE_MAINTENANCE_ALLOWANCE =
          o['OFFICE_MAINTENANCE_ALLOWANCE'].toString();
    }
    if (o['CDA'] != null) {
      CDA = o['CDA'].toString();
    }
    if (o['COMBINATION_DELIVERY_ALLOWANCE'] != null) {
      COMBINATION_DELIVERY_ALLOWANCE =
          o['COMBINATION_DELIVERY_ALLOWANCE'].toString();
    }
    if (o['COMPENSATION_MAIL_CARRIER'] != null) {
      COMPENSATION_MAIL_CARRIER = o['COMPENSATION_MAIL_CARRIER'].toString();
    }
    if (o['RETAINERSHIP_ALLOWANCE'] != null) {
      RETAINERSHIP_ALLOWANCE = o['RETAINERSHIP_ALLOWANCE'].toString();
    }
    if (o['CASH_CONVEYANCE_ALLOWANCE'] != null) {
      CASH_CONVEYANCE_ALLOWANCE = o['CASH_CONVEYANCE_ALLOWANCE'].toString();
    }
    if (o['PERSONAL_ALLOWANCE_GDS'] != null) {
      PERSONAL_ALLOWANCE_GDS = o['PERSONAL_ALLOWANCE_GDS'].toString();
    }
    if (o['BONUS_GDS'] != null) {
      BONUS_GDS = o['BONUS_GDS'].toString();
    }
    if (o['EXGRATIA_GRATUITY'] != null) {
      EXGRATIA_GRATUITY = o['EXGRATIA_GRATUITY'].toString();
    }
    if (o['SEVERANCE_AMOUNT'] != null) {
      SEVERANCE_AMOUNT = o['SEVERANCE_AMOUNT'].toString();
    }
    if (o['INCENTIVES'] != null) {
      INCENTIVES = o['INCENTIVES'].toString();
    }
    if (o['DA_ARREARS_GDS'] != null) {
      DA_ARREARS_GDS = o['DA_ARREARS_GDS'].toString();
    }
    if (o['TOTAL_EARNINGS'] != null) {
      TOTAL_EARNINGS = o['TOTAL_EARNINGS'].toString();
    }
    if (o['TRCA_ALLOWANCE_ARREARS'] != null) {
      TRCA_ALLOWANCE_ARREARS = o['TRCA_ALLOWANCE_ARREARS'].toString();
    }
    if (o['DEARNESS_ALLOWANCE_ARREAR'] != null) {
      DEARNESS_ALLOWANCE_ARREAR = o['DEARNESS_ALLOWANCE_ARREAR'].toString();
    }
    if (o['DEARNESS_RELIEF_CDAARREAR'] != null) {
      DEARNESS_RELIEF_CDAARREAR = o['DEARNESS_RELIEF_CDAARREAR'].toString();
    }
    if (o['TOTAL_ARREARS'] != null) {
      TOTAL_ARREARS = o['TOTAL_ARREARS'].toString();
    }
    if (o['COURT_ATTACHMENT_ODFM'] != null) {
      COURT_ATTACHMENT_ODFM = o['COURT_ATTACHMENT_ODFM'].toString();
    }
    if (o['RD'] != null) {
      RD = o['RD'].toString();
    }
    if (o['COURT_ATTACHMENT_DFM'] != null) {
      COURT_ATTACHMENT_DFM = o['COURT_ATTACHMENT_DFM'].toString();
    }
    if (o['LICENSE_FEE'] != null) {
      LICENSE_FEE = o['LICENSE_FEE'].toString();
    }
    if (o['SDBS'] != null) {
      SDBS = o['SDBS'].toString();
    }
    if (o['AUDIT_OFFICE_RECOVERY'] != null) {
      AUDIT_OFFICE_RECOVERY = o['AUDIT_OFFICE_RECOVERY'].toString();
    }
    if (o['COOP_CREDIT_SOCIETY'] != null) {
      COOP_CREDIT_SOCIETY = o['COOP_CREDIT_SOCIETY'].toString();
    }
    if (o['RELIEF_FUND'] != null) {
      RELIEF_FUND = o['RELIEF_FUND'].toString();
    }
    if (o['DEATH_RELIEF_FUND'] != null) {
      DEATH_RELIEF_FUND = o['DEATH_RELIEF_FUND'].toString();
    }
    if (o['WATER_TAX'] != null) {
      WATER_TAX = o['WATER_TAX'].toString();
    }
    if (o['ELECTRICITY_CHARGES'] != null) {
      ELECTRICITY_CHARGES = o['ELECTRICITY_CHARGES'].toString();
    }
    if (o['AOR_NONTAX'] != null) {
      AOR_NONTAX = o['AOR_NONTAX'].toString();
    }
    if (o['POSTAL_RELIEF_FUND'] != null) {
      POSTAL_RELIEF_FUND = o['POSTAL_RELIEF_FUND'].toString();
    }
    if (o['PLI_PREMIUM'] != null) {
      PLI_PREMIUM = o['PLI_PREMIUM'].toString();
    }
    if (o['RECREATION_CLUB'] != null) {
      RECREATION_CLUB = o['RECREATION_CLUB'].toString();
    }
    if (o['UNION_ASSOCIATION'] != null) {
      UNION_ASSOCIATION = o['UNION_ASSOCIATION'].toString();
    }
    if (o['WELFARE_FUND'] != null) {
      WELFARE_FUND = o['WELFARE_FUND'].toString();
    }
    if (o['CGEGIS'] != null) {
      CGEGIS = o['CGEGIS'].toString();
    }
    if (o['CGHS'] != null) {
      CGHS = o['CGHS'].toString();
    }
    if (o['EDAGIS_92'] != null) {
      EDAGIS_92 = o['EDAGIS_92'].toString();
    }
    if (o['LIC_PREMIUM'] != null) {
      LIC_PREMIUM = o['LIC_PREMIUM'].toString();
    }
    if (o['CGIS'] != null) {
      CGIS = o['CGIS'].toString();
    }
    if (o['RPLI'] != null) {
      RPLI = o['RPLI'].toString();
    }
    if (o['PLI_SERVICE_TAX'] != null) {
      PLI_SERVICE_TAX = o['PLI_SERVICE_TAX'].toString();
    }
    if (o['CONNECTIONS'] != null) {
      CONNECTIONS = o['CONNECTIONS'].toString();
    }
    if (o['CGEWCC'] != null) {
      CGEWCC = o['CGEWCC'].toString();
    }
    if (o['SOCIETIES'] != null) {
      SOCIETIES = o['SOCIETIES'].toString();
    }
    if (o['FNPO'] != null) {
      FNPO = o['FNPO'].toString();
    }
    if (o['ED_GIS'] != null) {
      ED_GIS = o['ED_GIS'].toString();
    }
    if (o['SECURITY_BONDS'] != null) {
      SECURITY_BONDS = o['SECURITY_BONDS'].toString();
    }
    if (o['EXTRA_DEPARTMENTAL_UNIONS'] != null) {
      EXTRA_DEPARTMENTAL_UNIONS = o['EXTRA_DEPARTMENTAL_UNIONS'].toString();
    }
    if (o['CGEGIS_INSURANCE_FUND'] != null) {
      CGEGIS_INSURANCE_FUND = o['CGEGIS_INSURANCE_FUND'].toString();
    }
    if (o['POSTAL_COOP_SOCIETY'] != null) {
      POSTAL_COOP_SOCIETY = o['POSTAL_COOP_SOCIETY'].toString();
    }
    if (o['COOP_BANK_REC'] != null) {
      COOP_BANK_REC = o['COOP_BANK_REC'].toString();
    }
    if (o['DIVISION_SPORTS_BOARD'] != null) {
      DIVISION_SPORTS_BOARD = o['DIVISION_SPORTS_BOARD'].toString();
    }
    if (o['MISC_DEDUCTIONS'] != null) {
      MISC_DEDUCTIONS = o['MISC_DEDUCTIONS'].toString();
    }
    if (o['BONDS'] != null) {
      BONDS = o['BONDS'].toString();
    }
    if (o['CWFGDS'] != null) {
      CWFGDS = o['CWFGDS'].toString();
    }
    if (o['FESTIVAL_ADVANCE_SPECIAL'] != null) {
      FESTIVAL_ADVANCE_SPECIAL = o['FESTIVAL_ADVANCE_SPECIAL'].toString();
    }
    if (o['TOTAL_DEDUCTIONS'] != null) {
      TOTAL_DEDUCTIONS = o['TOTAL_DEDUCTIONS'].toString();
    }
    if (o['TOTAL_GROSS_AMOUNT'] != null) {
      TOTAL_GROSS_AMOUNT = o['TOTAL_GROSS_AMOUNT'].toString();
    }
    if (o['NET_PAY'] != null) {
      NET_PAY = o['NET_PAY'].toString();
    }

    isSaved = true;
  }
  // FIELDS (PaySlipData)
  String? EMPLOYEE_ID;
  String? EMPLOYEE_NAME;
  String? OFFICE;
  String? POSITION;
  String? MONTH;
  String? YEAR;
  String? ACCOUNT_NUMBER;
  String? TRCA;
  String? DEARNESS_ALLOWANCE;
  String? FIXED_STATIONERY_CHARGES;
  String? BOAT_ALLOWANCE;
  String? CYCLE_MAINTENANCE_ALLOWANCE;
  String? OFFICE_MAINTENANCE_ALLOWANCE;
  String? CDA;
  String? COMBINATION_DELIVERY_ALLOWANCE;
  String? COMPENSATION_MAIL_CARRIER;
  String? RETAINERSHIP_ALLOWANCE;
  String? CASH_CONVEYANCE_ALLOWANCE;
  String? PERSONAL_ALLOWANCE_GDS;
  String? BONUS_GDS;
  String? EXGRATIA_GRATUITY;
  String? SEVERANCE_AMOUNT;
  String? INCENTIVES;
  String? DA_ARREARS_GDS;
  String? TOTAL_EARNINGS;
  String? TRCA_ALLOWANCE_ARREARS;
  String? DEARNESS_ALLOWANCE_ARREAR;
  String? DEARNESS_RELIEF_CDAARREAR;
  String? TOTAL_ARREARS;
  String? COURT_ATTACHMENT_ODFM;
  String? RD;
  String? COURT_ATTACHMENT_DFM;
  String? LICENSE_FEE;
  String? SDBS;
  String? AUDIT_OFFICE_RECOVERY;
  String? COOP_CREDIT_SOCIETY;
  String? RELIEF_FUND;
  String? DEATH_RELIEF_FUND;
  String? WATER_TAX;
  String? ELECTRICITY_CHARGES;
  String? AOR_NONTAX;
  String? POSTAL_RELIEF_FUND;
  String? PLI_PREMIUM;
  String? RECREATION_CLUB;
  String? UNION_ASSOCIATION;
  String? WELFARE_FUND;
  String? CGEGIS;
  String? CGHS;
  String? EDAGIS_92;
  String? LIC_PREMIUM;
  String? CGIS;
  String? RPLI;
  String? PLI_SERVICE_TAX;
  String? CONNECTIONS;
  String? CGEWCC;
  String? SOCIETIES;
  String? FNPO;
  String? ED_GIS;
  String? SECURITY_BONDS;
  String? EXTRA_DEPARTMENTAL_UNIONS;
  String? CGEGIS_INSURANCE_FUND;
  String? POSTAL_COOP_SOCIETY;
  String? COOP_BANK_REC;
  String? DIVISION_SPORTS_BOARD;
  String? MISC_DEDUCTIONS;
  String? BONDS;
  String? CWFGDS;
  String? FESTIVAL_ADVANCE_SPECIAL;
  String? TOTAL_DEDUCTIONS;
  String? TOTAL_GROSS_AMOUNT;
  String? NET_PAY;
  bool? isSaved;
  // end FIELDS (PaySlipData)

  static const bool _softDeleteActivated = false;
  PaySlipDataManager? __mnPaySlipData;

  PaySlipDataManager get _mnPaySlipData {
    return __mnPaySlipData = __mnPaySlipData ?? PaySlipDataManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    if (EMPLOYEE_ID != null || !forView) {
      map['EMPLOYEE_ID'] = EMPLOYEE_ID;
    }
    if (EMPLOYEE_NAME != null || !forView) {
      map['EMPLOYEE_NAME'] = EMPLOYEE_NAME;
    }
    if (OFFICE != null || !forView) {
      map['OFFICE'] = OFFICE;
    }
    if (POSITION != null || !forView) {
      map['POSITION'] = POSITION;
    }
    if (MONTH != null || !forView) {
      map['MONTH'] = MONTH;
    }
    if (YEAR != null || !forView) {
      map['YEAR'] = YEAR;
    }
    if (ACCOUNT_NUMBER != null || !forView) {
      map['ACCOUNT_NUMBER'] = ACCOUNT_NUMBER;
    }
    if (TRCA != null || !forView) {
      map['TRCA'] = TRCA;
    }
    if (DEARNESS_ALLOWANCE != null || !forView) {
      map['DEARNESS_ALLOWANCE'] = DEARNESS_ALLOWANCE;
    }
    if (FIXED_STATIONERY_CHARGES != null || !forView) {
      map['FIXED_STATIONERY_CHARGES'] = FIXED_STATIONERY_CHARGES;
    }
    if (BOAT_ALLOWANCE != null || !forView) {
      map['BOAT_ALLOWANCE'] = BOAT_ALLOWANCE;
    }
    if (CYCLE_MAINTENANCE_ALLOWANCE != null || !forView) {
      map['CYCLE_MAINTENANCE_ALLOWANCE'] = CYCLE_MAINTENANCE_ALLOWANCE;
    }
    if (OFFICE_MAINTENANCE_ALLOWANCE != null || !forView) {
      map['OFFICE_MAINTENANCE_ALLOWANCE'] = OFFICE_MAINTENANCE_ALLOWANCE;
    }
    if (CDA != null || !forView) {
      map['CDA'] = CDA;
    }
    if (COMBINATION_DELIVERY_ALLOWANCE != null || !forView) {
      map['COMBINATION_DELIVERY_ALLOWANCE'] = COMBINATION_DELIVERY_ALLOWANCE;
    }
    if (COMPENSATION_MAIL_CARRIER != null || !forView) {
      map['COMPENSATION_MAIL_CARRIER'] = COMPENSATION_MAIL_CARRIER;
    }
    if (RETAINERSHIP_ALLOWANCE != null || !forView) {
      map['RETAINERSHIP_ALLOWANCE'] = RETAINERSHIP_ALLOWANCE;
    }
    if (CASH_CONVEYANCE_ALLOWANCE != null || !forView) {
      map['CASH_CONVEYANCE_ALLOWANCE'] = CASH_CONVEYANCE_ALLOWANCE;
    }
    if (PERSONAL_ALLOWANCE_GDS != null || !forView) {
      map['PERSONAL_ALLOWANCE_GDS'] = PERSONAL_ALLOWANCE_GDS;
    }
    if (BONUS_GDS != null || !forView) {
      map['BONUS_GDS'] = BONUS_GDS;
    }
    if (EXGRATIA_GRATUITY != null || !forView) {
      map['EXGRATIA_GRATUITY'] = EXGRATIA_GRATUITY;
    }
    if (SEVERANCE_AMOUNT != null || !forView) {
      map['SEVERANCE_AMOUNT'] = SEVERANCE_AMOUNT;
    }
    if (INCENTIVES != null || !forView) {
      map['INCENTIVES'] = INCENTIVES;
    }
    if (DA_ARREARS_GDS != null || !forView) {
      map['DA_ARREARS_GDS'] = DA_ARREARS_GDS;
    }
    if (TOTAL_EARNINGS != null || !forView) {
      map['TOTAL_EARNINGS'] = TOTAL_EARNINGS;
    }
    if (TRCA_ALLOWANCE_ARREARS != null || !forView) {
      map['TRCA_ALLOWANCE_ARREARS'] = TRCA_ALLOWANCE_ARREARS;
    }
    if (DEARNESS_ALLOWANCE_ARREAR != null || !forView) {
      map['DEARNESS_ALLOWANCE_ARREAR'] = DEARNESS_ALLOWANCE_ARREAR;
    }
    if (DEARNESS_RELIEF_CDAARREAR != null || !forView) {
      map['DEARNESS_RELIEF_CDAARREAR'] = DEARNESS_RELIEF_CDAARREAR;
    }
    if (TOTAL_ARREARS != null || !forView) {
      map['TOTAL_ARREARS'] = TOTAL_ARREARS;
    }
    if (COURT_ATTACHMENT_ODFM != null || !forView) {
      map['COURT_ATTACHMENT_ODFM'] = COURT_ATTACHMENT_ODFM;
    }
    if (RD != null || !forView) {
      map['RD'] = RD;
    }
    if (COURT_ATTACHMENT_DFM != null || !forView) {
      map['COURT_ATTACHMENT_DFM'] = COURT_ATTACHMENT_DFM;
    }
    if (LICENSE_FEE != null || !forView) {
      map['LICENSE_FEE'] = LICENSE_FEE;
    }
    if (SDBS != null || !forView) {
      map['SDBS'] = SDBS;
    }
    if (AUDIT_OFFICE_RECOVERY != null || !forView) {
      map['AUDIT_OFFICE_RECOVERY'] = AUDIT_OFFICE_RECOVERY;
    }
    if (COOP_CREDIT_SOCIETY != null || !forView) {
      map['COOP_CREDIT_SOCIETY'] = COOP_CREDIT_SOCIETY;
    }
    if (RELIEF_FUND != null || !forView) {
      map['RELIEF_FUND'] = RELIEF_FUND;
    }
    if (DEATH_RELIEF_FUND != null || !forView) {
      map['DEATH_RELIEF_FUND'] = DEATH_RELIEF_FUND;
    }
    if (WATER_TAX != null || !forView) {
      map['WATER_TAX'] = WATER_TAX;
    }
    if (ELECTRICITY_CHARGES != null || !forView) {
      map['ELECTRICITY_CHARGES'] = ELECTRICITY_CHARGES;
    }
    if (AOR_NONTAX != null || !forView) {
      map['AOR_NONTAX'] = AOR_NONTAX;
    }
    if (POSTAL_RELIEF_FUND != null || !forView) {
      map['POSTAL_RELIEF_FUND'] = POSTAL_RELIEF_FUND;
    }
    if (PLI_PREMIUM != null || !forView) {
      map['PLI_PREMIUM'] = PLI_PREMIUM;
    }
    if (RECREATION_CLUB != null || !forView) {
      map['RECREATION_CLUB'] = RECREATION_CLUB;
    }
    if (UNION_ASSOCIATION != null || !forView) {
      map['UNION_ASSOCIATION'] = UNION_ASSOCIATION;
    }
    if (WELFARE_FUND != null || !forView) {
      map['WELFARE_FUND'] = WELFARE_FUND;
    }
    if (CGEGIS != null || !forView) {
      map['CGEGIS'] = CGEGIS;
    }
    if (CGHS != null || !forView) {
      map['CGHS'] = CGHS;
    }
    if (EDAGIS_92 != null || !forView) {
      map['EDAGIS_92'] = EDAGIS_92;
    }
    if (LIC_PREMIUM != null || !forView) {
      map['LIC_PREMIUM'] = LIC_PREMIUM;
    }
    if (CGIS != null || !forView) {
      map['CGIS'] = CGIS;
    }
    if (RPLI != null || !forView) {
      map['RPLI'] = RPLI;
    }
    if (PLI_SERVICE_TAX != null || !forView) {
      map['PLI_SERVICE_TAX'] = PLI_SERVICE_TAX;
    }
    if (CONNECTIONS != null || !forView) {
      map['CONNECTIONS'] = CONNECTIONS;
    }
    if (CGEWCC != null || !forView) {
      map['CGEWCC'] = CGEWCC;
    }
    if (SOCIETIES != null || !forView) {
      map['SOCIETIES'] = SOCIETIES;
    }
    if (FNPO != null || !forView) {
      map['FNPO'] = FNPO;
    }
    if (ED_GIS != null || !forView) {
      map['ED_GIS'] = ED_GIS;
    }
    if (SECURITY_BONDS != null || !forView) {
      map['SECURITY_BONDS'] = SECURITY_BONDS;
    }
    if (EXTRA_DEPARTMENTAL_UNIONS != null || !forView) {
      map['EXTRA_DEPARTMENTAL_UNIONS'] = EXTRA_DEPARTMENTAL_UNIONS;
    }
    if (CGEGIS_INSURANCE_FUND != null || !forView) {
      map['CGEGIS_INSURANCE_FUND'] = CGEGIS_INSURANCE_FUND;
    }
    if (POSTAL_COOP_SOCIETY != null || !forView) {
      map['POSTAL_COOP_SOCIETY'] = POSTAL_COOP_SOCIETY;
    }
    if (COOP_BANK_REC != null || !forView) {
      map['COOP_BANK_REC'] = COOP_BANK_REC;
    }
    if (DIVISION_SPORTS_BOARD != null || !forView) {
      map['DIVISION_SPORTS_BOARD'] = DIVISION_SPORTS_BOARD;
    }
    if (MISC_DEDUCTIONS != null || !forView) {
      map['MISC_DEDUCTIONS'] = MISC_DEDUCTIONS;
    }
    if (BONDS != null || !forView) {
      map['BONDS'] = BONDS;
    }
    if (CWFGDS != null || !forView) {
      map['CWFGDS'] = CWFGDS;
    }
    if (FESTIVAL_ADVANCE_SPECIAL != null || !forView) {
      map['FESTIVAL_ADVANCE_SPECIAL'] = FESTIVAL_ADVANCE_SPECIAL;
    }
    if (TOTAL_DEDUCTIONS != null || !forView) {
      map['TOTAL_DEDUCTIONS'] = TOTAL_DEDUCTIONS;
    }
    if (TOTAL_GROSS_AMOUNT != null || !forView) {
      map['TOTAL_GROSS_AMOUNT'] = TOTAL_GROSS_AMOUNT;
    }
    if (NET_PAY != null || !forView) {
      map['NET_PAY'] = NET_PAY;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    if (EMPLOYEE_ID != null || !forView) {
      map['EMPLOYEE_ID'] = EMPLOYEE_ID;
    }
    if (EMPLOYEE_NAME != null || !forView) {
      map['EMPLOYEE_NAME'] = EMPLOYEE_NAME;
    }
    if (OFFICE != null || !forView) {
      map['OFFICE'] = OFFICE;
    }
    if (POSITION != null || !forView) {
      map['POSITION'] = POSITION;
    }
    if (MONTH != null || !forView) {
      map['MONTH'] = MONTH;
    }
    if (YEAR != null || !forView) {
      map['YEAR'] = YEAR;
    }
    if (ACCOUNT_NUMBER != null || !forView) {
      map['ACCOUNT_NUMBER'] = ACCOUNT_NUMBER;
    }
    if (TRCA != null || !forView) {
      map['TRCA'] = TRCA;
    }
    if (DEARNESS_ALLOWANCE != null || !forView) {
      map['DEARNESS_ALLOWANCE'] = DEARNESS_ALLOWANCE;
    }
    if (FIXED_STATIONERY_CHARGES != null || !forView) {
      map['FIXED_STATIONERY_CHARGES'] = FIXED_STATIONERY_CHARGES;
    }
    if (BOAT_ALLOWANCE != null || !forView) {
      map['BOAT_ALLOWANCE'] = BOAT_ALLOWANCE;
    }
    if (CYCLE_MAINTENANCE_ALLOWANCE != null || !forView) {
      map['CYCLE_MAINTENANCE_ALLOWANCE'] = CYCLE_MAINTENANCE_ALLOWANCE;
    }
    if (OFFICE_MAINTENANCE_ALLOWANCE != null || !forView) {
      map['OFFICE_MAINTENANCE_ALLOWANCE'] = OFFICE_MAINTENANCE_ALLOWANCE;
    }
    if (CDA != null || !forView) {
      map['CDA'] = CDA;
    }
    if (COMBINATION_DELIVERY_ALLOWANCE != null || !forView) {
      map['COMBINATION_DELIVERY_ALLOWANCE'] = COMBINATION_DELIVERY_ALLOWANCE;
    }
    if (COMPENSATION_MAIL_CARRIER != null || !forView) {
      map['COMPENSATION_MAIL_CARRIER'] = COMPENSATION_MAIL_CARRIER;
    }
    if (RETAINERSHIP_ALLOWANCE != null || !forView) {
      map['RETAINERSHIP_ALLOWANCE'] = RETAINERSHIP_ALLOWANCE;
    }
    if (CASH_CONVEYANCE_ALLOWANCE != null || !forView) {
      map['CASH_CONVEYANCE_ALLOWANCE'] = CASH_CONVEYANCE_ALLOWANCE;
    }
    if (PERSONAL_ALLOWANCE_GDS != null || !forView) {
      map['PERSONAL_ALLOWANCE_GDS'] = PERSONAL_ALLOWANCE_GDS;
    }
    if (BONUS_GDS != null || !forView) {
      map['BONUS_GDS'] = BONUS_GDS;
    }
    if (EXGRATIA_GRATUITY != null || !forView) {
      map['EXGRATIA_GRATUITY'] = EXGRATIA_GRATUITY;
    }
    if (SEVERANCE_AMOUNT != null || !forView) {
      map['SEVERANCE_AMOUNT'] = SEVERANCE_AMOUNT;
    }
    if (INCENTIVES != null || !forView) {
      map['INCENTIVES'] = INCENTIVES;
    }
    if (DA_ARREARS_GDS != null || !forView) {
      map['DA_ARREARS_GDS'] = DA_ARREARS_GDS;
    }
    if (TOTAL_EARNINGS != null || !forView) {
      map['TOTAL_EARNINGS'] = TOTAL_EARNINGS;
    }
    if (TRCA_ALLOWANCE_ARREARS != null || !forView) {
      map['TRCA_ALLOWANCE_ARREARS'] = TRCA_ALLOWANCE_ARREARS;
    }
    if (DEARNESS_ALLOWANCE_ARREAR != null || !forView) {
      map['DEARNESS_ALLOWANCE_ARREAR'] = DEARNESS_ALLOWANCE_ARREAR;
    }
    if (DEARNESS_RELIEF_CDAARREAR != null || !forView) {
      map['DEARNESS_RELIEF_CDAARREAR'] = DEARNESS_RELIEF_CDAARREAR;
    }
    if (TOTAL_ARREARS != null || !forView) {
      map['TOTAL_ARREARS'] = TOTAL_ARREARS;
    }
    if (COURT_ATTACHMENT_ODFM != null || !forView) {
      map['COURT_ATTACHMENT_ODFM'] = COURT_ATTACHMENT_ODFM;
    }
    if (RD != null || !forView) {
      map['RD'] = RD;
    }
    if (COURT_ATTACHMENT_DFM != null || !forView) {
      map['COURT_ATTACHMENT_DFM'] = COURT_ATTACHMENT_DFM;
    }
    if (LICENSE_FEE != null || !forView) {
      map['LICENSE_FEE'] = LICENSE_FEE;
    }
    if (SDBS != null || !forView) {
      map['SDBS'] = SDBS;
    }
    if (AUDIT_OFFICE_RECOVERY != null || !forView) {
      map['AUDIT_OFFICE_RECOVERY'] = AUDIT_OFFICE_RECOVERY;
    }
    if (COOP_CREDIT_SOCIETY != null || !forView) {
      map['COOP_CREDIT_SOCIETY'] = COOP_CREDIT_SOCIETY;
    }
    if (RELIEF_FUND != null || !forView) {
      map['RELIEF_FUND'] = RELIEF_FUND;
    }
    if (DEATH_RELIEF_FUND != null || !forView) {
      map['DEATH_RELIEF_FUND'] = DEATH_RELIEF_FUND;
    }
    if (WATER_TAX != null || !forView) {
      map['WATER_TAX'] = WATER_TAX;
    }
    if (ELECTRICITY_CHARGES != null || !forView) {
      map['ELECTRICITY_CHARGES'] = ELECTRICITY_CHARGES;
    }
    if (AOR_NONTAX != null || !forView) {
      map['AOR_NONTAX'] = AOR_NONTAX;
    }
    if (POSTAL_RELIEF_FUND != null || !forView) {
      map['POSTAL_RELIEF_FUND'] = POSTAL_RELIEF_FUND;
    }
    if (PLI_PREMIUM != null || !forView) {
      map['PLI_PREMIUM'] = PLI_PREMIUM;
    }
    if (RECREATION_CLUB != null || !forView) {
      map['RECREATION_CLUB'] = RECREATION_CLUB;
    }
    if (UNION_ASSOCIATION != null || !forView) {
      map['UNION_ASSOCIATION'] = UNION_ASSOCIATION;
    }
    if (WELFARE_FUND != null || !forView) {
      map['WELFARE_FUND'] = WELFARE_FUND;
    }
    if (CGEGIS != null || !forView) {
      map['CGEGIS'] = CGEGIS;
    }
    if (CGHS != null || !forView) {
      map['CGHS'] = CGHS;
    }
    if (EDAGIS_92 != null || !forView) {
      map['EDAGIS_92'] = EDAGIS_92;
    }
    if (LIC_PREMIUM != null || !forView) {
      map['LIC_PREMIUM'] = LIC_PREMIUM;
    }
    if (CGIS != null || !forView) {
      map['CGIS'] = CGIS;
    }
    if (RPLI != null || !forView) {
      map['RPLI'] = RPLI;
    }
    if (PLI_SERVICE_TAX != null || !forView) {
      map['PLI_SERVICE_TAX'] = PLI_SERVICE_TAX;
    }
    if (CONNECTIONS != null || !forView) {
      map['CONNECTIONS'] = CONNECTIONS;
    }
    if (CGEWCC != null || !forView) {
      map['CGEWCC'] = CGEWCC;
    }
    if (SOCIETIES != null || !forView) {
      map['SOCIETIES'] = SOCIETIES;
    }
    if (FNPO != null || !forView) {
      map['FNPO'] = FNPO;
    }
    if (ED_GIS != null || !forView) {
      map['ED_GIS'] = ED_GIS;
    }
    if (SECURITY_BONDS != null || !forView) {
      map['SECURITY_BONDS'] = SECURITY_BONDS;
    }
    if (EXTRA_DEPARTMENTAL_UNIONS != null || !forView) {
      map['EXTRA_DEPARTMENTAL_UNIONS'] = EXTRA_DEPARTMENTAL_UNIONS;
    }
    if (CGEGIS_INSURANCE_FUND != null || !forView) {
      map['CGEGIS_INSURANCE_FUND'] = CGEGIS_INSURANCE_FUND;
    }
    if (POSTAL_COOP_SOCIETY != null || !forView) {
      map['POSTAL_COOP_SOCIETY'] = POSTAL_COOP_SOCIETY;
    }
    if (COOP_BANK_REC != null || !forView) {
      map['COOP_BANK_REC'] = COOP_BANK_REC;
    }
    if (DIVISION_SPORTS_BOARD != null || !forView) {
      map['DIVISION_SPORTS_BOARD'] = DIVISION_SPORTS_BOARD;
    }
    if (MISC_DEDUCTIONS != null || !forView) {
      map['MISC_DEDUCTIONS'] = MISC_DEDUCTIONS;
    }
    if (BONDS != null || !forView) {
      map['BONDS'] = BONDS;
    }
    if (CWFGDS != null || !forView) {
      map['CWFGDS'] = CWFGDS;
    }
    if (FESTIVAL_ADVANCE_SPECIAL != null || !forView) {
      map['FESTIVAL_ADVANCE_SPECIAL'] = FESTIVAL_ADVANCE_SPECIAL;
    }
    if (TOTAL_DEDUCTIONS != null || !forView) {
      map['TOTAL_DEDUCTIONS'] = TOTAL_DEDUCTIONS;
    }
    if (TOTAL_GROSS_AMOUNT != null || !forView) {
      map['TOTAL_GROSS_AMOUNT'] = TOTAL_GROSS_AMOUNT;
    }
    if (NET_PAY != null || !forView) {
      map['NET_PAY'] = NET_PAY;
    }

    return map;
  }

  /// This method returns Json String [PaySlipData]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [PaySlipData]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      EMPLOYEE_ID,
      EMPLOYEE_NAME,
      OFFICE,
      POSITION,
      MONTH,
      YEAR,
      ACCOUNT_NUMBER,
      TRCA,
      DEARNESS_ALLOWANCE,
      FIXED_STATIONERY_CHARGES,
      BOAT_ALLOWANCE,
      CYCLE_MAINTENANCE_ALLOWANCE,
      OFFICE_MAINTENANCE_ALLOWANCE,
      CDA,
      COMBINATION_DELIVERY_ALLOWANCE,
      COMPENSATION_MAIL_CARRIER,
      RETAINERSHIP_ALLOWANCE,
      CASH_CONVEYANCE_ALLOWANCE,
      PERSONAL_ALLOWANCE_GDS,
      BONUS_GDS,
      EXGRATIA_GRATUITY,
      SEVERANCE_AMOUNT,
      INCENTIVES,
      DA_ARREARS_GDS,
      TOTAL_EARNINGS,
      TRCA_ALLOWANCE_ARREARS,
      DEARNESS_ALLOWANCE_ARREAR,
      DEARNESS_RELIEF_CDAARREAR,
      TOTAL_ARREARS,
      COURT_ATTACHMENT_ODFM,
      RD,
      COURT_ATTACHMENT_DFM,
      LICENSE_FEE,
      SDBS,
      AUDIT_OFFICE_RECOVERY,
      COOP_CREDIT_SOCIETY,
      RELIEF_FUND,
      DEATH_RELIEF_FUND,
      WATER_TAX,
      ELECTRICITY_CHARGES,
      AOR_NONTAX,
      POSTAL_RELIEF_FUND,
      PLI_PREMIUM,
      RECREATION_CLUB,
      UNION_ASSOCIATION,
      WELFARE_FUND,
      CGEGIS,
      CGHS,
      EDAGIS_92,
      LIC_PREMIUM,
      CGIS,
      RPLI,
      PLI_SERVICE_TAX,
      CONNECTIONS,
      CGEWCC,
      SOCIETIES,
      FNPO,
      ED_GIS,
      SECURITY_BONDS,
      EXTRA_DEPARTMENTAL_UNIONS,
      CGEGIS_INSURANCE_FUND,
      POSTAL_COOP_SOCIETY,
      COOP_BANK_REC,
      DIVISION_SPORTS_BOARD,
      MISC_DEDUCTIONS,
      BONDS,
      CWFGDS,
      FESTIVAL_ADVANCE_SPECIAL,
      TOTAL_DEDUCTIONS,
      TOTAL_GROSS_AMOUNT,
      NET_PAY
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      EMPLOYEE_ID,
      EMPLOYEE_NAME,
      OFFICE,
      POSITION,
      MONTH,
      YEAR,
      ACCOUNT_NUMBER,
      TRCA,
      DEARNESS_ALLOWANCE,
      FIXED_STATIONERY_CHARGES,
      BOAT_ALLOWANCE,
      CYCLE_MAINTENANCE_ALLOWANCE,
      OFFICE_MAINTENANCE_ALLOWANCE,
      CDA,
      COMBINATION_DELIVERY_ALLOWANCE,
      COMPENSATION_MAIL_CARRIER,
      RETAINERSHIP_ALLOWANCE,
      CASH_CONVEYANCE_ALLOWANCE,
      PERSONAL_ALLOWANCE_GDS,
      BONUS_GDS,
      EXGRATIA_GRATUITY,
      SEVERANCE_AMOUNT,
      INCENTIVES,
      DA_ARREARS_GDS,
      TOTAL_EARNINGS,
      TRCA_ALLOWANCE_ARREARS,
      DEARNESS_ALLOWANCE_ARREAR,
      DEARNESS_RELIEF_CDAARREAR,
      TOTAL_ARREARS,
      COURT_ATTACHMENT_ODFM,
      RD,
      COURT_ATTACHMENT_DFM,
      LICENSE_FEE,
      SDBS,
      AUDIT_OFFICE_RECOVERY,
      COOP_CREDIT_SOCIETY,
      RELIEF_FUND,
      DEATH_RELIEF_FUND,
      WATER_TAX,
      ELECTRICITY_CHARGES,
      AOR_NONTAX,
      POSTAL_RELIEF_FUND,
      PLI_PREMIUM,
      RECREATION_CLUB,
      UNION_ASSOCIATION,
      WELFARE_FUND,
      CGEGIS,
      CGHS,
      EDAGIS_92,
      LIC_PREMIUM,
      CGIS,
      RPLI,
      PLI_SERVICE_TAX,
      CONNECTIONS,
      CGEWCC,
      SOCIETIES,
      FNPO,
      ED_GIS,
      SECURITY_BONDS,
      EXTRA_DEPARTMENTAL_UNIONS,
      CGEGIS_INSURANCE_FUND,
      POSTAL_COOP_SOCIETY,
      COOP_BANK_REC,
      DIVISION_SPORTS_BOARD,
      MISC_DEDUCTIONS,
      BONDS,
      CWFGDS,
      FESTIVAL_ADVANCE_SPECIAL,
      TOTAL_DEDUCTIONS,
      TOTAL_GROSS_AMOUNT,
      NET_PAY
    ];
  }

  static Future<List<PaySlipData>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaySlipData.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<PaySlipData>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <PaySlipData>[];
    try {
      objList = list
          .map((payslipdata) =>
              PaySlipData.fromMap(payslipdata as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR PaySlipData.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<PaySlipData>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<PaySlipData> objList = <PaySlipData>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = PaySlipData.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns PaySlipData by ID if exist, otherwise returns null
  /// Primary Keys: String? EMPLOYEE_ID, String? MONTH, String? YEAR
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [PaySlipData] if exist, otherwise returns null
  Future<PaySlipData?> getById(String? EMPLOYEE_ID, String? MONTH, String? YEAR,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EMPLOYEE_ID == null) {
      return null;
    }
    PaySlipData? obj;
    final data = await _mnPaySlipData.getById([EMPLOYEE_ID, MONTH, YEAR]);
    if (data.length != 0) {
      obj = PaySlipData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (PaySlipData) object. If the Primary Key (EMPLOYEE_ID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EMPLOYEE_ID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnPaySlipData.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO PaySlipData ( EMPLOYEE_ID, EMPLOYEE_NAME, OFFICE, POSITION, MONTH, YEAR, ACCOUNT_NUMBER, TRCA, DEARNESS_ALLOWANCE, FIXED_STATIONERY_CHARGES, BOAT_ALLOWANCE, CYCLE_MAINTENANCE_ALLOWANCE, OFFICE_MAINTENANCE_ALLOWANCE, CDA, COMBINATION_DELIVERY_ALLOWANCE, COMPENSATION_MAIL_CARRIER, RETAINERSHIP_ALLOWANCE, CASH_CONVEYANCE_ALLOWANCE, PERSONAL_ALLOWANCE_GDS, BONUS_GDS, EXGRATIA_GRATUITY, SEVERANCE_AMOUNT, INCENTIVES, DA_ARREARS_GDS, TOTAL_EARNINGS, TRCA_ALLOWANCE_ARREARS, DEARNESS_ALLOWANCE_ARREAR, DEARNESS_RELIEF_CDAARREAR, TOTAL_ARREARS, COURT_ATTACHMENT_ODFM, RD, COURT_ATTACHMENT_DFM, LICENSE_FEE, SDBS, AUDIT_OFFICE_RECOVERY, COOP_CREDIT_SOCIETY, RELIEF_FUND, DEATH_RELIEF_FUND, WATER_TAX, ELECTRICITY_CHARGES, AOR_NONTAX, POSTAL_RELIEF_FUND, PLI_PREMIUM, RECREATION_CLUB, UNION_ASSOCIATION, WELFARE_FUND, CGEGIS, CGHS, EDAGIS_92, LIC_PREMIUM, CGIS, RPLI, PLI_SERVICE_TAX, CONNECTIONS, CGEWCC, SOCIETIES, FNPO, ED_GIS, SECURITY_BONDS, EXTRA_DEPARTMENTAL_UNIONS, CGEGIS_INSURANCE_FUND, POSTAL_COOP_SOCIETY, COOP_BANK_REC, DIVISION_SPORTS_BOARD, MISC_DEDUCTIONS, BONDS, CWFGDS, FESTIVAL_ADVANCE_SPECIAL, TOTAL_DEDUCTIONS, TOTAL_GROSS_AMOUNT, NET_PAY)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<PaySlipData> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<PaySlipData> payslipdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await UserDB().batchStart();
    for (final obj in payslipdatas) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await UserDB().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < payslipdatas.length; i++) {
        if (payslipdatas[i].EMPLOYEE_ID == null) {
          payslipdatas[i].EMPLOYEE_ID = result![i] as String;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns EMPLOYEE_ID
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPaySlipData.rawInsert(
          'INSERT OR REPLACE INTO PaySlipData ( EMPLOYEE_ID, EMPLOYEE_NAME, OFFICE, POSITION, MONTH, YEAR, ACCOUNT_NUMBER, TRCA, DEARNESS_ALLOWANCE, FIXED_STATIONERY_CHARGES, BOAT_ALLOWANCE, CYCLE_MAINTENANCE_ALLOWANCE, OFFICE_MAINTENANCE_ALLOWANCE, CDA, COMBINATION_DELIVERY_ALLOWANCE, COMPENSATION_MAIL_CARRIER, RETAINERSHIP_ALLOWANCE, CASH_CONVEYANCE_ALLOWANCE, PERSONAL_ALLOWANCE_GDS, BONUS_GDS, EXGRATIA_GRATUITY, SEVERANCE_AMOUNT, INCENTIVES, DA_ARREARS_GDS, TOTAL_EARNINGS, TRCA_ALLOWANCE_ARREARS, DEARNESS_ALLOWANCE_ARREAR, DEARNESS_RELIEF_CDAARREAR, TOTAL_ARREARS, COURT_ATTACHMENT_ODFM, RD, COURT_ATTACHMENT_DFM, LICENSE_FEE, SDBS, AUDIT_OFFICE_RECOVERY, COOP_CREDIT_SOCIETY, RELIEF_FUND, DEATH_RELIEF_FUND, WATER_TAX, ELECTRICITY_CHARGES, AOR_NONTAX, POSTAL_RELIEF_FUND, PLI_PREMIUM, RECREATION_CLUB, UNION_ASSOCIATION, WELFARE_FUND, CGEGIS, CGHS, EDAGIS_92, LIC_PREMIUM, CGIS, RPLI, PLI_SERVICE_TAX, CONNECTIONS, CGEWCC, SOCIETIES, FNPO, ED_GIS, SECURITY_BONDS, EXTRA_DEPARTMENTAL_UNIONS, CGEGIS_INSURANCE_FUND, POSTAL_COOP_SOCIETY, COOP_BANK_REC, DIVISION_SPORTS_BOARD, MISC_DEDUCTIONS, BONDS, CWFGDS, FESTIVAL_ADVANCE_SPECIAL, TOTAL_DEDUCTIONS, TOTAL_GROSS_AMOUNT, NET_PAY)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPLOYEE_ID,
            EMPLOYEE_NAME,
            OFFICE,
            POSITION,
            MONTH,
            YEAR,
            ACCOUNT_NUMBER,
            TRCA,
            DEARNESS_ALLOWANCE,
            FIXED_STATIONERY_CHARGES,
            BOAT_ALLOWANCE,
            CYCLE_MAINTENANCE_ALLOWANCE,
            OFFICE_MAINTENANCE_ALLOWANCE,
            CDA,
            COMBINATION_DELIVERY_ALLOWANCE,
            COMPENSATION_MAIL_CARRIER,
            RETAINERSHIP_ALLOWANCE,
            CASH_CONVEYANCE_ALLOWANCE,
            PERSONAL_ALLOWANCE_GDS,
            BONUS_GDS,
            EXGRATIA_GRATUITY,
            SEVERANCE_AMOUNT,
            INCENTIVES,
            DA_ARREARS_GDS,
            TOTAL_EARNINGS,
            TRCA_ALLOWANCE_ARREARS,
            DEARNESS_ALLOWANCE_ARREAR,
            DEARNESS_RELIEF_CDAARREAR,
            TOTAL_ARREARS,
            COURT_ATTACHMENT_ODFM,
            RD,
            COURT_ATTACHMENT_DFM,
            LICENSE_FEE,
            SDBS,
            AUDIT_OFFICE_RECOVERY,
            COOP_CREDIT_SOCIETY,
            RELIEF_FUND,
            DEATH_RELIEF_FUND,
            WATER_TAX,
            ELECTRICITY_CHARGES,
            AOR_NONTAX,
            POSTAL_RELIEF_FUND,
            PLI_PREMIUM,
            RECREATION_CLUB,
            UNION_ASSOCIATION,
            WELFARE_FUND,
            CGEGIS,
            CGHS,
            EDAGIS_92,
            LIC_PREMIUM,
            CGIS,
            RPLI,
            PLI_SERVICE_TAX,
            CONNECTIONS,
            CGEWCC,
            SOCIETIES,
            FNPO,
            ED_GIS,
            SECURITY_BONDS,
            EXTRA_DEPARTMENTAL_UNIONS,
            CGEGIS_INSURANCE_FUND,
            POSTAL_COOP_SOCIETY,
            COOP_BANK_REC,
            DIVISION_SPORTS_BOARD,
            MISC_DEDUCTIONS,
            BONDS,
            CWFGDS,
            FESTIVAL_ADVANCE_SPECIAL,
            TOTAL_DEDUCTIONS,
            TOTAL_GROSS_AMOUNT,
            NET_PAY
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PaySlipData EMPLOYEE_ID=$EMPLOYEE_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'PaySlipData EMPLOYEE_ID=$EMPLOYEE_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PaySlipData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns EMPLOYEE_ID
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnPaySlipData.rawInsert(
          'INSERT OR IGNORE INTO PaySlipData ( EMPLOYEE_ID, EMPLOYEE_NAME, OFFICE, POSITION, MONTH, YEAR, ACCOUNT_NUMBER, TRCA, DEARNESS_ALLOWANCE, FIXED_STATIONERY_CHARGES, BOAT_ALLOWANCE, CYCLE_MAINTENANCE_ALLOWANCE, OFFICE_MAINTENANCE_ALLOWANCE, CDA, COMBINATION_DELIVERY_ALLOWANCE, COMPENSATION_MAIL_CARRIER, RETAINERSHIP_ALLOWANCE, CASH_CONVEYANCE_ALLOWANCE, PERSONAL_ALLOWANCE_GDS, BONUS_GDS, EXGRATIA_GRATUITY, SEVERANCE_AMOUNT, INCENTIVES, DA_ARREARS_GDS, TOTAL_EARNINGS, TRCA_ALLOWANCE_ARREARS, DEARNESS_ALLOWANCE_ARREAR, DEARNESS_RELIEF_CDAARREAR, TOTAL_ARREARS, COURT_ATTACHMENT_ODFM, RD, COURT_ATTACHMENT_DFM, LICENSE_FEE, SDBS, AUDIT_OFFICE_RECOVERY, COOP_CREDIT_SOCIETY, RELIEF_FUND, DEATH_RELIEF_FUND, WATER_TAX, ELECTRICITY_CHARGES, AOR_NONTAX, POSTAL_RELIEF_FUND, PLI_PREMIUM, RECREATION_CLUB, UNION_ASSOCIATION, WELFARE_FUND, CGEGIS, CGHS, EDAGIS_92, LIC_PREMIUM, CGIS, RPLI, PLI_SERVICE_TAX, CONNECTIONS, CGEWCC, SOCIETIES, FNPO, ED_GIS, SECURITY_BONDS, EXTRA_DEPARTMENTAL_UNIONS, CGEGIS_INSURANCE_FUND, POSTAL_COOP_SOCIETY, COOP_BANK_REC, DIVISION_SPORTS_BOARD, MISC_DEDUCTIONS, BONDS, CWFGDS, FESTIVAL_ADVANCE_SPECIAL, TOTAL_DEDUCTIONS, TOTAL_GROSS_AMOUNT, NET_PAY)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            EMPLOYEE_ID,
            EMPLOYEE_NAME,
            OFFICE,
            POSITION,
            MONTH,
            YEAR,
            ACCOUNT_NUMBER,
            TRCA,
            DEARNESS_ALLOWANCE,
            FIXED_STATIONERY_CHARGES,
            BOAT_ALLOWANCE,
            CYCLE_MAINTENANCE_ALLOWANCE,
            OFFICE_MAINTENANCE_ALLOWANCE,
            CDA,
            COMBINATION_DELIVERY_ALLOWANCE,
            COMPENSATION_MAIL_CARRIER,
            RETAINERSHIP_ALLOWANCE,
            CASH_CONVEYANCE_ALLOWANCE,
            PERSONAL_ALLOWANCE_GDS,
            BONUS_GDS,
            EXGRATIA_GRATUITY,
            SEVERANCE_AMOUNT,
            INCENTIVES,
            DA_ARREARS_GDS,
            TOTAL_EARNINGS,
            TRCA_ALLOWANCE_ARREARS,
            DEARNESS_ALLOWANCE_ARREAR,
            DEARNESS_RELIEF_CDAARREAR,
            TOTAL_ARREARS,
            COURT_ATTACHMENT_ODFM,
            RD,
            COURT_ATTACHMENT_DFM,
            LICENSE_FEE,
            SDBS,
            AUDIT_OFFICE_RECOVERY,
            COOP_CREDIT_SOCIETY,
            RELIEF_FUND,
            DEATH_RELIEF_FUND,
            WATER_TAX,
            ELECTRICITY_CHARGES,
            AOR_NONTAX,
            POSTAL_RELIEF_FUND,
            PLI_PREMIUM,
            RECREATION_CLUB,
            UNION_ASSOCIATION,
            WELFARE_FUND,
            CGEGIS,
            CGHS,
            EDAGIS_92,
            LIC_PREMIUM,
            CGIS,
            RPLI,
            PLI_SERVICE_TAX,
            CONNECTIONS,
            CGEWCC,
            SOCIETIES,
            FNPO,
            ED_GIS,
            SECURITY_BONDS,
            EXTRA_DEPARTMENTAL_UNIONS,
            CGEGIS_INSURANCE_FUND,
            POSTAL_COOP_SOCIETY,
            COOP_BANK_REC,
            DIVISION_SPORTS_BOARD,
            MISC_DEDUCTIONS,
            BONDS,
            CWFGDS,
            FESTIVAL_ADVANCE_SPECIAL,
            TOTAL_DEDUCTIONS,
            TOTAL_GROSS_AMOUNT,
            NET_PAY
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'PaySlipData EMPLOYEE_ID=$EMPLOYEE_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'PaySlipData EMPLOYEE_ID=$EMPLOYEE_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'PaySlipData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<PaySlipData>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<PaySlipData> payslipdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnPaySlipData.rawInsertAll(
        'INSERT OR REPLACE INTO PaySlipData ( EMPLOYEE_ID, EMPLOYEE_NAME, OFFICE, POSITION, MONTH, YEAR, ACCOUNT_NUMBER, TRCA, DEARNESS_ALLOWANCE, FIXED_STATIONERY_CHARGES, BOAT_ALLOWANCE, CYCLE_MAINTENANCE_ALLOWANCE, OFFICE_MAINTENANCE_ALLOWANCE, CDA, COMBINATION_DELIVERY_ALLOWANCE, COMPENSATION_MAIL_CARRIER, RETAINERSHIP_ALLOWANCE, CASH_CONVEYANCE_ALLOWANCE, PERSONAL_ALLOWANCE_GDS, BONUS_GDS, EXGRATIA_GRATUITY, SEVERANCE_AMOUNT, INCENTIVES, DA_ARREARS_GDS, TOTAL_EARNINGS, TRCA_ALLOWANCE_ARREARS, DEARNESS_ALLOWANCE_ARREAR, DEARNESS_RELIEF_CDAARREAR, TOTAL_ARREARS, COURT_ATTACHMENT_ODFM, RD, COURT_ATTACHMENT_DFM, LICENSE_FEE, SDBS, AUDIT_OFFICE_RECOVERY, COOP_CREDIT_SOCIETY, RELIEF_FUND, DEATH_RELIEF_FUND, WATER_TAX, ELECTRICITY_CHARGES, AOR_NONTAX, POSTAL_RELIEF_FUND, PLI_PREMIUM, RECREATION_CLUB, UNION_ASSOCIATION, WELFARE_FUND, CGEGIS, CGHS, EDAGIS_92, LIC_PREMIUM, CGIS, RPLI, PLI_SERVICE_TAX, CONNECTIONS, CGEWCC, SOCIETIES, FNPO, ED_GIS, SECURITY_BONDS, EXTRA_DEPARTMENTAL_UNIONS, CGEGIS_INSURANCE_FUND, POSTAL_COOP_SOCIETY, COOP_BANK_REC, DIVISION_SPORTS_BOARD, MISC_DEDUCTIONS, BONDS, CWFGDS, FESTIVAL_ADVANCE_SPECIAL, TOTAL_DEDUCTIONS, TOTAL_GROSS_AMOUNT, NET_PAY)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        payslipdatas,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes PaySlipData

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete PaySlipData invoked (EMPLOYEE_ID=$EMPLOYEE_ID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnPaySlipData.delete(QueryParams(
          whereString: 'EMPLOYEE_ID=? AND MONTH=? AND YEAR=?',
          whereArguments: [EMPLOYEE_ID, MONTH, YEAR]));
    } else {
      return _mnPaySlipData.updateBatch(
          QueryParams(
              whereString: 'EMPLOYEE_ID=? AND MONTH=? AND YEAR=?',
              whereArguments: [EMPLOYEE_ID, MONTH, YEAR]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [PaySlipData] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  PaySlipDataFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaySlipDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  PaySlipDataFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return PaySlipDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EMPLOYEE_ID = null;
      MONTH = null;
      YEAR = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion payslipdata

// region PaySlipDataField
class PaySlipDataField extends FilterBase {
  PaySlipDataField(PaySlipDataFilterBuilder payslipdataFB)
      : super(payslipdataFB);

  @override
  PaySlipDataFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder isNull() {
    return super.isNull() as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as PaySlipDataFilterBuilder;
  }

  @override
  PaySlipDataField get not {
    return super.not as PaySlipDataField;
  }
}
// endregion PaySlipDataField

// region PaySlipDataFilterBuilder
class PaySlipDataFilterBuilder extends ConjunctionBase {
  PaySlipDataFilterBuilder(PaySlipData obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnPaySlipData = obj._mnPaySlipData;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  PaySlipDataManager? _mnPaySlipData;

  /// put the sql keyword 'AND'
  @override
  PaySlipDataFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  PaySlipDataFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  PaySlipDataFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  PaySlipDataFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  PaySlipDataFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  PaySlipDataFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  PaySlipDataFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaySlipDataFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaySlipDataFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  PaySlipDataFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  PaySlipDataFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  PaySlipDataField _setField(
      PaySlipDataField? field, String colName, DbType dbtype) {
    return PaySlipDataField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  PaySlipDataField? _EMPLOYEE_ID;
  PaySlipDataField get EMPLOYEE_ID {
    return _EMPLOYEE_ID = _setField(_EMPLOYEE_ID, 'EMPLOYEE_ID', DbType.text);
  }

  PaySlipDataField? _EMPLOYEE_NAME;
  PaySlipDataField get EMPLOYEE_NAME {
    return _EMPLOYEE_NAME =
        _setField(_EMPLOYEE_NAME, 'EMPLOYEE_NAME', DbType.text);
  }

  PaySlipDataField? _OFFICE;
  PaySlipDataField get OFFICE {
    return _OFFICE = _setField(_OFFICE, 'OFFICE', DbType.text);
  }

  PaySlipDataField? _POSITION;
  PaySlipDataField get POSITION {
    return _POSITION = _setField(_POSITION, 'POSITION', DbType.text);
  }

  PaySlipDataField? _MONTH;
  PaySlipDataField get MONTH {
    return _MONTH = _setField(_MONTH, 'MONTH', DbType.text);
  }

  PaySlipDataField? _YEAR;
  PaySlipDataField get YEAR {
    return _YEAR = _setField(_YEAR, 'YEAR', DbType.text);
  }

  PaySlipDataField? _ACCOUNT_NUMBER;
  PaySlipDataField get ACCOUNT_NUMBER {
    return _ACCOUNT_NUMBER =
        _setField(_ACCOUNT_NUMBER, 'ACCOUNT_NUMBER', DbType.text);
  }

  PaySlipDataField? _TRCA;
  PaySlipDataField get TRCA {
    return _TRCA = _setField(_TRCA, 'TRCA', DbType.text);
  }

  PaySlipDataField? _DEARNESS_ALLOWANCE;
  PaySlipDataField get DEARNESS_ALLOWANCE {
    return _DEARNESS_ALLOWANCE =
        _setField(_DEARNESS_ALLOWANCE, 'DEARNESS_ALLOWANCE', DbType.text);
  }

  PaySlipDataField? _FIXED_STATIONERY_CHARGES;
  PaySlipDataField get FIXED_STATIONERY_CHARGES {
    return _FIXED_STATIONERY_CHARGES = _setField(
        _FIXED_STATIONERY_CHARGES, 'FIXED_STATIONERY_CHARGES', DbType.text);
  }

  PaySlipDataField? _BOAT_ALLOWANCE;
  PaySlipDataField get BOAT_ALLOWANCE {
    return _BOAT_ALLOWANCE =
        _setField(_BOAT_ALLOWANCE, 'BOAT_ALLOWANCE', DbType.text);
  }

  PaySlipDataField? _CYCLE_MAINTENANCE_ALLOWANCE;
  PaySlipDataField get CYCLE_MAINTENANCE_ALLOWANCE {
    return _CYCLE_MAINTENANCE_ALLOWANCE = _setField(
        _CYCLE_MAINTENANCE_ALLOWANCE,
        'CYCLE_MAINTENANCE_ALLOWANCE',
        DbType.text);
  }

  PaySlipDataField? _OFFICE_MAINTENANCE_ALLOWANCE;
  PaySlipDataField get OFFICE_MAINTENANCE_ALLOWANCE {
    return _OFFICE_MAINTENANCE_ALLOWANCE = _setField(
        _OFFICE_MAINTENANCE_ALLOWANCE,
        'OFFICE_MAINTENANCE_ALLOWANCE',
        DbType.text);
  }

  PaySlipDataField? _CDA;
  PaySlipDataField get CDA {
    return _CDA = _setField(_CDA, 'CDA', DbType.text);
  }

  PaySlipDataField? _COMBINATION_DELIVERY_ALLOWANCE;
  PaySlipDataField get COMBINATION_DELIVERY_ALLOWANCE {
    return _COMBINATION_DELIVERY_ALLOWANCE = _setField(
        _COMBINATION_DELIVERY_ALLOWANCE,
        'COMBINATION_DELIVERY_ALLOWANCE',
        DbType.text);
  }

  PaySlipDataField? _COMPENSATION_MAIL_CARRIER;
  PaySlipDataField get COMPENSATION_MAIL_CARRIER {
    return _COMPENSATION_MAIL_CARRIER = _setField(
        _COMPENSATION_MAIL_CARRIER, 'COMPENSATION_MAIL_CARRIER', DbType.text);
  }

  PaySlipDataField? _RETAINERSHIP_ALLOWANCE;
  PaySlipDataField get RETAINERSHIP_ALLOWANCE {
    return _RETAINERSHIP_ALLOWANCE = _setField(
        _RETAINERSHIP_ALLOWANCE, 'RETAINERSHIP_ALLOWANCE', DbType.text);
  }

  PaySlipDataField? _CASH_CONVEYANCE_ALLOWANCE;
  PaySlipDataField get CASH_CONVEYANCE_ALLOWANCE {
    return _CASH_CONVEYANCE_ALLOWANCE = _setField(
        _CASH_CONVEYANCE_ALLOWANCE, 'CASH_CONVEYANCE_ALLOWANCE', DbType.text);
  }

  PaySlipDataField? _PERSONAL_ALLOWANCE_GDS;
  PaySlipDataField get PERSONAL_ALLOWANCE_GDS {
    return _PERSONAL_ALLOWANCE_GDS = _setField(
        _PERSONAL_ALLOWANCE_GDS, 'PERSONAL_ALLOWANCE_GDS', DbType.text);
  }

  PaySlipDataField? _BONUS_GDS;
  PaySlipDataField get BONUS_GDS {
    return _BONUS_GDS = _setField(_BONUS_GDS, 'BONUS_GDS', DbType.text);
  }

  PaySlipDataField? _EXGRATIA_GRATUITY;
  PaySlipDataField get EXGRATIA_GRATUITY {
    return _EXGRATIA_GRATUITY =
        _setField(_EXGRATIA_GRATUITY, 'EXGRATIA_GRATUITY', DbType.text);
  }

  PaySlipDataField? _SEVERANCE_AMOUNT;
  PaySlipDataField get SEVERANCE_AMOUNT {
    return _SEVERANCE_AMOUNT =
        _setField(_SEVERANCE_AMOUNT, 'SEVERANCE_AMOUNT', DbType.text);
  }

  PaySlipDataField? _INCENTIVES;
  PaySlipDataField get INCENTIVES {
    return _INCENTIVES = _setField(_INCENTIVES, 'INCENTIVES', DbType.text);
  }

  PaySlipDataField? _DA_ARREARS_GDS;
  PaySlipDataField get DA_ARREARS_GDS {
    return _DA_ARREARS_GDS =
        _setField(_DA_ARREARS_GDS, 'DA_ARREARS_GDS', DbType.text);
  }

  PaySlipDataField? _TOTAL_EARNINGS;
  PaySlipDataField get TOTAL_EARNINGS {
    return _TOTAL_EARNINGS =
        _setField(_TOTAL_EARNINGS, 'TOTAL_EARNINGS', DbType.text);
  }

  PaySlipDataField? _TRCA_ALLOWANCE_ARREARS;
  PaySlipDataField get TRCA_ALLOWANCE_ARREARS {
    return _TRCA_ALLOWANCE_ARREARS = _setField(
        _TRCA_ALLOWANCE_ARREARS, 'TRCA_ALLOWANCE_ARREARS', DbType.text);
  }

  PaySlipDataField? _DEARNESS_ALLOWANCE_ARREAR;
  PaySlipDataField get DEARNESS_ALLOWANCE_ARREAR {
    return _DEARNESS_ALLOWANCE_ARREAR = _setField(
        _DEARNESS_ALLOWANCE_ARREAR, 'DEARNESS_ALLOWANCE_ARREAR', DbType.text);
  }

  PaySlipDataField? _DEARNESS_RELIEF_CDAARREAR;
  PaySlipDataField get DEARNESS_RELIEF_CDAARREAR {
    return _DEARNESS_RELIEF_CDAARREAR = _setField(
        _DEARNESS_RELIEF_CDAARREAR, 'DEARNESS_RELIEF_CDAARREAR', DbType.text);
  }

  PaySlipDataField? _TOTAL_ARREARS;
  PaySlipDataField get TOTAL_ARREARS {
    return _TOTAL_ARREARS =
        _setField(_TOTAL_ARREARS, 'TOTAL_ARREARS', DbType.text);
  }

  PaySlipDataField? _COURT_ATTACHMENT_ODFM;
  PaySlipDataField get COURT_ATTACHMENT_ODFM {
    return _COURT_ATTACHMENT_ODFM =
        _setField(_COURT_ATTACHMENT_ODFM, 'COURT_ATTACHMENT_ODFM', DbType.text);
  }

  PaySlipDataField? _RD;
  PaySlipDataField get RD {
    return _RD = _setField(_RD, 'RD', DbType.text);
  }

  PaySlipDataField? _COURT_ATTACHMENT_DFM;
  PaySlipDataField get COURT_ATTACHMENT_DFM {
    return _COURT_ATTACHMENT_DFM =
        _setField(_COURT_ATTACHMENT_DFM, 'COURT_ATTACHMENT_DFM', DbType.text);
  }

  PaySlipDataField? _LICENSE_FEE;
  PaySlipDataField get LICENSE_FEE {
    return _LICENSE_FEE = _setField(_LICENSE_FEE, 'LICENSE_FEE', DbType.text);
  }

  PaySlipDataField? _SDBS;
  PaySlipDataField get SDBS {
    return _SDBS = _setField(_SDBS, 'SDBS', DbType.text);
  }

  PaySlipDataField? _AUDIT_OFFICE_RECOVERY;
  PaySlipDataField get AUDIT_OFFICE_RECOVERY {
    return _AUDIT_OFFICE_RECOVERY =
        _setField(_AUDIT_OFFICE_RECOVERY, 'AUDIT_OFFICE_RECOVERY', DbType.text);
  }

  PaySlipDataField? _COOP_CREDIT_SOCIETY;
  PaySlipDataField get COOP_CREDIT_SOCIETY {
    return _COOP_CREDIT_SOCIETY =
        _setField(_COOP_CREDIT_SOCIETY, 'COOP_CREDIT_SOCIETY', DbType.text);
  }

  PaySlipDataField? _RELIEF_FUND;
  PaySlipDataField get RELIEF_FUND {
    return _RELIEF_FUND = _setField(_RELIEF_FUND, 'RELIEF_FUND', DbType.text);
  }

  PaySlipDataField? _DEATH_RELIEF_FUND;
  PaySlipDataField get DEATH_RELIEF_FUND {
    return _DEATH_RELIEF_FUND =
        _setField(_DEATH_RELIEF_FUND, 'DEATH_RELIEF_FUND', DbType.text);
  }

  PaySlipDataField? _WATER_TAX;
  PaySlipDataField get WATER_TAX {
    return _WATER_TAX = _setField(_WATER_TAX, 'WATER_TAX', DbType.text);
  }

  PaySlipDataField? _ELECTRICITY_CHARGES;
  PaySlipDataField get ELECTRICITY_CHARGES {
    return _ELECTRICITY_CHARGES =
        _setField(_ELECTRICITY_CHARGES, 'ELECTRICITY_CHARGES', DbType.text);
  }

  PaySlipDataField? _AOR_NONTAX;
  PaySlipDataField get AOR_NONTAX {
    return _AOR_NONTAX = _setField(_AOR_NONTAX, 'AOR_NONTAX', DbType.text);
  }

  PaySlipDataField? _POSTAL_RELIEF_FUND;
  PaySlipDataField get POSTAL_RELIEF_FUND {
    return _POSTAL_RELIEF_FUND =
        _setField(_POSTAL_RELIEF_FUND, 'POSTAL_RELIEF_FUND', DbType.text);
  }

  PaySlipDataField? _PLI_PREMIUM;
  PaySlipDataField get PLI_PREMIUM {
    return _PLI_PREMIUM = _setField(_PLI_PREMIUM, 'PLI_PREMIUM', DbType.text);
  }

  PaySlipDataField? _RECREATION_CLUB;
  PaySlipDataField get RECREATION_CLUB {
    return _RECREATION_CLUB =
        _setField(_RECREATION_CLUB, 'RECREATION_CLUB', DbType.text);
  }

  PaySlipDataField? _UNION_ASSOCIATION;
  PaySlipDataField get UNION_ASSOCIATION {
    return _UNION_ASSOCIATION =
        _setField(_UNION_ASSOCIATION, 'UNION_ASSOCIATION', DbType.text);
  }

  PaySlipDataField? _WELFARE_FUND;
  PaySlipDataField get WELFARE_FUND {
    return _WELFARE_FUND =
        _setField(_WELFARE_FUND, 'WELFARE_FUND', DbType.text);
  }

  PaySlipDataField? _CGEGIS;
  PaySlipDataField get CGEGIS {
    return _CGEGIS = _setField(_CGEGIS, 'CGEGIS', DbType.text);
  }

  PaySlipDataField? _CGHS;
  PaySlipDataField get CGHS {
    return _CGHS = _setField(_CGHS, 'CGHS', DbType.text);
  }

  PaySlipDataField? _EDAGIS_92;
  PaySlipDataField get EDAGIS_92 {
    return _EDAGIS_92 = _setField(_EDAGIS_92, 'EDAGIS_92', DbType.text);
  }

  PaySlipDataField? _LIC_PREMIUM;
  PaySlipDataField get LIC_PREMIUM {
    return _LIC_PREMIUM = _setField(_LIC_PREMIUM, 'LIC_PREMIUM', DbType.text);
  }

  PaySlipDataField? _CGIS;
  PaySlipDataField get CGIS {
    return _CGIS = _setField(_CGIS, 'CGIS', DbType.text);
  }

  PaySlipDataField? _RPLI;
  PaySlipDataField get RPLI {
    return _RPLI = _setField(_RPLI, 'RPLI', DbType.text);
  }

  PaySlipDataField? _PLI_SERVICE_TAX;
  PaySlipDataField get PLI_SERVICE_TAX {
    return _PLI_SERVICE_TAX =
        _setField(_PLI_SERVICE_TAX, 'PLI_SERVICE_TAX', DbType.text);
  }

  PaySlipDataField? _CONNECTIONS;
  PaySlipDataField get CONNECTIONS {
    return _CONNECTIONS = _setField(_CONNECTIONS, 'CONNECTIONS', DbType.text);
  }

  PaySlipDataField? _CGEWCC;
  PaySlipDataField get CGEWCC {
    return _CGEWCC = _setField(_CGEWCC, 'CGEWCC', DbType.text);
  }

  PaySlipDataField? _SOCIETIES;
  PaySlipDataField get SOCIETIES {
    return _SOCIETIES = _setField(_SOCIETIES, 'SOCIETIES', DbType.text);
  }

  PaySlipDataField? _FNPO;
  PaySlipDataField get FNPO {
    return _FNPO = _setField(_FNPO, 'FNPO', DbType.text);
  }

  PaySlipDataField? _ED_GIS;
  PaySlipDataField get ED_GIS {
    return _ED_GIS = _setField(_ED_GIS, 'ED_GIS', DbType.text);
  }

  PaySlipDataField? _SECURITY_BONDS;
  PaySlipDataField get SECURITY_BONDS {
    return _SECURITY_BONDS =
        _setField(_SECURITY_BONDS, 'SECURITY_BONDS', DbType.text);
  }

  PaySlipDataField? _EXTRA_DEPARTMENTAL_UNIONS;
  PaySlipDataField get EXTRA_DEPARTMENTAL_UNIONS {
    return _EXTRA_DEPARTMENTAL_UNIONS = _setField(
        _EXTRA_DEPARTMENTAL_UNIONS, 'EXTRA_DEPARTMENTAL_UNIONS', DbType.text);
  }

  PaySlipDataField? _CGEGIS_INSURANCE_FUND;
  PaySlipDataField get CGEGIS_INSURANCE_FUND {
    return _CGEGIS_INSURANCE_FUND =
        _setField(_CGEGIS_INSURANCE_FUND, 'CGEGIS_INSURANCE_FUND', DbType.text);
  }

  PaySlipDataField? _POSTAL_COOP_SOCIETY;
  PaySlipDataField get POSTAL_COOP_SOCIETY {
    return _POSTAL_COOP_SOCIETY =
        _setField(_POSTAL_COOP_SOCIETY, 'POSTAL_COOP_SOCIETY', DbType.text);
  }

  PaySlipDataField? _COOP_BANK_REC;
  PaySlipDataField get COOP_BANK_REC {
    return _COOP_BANK_REC =
        _setField(_COOP_BANK_REC, 'COOP_BANK_REC', DbType.text);
  }

  PaySlipDataField? _DIVISION_SPORTS_BOARD;
  PaySlipDataField get DIVISION_SPORTS_BOARD {
    return _DIVISION_SPORTS_BOARD =
        _setField(_DIVISION_SPORTS_BOARD, 'DIVISION_SPORTS_BOARD', DbType.text);
  }

  PaySlipDataField? _MISC_DEDUCTIONS;
  PaySlipDataField get MISC_DEDUCTIONS {
    return _MISC_DEDUCTIONS =
        _setField(_MISC_DEDUCTIONS, 'MISC_DEDUCTIONS', DbType.text);
  }

  PaySlipDataField? _BONDS;
  PaySlipDataField get BONDS {
    return _BONDS = _setField(_BONDS, 'BONDS', DbType.text);
  }

  PaySlipDataField? _CWFGDS;
  PaySlipDataField get CWFGDS {
    return _CWFGDS = _setField(_CWFGDS, 'CWFGDS', DbType.text);
  }

  PaySlipDataField? _FESTIVAL_ADVANCE_SPECIAL;
  PaySlipDataField get FESTIVAL_ADVANCE_SPECIAL {
    return _FESTIVAL_ADVANCE_SPECIAL = _setField(
        _FESTIVAL_ADVANCE_SPECIAL, 'FESTIVAL_ADVANCE_SPECIAL', DbType.text);
  }

  PaySlipDataField? _TOTAL_DEDUCTIONS;
  PaySlipDataField get TOTAL_DEDUCTIONS {
    return _TOTAL_DEDUCTIONS =
        _setField(_TOTAL_DEDUCTIONS, 'TOTAL_DEDUCTIONS', DbType.text);
  }

  PaySlipDataField? _TOTAL_GROSS_AMOUNT;
  PaySlipDataField get TOTAL_GROSS_AMOUNT {
    return _TOTAL_GROSS_AMOUNT =
        _setField(_TOTAL_GROSS_AMOUNT, 'TOTAL_GROSS_AMOUNT', DbType.text);
  }

  PaySlipDataField? _NET_PAY;
  PaySlipDataField get NET_PAY {
    return _NET_PAY = _setField(_NET_PAY, 'NET_PAY', DbType.text);
  }

  /// Deletes List<PaySlipData> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnPaySlipData!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnPaySlipData!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EMPLOYEE_ID IN (SELECT EMPLOYEE_ID from PaySlipData ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnPaySlipData!.updateBatch(qparams, values);
  }

  /// This method always returns [PaySlipData] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaySlipData?
  @override
  Future<PaySlipData?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnPaySlipData!.toList(qparams);
    final data = await objFuture;
    PaySlipData? obj;
    if (data.isNotEmpty) {
      obj = PaySlipData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [PaySlipData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> PaySlipData?
  @override
  Future<PaySlipData> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        PaySlipData();
  }

  /// This method returns int. [PaySlipData]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? payslipdataCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final payslipdatasFuture = await _mnPaySlipData!.toList(qparams);
    final int count = payslipdatasFuture[0]['CNT'] as int;
    if (payslipdataCount != null) {
      payslipdataCount(count);
    }
    return count;
  }

  /// This method returns List<PaySlipData> [PaySlipData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<PaySlipData>
  @override
  Future<List<PaySlipData>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<PaySlipData> payslipdatasData = await PaySlipData.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return payslipdatasData;
  }

  /// This method returns Json String [PaySlipData]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [PaySlipData]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [PaySlipData]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnPaySlipData!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [PaySlipData]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EMPLOYEE_ID`MONTH`YEAR` FROM PaySlipData WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<EMPLOYEE_ID,MONTH,YEAR> [PaySlipData]
  /// <returns>List<EMPLOYEE_ID,MONTH,YEAR>
  @override
  Future<List<PaySlipData>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['EMPLOYEE_ID', 'MONTH', 'YEAR'];
    final payslipdataFuture = await _mnPaySlipData!.toList(qparams);
    return await PaySlipData.fromMapList(payslipdataFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [PaySlipData]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnPaySlipData!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await PaySlipData.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnPaySlipData!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion PaySlipDataFilterBuilder

// region PaySlipDataFields
class PaySlipDataFields {
  static TableField? _fEMPLOYEE_ID;
  static TableField get EMPLOYEE_ID {
    return _fEMPLOYEE_ID = _fEMPLOYEE_ID ??
        SqlSyntax.setField(_fEMPLOYEE_ID, 'EMPLOYEE_ID', DbType.text);
  }

  static TableField? _fEMPLOYEE_NAME;
  static TableField get EMPLOYEE_NAME {
    return _fEMPLOYEE_NAME = _fEMPLOYEE_NAME ??
        SqlSyntax.setField(_fEMPLOYEE_NAME, 'EMPLOYEE_NAME', DbType.text);
  }

  static TableField? _fOFFICE;
  static TableField get OFFICE {
    return _fOFFICE =
        _fOFFICE ?? SqlSyntax.setField(_fOFFICE, 'OFFICE', DbType.text);
  }

  static TableField? _fPOSITION;
  static TableField get POSITION {
    return _fPOSITION =
        _fPOSITION ?? SqlSyntax.setField(_fPOSITION, 'POSITION', DbType.text);
  }

  static TableField? _fMONTH;
  static TableField get MONTH {
    return _fMONTH =
        _fMONTH ?? SqlSyntax.setField(_fMONTH, 'MONTH', DbType.text);
  }

  static TableField? _fYEAR;
  static TableField get YEAR {
    return _fYEAR = _fYEAR ?? SqlSyntax.setField(_fYEAR, 'YEAR', DbType.text);
  }

  static TableField? _fACCOUNT_NUMBER;
  static TableField get ACCOUNT_NUMBER {
    return _fACCOUNT_NUMBER = _fACCOUNT_NUMBER ??
        SqlSyntax.setField(_fACCOUNT_NUMBER, 'ACCOUNT_NUMBER', DbType.text);
  }

  static TableField? _fTRCA;
  static TableField get TRCA {
    return _fTRCA = _fTRCA ?? SqlSyntax.setField(_fTRCA, 'TRCA', DbType.text);
  }

  static TableField? _fDEARNESS_ALLOWANCE;
  static TableField get DEARNESS_ALLOWANCE {
    return _fDEARNESS_ALLOWANCE = _fDEARNESS_ALLOWANCE ??
        SqlSyntax.setField(
            _fDEARNESS_ALLOWANCE, 'DEARNESS_ALLOWANCE', DbType.text);
  }

  static TableField? _fFIXED_STATIONERY_CHARGES;
  static TableField get FIXED_STATIONERY_CHARGES {
    return _fFIXED_STATIONERY_CHARGES = _fFIXED_STATIONERY_CHARGES ??
        SqlSyntax.setField(_fFIXED_STATIONERY_CHARGES,
            'FIXED_STATIONERY_CHARGES', DbType.text);
  }

  static TableField? _fBOAT_ALLOWANCE;
  static TableField get BOAT_ALLOWANCE {
    return _fBOAT_ALLOWANCE = _fBOAT_ALLOWANCE ??
        SqlSyntax.setField(_fBOAT_ALLOWANCE, 'BOAT_ALLOWANCE', DbType.text);
  }

  static TableField? _fCYCLE_MAINTENANCE_ALLOWANCE;
  static TableField get CYCLE_MAINTENANCE_ALLOWANCE {
    return _fCYCLE_MAINTENANCE_ALLOWANCE = _fCYCLE_MAINTENANCE_ALLOWANCE ??
        SqlSyntax.setField(_fCYCLE_MAINTENANCE_ALLOWANCE,
            'CYCLE_MAINTENANCE_ALLOWANCE', DbType.text);
  }

  static TableField? _fOFFICE_MAINTENANCE_ALLOWANCE;
  static TableField get OFFICE_MAINTENANCE_ALLOWANCE {
    return _fOFFICE_MAINTENANCE_ALLOWANCE = _fOFFICE_MAINTENANCE_ALLOWANCE ??
        SqlSyntax.setField(_fOFFICE_MAINTENANCE_ALLOWANCE,
            'OFFICE_MAINTENANCE_ALLOWANCE', DbType.text);
  }

  static TableField? _fCDA;
  static TableField get CDA {
    return _fCDA = _fCDA ?? SqlSyntax.setField(_fCDA, 'CDA', DbType.text);
  }

  static TableField? _fCOMBINATION_DELIVERY_ALLOWANCE;
  static TableField get COMBINATION_DELIVERY_ALLOWANCE {
    return _fCOMBINATION_DELIVERY_ALLOWANCE =
        _fCOMBINATION_DELIVERY_ALLOWANCE ??
            SqlSyntax.setField(_fCOMBINATION_DELIVERY_ALLOWANCE,
                'COMBINATION_DELIVERY_ALLOWANCE', DbType.text);
  }

  static TableField? _fCOMPENSATION_MAIL_CARRIER;
  static TableField get COMPENSATION_MAIL_CARRIER {
    return _fCOMPENSATION_MAIL_CARRIER = _fCOMPENSATION_MAIL_CARRIER ??
        SqlSyntax.setField(_fCOMPENSATION_MAIL_CARRIER,
            'COMPENSATION_MAIL_CARRIER', DbType.text);
  }

  static TableField? _fRETAINERSHIP_ALLOWANCE;
  static TableField get RETAINERSHIP_ALLOWANCE {
    return _fRETAINERSHIP_ALLOWANCE = _fRETAINERSHIP_ALLOWANCE ??
        SqlSyntax.setField(
            _fRETAINERSHIP_ALLOWANCE, 'RETAINERSHIP_ALLOWANCE', DbType.text);
  }

  static TableField? _fCASH_CONVEYANCE_ALLOWANCE;
  static TableField get CASH_CONVEYANCE_ALLOWANCE {
    return _fCASH_CONVEYANCE_ALLOWANCE = _fCASH_CONVEYANCE_ALLOWANCE ??
        SqlSyntax.setField(_fCASH_CONVEYANCE_ALLOWANCE,
            'CASH_CONVEYANCE_ALLOWANCE', DbType.text);
  }

  static TableField? _fPERSONAL_ALLOWANCE_GDS;
  static TableField get PERSONAL_ALLOWANCE_GDS {
    return _fPERSONAL_ALLOWANCE_GDS = _fPERSONAL_ALLOWANCE_GDS ??
        SqlSyntax.setField(
            _fPERSONAL_ALLOWANCE_GDS, 'PERSONAL_ALLOWANCE_GDS', DbType.text);
  }

  static TableField? _fBONUS_GDS;
  static TableField get BONUS_GDS {
    return _fBONUS_GDS = _fBONUS_GDS ??
        SqlSyntax.setField(_fBONUS_GDS, 'BONUS_GDS', DbType.text);
  }

  static TableField? _fEXGRATIA_GRATUITY;
  static TableField get EXGRATIA_GRATUITY {
    return _fEXGRATIA_GRATUITY = _fEXGRATIA_GRATUITY ??
        SqlSyntax.setField(
            _fEXGRATIA_GRATUITY, 'EXGRATIA_GRATUITY', DbType.text);
  }

  static TableField? _fSEVERANCE_AMOUNT;
  static TableField get SEVERANCE_AMOUNT {
    return _fSEVERANCE_AMOUNT = _fSEVERANCE_AMOUNT ??
        SqlSyntax.setField(_fSEVERANCE_AMOUNT, 'SEVERANCE_AMOUNT', DbType.text);
  }

  static TableField? _fINCENTIVES;
  static TableField get INCENTIVES {
    return _fINCENTIVES = _fINCENTIVES ??
        SqlSyntax.setField(_fINCENTIVES, 'INCENTIVES', DbType.text);
  }

  static TableField? _fDA_ARREARS_GDS;
  static TableField get DA_ARREARS_GDS {
    return _fDA_ARREARS_GDS = _fDA_ARREARS_GDS ??
        SqlSyntax.setField(_fDA_ARREARS_GDS, 'DA_ARREARS_GDS', DbType.text);
  }

  static TableField? _fTOTAL_EARNINGS;
  static TableField get TOTAL_EARNINGS {
    return _fTOTAL_EARNINGS = _fTOTAL_EARNINGS ??
        SqlSyntax.setField(_fTOTAL_EARNINGS, 'TOTAL_EARNINGS', DbType.text);
  }

  static TableField? _fTRCA_ALLOWANCE_ARREARS;
  static TableField get TRCA_ALLOWANCE_ARREARS {
    return _fTRCA_ALLOWANCE_ARREARS = _fTRCA_ALLOWANCE_ARREARS ??
        SqlSyntax.setField(
            _fTRCA_ALLOWANCE_ARREARS, 'TRCA_ALLOWANCE_ARREARS', DbType.text);
  }

  static TableField? _fDEARNESS_ALLOWANCE_ARREAR;
  static TableField get DEARNESS_ALLOWANCE_ARREAR {
    return _fDEARNESS_ALLOWANCE_ARREAR = _fDEARNESS_ALLOWANCE_ARREAR ??
        SqlSyntax.setField(_fDEARNESS_ALLOWANCE_ARREAR,
            'DEARNESS_ALLOWANCE_ARREAR', DbType.text);
  }

  static TableField? _fDEARNESS_RELIEF_CDAARREAR;
  static TableField get DEARNESS_RELIEF_CDAARREAR {
    return _fDEARNESS_RELIEF_CDAARREAR = _fDEARNESS_RELIEF_CDAARREAR ??
        SqlSyntax.setField(_fDEARNESS_RELIEF_CDAARREAR,
            'DEARNESS_RELIEF_CDAARREAR', DbType.text);
  }

  static TableField? _fTOTAL_ARREARS;
  static TableField get TOTAL_ARREARS {
    return _fTOTAL_ARREARS = _fTOTAL_ARREARS ??
        SqlSyntax.setField(_fTOTAL_ARREARS, 'TOTAL_ARREARS', DbType.text);
  }

  static TableField? _fCOURT_ATTACHMENT_ODFM;
  static TableField get COURT_ATTACHMENT_ODFM {
    return _fCOURT_ATTACHMENT_ODFM = _fCOURT_ATTACHMENT_ODFM ??
        SqlSyntax.setField(
            _fCOURT_ATTACHMENT_ODFM, 'COURT_ATTACHMENT_ODFM', DbType.text);
  }

  static TableField? _fRD;
  static TableField get RD {
    return _fRD = _fRD ?? SqlSyntax.setField(_fRD, 'RD', DbType.text);
  }

  static TableField? _fCOURT_ATTACHMENT_DFM;
  static TableField get COURT_ATTACHMENT_DFM {
    return _fCOURT_ATTACHMENT_DFM = _fCOURT_ATTACHMENT_DFM ??
        SqlSyntax.setField(
            _fCOURT_ATTACHMENT_DFM, 'COURT_ATTACHMENT_DFM', DbType.text);
  }

  static TableField? _fLICENSE_FEE;
  static TableField get LICENSE_FEE {
    return _fLICENSE_FEE = _fLICENSE_FEE ??
        SqlSyntax.setField(_fLICENSE_FEE, 'LICENSE_FEE', DbType.text);
  }

  static TableField? _fSDBS;
  static TableField get SDBS {
    return _fSDBS = _fSDBS ?? SqlSyntax.setField(_fSDBS, 'SDBS', DbType.text);
  }

  static TableField? _fAUDIT_OFFICE_RECOVERY;
  static TableField get AUDIT_OFFICE_RECOVERY {
    return _fAUDIT_OFFICE_RECOVERY = _fAUDIT_OFFICE_RECOVERY ??
        SqlSyntax.setField(
            _fAUDIT_OFFICE_RECOVERY, 'AUDIT_OFFICE_RECOVERY', DbType.text);
  }

  static TableField? _fCOOP_CREDIT_SOCIETY;
  static TableField get COOP_CREDIT_SOCIETY {
    return _fCOOP_CREDIT_SOCIETY = _fCOOP_CREDIT_SOCIETY ??
        SqlSyntax.setField(
            _fCOOP_CREDIT_SOCIETY, 'COOP_CREDIT_SOCIETY', DbType.text);
  }

  static TableField? _fRELIEF_FUND;
  static TableField get RELIEF_FUND {
    return _fRELIEF_FUND = _fRELIEF_FUND ??
        SqlSyntax.setField(_fRELIEF_FUND, 'RELIEF_FUND', DbType.text);
  }

  static TableField? _fDEATH_RELIEF_FUND;
  static TableField get DEATH_RELIEF_FUND {
    return _fDEATH_RELIEF_FUND = _fDEATH_RELIEF_FUND ??
        SqlSyntax.setField(
            _fDEATH_RELIEF_FUND, 'DEATH_RELIEF_FUND', DbType.text);
  }

  static TableField? _fWATER_TAX;
  static TableField get WATER_TAX {
    return _fWATER_TAX = _fWATER_TAX ??
        SqlSyntax.setField(_fWATER_TAX, 'WATER_TAX', DbType.text);
  }

  static TableField? _fELECTRICITY_CHARGES;
  static TableField get ELECTRICITY_CHARGES {
    return _fELECTRICITY_CHARGES = _fELECTRICITY_CHARGES ??
        SqlSyntax.setField(
            _fELECTRICITY_CHARGES, 'ELECTRICITY_CHARGES', DbType.text);
  }

  static TableField? _fAOR_NONTAX;
  static TableField get AOR_NONTAX {
    return _fAOR_NONTAX = _fAOR_NONTAX ??
        SqlSyntax.setField(_fAOR_NONTAX, 'AOR_NONTAX', DbType.text);
  }

  static TableField? _fPOSTAL_RELIEF_FUND;
  static TableField get POSTAL_RELIEF_FUND {
    return _fPOSTAL_RELIEF_FUND = _fPOSTAL_RELIEF_FUND ??
        SqlSyntax.setField(
            _fPOSTAL_RELIEF_FUND, 'POSTAL_RELIEF_FUND', DbType.text);
  }

  static TableField? _fPLI_PREMIUM;
  static TableField get PLI_PREMIUM {
    return _fPLI_PREMIUM = _fPLI_PREMIUM ??
        SqlSyntax.setField(_fPLI_PREMIUM, 'PLI_PREMIUM', DbType.text);
  }

  static TableField? _fRECREATION_CLUB;
  static TableField get RECREATION_CLUB {
    return _fRECREATION_CLUB = _fRECREATION_CLUB ??
        SqlSyntax.setField(_fRECREATION_CLUB, 'RECREATION_CLUB', DbType.text);
  }

  static TableField? _fUNION_ASSOCIATION;
  static TableField get UNION_ASSOCIATION {
    return _fUNION_ASSOCIATION = _fUNION_ASSOCIATION ??
        SqlSyntax.setField(
            _fUNION_ASSOCIATION, 'UNION_ASSOCIATION', DbType.text);
  }

  static TableField? _fWELFARE_FUND;
  static TableField get WELFARE_FUND {
    return _fWELFARE_FUND = _fWELFARE_FUND ??
        SqlSyntax.setField(_fWELFARE_FUND, 'WELFARE_FUND', DbType.text);
  }

  static TableField? _fCGEGIS;
  static TableField get CGEGIS {
    return _fCGEGIS =
        _fCGEGIS ?? SqlSyntax.setField(_fCGEGIS, 'CGEGIS', DbType.text);
  }

  static TableField? _fCGHS;
  static TableField get CGHS {
    return _fCGHS = _fCGHS ?? SqlSyntax.setField(_fCGHS, 'CGHS', DbType.text);
  }

  static TableField? _fEDAGIS_92;
  static TableField get EDAGIS_92 {
    return _fEDAGIS_92 = _fEDAGIS_92 ??
        SqlSyntax.setField(_fEDAGIS_92, 'EDAGIS_92', DbType.text);
  }

  static TableField? _fLIC_PREMIUM;
  static TableField get LIC_PREMIUM {
    return _fLIC_PREMIUM = _fLIC_PREMIUM ??
        SqlSyntax.setField(_fLIC_PREMIUM, 'LIC_PREMIUM', DbType.text);
  }

  static TableField? _fCGIS;
  static TableField get CGIS {
    return _fCGIS = _fCGIS ?? SqlSyntax.setField(_fCGIS, 'CGIS', DbType.text);
  }

  static TableField? _fRPLI;
  static TableField get RPLI {
    return _fRPLI = _fRPLI ?? SqlSyntax.setField(_fRPLI, 'RPLI', DbType.text);
  }

  static TableField? _fPLI_SERVICE_TAX;
  static TableField get PLI_SERVICE_TAX {
    return _fPLI_SERVICE_TAX = _fPLI_SERVICE_TAX ??
        SqlSyntax.setField(_fPLI_SERVICE_TAX, 'PLI_SERVICE_TAX', DbType.text);
  }

  static TableField? _fCONNECTIONS;
  static TableField get CONNECTIONS {
    return _fCONNECTIONS = _fCONNECTIONS ??
        SqlSyntax.setField(_fCONNECTIONS, 'CONNECTIONS', DbType.text);
  }

  static TableField? _fCGEWCC;
  static TableField get CGEWCC {
    return _fCGEWCC =
        _fCGEWCC ?? SqlSyntax.setField(_fCGEWCC, 'CGEWCC', DbType.text);
  }

  static TableField? _fSOCIETIES;
  static TableField get SOCIETIES {
    return _fSOCIETIES = _fSOCIETIES ??
        SqlSyntax.setField(_fSOCIETIES, 'SOCIETIES', DbType.text);
  }

  static TableField? _fFNPO;
  static TableField get FNPO {
    return _fFNPO = _fFNPO ?? SqlSyntax.setField(_fFNPO, 'FNPO', DbType.text);
  }

  static TableField? _fED_GIS;
  static TableField get ED_GIS {
    return _fED_GIS =
        _fED_GIS ?? SqlSyntax.setField(_fED_GIS, 'ED_GIS', DbType.text);
  }

  static TableField? _fSECURITY_BONDS;
  static TableField get SECURITY_BONDS {
    return _fSECURITY_BONDS = _fSECURITY_BONDS ??
        SqlSyntax.setField(_fSECURITY_BONDS, 'SECURITY_BONDS', DbType.text);
  }

  static TableField? _fEXTRA_DEPARTMENTAL_UNIONS;
  static TableField get EXTRA_DEPARTMENTAL_UNIONS {
    return _fEXTRA_DEPARTMENTAL_UNIONS = _fEXTRA_DEPARTMENTAL_UNIONS ??
        SqlSyntax.setField(_fEXTRA_DEPARTMENTAL_UNIONS,
            'EXTRA_DEPARTMENTAL_UNIONS', DbType.text);
  }

  static TableField? _fCGEGIS_INSURANCE_FUND;
  static TableField get CGEGIS_INSURANCE_FUND {
    return _fCGEGIS_INSURANCE_FUND = _fCGEGIS_INSURANCE_FUND ??
        SqlSyntax.setField(
            _fCGEGIS_INSURANCE_FUND, 'CGEGIS_INSURANCE_FUND', DbType.text);
  }

  static TableField? _fPOSTAL_COOP_SOCIETY;
  static TableField get POSTAL_COOP_SOCIETY {
    return _fPOSTAL_COOP_SOCIETY = _fPOSTAL_COOP_SOCIETY ??
        SqlSyntax.setField(
            _fPOSTAL_COOP_SOCIETY, 'POSTAL_COOP_SOCIETY', DbType.text);
  }

  static TableField? _fCOOP_BANK_REC;
  static TableField get COOP_BANK_REC {
    return _fCOOP_BANK_REC = _fCOOP_BANK_REC ??
        SqlSyntax.setField(_fCOOP_BANK_REC, 'COOP_BANK_REC', DbType.text);
  }

  static TableField? _fDIVISION_SPORTS_BOARD;
  static TableField get DIVISION_SPORTS_BOARD {
    return _fDIVISION_SPORTS_BOARD = _fDIVISION_SPORTS_BOARD ??
        SqlSyntax.setField(
            _fDIVISION_SPORTS_BOARD, 'DIVISION_SPORTS_BOARD', DbType.text);
  }

  static TableField? _fMISC_DEDUCTIONS;
  static TableField get MISC_DEDUCTIONS {
    return _fMISC_DEDUCTIONS = _fMISC_DEDUCTIONS ??
        SqlSyntax.setField(_fMISC_DEDUCTIONS, 'MISC_DEDUCTIONS', DbType.text);
  }

  static TableField? _fBONDS;
  static TableField get BONDS {
    return _fBONDS =
        _fBONDS ?? SqlSyntax.setField(_fBONDS, 'BONDS', DbType.text);
  }

  static TableField? _fCWFGDS;
  static TableField get CWFGDS {
    return _fCWFGDS =
        _fCWFGDS ?? SqlSyntax.setField(_fCWFGDS, 'CWFGDS', DbType.text);
  }

  static TableField? _fFESTIVAL_ADVANCE_SPECIAL;
  static TableField get FESTIVAL_ADVANCE_SPECIAL {
    return _fFESTIVAL_ADVANCE_SPECIAL = _fFESTIVAL_ADVANCE_SPECIAL ??
        SqlSyntax.setField(_fFESTIVAL_ADVANCE_SPECIAL,
            'FESTIVAL_ADVANCE_SPECIAL', DbType.text);
  }

  static TableField? _fTOTAL_DEDUCTIONS;
  static TableField get TOTAL_DEDUCTIONS {
    return _fTOTAL_DEDUCTIONS = _fTOTAL_DEDUCTIONS ??
        SqlSyntax.setField(_fTOTAL_DEDUCTIONS, 'TOTAL_DEDUCTIONS', DbType.text);
  }

  static TableField? _fTOTAL_GROSS_AMOUNT;
  static TableField get TOTAL_GROSS_AMOUNT {
    return _fTOTAL_GROSS_AMOUNT = _fTOTAL_GROSS_AMOUNT ??
        SqlSyntax.setField(
            _fTOTAL_GROSS_AMOUNT, 'TOTAL_GROSS_AMOUNT', DbType.text);
  }

  static TableField? _fNET_PAY;
  static TableField get NET_PAY {
    return _fNET_PAY =
        _fNET_PAY ?? SqlSyntax.setField(_fNET_PAY, 'NET_PAY', DbType.text);
  }
}
// endregion PaySlipDataFields

//region PaySlipDataManager
class PaySlipDataManager extends SqfEntityProvider {
  PaySlipDataManager()
      : super(UserDB(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'PaySlipData';
  static const List<String> _primaryKeyList = ['EMPLOYEE_ID', 'MONTH', 'YEAR'];
  static const String _whereStr = 'EMPLOYEE_ID=? AND MONTH=? AND YEAR=?';
}

//endregion PaySlipDataManager
class UserDBSequenceManager extends SqfEntityProvider {
  UserDBSequenceManager() : super(UserDB());
}
// END OF ENTITIES
