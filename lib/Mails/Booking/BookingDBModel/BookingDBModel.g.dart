// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'BookingDBModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:ArticleType.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// ArticleType TABLE
class TableArticleType extends SqfEntityTableBase {
  TableArticleType() {
    // declare properties of EntityTable
    tableName = 'ArticleTypes';
    primaryKeyName = 'Article_Prefix_Code';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Article_Category_Name', DbType.text),
      SqfEntityFieldBase('Article_Used_Word', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableArticleType();
  }
}

// ParcelBooking TABLE
class TableParcelBooking extends SqfEntityTableBase {
  TableParcelBooking() {
    // declare properties of EntityTable
    tableName = 'parcelBooking';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserID', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyID', DbType.text),
      SqfEntityFieldBase('TenderID', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CheckerUserID', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('WeightCode', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerNumber', DbType.text),
      SqfEntityFieldBase('SenderName', DbType.text),
      SqfEntityFieldBase('SenderAddress', DbType.text),
      SqfEntityFieldBase('SenderCity', DbType.text),
      SqfEntityFieldBase('SenderState', DbType.text),
      SqfEntityFieldBase('SenderZip', DbType.text),
      SqfEntityFieldBase('SenderCountry', DbType.text),
      SqfEntityFieldBase('RecipientName', DbType.text),
      SqfEntityFieldBase('RecipientAddress', DbType.text),
      SqfEntityFieldBase('RecipientCity', DbType.text),
      SqfEntityFieldBase('RecipientState', DbType.text),
      SqfEntityFieldBase('RecipientZip', DbType.text),
      SqfEntityFieldBase('RecipientCountryID', DbType.text),
      SqfEntityFieldBase('RecipientMobile', DbType.text),
      SqfEntityFieldBase('RecipientEmail', DbType.text),
      SqfEntityFieldBase('ReturnName', DbType.text),
      SqfEntityFieldBase('ReturnAddress', DbType.text),
      SqfEntityFieldBase('ReturnCity', DbType.text),
      SqfEntityFieldBase('ReturnState', DbType.text),
      SqfEntityFieldBase('ReturnZip', DbType.text),
      SqfEntityFieldBase('ReturnCountryID', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacility', DbType.text),
      SqfEntityFieldBase('TaxAmount', DbType.text),
      SqfEntityFieldBase('RepaymentMode', DbType.text),
      SqfEntityFieldBase('PostageDue', DbType.text),
      SqfEntityFieldBase('PrepaidAmount', DbType.text),
      SqfEntityFieldBase('VAS', DbType.text),
      SqfEntityFieldBase('VASValue', DbType.text),
      SqfEntityFieldBase('IsAMS', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('IsFullPrepaid', DbType.text),
      SqfEntityFieldBase('IsOnPostalService', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('CancellationReason', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableParcelBooking();
  }
}

// ProductSaleTable TABLE
class TableProductSaleTable extends SqfEntityTableBase {
  TableProductSaleTable() {
    // declare properties of EntityTable
    tableName = 'ProductSaleTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserId', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyId', DbType.text),
      SqfEntityFieldBase('TenderId', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerId', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacilityId', DbType.text),
      SqfEntityFieldBase('UoM', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileCreatedDate', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDate', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProductSaleTable();
  }
}

// InventoryDailyTable TABLE
class TableInventoryDailyTable extends SqfEntityTableBase {
  TableInventoryDailyTable() {
    // declare properties of EntityTable
    tableName = 'InventoryDailyTable';
    primaryKeyName = 'InventoryId';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('StampName', DbType.text),
      SqfEntityFieldBase('Price', DbType.text),
      SqfEntityFieldBase('RecordedDate', DbType.text),
      SqfEntityFieldBase('OpeningQuantity', DbType.text),
      SqfEntityFieldBase('OpeningValue', DbType.text),
      SqfEntityFieldBase('ClosingQuantity', DbType.text),
      SqfEntityFieldBase('ClosingValue', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInventoryDailyTable();
  }
}

// Liability TABLE
class TableLiability extends SqfEntityTableBase {
  TableLiability() {
    // declare properties of EntityTable
    tableName = 'Liability';
    primaryKeyName = 'Date';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Description', DbType.text),
      SqfEntityFieldBase('Amount', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLiability();
  }
}

// TempLiability TABLE
class TableTempLiability extends SqfEntityTableBase {
  TableTempLiability() {
    // declare properties of EntityTable
    tableName = 'tempLiability';
    primaryKeyName = 'Date';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Description', DbType.text),
      SqfEntityFieldBase('Amount', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTempLiability();
  }
}

// BodaSlip TABLE
class TableBodaSlip extends SqfEntityTableBase {
  TableBodaSlip() {
    // declare properties of EntityTable
    tableName = 'bodaSlip';
    primaryKeyName = 'bodaDate';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('cashFrom', DbType.text),
      SqfEntityFieldBase('cashTo', DbType.text),
      SqfEntityFieldBase('bodaNumber', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBodaSlip();
  }
}

// LetterBooking TABLE
class TableLetterBooking extends SqfEntityTableBase {
  TableLetterBooking() {
    // declare properties of EntityTable
    tableName = 'letterBooking';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserID', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyID', DbType.text),
      SqfEntityFieldBase('TenderID', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('WeightCode', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerNumber', DbType.text),
      SqfEntityFieldBase('SenderName', DbType.text),
      SqfEntityFieldBase('SenderAddress', DbType.text),
      SqfEntityFieldBase('SenderCity', DbType.text),
      SqfEntityFieldBase('SenderState', DbType.text),
      SqfEntityFieldBase('SenderZip', DbType.text),
      SqfEntityFieldBase('SenderCountry', DbType.text),
      SqfEntityFieldBase('RecipientName', DbType.text),
      SqfEntityFieldBase('RecipientAddress', DbType.text),
      SqfEntityFieldBase('RecipientCity', DbType.text),
      SqfEntityFieldBase('RecipientState', DbType.text),
      SqfEntityFieldBase('RecipientZip', DbType.text),
      SqfEntityFieldBase('RecipientCountryID', DbType.text),
      SqfEntityFieldBase('RecipientMobile', DbType.text),
      SqfEntityFieldBase('RecipientEmail', DbType.text),
      SqfEntityFieldBase('ReturnName', DbType.text),
      SqfEntityFieldBase('ReturnAddress', DbType.text),
      SqfEntityFieldBase('ReturnCity', DbType.text),
      SqfEntityFieldBase('ReturnState', DbType.text),
      SqfEntityFieldBase('ReturnZip', DbType.text),
      SqfEntityFieldBase('ReturnCountryID', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('TaxAmount', DbType.text),
      SqfEntityFieldBase('RepaymentMode', DbType.text),
      SqfEntityFieldBase('PostageDue', DbType.text),
      SqfEntityFieldBase('PrepaidAmount', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacility', DbType.text),
      SqfEntityFieldBase('VAS', DbType.text),
      SqfEntityFieldBase('VASValue', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('IsFullyPrepaid', DbType.text),
      SqfEntityFieldBase('IsOnPostalService', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('CancellationReason', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLetterBooking();
  }
}

// EmoBooking TABLE
class TableEmoBooking extends SqfEntityTableBase {
  TableEmoBooking() {
    // declare properties of EntityTable
    tableName = 'emoBooking';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserID', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyID', DbType.text),
      SqfEntityFieldBase('TenderID', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CheckerUserID', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('ValueCode', DbType.text),
      SqfEntityFieldBase('Value', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerNumber', DbType.text),
      SqfEntityFieldBase('SenderName', DbType.text),
      SqfEntityFieldBase('SenderAddress', DbType.text),
      SqfEntityFieldBase('SenderCity', DbType.text),
      SqfEntityFieldBase('SenderState', DbType.text),
      SqfEntityFieldBase('SenderZip', DbType.text),
      SqfEntityFieldBase('SenderCountry', DbType.text),
      SqfEntityFieldBase('RecipientName', DbType.text),
      SqfEntityFieldBase('RecipientAddress', DbType.text),
      SqfEntityFieldBase('RecipientCity', DbType.text),
      SqfEntityFieldBase('RecipientState', DbType.text),
      SqfEntityFieldBase('RecipientZip', DbType.text),
      SqfEntityFieldBase('RecipientCountryID', DbType.text),
      SqfEntityFieldBase('RecipientMobile', DbType.text),
      SqfEntityFieldBase('RecipientEmail', DbType.text),
      SqfEntityFieldBase('ReturnName', DbType.text),
      SqfEntityFieldBase('ReturnAddress', DbType.text),
      SqfEntityFieldBase('ReturnCity', DbType.text),
      SqfEntityFieldBase('ReturnState', DbType.text),
      SqfEntityFieldBase('ReturnZip', DbType.text),
      SqfEntityFieldBase('ReturnCountryID', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('RepaymentMode', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacility', DbType.text),
      SqfEntityFieldBase('SenderMoneyTransferValue', DbType.text),
      SqfEntityFieldBase('MOTrackingID', DbType.text),
      SqfEntityFieldBase('MOMessage', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('BulkAddressType', DbType.text),
      SqfEntityFieldBase('VPMOIdentifier', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEmoBooking();
  }
}

// SpeedBooking TABLE
class TableSpeedBooking extends SqfEntityTableBase {
  TableSpeedBooking() {
    // declare properties of EntityTable
    tableName = 'speedBooking';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserID', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyID', DbType.text),
      SqfEntityFieldBase('TenderID', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('WeightCode', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('DistanceCode', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerNumber', DbType.text),
      SqfEntityFieldBase('SenderName', DbType.text),
      SqfEntityFieldBase('SenderAddress', DbType.text),
      SqfEntityFieldBase('SenderCity', DbType.text),
      SqfEntityFieldBase('SenderState', DbType.text),
      SqfEntityFieldBase('SenderZip', DbType.text),
      SqfEntityFieldBase('SenderCountry', DbType.text),
      SqfEntityFieldBase('SenderMobile', DbType.text),
      SqfEntityFieldBase('RecipientName', DbType.text),
      SqfEntityFieldBase('RecipientAddress', DbType.text),
      SqfEntityFieldBase('RecipientCity', DbType.text),
      SqfEntityFieldBase('RecipientState', DbType.text),
      SqfEntityFieldBase('RecipientZip', DbType.text),
      SqfEntityFieldBase('RecipientCountryID', DbType.text),
      SqfEntityFieldBase('ReturnName', DbType.text),
      SqfEntityFieldBase('ReturnAddress', DbType.text),
      SqfEntityFieldBase('ReturnCity', DbType.text),
      SqfEntityFieldBase('ReturnState', DbType.text),
      SqfEntityFieldBase('ReturnZip', DbType.text),
      SqfEntityFieldBase('ReturnCountryID', DbType.text),
      SqfEntityFieldBase('TaxAmount', DbType.text),
      SqfEntityFieldBase('PostageDue', DbType.text),
      SqfEntityFieldBase('RepaymentMode', DbType.text),
      SqfEntityFieldBase('PrepaidAmount', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacility', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('IsFullPrepaid', DbType.text),
      SqfEntityFieldBase('VAS', DbType.text),
      SqfEntityFieldBase('VASValue', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('CancellationReason', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSpeedBooking();
  }
}

// ProductsMaster TABLE
class TableProductsMaster extends SqfEntityTableBase {
  TableProductsMaster() {
    // declare properties of EntityTable
    tableName = 'productsMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ItemCode', DbType.text),
      SqfEntityFieldBase('ShortDescription', DbType.text),
      SqfEntityFieldBase('CategoryDescription', DbType.text),
      SqfEntityFieldBase('SalePrice', DbType.text),
      SqfEntityFieldBase('EffStartDate', DbType.text),
      SqfEntityFieldBase('EffEndDate', DbType.text),
      SqfEntityFieldBase('POSCurrentStock', DbType.text),
      SqfEntityFieldBase('OpeningStock', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('UnitMeasurement', DbType.text),
      SqfEntityFieldBase('CreatedBy', DbType.text),
      SqfEntityFieldBase('CreatedOn', DbType.text),
      SqfEntityFieldBase('ModifiedBy', DbType.text),
      SqfEntityFieldBase('ModifiedOn', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProductsMaster();
  }
}

// EmoMOCommission TABLE
class TableEmoMOCommission extends SqfEntityTableBase {
  TableEmoMOCommission() {
    // declare properties of EntityTable
    tableName = 'emoMOCommission';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Commission', DbType.text),
      SqfEntityFieldBase('MinimumAmount', DbType.text),
      SqfEntityFieldBase('MaximumAmount', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('AdditionalService', DbType.text),
      SqfEntityFieldBase('ValueID', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableEmoMOCommission();
  }
}

// InsMOCommission TABLE
class TableInsMOCommission extends SqfEntityTableBase {
  TableInsMOCommission() {
    // declare properties of EntityTable
    tableName = 'insMOCommission';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Commission', DbType.text),
      SqfEntityFieldBase('MinimumAmount', DbType.text),
      SqfEntityFieldBase('MaximumAmount', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('AdditionalService', DbType.text),
      SqfEntityFieldBase('ValueID', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableInsMOCommission();
  }
}

// VppMOCommission TABLE
class TableVppMOCommission extends SqfEntityTableBase {
  TableVppMOCommission() {
    // declare properties of EntityTable
    tableName = 'vppMOCommission';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Commission', DbType.text),
      SqfEntityFieldBase('MinimumAmount', DbType.text),
      SqfEntityFieldBase('MaximumAmount', DbType.text),
      SqfEntityFieldBase('CommissionAmount', DbType.text),
      SqfEntityFieldBase('AdditionalService', DbType.text),
      SqfEntityFieldBase('ValueID', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableVppMOCommission();
  }
}

// DistanceMaster TABLE
class TableDistanceMaster extends SqfEntityTableBase {
  TableDistanceMaster() {
    // declare properties of EntityTable
    tableName = 'distanceMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('MinDistance', DbType.text),
      SqfEntityFieldBase('MaxDistance', DbType.text),
      SqfEntityFieldBase('Service', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDistanceMaster();
  }
}

// TaxMaster TABLE
class TableTaxMaster extends SqfEntityTableBase {
  TableTaxMaster() {
    // declare properties of EntityTable
    tableName = 'taxMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Service', DbType.text),
      SqfEntityFieldBase('PercentageValue', DbType.text),
      SqfEntityFieldBase('TaxDescription', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTaxMaster();
  }
}

// TariffMaster TABLE
class TableTariffMaster extends SqfEntityTableBase {
  TableTariffMaster() {
    // declare properties of EntityTable
    tableName = 'tariffMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Service', DbType.text),
      SqfEntityFieldBase('WeightId', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTariffMaster();
  }
}

// ServiceMaster TABLE
class TableServiceMaster extends SqfEntityTableBase {
  TableServiceMaster() {
    // declare properties of EntityTable
    tableName = 'serviceMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ServiceId', DbType.text),
      SqfEntityFieldBase('ServiceName', DbType.text),
      SqfEntityFieldBase('MinimumWeight', DbType.text),
      SqfEntityFieldBase('MaximumWeight', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableServiceMaster();
  }
}

// WeightMaster TABLE
class TableWeightMaster extends SqfEntityTableBase {
  TableWeightMaster() {
    // declare properties of EntityTable
    tableName = 'weightMaster';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('WeightId', DbType.text),
      SqfEntityFieldBase('MinimumWeight', DbType.text),
      SqfEntityFieldBase('MaximumWeight', DbType.text),
      SqfEntityFieldBase('ServiceId', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableWeightMaster();
  }
}

// LeaveBalanceTable TABLE
class TableLeaveBalanceTable extends SqfEntityTableBase {
  TableLeaveBalanceTable() {
    // declare properties of EntityTable
    tableName = 'leaveBalanceTable';
    primaryKeyName = 'EmployeeNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('QuotaType', DbType.text),
      SqfEntityFieldBase('LeaveBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLeaveBalanceTable();
  }
}

// CashIndentTable TABLE
class TableCashIndentTable extends SqfEntityTableBase {
  TableCashIndentTable() {
    // declare properties of EntityTable
    tableName = 'cashIndentTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BOID', DbType.text),
      SqfEntityFieldBase('Date', DbType.text),
      SqfEntityFieldBase('Time', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('HOName', DbType.text),
      SqfEntityFieldBase('Amount1', DbType.text),
      SqfEntityFieldBase('Amount2', DbType.text),
      SqfEntityFieldBase('Amount3', DbType.text),
      SqfEntityFieldBase('AmountType', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCashIndentTable();
  }
}

// SpecialRemittanceTable TABLE
class TableSpecialRemittanceTable extends SqfEntityTableBase {
  TableSpecialRemittanceTable() {
    // declare properties of EntityTable
    tableName = 'specialRemittanceTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SpecialRemittanceId', DbType.text),
      SqfEntityFieldBase('Date', DbType.text),
      SqfEntityFieldBase('Time', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('HOName', DbType.text),
      SqfEntityFieldBase('Amount1', DbType.text),
      SqfEntityFieldBase('Amount2', DbType.text),
      SqfEntityFieldBase('Amount3', DbType.text),
      SqfEntityFieldBase('AmountType', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSpecialRemittanceTable();
  }
}

// ExcessCashTable TABLE
class TableExcessCashTable extends SqfEntityTableBase {
  TableExcessCashTable() {
    // declare properties of EntityTable
    tableName = 'excessCashTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BOID', DbType.text),
      SqfEntityFieldBase('Date', DbType.text),
      SqfEntityFieldBase('Time', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('HOName', DbType.text),
      SqfEntityFieldBase('Amount1', DbType.text),
      SqfEntityFieldBase('Amount2', DbType.text),
      SqfEntityFieldBase('Amount3', DbType.text),
      SqfEntityFieldBase('AmountType', DbType.text),
      SqfEntityFieldBase('Amount4', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExcessCashTable();
  }
}

// SetUpInventoryTable TABLE
class TableSetUpInventoryTable extends SqfEntityTableBase {
  TableSetUpInventoryTable() {
    // declare properties of EntityTable
    tableName = 'setUpInventoryTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BOId', DbType.text),
      SqfEntityFieldBase('InventoryName', DbType.text),
      SqfEntityFieldBase('Column1', DbType.text),
      SqfEntityFieldBase('Column2', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSetUpInventoryTable();
  }
}

// LocalStoreTable TABLE
class TableLocalStoreTable extends SqfEntityTableBase {
  TableLocalStoreTable() {
    // declare properties of EntityTable
    tableName = 'localStoreTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ParentOfficeId', DbType.text),
      SqfEntityFieldBase('ParentOfficeName', DbType.text),
      SqfEntityFieldBase('OfficeId', DbType.text),
      SqfEntityFieldBase('BOSequenceId', DbType.text),
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('Address', DbType.text),
      SqfEntityFieldBase('Pin', DbType.text),
      SqfEntityFieldBase('Latitude', DbType.text),
      SqfEntityFieldBase('Longitude', DbType.text),
      SqfEntityFieldBase('City', DbType.text),
      SqfEntityFieldBase('StateCode', DbType.text),
      SqfEntityFieldBase('StateName', DbType.text),
      SqfEntityFieldBase('SolutionId', DbType.text),
      SqfEntityFieldBase('LegacyCode', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('Circle', DbType.text),
      SqfEntityFieldBase('CreatedBy', DbType.text),
      SqfEntityFieldBase('CreatedOn', DbType.text),
      SqfEntityFieldBase('ModifiedBy', DbType.text),
      SqfEntityFieldBase('ModifiedOn', DbType.text),
      SqfEntityFieldBase('IsStoreBegin', DbType.text),
      SqfEntityFieldBase('WalkInCustomerId', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLocalStoreTable();
  }
}

// AdditionalServiceMappingTable TABLE
class TableAdditionalServiceMappingTable extends SqfEntityTableBase {
  TableAdditionalServiceMappingTable() {
    // declare properties of EntityTable
    tableName = 'additionalServiceMappingTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ServiceId', DbType.text),
      SqfEntityFieldBase('AdditionalServiceId', DbType.text),
      SqfEntityFieldBase('AdditionalServicePrice', DbType.text),
      SqfEntityFieldBase('Identifier', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableAdditionalServiceMappingTable();
  }
}

// SwitchOnTable TABLE
class TableSwitchOnTable extends SqfEntityTableBase {
  TableSwitchOnTable() {
    // declare properties of EntityTable
    tableName = 'switchOnTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ParentOfficeId', DbType.text),
      SqfEntityFieldBase('OfficeId', DbType.text),
      SqfEntityFieldBase('BOSequenceId', DbType.text),
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('LegacyCode', DbType.text),
      SqfEntityFieldBase('SanctionedLimit', DbType.text),
      SqfEntityFieldBase('CashBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSwitchOnTable();
  }
}

// DayBegin TABLE
class TableDayBegin extends SqfEntityTableBase {
  TableDayBegin() {
    // declare properties of EntityTable
    tableName = 'dayBegin';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BPMId', DbType.text),
      SqfEntityFieldBase('DayBeginTimeStamp1', DbType.text),
      SqfEntityFieldBase('DayBeginTimeStamp2', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDayBegin();
  }
}

// CashIndent TABLE
class TableCashIndent extends SqfEntityTableBase {
  TableCashIndent() {
    // declare properties of EntityTable
    tableName = 'cashIndent';
    primaryKeyName = 'SOSlipNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SOGenerationDate', DbType.text),
      SqfEntityFieldBase('ChequeNumber', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('SOName', DbType.text),
      SqfEntityFieldBase('CashAmount', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('ChequeAmount', DbType.text),
      SqfEntityFieldBase('AmountType', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCashIndent();
  }
}

// CancelBooking TABLE
class TableCancelBooking extends SqfEntityTableBase {
  TableCancelBooking() {
    // declare properties of EntityTable
    tableName = 'CancelBooking';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserId', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyId', DbType.text),
      SqfEntityFieldBase('TenderId', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifferenceAmount', DbType.text),
      SqfEntityFieldBase('ParentInvoiceNumber', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('BasePrice', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('ArticleNumber', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('WeightCode', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('ValueCode', DbType.text),
      SqfEntityFieldBase('Value', DbType.text),
      SqfEntityFieldBase('DistanceCode', DbType.text),
      SqfEntityFieldBase('Distance', DbType.text),
      SqfEntityFieldBase('SenderCustomerId', DbType.text),
      SqfEntityFieldBase('RecipientCountryId', DbType.text),
      SqfEntityFieldBase('IsReversed', DbType.text),
      SqfEntityFieldBase('TaxAmount', DbType.text),
      SqfEntityFieldBase('PostageDue', DbType.text),
      SqfEntityFieldBase('PrepaidAmount', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('SerialNumber', DbType.text),
      SqfEntityFieldBase('IsFullPrepaid', DbType.text),
      SqfEntityFieldBase('VAS', DbType.text),
      SqfEntityFieldBase('VASValue', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('CancellationReason', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCancelBooking();
  }
}

// CancelBiller TABLE
class TableCancelBiller extends SqfEntityTableBase {
  TableCancelBiller() {
    // declare properties of EntityTable
    tableName = 'CancelBiller';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('BookingFacilityZip', DbType.text),
      SqfEntityFieldBase('DistributionChannel', DbType.text),
      SqfEntityFieldBase('UserId', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyId', DbType.text),
      SqfEntityFieldBase('TenderId', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifferenceAmount', DbType.text),
      SqfEntityFieldBase('ParentInvoiceNumber', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('ArticleNumber', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('ValueCode', DbType.text),
      SqfEntityFieldBase('Value', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('SenderCustomerId', DbType.text),
      SqfEntityFieldBase('IsReversed', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('SerialNumber', DbType.text),
      SqfEntityFieldBase('AddlBillInfo', DbType.text),
      SqfEntityFieldBase('AddlBillAmountInfo', DbType.text),
      SqfEntityFieldBase('BillerID', DbType.text),
      SqfEntityFieldBase('BillerName', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
      SqfEntityFieldBase('CancellationReason', DbType.text),
      SqfEntityFieldBase('Authorized', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCancelBiller();
  }
}

// SwitchOnAcknowledge TABLE
class TableSwitchOnAcknowledge extends SqfEntityTableBase {
  TableSwitchOnAcknowledge() {
    // declare properties of EntityTable
    tableName = 'switchOnAcknowledge';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ParentOfficeNumber', DbType.text),
      SqfEntityFieldBase('OfficeId', DbType.text),
      SqfEntityFieldBase('BOSequenceId', DbType.text),
      SqfEntityFieldBase('OfficeName', DbType.text),
      SqfEntityFieldBase('LegacyCode', DbType.text),
      SqfEntityFieldBase('SanctionedLimit', DbType.text),
      SqfEntityFieldBase('CashBalance', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSwitchOnAcknowledge();
  }
}

// SwitchOnAcknowledgement TABLE
class TableSwitchOnAcknowledgement extends SqfEntityTableBase {
  TableSwitchOnAcknowledgement() {
    // declare properties of EntityTable
    tableName = 'switchOnAcknowledgement';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('LegacyUpdation', DbType.text),
      SqfEntityFieldBase('SanctionedDeletion', DbType.text),
      SqfEntityFieldBase('SanctionedInsertion', DbType.text),
      SqfEntityFieldBase('UpdateWallet', DbType.text),
      SqfEntityFieldBase('InsertionClosingBalance', DbType.text),
      SqfEntityFieldBase('InsertionOpeningBalance', DbType.text),
      SqfEntityFieldBase('InsertionOpeningStock', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSwitchOnAcknowledgement();
  }
}

// BillerData TABLE
class TableBillerData extends SqfEntityTableBase {
  TableBillerData() {
    // declare properties of EntityTable
    tableName = 'billerData';
    primaryKeyName = 'BillerId';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BillerName', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBillerData();
  }
}

// SpecialRemittanceFile TABLE
class TableSpecialRemittanceFile extends SqfEntityTableBase {
  TableSpecialRemittanceFile() {
    // declare properties of EntityTable
    tableName = 'specialRemittanceFile';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SlipNumber', DbType.text),
      SqfEntityFieldBase('Date', DbType.text),
      SqfEntityFieldBase('ChequeNumber', DbType.text),
      SqfEntityFieldBase('BOProfitName', DbType.text),
      SqfEntityFieldBase('SOProfitName', DbType.text),
      SqfEntityFieldBase('CashAmount', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('ChequeAmount', DbType.text),
      SqfEntityFieldBase('ChequeCash', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('FILE_NAME', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableSpecialRemittanceFile();
  }
}

// BillFile TABLE
class TableBillFile extends SqfEntityTableBase {
  TableBillFile() {
    // declare properties of EntityTable
    tableName = 'billFile';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('FacilityId', DbType.text),
      SqfEntityFieldBase('Zip', DbType.text),
      SqfEntityFieldBase('Channel', DbType.text),
      SqfEntityFieldBase('UserId', DbType.text),
      SqfEntityFieldBase('CounterNumber', DbType.text),
      SqfEntityFieldBase('InvoiceNumber', DbType.text),
      SqfEntityFieldBase('TotalAmount', DbType.text),
      SqfEntityFieldBase('BookingDate', DbType.text),
      SqfEntityFieldBase('BookingTime', DbType.text),
      SqfEntityFieldBase('CurrencyId', DbType.text),
      SqfEntityFieldBase('TenderId', DbType.text),
      SqfEntityFieldBase('TotalCashAmount', DbType.text),
      SqfEntityFieldBase('RoundOffDifference', DbType.text),
      SqfEntityFieldBase('CircleCode', DbType.text),
      SqfEntityFieldBase('LineItemNumber', DbType.text),
      SqfEntityFieldBase('LineItemTotalAmount', DbType.text),
      SqfEntityFieldBase('ArticleNumber', DbType.text),
      SqfEntityFieldBase('Division', DbType.text),
      SqfEntityFieldBase('OrderType', DbType.text),
      SqfEntityFieldBase('ProductType', DbType.text),
      SqfEntityFieldBase('ProductCode', DbType.text),
      SqfEntityFieldBase('ValueCode', DbType.text),
      SqfEntityFieldBase('Value', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('CustomerId', DbType.text),
      SqfEntityFieldBase('MaterialGroup', DbType.text),
      SqfEntityFieldBase('DestinationFacilityId', DbType.text),
      SqfEntityFieldBase('ElapsedTime', DbType.text),
      SqfEntityFieldBase('AdditionalBillInfo', DbType.text),
      SqfEntityFieldBase('AdditionalBillAmountInfo', DbType.text),
      SqfEntityFieldBase('BillerId', DbType.text),
      SqfEntityFieldBase('BillerName', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('FILE_NAME', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBillFile();
  }
}

// DayModel TABLE
class TableDayModel extends SqfEntityTableBase {
  TableDayModel() {
    // declare properties of EntityTable
    tableName = 'DayModel';
    primaryKeyName = 'DayBeginDate';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('DayBeginTime', DbType.text),
      SqfEntityFieldBase('CashOpeningBalance', DbType.text),
      SqfEntityFieldBase('CashClosingBalance', DbType.text),
      SqfEntityFieldBase('DayCloseDate', DbType.text),
      SqfEntityFieldBase('DayCloseTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDayModel();
  }
}

// BodaBrief TABLE
class TableBodaBrief extends SqfEntityTableBase {
  TableBodaBrief() {
    // declare properties of EntityTable
    tableName = 'bodaBrief';
    primaryKeyName = 'BodaGeneratedDate';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BodaGeneratedTime', DbType.text),
      SqfEntityFieldBase('OpeningBalance', DbType.text),
      SqfEntityFieldBase('ClosingBalance', DbType.text),
      SqfEntityFieldBase('BodaNumber', DbType.text),
      SqfEntityFieldBase('MailsAmount', DbType.text),
      SqfEntityFieldBase('TotalReceiptsAmount', DbType.text),
      SqfEntityFieldBase('CashToAOAmount', DbType.text),
      SqfEntityFieldBase('InsuranceAmount', DbType.text),
      SqfEntityFieldBase('BankingAmount', DbType.text),
      SqfEntityFieldBase('InventoryAmount', DbType.text),
      SqfEntityFieldBase('LiabilitiesAmount', DbType.text),
      SqfEntityFieldBase('CashIndentAmount', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBodaBrief();
  }
}

// BodaArticle TABLE
class TableBodaArticle extends SqfEntityTableBase {
  TableBodaArticle() {
    // declare properties of EntityTable
    tableName = 'bodaArticles';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ArticleType', DbType.text),
      SqfEntityFieldBase('ArticleAmount', DbType.text),
      SqfEntityFieldBase('BodaDate', DbType.text),
      SqfEntityFieldBase('BodaTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBodaArticle();
  }
}

// BodaInventory TABLE
class TableBodaInventory extends SqfEntityTableBase {
  TableBodaInventory() {
    // declare properties of EntityTable
    tableName = 'bodaInventory';
    primaryKeyName = 'inventoryid';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('InventoryName', DbType.text),
      SqfEntityFieldBase('InventoryQuantity', DbType.text),
      SqfEntityFieldBase('InventoryPrice', DbType.text),
      SqfEntityFieldBase('InventoryDate', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBodaInventory();
  }
}

// BodaInsurance TABLE
class TableBodaInsurance extends SqfEntityTableBase {
  TableBodaInsurance() {
    // declare properties of EntityTable
    tableName = 'bodaInsurance';
    primaryKeyName = 'InsuranceId';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('PolicyNumber', DbType.text),
      SqfEntityFieldBase('PolicyType', DbType.text),
      SqfEntityFieldBase('PolicyAmount', DbType.text),
      SqfEntityFieldBase('PolicyDate', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBodaInsurance();
  }
}

// BillData TABLE
class TableBillData extends SqfEntityTableBase {
  TableBillData() {
    // declare properties of EntityTable
    tableName = 'billData';
    primaryKeyName = 'BillId';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BillName', DbType.text),
      SqfEntityFieldBase('BillCode', DbType.text),
      SqfEntityFieldBase('BillAccountNumber', DbType.text),
      SqfEntityFieldBase('BillDate', DbType.text),
      SqfEntityFieldBase('BillPayableAmount', DbType.text),
      SqfEntityFieldBase('BillCollectedAmount', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBillData();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class BookingModel extends SqfEntityModelProvider {
  BookingModel() {
    databaseName = bookingModel.databaseName;
    password = bookingModel.password;
    dbVersion = bookingModel.dbVersion;
    preSaveAction = bookingModel.preSaveAction;
    logFunction = bookingModel.logFunction;
    databaseTables = [
      TableArticleType.getInstance,
      TableParcelBooking.getInstance,
      TableProductSaleTable.getInstance,
      TableInventoryDailyTable.getInstance,
      TableLiability.getInstance,
      TableTempLiability.getInstance,
      TableBodaSlip.getInstance,
      TableLetterBooking.getInstance,
      TableEmoBooking.getInstance,
      TableSpeedBooking.getInstance,
      TableProductsMaster.getInstance,
      TableEmoMOCommission.getInstance,
      TableInsMOCommission.getInstance,
      TableVppMOCommission.getInstance,
      TableDistanceMaster.getInstance,
      TableTaxMaster.getInstance,
      TableTariffMaster.getInstance,
      TableServiceMaster.getInstance,
      TableWeightMaster.getInstance,
      TableLeaveBalanceTable.getInstance,
      TableCashIndentTable.getInstance,
      TableSpecialRemittanceTable.getInstance,
      TableExcessCashTable.getInstance,
      TableSetUpInventoryTable.getInstance,
      TableLocalStoreTable.getInstance,
      TableAdditionalServiceMappingTable.getInstance,
      TableSwitchOnTable.getInstance,
      TableDayBegin.getInstance,
      TableCashIndent.getInstance,
      TableCancelBooking.getInstance,
      TableCancelBiller.getInstance,
      TableSwitchOnAcknowledge.getInstance,
      TableSwitchOnAcknowledgement.getInstance,
      TableBillerData.getInstance,
      TableSpecialRemittanceFile.getInstance,
      TableBillFile.getInstance,
      TableDayModel.getInstance,
      TableBodaBrief.getInstance,
      TableBodaArticle.getInstance,
      TableBodaInventory.getInstance,
      TableBodaInsurance.getInstance,
      TableBillData.getInstance,
    ];

    bundledDatabasePath = bookingModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = bookingModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region ArticleType
class ArticleType extends TableBase {
  ArticleType(
      {this.Article_Prefix_Code,
      this.Article_Category_Name,
      this.Article_Used_Word}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ArticleType.withFields(this.Article_Prefix_Code, this.Article_Category_Name,
      this.Article_Used_Word) {
    _setDefaultValues();
  }
  ArticleType.withId(this.Article_Prefix_Code, this.Article_Category_Name,
      this.Article_Used_Word) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ArticleType.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Article_Prefix_Code = o['Article_Prefix_Code'].toString();
    if (o['Article_Category_Name'] != null) {
      Article_Category_Name = o['Article_Category_Name'].toString();
    }
    if (o['Article_Used_Word'] != null) {
      Article_Used_Word = o['Article_Used_Word'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ArticleType)
  String? Article_Prefix_Code;
  String? Article_Category_Name;
  String? Article_Used_Word;
  bool? isSaved;
  // end FIELDS (ArticleType)

  static const bool _softDeleteActivated = false;
  ArticleTypeManager? __mnArticleType;

  ArticleTypeManager get _mnArticleType {
    return __mnArticleType = __mnArticleType ?? ArticleTypeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Article_Prefix_Code'] = Article_Prefix_Code;
    if (Article_Category_Name != null || !forView) {
      map['Article_Category_Name'] = Article_Category_Name;
    }
    if (Article_Used_Word != null || !forView) {
      map['Article_Used_Word'] = Article_Used_Word;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Article_Prefix_Code'] = Article_Prefix_Code;
    if (Article_Category_Name != null || !forView) {
      map['Article_Category_Name'] = Article_Category_Name;
    }
    if (Article_Used_Word != null || !forView) {
      map['Article_Used_Word'] = Article_Used_Word;
    }

    return map;
  }

  /// This method returns Json String [ArticleType]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ArticleType]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Article_Prefix_Code, Article_Category_Name, Article_Used_Word];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Article_Prefix_Code, Article_Category_Name, Article_Used_Word];
  }

  static Future<List<ArticleType>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArticleType.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ArticleType>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ArticleType>[];
    try {
      objList = list
          .map((articletype) =>
              ArticleType.fromMap(articletype as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ArticleType.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ArticleType>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ArticleType> objList = <ArticleType>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ArticleType.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ArticleType by ID if exist, otherwise returns null
  /// Primary Keys: String? Article_Prefix_Code
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ArticleType] if exist, otherwise returns null
  Future<ArticleType?> getById(String? Article_Prefix_Code,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Article_Prefix_Code == null) {
      return null;
    }
    ArticleType? obj;
    final data = await _mnArticleType.getById([Article_Prefix_Code]);
    if (data.length != 0) {
      obj = ArticleType.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ArticleType) object. If the Primary Key (Article_Prefix_Code) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Article_Prefix_Code
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnArticleType.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO ArticleTypes (Article_Prefix_Code, Article_Category_Name, Article_Used_Word)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ArticleType> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ArticleType> articletypes,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in articletypes) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArticleType.rawInsert(
          'INSERT OR REPLACE INTO ArticleTypes (Article_Prefix_Code, Article_Category_Name, Article_Used_Word)  VALUES (?,?,?)',
          [Article_Prefix_Code, Article_Category_Name, Article_Used_Word],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArticleType Article_Prefix_Code=$Article_Prefix_Code updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ArticleType Article_Prefix_Code=$Article_Prefix_Code did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArticleType Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnArticleType.rawInsert(
          'INSERT OR IGNORE INTO ArticleTypes (Article_Prefix_Code, Article_Category_Name, Article_Used_Word)  VALUES (?,?,?)',
          [Article_Prefix_Code, Article_Category_Name, Article_Used_Word],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ArticleType Article_Prefix_Code=$Article_Prefix_Code updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ArticleType Article_Prefix_Code=$Article_Prefix_Code did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ArticleType Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ArticleType

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ArticleType invoked (Article_Prefix_Code=$Article_Prefix_Code)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnArticleType.delete(QueryParams(
          whereString: 'Article_Prefix_Code=?',
          whereArguments: [Article_Prefix_Code]));
    } else {
      return _mnArticleType.updateBatch(
          QueryParams(
              whereString: 'Article_Prefix_Code=?',
              whereArguments: [Article_Prefix_Code]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ArticleType] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ArticleTypeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArticleTypeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ArticleTypeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ArticleTypeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Article_Prefix_Code = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion articletype

// region ArticleTypeField
class ArticleTypeField extends FilterBase {
  ArticleTypeField(ArticleTypeFilterBuilder articletypeFB)
      : super(articletypeFB);

  @override
  ArticleTypeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder isNull() {
    return super.isNull() as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ArticleTypeFilterBuilder;
  }

  @override
  ArticleTypeField get not {
    return super.not as ArticleTypeField;
  }
}
// endregion ArticleTypeField

// region ArticleTypeFilterBuilder
class ArticleTypeFilterBuilder extends ConjunctionBase {
  ArticleTypeFilterBuilder(ArticleType obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnArticleType = obj._mnArticleType;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ArticleTypeManager? _mnArticleType;

  /// put the sql keyword 'AND'
  @override
  ArticleTypeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ArticleTypeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ArticleTypeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ArticleTypeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ArticleTypeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ArticleTypeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ArticleTypeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArticleTypeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArticleTypeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ArticleTypeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ArticleTypeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ArticleTypeField _setField(
      ArticleTypeField? field, String colName, DbType dbtype) {
    return ArticleTypeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ArticleTypeField? _Article_Prefix_Code;
  ArticleTypeField get Article_Prefix_Code {
    return _Article_Prefix_Code =
        _setField(_Article_Prefix_Code, 'Article_Prefix_Code', DbType.integer);
  }

  ArticleTypeField? _Article_Category_Name;
  ArticleTypeField get Article_Category_Name {
    return _Article_Category_Name =
        _setField(_Article_Category_Name, 'Article_Category_Name', DbType.text);
  }

  ArticleTypeField? _Article_Used_Word;
  ArticleTypeField get Article_Used_Word {
    return _Article_Used_Word =
        _setField(_Article_Used_Word, 'Article_Used_Word', DbType.text);
  }

  /// Deletes List<ArticleType> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnArticleType!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnArticleType!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Article_Prefix_Code IN (SELECT Article_Prefix_Code from ArticleTypes ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnArticleType!.updateBatch(qparams, values);
  }

  /// This method always returns [ArticleType] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArticleType?
  @override
  Future<ArticleType?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnArticleType!.toList(qparams);
    final data = await objFuture;
    ArticleType? obj;
    if (data.isNotEmpty) {
      obj = ArticleType.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ArticleType]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ArticleType?
  @override
  Future<ArticleType> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ArticleType();
  }

  /// This method returns int. [ArticleType]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? articletypeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final articletypesFuture = await _mnArticleType!.toList(qparams);
    final int count = articletypesFuture[0]['CNT'] as int;
    if (articletypeCount != null) {
      articletypeCount(count);
    }
    return count;
  }

  /// This method returns List<ArticleType> [ArticleType]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ArticleType>
  @override
  Future<List<ArticleType>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ArticleType> articletypesData = await ArticleType.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return articletypesData;
  }

  /// This method returns Json String [ArticleType]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ArticleType]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ArticleType]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnArticleType!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ArticleType]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Article_Prefix_Code` FROM ArticleTypes WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> Article_Prefix_CodeData = <String>[];
    qparams.selectColumns = ['Article_Prefix_Code'];
    final Article_Prefix_CodeFuture = await _mnArticleType!.toList(qparams);

    final int count = Article_Prefix_CodeFuture.length;
    for (int i = 0; i < count; i++) {
      Article_Prefix_CodeData.add(
          Article_Prefix_CodeFuture[i]['Article_Prefix_Code'] as String);
    }
    return Article_Prefix_CodeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ArticleType]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnArticleType!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ArticleType.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnArticleType!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ArticleTypeFilterBuilder

// region ArticleTypeFields
class ArticleTypeFields {
  static TableField? _fArticle_Prefix_Code;
  static TableField get Article_Prefix_Code {
    return _fArticle_Prefix_Code = _fArticle_Prefix_Code ??
        SqlSyntax.setField(
            _fArticle_Prefix_Code, 'article_prefix_code', DbType.integer);
  }

  static TableField? _fArticle_Category_Name;
  static TableField get Article_Category_Name {
    return _fArticle_Category_Name = _fArticle_Category_Name ??
        SqlSyntax.setField(
            _fArticle_Category_Name, 'Article_Category_Name', DbType.text);
  }

  static TableField? _fArticle_Used_Word;
  static TableField get Article_Used_Word {
    return _fArticle_Used_Word = _fArticle_Used_Word ??
        SqlSyntax.setField(
            _fArticle_Used_Word, 'Article_Used_Word', DbType.text);
  }
}
// endregion ArticleTypeFields

//region ArticleTypeManager
class ArticleTypeManager extends SqfEntityProvider {
  ArticleTypeManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ArticleTypes';
  static const List<String> _primaryKeyList = ['Article_Prefix_Code'];
  static const String _whereStr = 'Article_Prefix_Code=?';
}

//endregion ArticleTypeManager
// region ParcelBooking
class ParcelBooking extends TableBase {
  ParcelBooking(
      {this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.VAS,
      this.VASValue,
      this.IsAMS,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ParcelBooking.withFields(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.VAS,
      this.VASValue,
      this.IsAMS,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  ParcelBooking.withId(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.VAS,
      this.VASValue,
      this.IsAMS,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ParcelBooking.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserID'] != null) {
      UserID = o['UserID'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyID'] != null) {
      CurrencyID = o['CurrencyID'].toString();
    }
    if (o['TenderID'] != null) {
      TenderID = o['TenderID'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CheckerUserID'] != null) {
      CheckerUserID = o['CheckerUserID'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['WeightCode'] != null) {
      WeightCode = o['WeightCode'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerNumber'] != null) {
      SenderCustomerNumber = o['SenderCustomerNumber'].toString();
    }
    if (o['SenderName'] != null) {
      SenderName = o['SenderName'].toString();
    }
    if (o['SenderAddress'] != null) {
      SenderAddress = o['SenderAddress'].toString();
    }
    if (o['SenderCity'] != null) {
      SenderCity = o['SenderCity'].toString();
    }
    if (o['SenderState'] != null) {
      SenderState = o['SenderState'].toString();
    }
    if (o['SenderZip'] != null) {
      SenderZip = o['SenderZip'].toString();
    }
    if (o['SenderCountry'] != null) {
      SenderCountry = o['SenderCountry'].toString();
    }
    if (o['RecipientName'] != null) {
      RecipientName = o['RecipientName'].toString();
    }
    if (o['RecipientAddress'] != null) {
      RecipientAddress = o['RecipientAddress'].toString();
    }
    if (o['RecipientCity'] != null) {
      RecipientCity = o['RecipientCity'].toString();
    }
    if (o['RecipientState'] != null) {
      RecipientState = o['RecipientState'].toString();
    }
    if (o['RecipientZip'] != null) {
      RecipientZip = o['RecipientZip'].toString();
    }
    if (o['RecipientCountryID'] != null) {
      RecipientCountryID = o['RecipientCountryID'].toString();
    }
    if (o['RecipientMobile'] != null) {
      RecipientMobile = o['RecipientMobile'].toString();
    }
    if (o['RecipientEmail'] != null) {
      RecipientEmail = o['RecipientEmail'].toString();
    }
    if (o['ReturnName'] != null) {
      ReturnName = o['ReturnName'].toString();
    }
    if (o['ReturnAddress'] != null) {
      ReturnAddress = o['ReturnAddress'].toString();
    }
    if (o['ReturnCity'] != null) {
      ReturnCity = o['ReturnCity'].toString();
    }
    if (o['ReturnState'] != null) {
      ReturnState = o['ReturnState'].toString();
    }
    if (o['ReturnZip'] != null) {
      ReturnZip = o['ReturnZip'].toString();
    }
    if (o['ReturnCountryID'] != null) {
      ReturnCountryID = o['ReturnCountryID'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacility'] != null) {
      DestinationFacility = o['DestinationFacility'].toString();
    }
    if (o['TaxAmount'] != null) {
      TaxAmount = o['TaxAmount'].toString();
    }
    if (o['RepaymentMode'] != null) {
      RepaymentMode = o['RepaymentMode'].toString();
    }
    if (o['PostageDue'] != null) {
      PostageDue = o['PostageDue'].toString();
    }
    if (o['PrepaidAmount'] != null) {
      PrepaidAmount = o['PrepaidAmount'].toString();
    }
    if (o['VAS'] != null) {
      VAS = o['VAS'].toString();
    }
    if (o['VASValue'] != null) {
      VASValue = o['VASValue'].toString();
    }
    if (o['IsAMS'] != null) {
      IsAMS = o['IsAMS'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['IsFullPrepaid'] != null) {
      IsFullPrepaid = o['IsFullPrepaid'].toString();
    }
    if (o['IsOnPostalService'] != null) {
      IsOnPostalService = o['IsOnPostalService'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['CancellationReason'] != null) {
      CancellationReason = o['CancellationReason'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ParcelBooking)
  String? ArticleNumber;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserID;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyID;
  String? TenderID;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CheckerUserID;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? WeightCode;
  String? Weight;
  String? Quantity;
  String? SenderCustomerNumber;
  String? SenderName;
  String? SenderAddress;
  String? SenderCity;
  String? SenderState;
  String? SenderZip;
  String? SenderCountry;
  String? RecipientName;
  String? RecipientAddress;
  String? RecipientCity;
  String? RecipientState;
  String? RecipientZip;
  String? RecipientCountryID;
  String? RecipientMobile;
  String? RecipientEmail;
  String? ReturnName;
  String? ReturnAddress;
  String? ReturnCity;
  String? ReturnState;
  String? ReturnZip;
  String? ReturnCountryID;
  String? CommissionAmount;
  String? MaterialGroup;
  String? DestinationFacility;
  String? TaxAmount;
  String? RepaymentMode;
  String? PostageDue;
  String? PrepaidAmount;
  String? VAS;
  String? VASValue;
  String? IsAMS;
  String? ElapsedTime;
  String? IsFullPrepaid;
  String? IsOnPostalService;
  String? Status;
  String? BagNumber;
  String? FileCreated;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? CancellationReason;
  String? Authorized;
  bool? isSaved;
  // end FIELDS (ParcelBooking)

  static const bool _softDeleteActivated = false;
  ParcelBookingManager? __mnParcelBooking;

  ParcelBookingManager get _mnParcelBooking {
    return __mnParcelBooking = __mnParcelBooking ?? ParcelBookingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CheckerUserID != null || !forView) {
      map['CheckerUserID'] = CheckerUserID;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (IsAMS != null || !forView) {
      map['IsAMS'] = IsAMS;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (IsOnPostalService != null || !forView) {
      map['IsOnPostalService'] = IsOnPostalService;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CheckerUserID != null || !forView) {
      map['CheckerUserID'] = CheckerUserID;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (IsAMS != null || !forView) {
      map['IsAMS'] = IsAMS;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (IsOnPostalService != null || !forView) {
      map['IsOnPostalService'] = IsOnPostalService;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [ParcelBooking]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ParcelBooking]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CheckerUserID,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      MaterialGroup,
      DestinationFacility,
      TaxAmount,
      RepaymentMode,
      PostageDue,
      PrepaidAmount,
      VAS,
      VASValue,
      IsAMS,
      ElapsedTime,
      IsFullPrepaid,
      IsOnPostalService,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CheckerUserID,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      MaterialGroup,
      DestinationFacility,
      TaxAmount,
      RepaymentMode,
      PostageDue,
      PrepaidAmount,
      VAS,
      VASValue,
      IsAMS,
      ElapsedTime,
      IsFullPrepaid,
      IsOnPostalService,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  static Future<List<ParcelBooking>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ParcelBooking.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ParcelBooking>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ParcelBooking>[];
    try {
      objList = list
          .map((parcelbooking) =>
              ParcelBooking.fromMap(parcelbooking as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ParcelBooking.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ParcelBooking>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ParcelBooking> objList = <ParcelBooking>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ParcelBooking.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ParcelBooking by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ParcelBooking] if exist, otherwise returns null
  Future<ParcelBooking?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    ParcelBooking? obj;
    final data = await _mnParcelBooking.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = ParcelBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ParcelBooking) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnParcelBooking.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO parcelBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, MaterialGroup, DestinationFacility, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, VAS, VASValue, IsAMS, ElapsedTime, IsFullPrepaid, IsOnPostalService, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ParcelBooking> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ParcelBooking> parcelbookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in parcelbookings) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnParcelBooking.rawInsert(
          'INSERT OR REPLACE INTO parcelBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, MaterialGroup, DestinationFacility, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, VAS, VASValue, IsAMS, ElapsedTime, IsFullPrepaid, IsOnPostalService, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CheckerUserID,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            MaterialGroup,
            DestinationFacility,
            TaxAmount,
            RepaymentMode,
            PostageDue,
            PrepaidAmount,
            VAS,
            VASValue,
            IsAMS,
            ElapsedTime,
            IsFullPrepaid,
            IsOnPostalService,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ParcelBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ParcelBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ParcelBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnParcelBooking.rawInsert(
          'INSERT OR IGNORE INTO parcelBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, MaterialGroup, DestinationFacility, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, VAS, VASValue, IsAMS, ElapsedTime, IsFullPrepaid, IsOnPostalService, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CheckerUserID,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            MaterialGroup,
            DestinationFacility,
            TaxAmount,
            RepaymentMode,
            PostageDue,
            PrepaidAmount,
            VAS,
            VASValue,
            IsAMS,
            ElapsedTime,
            IsFullPrepaid,
            IsOnPostalService,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ParcelBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'ParcelBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ParcelBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ParcelBooking

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ParcelBooking invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnParcelBooking.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnParcelBooking.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ParcelBooking] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ParcelBookingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ParcelBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ParcelBookingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ParcelBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion parcelbooking

// region ParcelBookingField
class ParcelBookingField extends FilterBase {
  ParcelBookingField(ParcelBookingFilterBuilder parcelbookingFB)
      : super(parcelbookingFB);

  @override
  ParcelBookingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder isNull() {
    return super.isNull() as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ParcelBookingFilterBuilder;
  }

  @override
  ParcelBookingField get not {
    return super.not as ParcelBookingField;
  }
}
// endregion ParcelBookingField

// region ParcelBookingFilterBuilder
class ParcelBookingFilterBuilder extends ConjunctionBase {
  ParcelBookingFilterBuilder(ParcelBooking obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnParcelBooking = obj._mnParcelBooking;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ParcelBookingManager? _mnParcelBooking;

  /// put the sql keyword 'AND'
  @override
  ParcelBookingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ParcelBookingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ParcelBookingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ParcelBookingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ParcelBookingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ParcelBookingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ParcelBookingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ParcelBookingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ParcelBookingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ParcelBookingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ParcelBookingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ParcelBookingField _setField(
      ParcelBookingField? field, String colName, DbType dbtype) {
    return ParcelBookingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ParcelBookingField? _ArticleNumber;
  ParcelBookingField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  ParcelBookingField? _FacilityId;
  ParcelBookingField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  ParcelBookingField? _BookingFacilityZip;
  ParcelBookingField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  ParcelBookingField? _DistributionChannel;
  ParcelBookingField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  ParcelBookingField? _UserID;
  ParcelBookingField get UserID {
    return _UserID = _setField(_UserID, 'UserID', DbType.text);
  }

  ParcelBookingField? _CounterNumber;
  ParcelBookingField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  ParcelBookingField? _InvoiceNumber;
  ParcelBookingField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  ParcelBookingField? _TotalAmount;
  ParcelBookingField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  ParcelBookingField? _BookingDate;
  ParcelBookingField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  ParcelBookingField? _BookingTime;
  ParcelBookingField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  ParcelBookingField? _CurrencyID;
  ParcelBookingField get CurrencyID {
    return _CurrencyID = _setField(_CurrencyID, 'CurrencyID', DbType.text);
  }

  ParcelBookingField? _TenderID;
  ParcelBookingField get TenderID {
    return _TenderID = _setField(_TenderID, 'TenderID', DbType.text);
  }

  ParcelBookingField? _TotalCashAmount;
  ParcelBookingField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  ParcelBookingField? _RoundOffDifference;
  ParcelBookingField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  ParcelBookingField? _CheckerUserID;
  ParcelBookingField get CheckerUserID {
    return _CheckerUserID =
        _setField(_CheckerUserID, 'CheckerUserID', DbType.text);
  }

  ParcelBookingField? _CircleCode;
  ParcelBookingField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  ParcelBookingField? _LineItemNumber;
  ParcelBookingField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  ParcelBookingField? _BasePrice;
  ParcelBookingField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  ParcelBookingField? _LineItemTotalAmount;
  ParcelBookingField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  ParcelBookingField? _Division;
  ParcelBookingField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  ParcelBookingField? _OrderType;
  ParcelBookingField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  ParcelBookingField? _ProductType;
  ParcelBookingField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  ParcelBookingField? _ProductCode;
  ParcelBookingField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  ParcelBookingField? _WeightCode;
  ParcelBookingField get WeightCode {
    return _WeightCode = _setField(_WeightCode, 'WeightCode', DbType.text);
  }

  ParcelBookingField? _Weight;
  ParcelBookingField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  ParcelBookingField? _Quantity;
  ParcelBookingField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  ParcelBookingField? _SenderCustomerNumber;
  ParcelBookingField get SenderCustomerNumber {
    return _SenderCustomerNumber =
        _setField(_SenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  ParcelBookingField? _SenderName;
  ParcelBookingField get SenderName {
    return _SenderName = _setField(_SenderName, 'SenderName', DbType.text);
  }

  ParcelBookingField? _SenderAddress;
  ParcelBookingField get SenderAddress {
    return _SenderAddress =
        _setField(_SenderAddress, 'SenderAddress', DbType.text);
  }

  ParcelBookingField? _SenderCity;
  ParcelBookingField get SenderCity {
    return _SenderCity = _setField(_SenderCity, 'SenderCity', DbType.text);
  }

  ParcelBookingField? _SenderState;
  ParcelBookingField get SenderState {
    return _SenderState = _setField(_SenderState, 'SenderState', DbType.text);
  }

  ParcelBookingField? _SenderZip;
  ParcelBookingField get SenderZip {
    return _SenderZip = _setField(_SenderZip, 'SenderZip', DbType.text);
  }

  ParcelBookingField? _SenderCountry;
  ParcelBookingField get SenderCountry {
    return _SenderCountry =
        _setField(_SenderCountry, 'SenderCountry', DbType.text);
  }

  ParcelBookingField? _RecipientName;
  ParcelBookingField get RecipientName {
    return _RecipientName =
        _setField(_RecipientName, 'RecipientName', DbType.text);
  }

  ParcelBookingField? _RecipientAddress;
  ParcelBookingField get RecipientAddress {
    return _RecipientAddress =
        _setField(_RecipientAddress, 'RecipientAddress', DbType.text);
  }

  ParcelBookingField? _RecipientCity;
  ParcelBookingField get RecipientCity {
    return _RecipientCity =
        _setField(_RecipientCity, 'RecipientCity', DbType.text);
  }

  ParcelBookingField? _RecipientState;
  ParcelBookingField get RecipientState {
    return _RecipientState =
        _setField(_RecipientState, 'RecipientState', DbType.text);
  }

  ParcelBookingField? _RecipientZip;
  ParcelBookingField get RecipientZip {
    return _RecipientZip =
        _setField(_RecipientZip, 'RecipientZip', DbType.text);
  }

  ParcelBookingField? _RecipientCountryID;
  ParcelBookingField get RecipientCountryID {
    return _RecipientCountryID =
        _setField(_RecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  ParcelBookingField? _RecipientMobile;
  ParcelBookingField get RecipientMobile {
    return _RecipientMobile =
        _setField(_RecipientMobile, 'RecipientMobile', DbType.text);
  }

  ParcelBookingField? _RecipientEmail;
  ParcelBookingField get RecipientEmail {
    return _RecipientEmail =
        _setField(_RecipientEmail, 'RecipientEmail', DbType.text);
  }

  ParcelBookingField? _ReturnName;
  ParcelBookingField get ReturnName {
    return _ReturnName = _setField(_ReturnName, 'ReturnName', DbType.text);
  }

  ParcelBookingField? _ReturnAddress;
  ParcelBookingField get ReturnAddress {
    return _ReturnAddress =
        _setField(_ReturnAddress, 'ReturnAddress', DbType.text);
  }

  ParcelBookingField? _ReturnCity;
  ParcelBookingField get ReturnCity {
    return _ReturnCity = _setField(_ReturnCity, 'ReturnCity', DbType.text);
  }

  ParcelBookingField? _ReturnState;
  ParcelBookingField get ReturnState {
    return _ReturnState = _setField(_ReturnState, 'ReturnState', DbType.text);
  }

  ParcelBookingField? _ReturnZip;
  ParcelBookingField get ReturnZip {
    return _ReturnZip = _setField(_ReturnZip, 'ReturnZip', DbType.text);
  }

  ParcelBookingField? _ReturnCountryID;
  ParcelBookingField get ReturnCountryID {
    return _ReturnCountryID =
        _setField(_ReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  ParcelBookingField? _CommissionAmount;
  ParcelBookingField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  ParcelBookingField? _MaterialGroup;
  ParcelBookingField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  ParcelBookingField? _DestinationFacility;
  ParcelBookingField get DestinationFacility {
    return _DestinationFacility =
        _setField(_DestinationFacility, 'DestinationFacility', DbType.text);
  }

  ParcelBookingField? _TaxAmount;
  ParcelBookingField get TaxAmount {
    return _TaxAmount = _setField(_TaxAmount, 'TaxAmount', DbType.text);
  }

  ParcelBookingField? _RepaymentMode;
  ParcelBookingField get RepaymentMode {
    return _RepaymentMode =
        _setField(_RepaymentMode, 'RepaymentMode', DbType.text);
  }

  ParcelBookingField? _PostageDue;
  ParcelBookingField get PostageDue {
    return _PostageDue = _setField(_PostageDue, 'PostageDue', DbType.text);
  }

  ParcelBookingField? _PrepaidAmount;
  ParcelBookingField get PrepaidAmount {
    return _PrepaidAmount =
        _setField(_PrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  ParcelBookingField? _VAS;
  ParcelBookingField get VAS {
    return _VAS = _setField(_VAS, 'VAS', DbType.text);
  }

  ParcelBookingField? _VASValue;
  ParcelBookingField get VASValue {
    return _VASValue = _setField(_VASValue, 'VASValue', DbType.text);
  }

  ParcelBookingField? _IsAMS;
  ParcelBookingField get IsAMS {
    return _IsAMS = _setField(_IsAMS, 'IsAMS', DbType.text);
  }

  ParcelBookingField? _ElapsedTime;
  ParcelBookingField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  ParcelBookingField? _IsFullPrepaid;
  ParcelBookingField get IsFullPrepaid {
    return _IsFullPrepaid =
        _setField(_IsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  ParcelBookingField? _IsOnPostalService;
  ParcelBookingField get IsOnPostalService {
    return _IsOnPostalService =
        _setField(_IsOnPostalService, 'IsOnPostalService', DbType.text);
  }

  ParcelBookingField? _Status;
  ParcelBookingField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  ParcelBookingField? _BagNumber;
  ParcelBookingField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  ParcelBookingField? _FileCreated;
  ParcelBookingField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  ParcelBookingField? _FileName;
  ParcelBookingField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  ParcelBookingField? _FileCreatedDateTime;
  ParcelBookingField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  ParcelBookingField? _FileTransmitted;
  ParcelBookingField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  ParcelBookingField? _FileTransmittedDateTime;
  ParcelBookingField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  ParcelBookingField? _CancellationReason;
  ParcelBookingField get CancellationReason {
    return _CancellationReason =
        _setField(_CancellationReason, 'CancellationReason', DbType.text);
  }

  ParcelBookingField? _Authorized;
  ParcelBookingField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<ParcelBooking> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnParcelBooking!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnParcelBooking!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from parcelBooking ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnParcelBooking!.updateBatch(qparams, values);
  }

  /// This method always returns [ParcelBooking] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ParcelBooking?
  @override
  Future<ParcelBooking?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnParcelBooking!.toList(qparams);
    final data = await objFuture;
    ParcelBooking? obj;
    if (data.isNotEmpty) {
      obj = ParcelBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ParcelBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ParcelBooking?
  @override
  Future<ParcelBooking> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ParcelBooking();
  }

  /// This method returns int. [ParcelBooking]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? parcelbookingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final parcelbookingsFuture = await _mnParcelBooking!.toList(qparams);
    final int count = parcelbookingsFuture[0]['CNT'] as int;
    if (parcelbookingCount != null) {
      parcelbookingCount(count);
    }
    return count;
  }

  /// This method returns List<ParcelBooking> [ParcelBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ParcelBooking>
  @override
  Future<List<ParcelBooking>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ParcelBooking> parcelbookingsData =
        await ParcelBooking.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return parcelbookingsData;
  }

  /// This method returns Json String [ParcelBooking]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ParcelBooking]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ParcelBooking]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnParcelBooking!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ParcelBooking]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM parcelBooking WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnParcelBooking!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ParcelBooking]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnParcelBooking!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ParcelBooking.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnParcelBooking!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ParcelBookingFilterBuilder

// region ParcelBookingFields
class ParcelBookingFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserID;
  static TableField get UserID {
    return _fUserID =
        _fUserID ?? SqlSyntax.setField(_fUserID, 'UserID', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyID;
  static TableField get CurrencyID {
    return _fCurrencyID = _fCurrencyID ??
        SqlSyntax.setField(_fCurrencyID, 'CurrencyID', DbType.text);
  }

  static TableField? _fTenderID;
  static TableField get TenderID {
    return _fTenderID =
        _fTenderID ?? SqlSyntax.setField(_fTenderID, 'TenderID', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCheckerUserID;
  static TableField get CheckerUserID {
    return _fCheckerUserID = _fCheckerUserID ??
        SqlSyntax.setField(_fCheckerUserID, 'CheckerUserID', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fWeightCode;
  static TableField get WeightCode {
    return _fWeightCode = _fWeightCode ??
        SqlSyntax.setField(_fWeightCode, 'WeightCode', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerNumber;
  static TableField get SenderCustomerNumber {
    return _fSenderCustomerNumber = _fSenderCustomerNumber ??
        SqlSyntax.setField(
            _fSenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  static TableField? _fSenderName;
  static TableField get SenderName {
    return _fSenderName = _fSenderName ??
        SqlSyntax.setField(_fSenderName, 'SenderName', DbType.text);
  }

  static TableField? _fSenderAddress;
  static TableField get SenderAddress {
    return _fSenderAddress = _fSenderAddress ??
        SqlSyntax.setField(_fSenderAddress, 'SenderAddress', DbType.text);
  }

  static TableField? _fSenderCity;
  static TableField get SenderCity {
    return _fSenderCity = _fSenderCity ??
        SqlSyntax.setField(_fSenderCity, 'SenderCity', DbType.text);
  }

  static TableField? _fSenderState;
  static TableField get SenderState {
    return _fSenderState = _fSenderState ??
        SqlSyntax.setField(_fSenderState, 'SenderState', DbType.text);
  }

  static TableField? _fSenderZip;
  static TableField get SenderZip {
    return _fSenderZip = _fSenderZip ??
        SqlSyntax.setField(_fSenderZip, 'SenderZip', DbType.text);
  }

  static TableField? _fSenderCountry;
  static TableField get SenderCountry {
    return _fSenderCountry = _fSenderCountry ??
        SqlSyntax.setField(_fSenderCountry, 'SenderCountry', DbType.text);
  }

  static TableField? _fRecipientName;
  static TableField get RecipientName {
    return _fRecipientName = _fRecipientName ??
        SqlSyntax.setField(_fRecipientName, 'RecipientName', DbType.text);
  }

  static TableField? _fRecipientAddress;
  static TableField get RecipientAddress {
    return _fRecipientAddress = _fRecipientAddress ??
        SqlSyntax.setField(_fRecipientAddress, 'RecipientAddress', DbType.text);
  }

  static TableField? _fRecipientCity;
  static TableField get RecipientCity {
    return _fRecipientCity = _fRecipientCity ??
        SqlSyntax.setField(_fRecipientCity, 'RecipientCity', DbType.text);
  }

  static TableField? _fRecipientState;
  static TableField get RecipientState {
    return _fRecipientState = _fRecipientState ??
        SqlSyntax.setField(_fRecipientState, 'RecipientState', DbType.text);
  }

  static TableField? _fRecipientZip;
  static TableField get RecipientZip {
    return _fRecipientZip = _fRecipientZip ??
        SqlSyntax.setField(_fRecipientZip, 'RecipientZip', DbType.text);
  }

  static TableField? _fRecipientCountryID;
  static TableField get RecipientCountryID {
    return _fRecipientCountryID = _fRecipientCountryID ??
        SqlSyntax.setField(
            _fRecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  static TableField? _fRecipientMobile;
  static TableField get RecipientMobile {
    return _fRecipientMobile = _fRecipientMobile ??
        SqlSyntax.setField(_fRecipientMobile, 'RecipientMobile', DbType.text);
  }

  static TableField? _fRecipientEmail;
  static TableField get RecipientEmail {
    return _fRecipientEmail = _fRecipientEmail ??
        SqlSyntax.setField(_fRecipientEmail, 'RecipientEmail', DbType.text);
  }

  static TableField? _fReturnName;
  static TableField get ReturnName {
    return _fReturnName = _fReturnName ??
        SqlSyntax.setField(_fReturnName, 'ReturnName', DbType.text);
  }

  static TableField? _fReturnAddress;
  static TableField get ReturnAddress {
    return _fReturnAddress = _fReturnAddress ??
        SqlSyntax.setField(_fReturnAddress, 'ReturnAddress', DbType.text);
  }

  static TableField? _fReturnCity;
  static TableField get ReturnCity {
    return _fReturnCity = _fReturnCity ??
        SqlSyntax.setField(_fReturnCity, 'ReturnCity', DbType.text);
  }

  static TableField? _fReturnState;
  static TableField get ReturnState {
    return _fReturnState = _fReturnState ??
        SqlSyntax.setField(_fReturnState, 'ReturnState', DbType.text);
  }

  static TableField? _fReturnZip;
  static TableField get ReturnZip {
    return _fReturnZip = _fReturnZip ??
        SqlSyntax.setField(_fReturnZip, 'ReturnZip', DbType.text);
  }

  static TableField? _fReturnCountryID;
  static TableField get ReturnCountryID {
    return _fReturnCountryID = _fReturnCountryID ??
        SqlSyntax.setField(_fReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacility;
  static TableField get DestinationFacility {
    return _fDestinationFacility = _fDestinationFacility ??
        SqlSyntax.setField(
            _fDestinationFacility, 'DestinationFacility', DbType.text);
  }

  static TableField? _fTaxAmount;
  static TableField get TaxAmount {
    return _fTaxAmount = _fTaxAmount ??
        SqlSyntax.setField(_fTaxAmount, 'TaxAmount', DbType.text);
  }

  static TableField? _fRepaymentMode;
  static TableField get RepaymentMode {
    return _fRepaymentMode = _fRepaymentMode ??
        SqlSyntax.setField(_fRepaymentMode, 'RepaymentMode', DbType.text);
  }

  static TableField? _fPostageDue;
  static TableField get PostageDue {
    return _fPostageDue = _fPostageDue ??
        SqlSyntax.setField(_fPostageDue, 'PostageDue', DbType.text);
  }

  static TableField? _fPrepaidAmount;
  static TableField get PrepaidAmount {
    return _fPrepaidAmount = _fPrepaidAmount ??
        SqlSyntax.setField(_fPrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  static TableField? _fVAS;
  static TableField get VAS {
    return _fVAS = _fVAS ?? SqlSyntax.setField(_fVAS, 'VAS', DbType.text);
  }

  static TableField? _fVASValue;
  static TableField get VASValue {
    return _fVASValue =
        _fVASValue ?? SqlSyntax.setField(_fVASValue, 'VASValue', DbType.text);
  }

  static TableField? _fIsAMS;
  static TableField get IsAMS {
    return _fIsAMS =
        _fIsAMS ?? SqlSyntax.setField(_fIsAMS, 'IsAMS', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fIsFullPrepaid;
  static TableField get IsFullPrepaid {
    return _fIsFullPrepaid = _fIsFullPrepaid ??
        SqlSyntax.setField(_fIsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  static TableField? _fIsOnPostalService;
  static TableField get IsOnPostalService {
    return _fIsOnPostalService = _fIsOnPostalService ??
        SqlSyntax.setField(
            _fIsOnPostalService, 'IsOnPostalService', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fCancellationReason;
  static TableField get CancellationReason {
    return _fCancellationReason = _fCancellationReason ??
        SqlSyntax.setField(
            _fCancellationReason, 'CancellationReason', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion ParcelBookingFields

//region ParcelBookingManager
class ParcelBookingManager extends SqfEntityProvider {
  ParcelBookingManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'parcelBooking';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion ParcelBookingManager
// region ProductSaleTable
class ProductSaleTable extends TableBase {
  ProductSaleTable(
      {this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.Quantity,
      this.SenderCustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.UoM,
      this.ElapsedTime,
      this.FileCreated,
      this.FileCreatedDate,
      this.FileName,
      this.FileTransmitted,
      this.FileTransmittedDate,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ProductSaleTable.withFields(
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.Quantity,
      this.SenderCustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.UoM,
      this.ElapsedTime,
      this.FileCreated,
      this.FileCreatedDate,
      this.FileName,
      this.FileTransmitted,
      this.FileTransmittedDate,
      this.Authorized) {
    _setDefaultValues();
  }
  ProductSaleTable.withId(
      this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.Quantity,
      this.SenderCustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.UoM,
      this.ElapsedTime,
      this.FileCreated,
      this.FileCreatedDate,
      this.FileName,
      this.FileTransmitted,
      this.FileTransmittedDate,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ProductSaleTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserId'] != null) {
      UserId = o['UserId'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyId'] != null) {
      CurrencyId = o['CurrencyId'].toString();
    }
    if (o['TenderId'] != null) {
      TenderId = o['TenderId'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerId'] != null) {
      SenderCustomerId = o['SenderCustomerId'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacilityId'] != null) {
      DestinationFacilityId = o['DestinationFacilityId'].toString();
    }
    if (o['UoM'] != null) {
      UoM = o['UoM'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileCreatedDate'] != null) {
      FileCreatedDate = o['FileCreatedDate'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDate'] != null) {
      FileTransmittedDate = o['FileTransmittedDate'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }
  }
  // FIELDS (ProductSaleTable)
  int? id;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserId;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyId;
  String? TenderId;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? Quantity;
  String? SenderCustomerId;
  String? MaterialGroup;
  String? DestinationFacilityId;
  String? UoM;
  String? ElapsedTime;
  String? FileCreated;
  String? FileCreatedDate;
  String? FileName;
  String? FileTransmitted;
  String? FileTransmittedDate;
  String? Authorized;

  // end FIELDS (ProductSaleTable)

  static const bool _softDeleteActivated = false;
  ProductSaleTableManager? __mnProductSaleTable;

  ProductSaleTableManager get _mnProductSaleTable {
    return __mnProductSaleTable =
        __mnProductSaleTable ?? ProductSaleTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacilityId != null || !forView) {
      map['DestinationFacilityId'] = DestinationFacilityId;
    }
    if (UoM != null || !forView) {
      map['UoM'] = UoM;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDate != null || !forView) {
      map['FileCreatedDate'] = FileCreatedDate;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDate != null || !forView) {
      map['FileTransmittedDate'] = FileTransmittedDate;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacilityId != null || !forView) {
      map['DestinationFacilityId'] = DestinationFacilityId;
    }
    if (UoM != null || !forView) {
      map['UoM'] = UoM;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDate != null || !forView) {
      map['FileCreatedDate'] = FileCreatedDate;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDate != null || !forView) {
      map['FileTransmittedDate'] = FileTransmittedDate;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [ProductSaleTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ProductSaleTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      Quantity,
      SenderCustomerId,
      MaterialGroup,
      DestinationFacilityId,
      UoM,
      ElapsedTime,
      FileCreated,
      FileCreatedDate,
      FileName,
      FileTransmitted,
      FileTransmittedDate,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      Quantity,
      SenderCustomerId,
      MaterialGroup,
      DestinationFacilityId,
      UoM,
      ElapsedTime,
      FileCreated,
      FileCreatedDate,
      FileName,
      FileTransmitted,
      FileTransmittedDate,
      Authorized
    ];
  }

  static Future<List<ProductSaleTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductSaleTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ProductSaleTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ProductSaleTable>[];
    try {
      objList = list
          .map((productsaletable) => ProductSaleTable.fromMap(
              productsaletable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductSaleTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ProductSaleTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ProductSaleTable> objList = <ProductSaleTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ProductSaleTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ProductSaleTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ProductSaleTable] if exist, otherwise returns null
  Future<ProductSaleTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ProductSaleTable? obj;
    final data = await _mnProductSaleTable.getById([id]);
    if (data.length != 0) {
      obj = ProductSaleTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ProductSaleTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProductSaleTable.insert(this, ignoreBatch);
    } else {
      await _mnProductSaleTable.update(this);
    }

    return id;
  }

  /// Saves the (ProductSaleTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProductSaleTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProductSaleTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ProductSaleTable. Returns a new Primary Key value of ProductSaleTable

  /// <returns>Returns a new Primary Key value of ProductSaleTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ProductSaleTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ProductSaleTable> productsaletables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in productsaletables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < productsaletables.length; i++) {
        if (productsaletables[i].id == null) {
          productsaletables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductSaleTable.rawInsert(
          'INSERT OR REPLACE INTO ProductSaleTable (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, Quantity, SenderCustomerId, MaterialGroup, DestinationFacilityId, UoM, ElapsedTime, FileCreated, FileCreatedDate, FileName, FileTransmitted, FileTransmittedDate, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            Quantity,
            SenderCustomerId,
            MaterialGroup,
            DestinationFacilityId,
            UoM,
            ElapsedTime,
            FileCreated,
            FileCreatedDate,
            FileName,
            FileTransmitted,
            FileTransmittedDate,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ProductSaleTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductSaleTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductSaleTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductSaleTable.rawInsert(
          'INSERT OR IGNORE INTO ProductSaleTable (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, Quantity, SenderCustomerId, MaterialGroup, DestinationFacilityId, UoM, ElapsedTime, FileCreated, FileCreatedDate, FileName, FileTransmitted, FileTransmittedDate, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            Quantity,
            SenderCustomerId,
            MaterialGroup,
            DestinationFacilityId,
            UoM,
            ElapsedTime,
            FileCreated,
            FileCreatedDate,
            FileName,
            FileTransmitted,
            FileTransmittedDate,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ProductSaleTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductSaleTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductSaleTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ProductSaleTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ProductSaleTable> productsaletables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnProductSaleTable.rawInsertAll(
        'INSERT OR REPLACE INTO ProductSaleTable (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, Quantity, SenderCustomerId, MaterialGroup, DestinationFacilityId, UoM, ElapsedTime, FileCreated, FileCreatedDate, FileName, FileTransmitted, FileTransmittedDate, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        productsaletables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ProductSaleTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ProductSaleTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnProductSaleTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProductSaleTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ProductSaleTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ProductSaleTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductSaleTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProductSaleTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductSaleTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion productsaletable

// region ProductSaleTableField
class ProductSaleTableField extends FilterBase {
  ProductSaleTableField(ProductSaleTableFilterBuilder productsaletableFB)
      : super(productsaletableFB);

  @override
  ProductSaleTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder isNull() {
    return super.isNull() as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProductSaleTableFilterBuilder;
  }

  @override
  ProductSaleTableField get not {
    return super.not as ProductSaleTableField;
  }
}
// endregion ProductSaleTableField

// region ProductSaleTableFilterBuilder
class ProductSaleTableFilterBuilder extends ConjunctionBase {
  ProductSaleTableFilterBuilder(ProductSaleTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProductSaleTable = obj._mnProductSaleTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProductSaleTableManager? _mnProductSaleTable;

  /// put the sql keyword 'AND'
  @override
  ProductSaleTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProductSaleTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProductSaleTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProductSaleTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProductSaleTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProductSaleTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProductSaleTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductSaleTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductSaleTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductSaleTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductSaleTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProductSaleTableField _setField(
      ProductSaleTableField? field, String colName, DbType dbtype) {
    return ProductSaleTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProductSaleTableField? _id;
  ProductSaleTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ProductSaleTableField? _FacilityId;
  ProductSaleTableField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  ProductSaleTableField? _BookingFacilityZip;
  ProductSaleTableField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  ProductSaleTableField? _DistributionChannel;
  ProductSaleTableField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  ProductSaleTableField? _UserId;
  ProductSaleTableField get UserId {
    return _UserId = _setField(_UserId, 'UserId', DbType.text);
  }

  ProductSaleTableField? _CounterNumber;
  ProductSaleTableField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  ProductSaleTableField? _InvoiceNumber;
  ProductSaleTableField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  ProductSaleTableField? _TotalAmount;
  ProductSaleTableField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  ProductSaleTableField? _BookingDate;
  ProductSaleTableField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  ProductSaleTableField? _BookingTime;
  ProductSaleTableField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  ProductSaleTableField? _CurrencyId;
  ProductSaleTableField get CurrencyId {
    return _CurrencyId = _setField(_CurrencyId, 'CurrencyId', DbType.text);
  }

  ProductSaleTableField? _TenderId;
  ProductSaleTableField get TenderId {
    return _TenderId = _setField(_TenderId, 'TenderId', DbType.text);
  }

  ProductSaleTableField? _TotalCashAmount;
  ProductSaleTableField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  ProductSaleTableField? _RoundOffDifference;
  ProductSaleTableField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  ProductSaleTableField? _CircleCode;
  ProductSaleTableField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  ProductSaleTableField? _LineItemNumber;
  ProductSaleTableField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  ProductSaleTableField? _BasePrice;
  ProductSaleTableField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  ProductSaleTableField? _LineItemTotalAmount;
  ProductSaleTableField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  ProductSaleTableField? _Division;
  ProductSaleTableField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  ProductSaleTableField? _OrderType;
  ProductSaleTableField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  ProductSaleTableField? _ProductType;
  ProductSaleTableField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  ProductSaleTableField? _ProductCode;
  ProductSaleTableField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  ProductSaleTableField? _Quantity;
  ProductSaleTableField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  ProductSaleTableField? _SenderCustomerId;
  ProductSaleTableField get SenderCustomerId {
    return _SenderCustomerId =
        _setField(_SenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  ProductSaleTableField? _MaterialGroup;
  ProductSaleTableField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  ProductSaleTableField? _DestinationFacilityId;
  ProductSaleTableField get DestinationFacilityId {
    return _DestinationFacilityId =
        _setField(_DestinationFacilityId, 'DestinationFacilityId', DbType.text);
  }

  ProductSaleTableField? _UoM;
  ProductSaleTableField get UoM {
    return _UoM = _setField(_UoM, 'UoM', DbType.text);
  }

  ProductSaleTableField? _ElapsedTime;
  ProductSaleTableField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  ProductSaleTableField? _FileCreated;
  ProductSaleTableField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  ProductSaleTableField? _FileCreatedDate;
  ProductSaleTableField get FileCreatedDate {
    return _FileCreatedDate =
        _setField(_FileCreatedDate, 'FileCreatedDate', DbType.text);
  }

  ProductSaleTableField? _FileName;
  ProductSaleTableField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  ProductSaleTableField? _FileTransmitted;
  ProductSaleTableField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  ProductSaleTableField? _FileTransmittedDate;
  ProductSaleTableField get FileTransmittedDate {
    return _FileTransmittedDate =
        _setField(_FileTransmittedDate, 'FileTransmittedDate', DbType.text);
  }

  ProductSaleTableField? _Authorized;
  ProductSaleTableField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<ProductSaleTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProductSaleTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProductSaleTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from ProductSaleTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProductSaleTable!.updateBatch(qparams, values);
  }

  /// This method always returns [ProductSaleTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductSaleTable?
  @override
  Future<ProductSaleTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProductSaleTable!.toList(qparams);
    final data = await objFuture;
    ProductSaleTable? obj;
    if (data.isNotEmpty) {
      obj = ProductSaleTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ProductSaleTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductSaleTable?
  @override
  Future<ProductSaleTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ProductSaleTable();
  }

  /// This method returns int. [ProductSaleTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? productsaletableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productsaletablesFuture = await _mnProductSaleTable!.toList(qparams);
    final int count = productsaletablesFuture[0]['CNT'] as int;
    if (productsaletableCount != null) {
      productsaletableCount(count);
    }
    return count;
  }

  /// This method returns List<ProductSaleTable> [ProductSaleTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ProductSaleTable>
  @override
  Future<List<ProductSaleTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ProductSaleTable> productsaletablesData =
        await ProductSaleTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return productsaletablesData;
  }

  /// This method returns Json String [ProductSaleTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ProductSaleTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ProductSaleTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProductSaleTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ProductSaleTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM ProductSaleTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnProductSaleTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ProductSaleTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProductSaleTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ProductSaleTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProductSaleTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductSaleTableFilterBuilder

// region ProductSaleTableFields
class ProductSaleTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserId;
  static TableField get UserId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'UserId', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyId;
  static TableField get CurrencyId {
    return _fCurrencyId = _fCurrencyId ??
        SqlSyntax.setField(_fCurrencyId, 'CurrencyId', DbType.text);
  }

  static TableField? _fTenderId;
  static TableField get TenderId {
    return _fTenderId =
        _fTenderId ?? SqlSyntax.setField(_fTenderId, 'TenderId', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerId;
  static TableField get SenderCustomerId {
    return _fSenderCustomerId = _fSenderCustomerId ??
        SqlSyntax.setField(_fSenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacilityId;
  static TableField get DestinationFacilityId {
    return _fDestinationFacilityId = _fDestinationFacilityId ??
        SqlSyntax.setField(
            _fDestinationFacilityId, 'DestinationFacilityId', DbType.text);
  }

  static TableField? _fUoM;
  static TableField get UoM {
    return _fUoM = _fUoM ?? SqlSyntax.setField(_fUoM, 'UoM', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileCreatedDate;
  static TableField get FileCreatedDate {
    return _fFileCreatedDate = _fFileCreatedDate ??
        SqlSyntax.setField(_fFileCreatedDate, 'FileCreatedDate', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDate;
  static TableField get FileTransmittedDate {
    return _fFileTransmittedDate = _fFileTransmittedDate ??
        SqlSyntax.setField(
            _fFileTransmittedDate, 'FileTransmittedDate', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion ProductSaleTableFields

//region ProductSaleTableManager
class ProductSaleTableManager extends SqfEntityProvider {
  ProductSaleTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ProductSaleTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProductSaleTableManager
// region InventoryDailyTable
class InventoryDailyTable extends TableBase {
  InventoryDailyTable(
      {this.InventoryId,
      this.StampName,
      this.Price,
      this.RecordedDate,
      this.OpeningQuantity,
      this.OpeningValue,
      this.ClosingQuantity,
      this.ClosingValue}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  InventoryDailyTable.withFields(
      this.InventoryId,
      this.StampName,
      this.Price,
      this.RecordedDate,
      this.OpeningQuantity,
      this.OpeningValue,
      this.ClosingQuantity,
      this.ClosingValue) {
    _setDefaultValues();
  }
  InventoryDailyTable.withId(
      this.InventoryId,
      this.StampName,
      this.Price,
      this.RecordedDate,
      this.OpeningQuantity,
      this.OpeningValue,
      this.ClosingQuantity,
      this.ClosingValue) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InventoryDailyTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InventoryId = o['InventoryId'].toString();
    if (o['StampName'] != null) {
      StampName = o['StampName'].toString();
    }
    if (o['Price'] != null) {
      Price = o['Price'].toString();
    }
    if (o['RecordedDate'] != null) {
      RecordedDate = o['RecordedDate'].toString();
    }
    if (o['OpeningQuantity'] != null) {
      OpeningQuantity = o['OpeningQuantity'].toString();
    }
    if (o['OpeningValue'] != null) {
      OpeningValue = o['OpeningValue'].toString();
    }
    if (o['ClosingQuantity'] != null) {
      ClosingQuantity = o['ClosingQuantity'].toString();
    }
    if (o['ClosingValue'] != null) {
      ClosingValue = o['ClosingValue'].toString();
    }

    isSaved = true;
  }
  // FIELDS (InventoryDailyTable)
  String? InventoryId;
  String? StampName;
  String? Price;
  String? RecordedDate;
  String? OpeningQuantity;
  String? OpeningValue;
  String? ClosingQuantity;
  String? ClosingValue;
  bool? isSaved;
  // end FIELDS (InventoryDailyTable)

  static const bool _softDeleteActivated = false;
  InventoryDailyTableManager? __mnInventoryDailyTable;

  InventoryDailyTableManager get _mnInventoryDailyTable {
    return __mnInventoryDailyTable =
        __mnInventoryDailyTable ?? InventoryDailyTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InventoryId'] = InventoryId;
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }
    if (RecordedDate != null || !forView) {
      map['RecordedDate'] = RecordedDate;
    }
    if (OpeningQuantity != null || !forView) {
      map['OpeningQuantity'] = OpeningQuantity;
    }
    if (OpeningValue != null || !forView) {
      map['OpeningValue'] = OpeningValue;
    }
    if (ClosingQuantity != null || !forView) {
      map['ClosingQuantity'] = ClosingQuantity;
    }
    if (ClosingValue != null || !forView) {
      map['ClosingValue'] = ClosingValue;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InventoryId'] = InventoryId;
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }
    if (RecordedDate != null || !forView) {
      map['RecordedDate'] = RecordedDate;
    }
    if (OpeningQuantity != null || !forView) {
      map['OpeningQuantity'] = OpeningQuantity;
    }
    if (OpeningValue != null || !forView) {
      map['OpeningValue'] = OpeningValue;
    }
    if (ClosingQuantity != null || !forView) {
      map['ClosingQuantity'] = ClosingQuantity;
    }
    if (ClosingValue != null || !forView) {
      map['ClosingValue'] = ClosingValue;
    }

    return map;
  }

  /// This method returns Json String [InventoryDailyTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InventoryDailyTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      InventoryId,
      StampName,
      Price,
      RecordedDate,
      OpeningQuantity,
      OpeningValue,
      ClosingQuantity,
      ClosingValue
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      InventoryId,
      StampName,
      Price,
      RecordedDate,
      OpeningQuantity,
      OpeningValue,
      ClosingQuantity,
      ClosingValue
    ];
  }

  static Future<List<InventoryDailyTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryDailyTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InventoryDailyTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InventoryDailyTable>[];
    try {
      objList = list
          .map((inventorydailytable) => InventoryDailyTable.fromMap(
              inventorydailytable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InventoryDailyTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InventoryDailyTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InventoryDailyTable> objList = <InventoryDailyTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InventoryDailyTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns InventoryDailyTable by ID if exist, otherwise returns null
  /// Primary Keys: String? InventoryId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [InventoryDailyTable] if exist, otherwise returns null
  Future<InventoryDailyTable?> getById(String? InventoryId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InventoryId == null) {
      return null;
    }
    InventoryDailyTable? obj;
    final data = await _mnInventoryDailyTable.getById([InventoryId]);
    if (data.length != 0) {
      obj = InventoryDailyTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InventoryDailyTable) object. If the Primary Key (InventoryId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same InventoryId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnInventoryDailyTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO InventoryDailyTable (InventoryId, StampName, Price, RecordedDate, OpeningQuantity, OpeningValue, ClosingQuantity, ClosingValue)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<InventoryDailyTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<InventoryDailyTable> inventorydailytables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in inventorydailytables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryDailyTable.rawInsert(
          'INSERT OR REPLACE INTO InventoryDailyTable (InventoryId, StampName, Price, RecordedDate, OpeningQuantity, OpeningValue, ClosingQuantity, ClosingValue)  VALUES (?,?,?,?,?,?,?,?)',
          [
            InventoryId,
            StampName,
            Price,
            RecordedDate,
            OpeningQuantity,
            OpeningValue,
            ClosingQuantity,
            ClosingValue
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryDailyTable InventoryId=$InventoryId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryDailyTable InventoryId=$InventoryId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryDailyTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInventoryDailyTable.rawInsert(
          'INSERT OR IGNORE INTO InventoryDailyTable (InventoryId, StampName, Price, RecordedDate, OpeningQuantity, OpeningValue, ClosingQuantity, ClosingValue)  VALUES (?,?,?,?,?,?,?,?)',
          [
            InventoryId,
            StampName,
            Price,
            RecordedDate,
            OpeningQuantity,
            OpeningValue,
            ClosingQuantity,
            ClosingValue
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'InventoryDailyTable InventoryId=$InventoryId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'InventoryDailyTable InventoryId=$InventoryId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'InventoryDailyTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes InventoryDailyTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete InventoryDailyTable invoked (InventoryId=$InventoryId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInventoryDailyTable.delete(QueryParams(
          whereString: 'InventoryId=?', whereArguments: [InventoryId]));
    } else {
      return _mnInventoryDailyTable.updateBatch(
          QueryParams(
              whereString: 'InventoryId=?', whereArguments: [InventoryId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [InventoryDailyTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InventoryDailyTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryDailyTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InventoryDailyTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InventoryDailyTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InventoryId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion inventorydailytable

// region InventoryDailyTableField
class InventoryDailyTableField extends FilterBase {
  InventoryDailyTableField(
      InventoryDailyTableFilterBuilder inventorydailytableFB)
      : super(inventorydailytableFB);

  @override
  InventoryDailyTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder isNull() {
    return super.isNull() as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InventoryDailyTableFilterBuilder;
  }

  @override
  InventoryDailyTableField get not {
    return super.not as InventoryDailyTableField;
  }
}
// endregion InventoryDailyTableField

// region InventoryDailyTableFilterBuilder
class InventoryDailyTableFilterBuilder extends ConjunctionBase {
  InventoryDailyTableFilterBuilder(InventoryDailyTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInventoryDailyTable = obj._mnInventoryDailyTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InventoryDailyTableManager? _mnInventoryDailyTable;

  /// put the sql keyword 'AND'
  @override
  InventoryDailyTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InventoryDailyTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InventoryDailyTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InventoryDailyTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InventoryDailyTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InventoryDailyTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InventoryDailyTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryDailyTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryDailyTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InventoryDailyTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InventoryDailyTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InventoryDailyTableField _setField(
      InventoryDailyTableField? field, String colName, DbType dbtype) {
    return InventoryDailyTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InventoryDailyTableField? _InventoryId;
  InventoryDailyTableField get InventoryId {
    return _InventoryId =
        _setField(_InventoryId, 'InventoryId', DbType.integer);
  }

  InventoryDailyTableField? _StampName;
  InventoryDailyTableField get StampName {
    return _StampName = _setField(_StampName, 'StampName', DbType.text);
  }

  InventoryDailyTableField? _Price;
  InventoryDailyTableField get Price {
    return _Price = _setField(_Price, 'Price', DbType.text);
  }

  InventoryDailyTableField? _RecordedDate;
  InventoryDailyTableField get RecordedDate {
    return _RecordedDate =
        _setField(_RecordedDate, 'RecordedDate', DbType.text);
  }

  InventoryDailyTableField? _OpeningQuantity;
  InventoryDailyTableField get OpeningQuantity {
    return _OpeningQuantity =
        _setField(_OpeningQuantity, 'OpeningQuantity', DbType.text);
  }

  InventoryDailyTableField? _OpeningValue;
  InventoryDailyTableField get OpeningValue {
    return _OpeningValue =
        _setField(_OpeningValue, 'OpeningValue', DbType.text);
  }

  InventoryDailyTableField? _ClosingQuantity;
  InventoryDailyTableField get ClosingQuantity {
    return _ClosingQuantity =
        _setField(_ClosingQuantity, 'ClosingQuantity', DbType.text);
  }

  InventoryDailyTableField? _ClosingValue;
  InventoryDailyTableField get ClosingValue {
    return _ClosingValue =
        _setField(_ClosingValue, 'ClosingValue', DbType.text);
  }

  /// Deletes List<InventoryDailyTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInventoryDailyTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInventoryDailyTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InventoryId IN (SELECT InventoryId from InventoryDailyTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInventoryDailyTable!.updateBatch(qparams, values);
  }

  /// This method always returns [InventoryDailyTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryDailyTable?
  @override
  Future<InventoryDailyTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInventoryDailyTable!.toList(qparams);
    final data = await objFuture;
    InventoryDailyTable? obj;
    if (data.isNotEmpty) {
      obj = InventoryDailyTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [InventoryDailyTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InventoryDailyTable?
  @override
  Future<InventoryDailyTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        InventoryDailyTable();
  }

  /// This method returns int. [InventoryDailyTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? inventorydailytableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final inventorydailytablesFuture =
        await _mnInventoryDailyTable!.toList(qparams);
    final int count = inventorydailytablesFuture[0]['CNT'] as int;
    if (inventorydailytableCount != null) {
      inventorydailytableCount(count);
    }
    return count;
  }

  /// This method returns List<InventoryDailyTable> [InventoryDailyTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<InventoryDailyTable>
  @override
  Future<List<InventoryDailyTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InventoryDailyTable> inventorydailytablesData =
        await InventoryDailyTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return inventorydailytablesData;
  }

  /// This method returns Json String [InventoryDailyTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InventoryDailyTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InventoryDailyTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInventoryDailyTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InventoryDailyTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InventoryId` FROM InventoryDailyTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> InventoryIdData = <String>[];
    qparams.selectColumns = ['InventoryId'];
    final InventoryIdFuture = await _mnInventoryDailyTable!.toList(qparams);

    final int count = InventoryIdFuture.length;
    for (int i = 0; i < count; i++) {
      InventoryIdData.add(InventoryIdFuture[i]['InventoryId'] as String);
    }
    return InventoryIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InventoryDailyTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInventoryDailyTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await InventoryDailyTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInventoryDailyTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InventoryDailyTableFilterBuilder

// region InventoryDailyTableFields
class InventoryDailyTableFields {
  static TableField? _fInventoryId;
  static TableField get InventoryId {
    return _fInventoryId = _fInventoryId ??
        SqlSyntax.setField(_fInventoryId, 'inventoryid', DbType.integer);
  }

  static TableField? _fStampName;
  static TableField get StampName {
    return _fStampName = _fStampName ??
        SqlSyntax.setField(_fStampName, 'StampName', DbType.text);
  }

  static TableField? _fPrice;
  static TableField get Price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'Price', DbType.text);
  }

  static TableField? _fRecordedDate;
  static TableField get RecordedDate {
    return _fRecordedDate = _fRecordedDate ??
        SqlSyntax.setField(_fRecordedDate, 'RecordedDate', DbType.text);
  }

  static TableField? _fOpeningQuantity;
  static TableField get OpeningQuantity {
    return _fOpeningQuantity = _fOpeningQuantity ??
        SqlSyntax.setField(_fOpeningQuantity, 'OpeningQuantity', DbType.text);
  }

  static TableField? _fOpeningValue;
  static TableField get OpeningValue {
    return _fOpeningValue = _fOpeningValue ??
        SqlSyntax.setField(_fOpeningValue, 'OpeningValue', DbType.text);
  }

  static TableField? _fClosingQuantity;
  static TableField get ClosingQuantity {
    return _fClosingQuantity = _fClosingQuantity ??
        SqlSyntax.setField(_fClosingQuantity, 'ClosingQuantity', DbType.text);
  }

  static TableField? _fClosingValue;
  static TableField get ClosingValue {
    return _fClosingValue = _fClosingValue ??
        SqlSyntax.setField(_fClosingValue, 'ClosingValue', DbType.text);
  }
}
// endregion InventoryDailyTableFields

//region InventoryDailyTableManager
class InventoryDailyTableManager extends SqfEntityProvider {
  InventoryDailyTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'InventoryDailyTable';
  static const List<String> _primaryKeyList = ['InventoryId'];
  static const String _whereStr = 'InventoryId=?';
}

//endregion InventoryDailyTableManager
// region Liability
class Liability extends TableBase {
  Liability({this.Date, this.Description, this.Amount}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  Liability.withFields(this.Date, this.Description, this.Amount) {
    _setDefaultValues();
  }
  Liability.withId(this.Date, this.Description, this.Amount) {
    _setDefaultValues();
  }
  // fromMap v2.0
  Liability.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Date = o['Date'].toString();
    if (o['Description'] != null) {
      Description = o['Description'].toString();
    }
    if (o['Amount'] != null) {
      Amount = o['Amount'].toString();
    }

    isSaved = true;
  }
  // FIELDS (Liability)
  String? Date;
  String? Description;
  String? Amount;
  bool? isSaved;
  // end FIELDS (Liability)

  static const bool _softDeleteActivated = false;
  LiabilityManager? __mnLiability;

  LiabilityManager get _mnLiability {
    return __mnLiability = __mnLiability ?? LiabilityManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Date'] = Date;
    if (Description != null || !forView) {
      map['Description'] = Description;
    }
    if (Amount != null || !forView) {
      map['Amount'] = Amount;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Date'] = Date;
    if (Description != null || !forView) {
      map['Description'] = Description;
    }
    if (Amount != null || !forView) {
      map['Amount'] = Amount;
    }

    return map;
  }

  /// This method returns Json String [Liability]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [Liability]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Date, Description, Amount];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Date, Description, Amount];
  }

  static Future<List<Liability>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Liability.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<Liability>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <Liability>[];
    try {
      objList = list
          .map((liability) =>
              Liability.fromMap(liability as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR Liability.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<Liability>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<Liability> objList = <Liability>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = Liability.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns Liability by ID if exist, otherwise returns null
  /// Primary Keys: String? Date
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [Liability] if exist, otherwise returns null
  Future<Liability?> getById(String? Date,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Date == null) {
      return null;
    }
    Liability? obj;
    final data = await _mnLiability.getById([Date]);
    if (data.length != 0) {
      obj = Liability.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (Liability) object. If the Primary Key (Date) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Date
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnLiability.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO Liability (Date, Description, Amount)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<Liability> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<Liability> liabilities,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in liabilities) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLiability.rawInsert(
          'INSERT OR REPLACE INTO Liability (Date, Description, Amount)  VALUES (?,?,?)',
          [Date, Description, Amount],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Liability Date=$Date updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Liability Date=$Date did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Liability Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLiability.rawInsert(
          'INSERT OR IGNORE INTO Liability (Date, Description, Amount)  VALUES (?,?,?)',
          [Date, Description, Amount],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'Liability Date=$Date updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'Liability Date=$Date did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'Liability Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes Liability

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete Liability invoked (Date=$Date)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLiability
          .delete(QueryParams(whereString: 'Date=?', whereArguments: [Date]));
    } else {
      return _mnLiability.updateBatch(
          QueryParams(whereString: 'Date=?', whereArguments: [Date]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [Liability] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LiabilityFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LiabilityFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LiabilityFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LiabilityFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Date = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion liability

// region LiabilityField
class LiabilityField extends FilterBase {
  LiabilityField(LiabilityFilterBuilder liabilityFB) : super(liabilityFB);

  @override
  LiabilityFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder isNull() {
    return super.isNull() as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LiabilityFilterBuilder;
  }

  @override
  LiabilityField get not {
    return super.not as LiabilityField;
  }
}
// endregion LiabilityField

// region LiabilityFilterBuilder
class LiabilityFilterBuilder extends ConjunctionBase {
  LiabilityFilterBuilder(Liability obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLiability = obj._mnLiability;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LiabilityManager? _mnLiability;

  /// put the sql keyword 'AND'
  @override
  LiabilityFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LiabilityFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LiabilityFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LiabilityFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LiabilityFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LiabilityFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LiabilityFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LiabilityFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LiabilityFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LiabilityFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LiabilityFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LiabilityField _setField(
      LiabilityField? field, String colName, DbType dbtype) {
    return LiabilityField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LiabilityField? _Date;
  LiabilityField get Date {
    return _Date = _setField(_Date, 'Date', DbType.integer);
  }

  LiabilityField? _Description;
  LiabilityField get Description {
    return _Description = _setField(_Description, 'Description', DbType.text);
  }

  LiabilityField? _Amount;
  LiabilityField get Amount {
    return _Amount = _setField(_Amount, 'Amount', DbType.text);
  }

  /// Deletes List<Liability> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLiability!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLiability!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Date IN (SELECT Date from Liability ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLiability!.updateBatch(qparams, values);
  }

  /// This method always returns [Liability] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Liability?
  @override
  Future<Liability?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLiability!.toList(qparams);
    final data = await objFuture;
    Liability? obj;
    if (data.isNotEmpty) {
      obj = Liability.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [Liability]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> Liability?
  @override
  Future<Liability> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        Liability();
  }

  /// This method returns int. [Liability]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? liabilityCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final liabilitiesFuture = await _mnLiability!.toList(qparams);
    final int count = liabilitiesFuture[0]['CNT'] as int;
    if (liabilityCount != null) {
      liabilityCount(count);
    }
    return count;
  }

  /// This method returns List<Liability> [Liability]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<Liability>
  @override
  Future<List<Liability>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<Liability> liabilitiesData = await Liability.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return liabilitiesData;
  }

  /// This method returns Json String [Liability]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [Liability]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [Liability]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLiability!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [Liability]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Date` FROM Liability WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> DateData = <String>[];
    qparams.selectColumns = ['Date'];
    final DateFuture = await _mnLiability!.toList(qparams);

    final int count = DateFuture.length;
    for (int i = 0; i < count; i++) {
      DateData.add(DateFuture[i]['Date'] as String);
    }
    return DateData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [Liability]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLiability!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await Liability.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLiability!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LiabilityFilterBuilder

// region LiabilityFields
class LiabilityFields {
  static TableField? _fDate;
  static TableField get Date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField? _fDescription;
  static TableField get Description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'Description', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get Amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'Amount', DbType.text);
  }
}
// endregion LiabilityFields

//region LiabilityManager
class LiabilityManager extends SqfEntityProvider {
  LiabilityManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'Liability';
  static const List<String> _primaryKeyList = ['Date'];
  static const String _whereStr = 'Date=?';
}

//endregion LiabilityManager
// region TempLiability
class TempLiability extends TableBase {
  TempLiability({this.Date, this.Description, this.Amount}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TempLiability.withFields(this.Date, this.Description, this.Amount) {
    _setDefaultValues();
  }
  TempLiability.withId(this.Date, this.Description, this.Amount) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TempLiability.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Date = o['Date'].toString();
    if (o['Description'] != null) {
      Description = o['Description'].toString();
    }
    if (o['Amount'] != null) {
      Amount = o['Amount'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TempLiability)
  String? Date;
  String? Description;
  String? Amount;
  bool? isSaved;
  // end FIELDS (TempLiability)

  static const bool _softDeleteActivated = false;
  TempLiabilityManager? __mnTempLiability;

  TempLiabilityManager get _mnTempLiability {
    return __mnTempLiability = __mnTempLiability ?? TempLiabilityManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Date'] = Date;
    if (Description != null || !forView) {
      map['Description'] = Description;
    }
    if (Amount != null || !forView) {
      map['Amount'] = Amount;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Date'] = Date;
    if (Description != null || !forView) {
      map['Description'] = Description;
    }
    if (Amount != null || !forView) {
      map['Amount'] = Amount;
    }

    return map;
  }

  /// This method returns Json String [TempLiability]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TempLiability]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Date, Description, Amount];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Date, Description, Amount];
  }

  static Future<List<TempLiability>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TempLiability.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TempLiability>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TempLiability>[];
    try {
      objList = list
          .map((templiability) =>
              TempLiability.fromMap(templiability as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TempLiability.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TempLiability>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TempLiability> objList = <TempLiability>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TempLiability.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TempLiability by ID if exist, otherwise returns null
  /// Primary Keys: String? Date
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TempLiability] if exist, otherwise returns null
  Future<TempLiability?> getById(String? Date,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Date == null) {
      return null;
    }
    TempLiability? obj;
    final data = await _mnTempLiability.getById([Date]);
    if (data.length != 0) {
      obj = TempLiability.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TempLiability) object. If the Primary Key (Date) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Date
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTempLiability.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO tempLiability (Date, Description, Amount)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TempLiability> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TempLiability> templiabilities,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in templiabilities) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTempLiability.rawInsert(
          'INSERT OR REPLACE INTO tempLiability (Date, Description, Amount)  VALUES (?,?,?)',
          [Date, Description, Amount],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TempLiability Date=$Date updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TempLiability Date=$Date did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TempLiability Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTempLiability.rawInsert(
          'INSERT OR IGNORE INTO tempLiability (Date, Description, Amount)  VALUES (?,?,?)',
          [Date, Description, Amount],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TempLiability Date=$Date updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TempLiability Date=$Date did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TempLiability Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes TempLiability

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TempLiability invoked (Date=$Date)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTempLiability
          .delete(QueryParams(whereString: 'Date=?', whereArguments: [Date]));
    } else {
      return _mnTempLiability.updateBatch(
          QueryParams(whereString: 'Date=?', whereArguments: [Date]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TempLiability] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TempLiabilityFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TempLiabilityFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TempLiabilityFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TempLiabilityFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Date = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion templiability

// region TempLiabilityField
class TempLiabilityField extends FilterBase {
  TempLiabilityField(TempLiabilityFilterBuilder templiabilityFB)
      : super(templiabilityFB);

  @override
  TempLiabilityFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder isNull() {
    return super.isNull() as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TempLiabilityFilterBuilder;
  }

  @override
  TempLiabilityField get not {
    return super.not as TempLiabilityField;
  }
}
// endregion TempLiabilityField

// region TempLiabilityFilterBuilder
class TempLiabilityFilterBuilder extends ConjunctionBase {
  TempLiabilityFilterBuilder(TempLiability obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTempLiability = obj._mnTempLiability;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TempLiabilityManager? _mnTempLiability;

  /// put the sql keyword 'AND'
  @override
  TempLiabilityFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TempLiabilityFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TempLiabilityFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TempLiabilityFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TempLiabilityFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TempLiabilityFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TempLiabilityFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TempLiabilityFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TempLiabilityFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TempLiabilityFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TempLiabilityFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TempLiabilityField _setField(
      TempLiabilityField? field, String colName, DbType dbtype) {
    return TempLiabilityField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TempLiabilityField? _Date;
  TempLiabilityField get Date {
    return _Date = _setField(_Date, 'Date', DbType.integer);
  }

  TempLiabilityField? _Description;
  TempLiabilityField get Description {
    return _Description = _setField(_Description, 'Description', DbType.text);
  }

  TempLiabilityField? _Amount;
  TempLiabilityField get Amount {
    return _Amount = _setField(_Amount, 'Amount', DbType.text);
  }

  /// Deletes List<TempLiability> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTempLiability!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTempLiability!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Date IN (SELECT Date from tempLiability ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTempLiability!.updateBatch(qparams, values);
  }

  /// This method always returns [TempLiability] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TempLiability?
  @override
  Future<TempLiability?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTempLiability!.toList(qparams);
    final data = await objFuture;
    TempLiability? obj;
    if (data.isNotEmpty) {
      obj = TempLiability.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TempLiability]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TempLiability?
  @override
  Future<TempLiability> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TempLiability();
  }

  /// This method returns int. [TempLiability]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? templiabilityCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final templiabilitiesFuture = await _mnTempLiability!.toList(qparams);
    final int count = templiabilitiesFuture[0]['CNT'] as int;
    if (templiabilityCount != null) {
      templiabilityCount(count);
    }
    return count;
  }

  /// This method returns List<TempLiability> [TempLiability]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TempLiability>
  @override
  Future<List<TempLiability>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TempLiability> templiabilitiesData =
        await TempLiability.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return templiabilitiesData;
  }

  /// This method returns Json String [TempLiability]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TempLiability]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TempLiability]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTempLiability!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TempLiability]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Date` FROM tempLiability WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> DateData = <String>[];
    qparams.selectColumns = ['Date'];
    final DateFuture = await _mnTempLiability!.toList(qparams);

    final int count = DateFuture.length;
    for (int i = 0; i < count; i++) {
      DateData.add(DateFuture[i]['Date'] as String);
    }
    return DateData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TempLiability]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTempLiability!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TempLiability.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTempLiability!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TempLiabilityFilterBuilder

// region TempLiabilityFields
class TempLiabilityFields {
  static TableField? _fDate;
  static TableField get Date {
    return _fDate =
        _fDate ?? SqlSyntax.setField(_fDate, 'date', DbType.integer);
  }

  static TableField? _fDescription;
  static TableField get Description {
    return _fDescription = _fDescription ??
        SqlSyntax.setField(_fDescription, 'Description', DbType.text);
  }

  static TableField? _fAmount;
  static TableField get Amount {
    return _fAmount =
        _fAmount ?? SqlSyntax.setField(_fAmount, 'Amount', DbType.text);
  }
}
// endregion TempLiabilityFields

//region TempLiabilityManager
class TempLiabilityManager extends SqfEntityProvider {
  TempLiabilityManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tempLiability';
  static const List<String> _primaryKeyList = ['Date'];
  static const String _whereStr = 'Date=?';
}

//endregion TempLiabilityManager
// region BodaSlip
class BodaSlip extends TableBase {
  BodaSlip({this.bodaDate, this.cashFrom, this.cashTo, this.bodaNumber}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BodaSlip.withFields(
      this.bodaDate, this.cashFrom, this.cashTo, this.bodaNumber) {
    _setDefaultValues();
  }
  BodaSlip.withId(this.bodaDate, this.cashFrom, this.cashTo, this.bodaNumber) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BodaSlip.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    bodaDate = o['bodaDate'].toString();
    if (o['cashFrom'] != null) {
      cashFrom = o['cashFrom'].toString();
    }
    if (o['cashTo'] != null) {
      cashTo = o['cashTo'].toString();
    }
    if (o['bodaNumber'] != null) {
      bodaNumber = o['bodaNumber'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BodaSlip)
  String? bodaDate;
  String? cashFrom;
  String? cashTo;
  String? bodaNumber;
  bool? isSaved;
  // end FIELDS (BodaSlip)

  static const bool _softDeleteActivated = false;
  BodaSlipManager? __mnBodaSlip;

  BodaSlipManager get _mnBodaSlip {
    return __mnBodaSlip = __mnBodaSlip ?? BodaSlipManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['bodaDate'] = bodaDate;
    if (cashFrom != null || !forView) {
      map['cashFrom'] = cashFrom;
    }
    if (cashTo != null || !forView) {
      map['cashTo'] = cashTo;
    }
    if (bodaNumber != null || !forView) {
      map['bodaNumber'] = bodaNumber;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['bodaDate'] = bodaDate;
    if (cashFrom != null || !forView) {
      map['cashFrom'] = cashFrom;
    }
    if (cashTo != null || !forView) {
      map['cashTo'] = cashTo;
    }
    if (bodaNumber != null || !forView) {
      map['bodaNumber'] = bodaNumber;
    }

    return map;
  }

  /// This method returns Json String [BodaSlip]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BodaSlip]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [bodaDate, cashFrom, cashTo, bodaNumber];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [bodaDate, cashFrom, cashTo, bodaNumber];
  }

  static Future<List<BodaSlip>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaSlip.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BodaSlip>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BodaSlip>[];
    try {
      objList = list
          .map((bodaslip) => BodaSlip.fromMap(bodaslip as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaSlip.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BodaSlip>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BodaSlip> objList = <BodaSlip>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BodaSlip.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BodaSlip by ID if exist, otherwise returns null
  /// Primary Keys: String? bodaDate
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BodaSlip] if exist, otherwise returns null
  Future<BodaSlip?> getById(String? bodaDate,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (bodaDate == null) {
      return null;
    }
    BodaSlip? obj;
    final data = await _mnBodaSlip.getById([bodaDate]);
    if (data.length != 0) {
      obj = BodaSlip.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BodaSlip) object. If the Primary Key (bodaDate) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same bodaDate
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBodaSlip.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bodaSlip (bodaDate, cashFrom, cashTo, bodaNumber)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BodaSlip> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BodaSlip> bodaslips,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in bodaslips) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaSlip.rawInsert(
          'INSERT OR REPLACE INTO bodaSlip (bodaDate, cashFrom, cashTo, bodaNumber)  VALUES (?,?,?,?)',
          [bodaDate, cashFrom, cashTo, bodaNumber],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BodaSlip bodaDate=$bodaDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BodaSlip bodaDate=$bodaDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaSlip Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaSlip.rawInsert(
          'INSERT OR IGNORE INTO bodaSlip (bodaDate, cashFrom, cashTo, bodaNumber)  VALUES (?,?,?,?)',
          [bodaDate, cashFrom, cashTo, bodaNumber],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BodaSlip bodaDate=$bodaDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BodaSlip bodaDate=$bodaDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaSlip Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BodaSlip

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BodaSlip invoked (bodaDate=$bodaDate)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBodaSlip.delete(
          QueryParams(whereString: 'bodaDate=?', whereArguments: [bodaDate]));
    } else {
      return _mnBodaSlip.updateBatch(
          QueryParams(whereString: 'bodaDate=?', whereArguments: [bodaDate]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BodaSlip] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BodaSlipFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaSlipFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BodaSlipFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaSlipFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      bodaDate = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bodaslip

// region BodaSlipField
class BodaSlipField extends FilterBase {
  BodaSlipField(BodaSlipFilterBuilder bodaslipFB) : super(bodaslipFB);

  @override
  BodaSlipFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder isNull() {
    return super.isNull() as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BodaSlipFilterBuilder;
  }

  @override
  BodaSlipField get not {
    return super.not as BodaSlipField;
  }
}
// endregion BodaSlipField

// region BodaSlipFilterBuilder
class BodaSlipFilterBuilder extends ConjunctionBase {
  BodaSlipFilterBuilder(BodaSlip obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBodaSlip = obj._mnBodaSlip;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BodaSlipManager? _mnBodaSlip;

  /// put the sql keyword 'AND'
  @override
  BodaSlipFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BodaSlipFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BodaSlipFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BodaSlipFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BodaSlipFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BodaSlipFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BodaSlipFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaSlipFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaSlipFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaSlipFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaSlipFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BodaSlipField _setField(BodaSlipField? field, String colName, DbType dbtype) {
    return BodaSlipField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BodaSlipField? _bodaDate;
  BodaSlipField get bodaDate {
    return _bodaDate = _setField(_bodaDate, 'bodaDate', DbType.integer);
  }

  BodaSlipField? _cashFrom;
  BodaSlipField get cashFrom {
    return _cashFrom = _setField(_cashFrom, 'cashFrom', DbType.text);
  }

  BodaSlipField? _cashTo;
  BodaSlipField get cashTo {
    return _cashTo = _setField(_cashTo, 'cashTo', DbType.text);
  }

  BodaSlipField? _bodaNumber;
  BodaSlipField get bodaNumber {
    return _bodaNumber = _setField(_bodaNumber, 'bodaNumber', DbType.text);
  }

  /// Deletes List<BodaSlip> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBodaSlip!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBodaSlip!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'bodaDate IN (SELECT bodaDate from bodaSlip ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBodaSlip!.updateBatch(qparams, values);
  }

  /// This method always returns [BodaSlip] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaSlip?
  @override
  Future<BodaSlip?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBodaSlip!.toList(qparams);
    final data = await objFuture;
    BodaSlip? obj;
    if (data.isNotEmpty) {
      obj = BodaSlip.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BodaSlip]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaSlip?
  @override
  Future<BodaSlip> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BodaSlip();
  }

  /// This method returns int. [BodaSlip]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bodaslipCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bodaslipsFuture = await _mnBodaSlip!.toList(qparams);
    final int count = bodaslipsFuture[0]['CNT'] as int;
    if (bodaslipCount != null) {
      bodaslipCount(count);
    }
    return count;
  }

  /// This method returns List<BodaSlip> [BodaSlip]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BodaSlip>
  @override
  Future<List<BodaSlip>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BodaSlip> bodaslipsData = await BodaSlip.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return bodaslipsData;
  }

  /// This method returns Json String [BodaSlip]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BodaSlip]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BodaSlip]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBodaSlip!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BodaSlip]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `bodaDate` FROM bodaSlip WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> bodaDateData = <String>[];
    qparams.selectColumns = ['bodaDate'];
    final bodaDateFuture = await _mnBodaSlip!.toList(qparams);

    final int count = bodaDateFuture.length;
    for (int i = 0; i < count; i++) {
      bodaDateData.add(bodaDateFuture[i]['bodaDate'] as String);
    }
    return bodaDateData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BodaSlip]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBodaSlip!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BodaSlip.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBodaSlip!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BodaSlipFilterBuilder

// region BodaSlipFields
class BodaSlipFields {
  static TableField? _fBodaDate;
  static TableField get bodaDate {
    return _fBodaDate = _fBodaDate ??
        SqlSyntax.setField(_fBodaDate, 'bodadate', DbType.integer);
  }

  static TableField? _fCashFrom;
  static TableField get cashFrom {
    return _fCashFrom =
        _fCashFrom ?? SqlSyntax.setField(_fCashFrom, 'cashFrom', DbType.text);
  }

  static TableField? _fCashTo;
  static TableField get cashTo {
    return _fCashTo =
        _fCashTo ?? SqlSyntax.setField(_fCashTo, 'cashTo', DbType.text);
  }

  static TableField? _fBodaNumber;
  static TableField get bodaNumber {
    return _fBodaNumber = _fBodaNumber ??
        SqlSyntax.setField(_fBodaNumber, 'bodaNumber', DbType.text);
  }
}
// endregion BodaSlipFields

//region BodaSlipManager
class BodaSlipManager extends SqfEntityProvider {
  BodaSlipManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bodaSlip';
  static const List<String> _primaryKeyList = ['bodaDate'];
  static const String _whereStr = 'bodaDate=?';
}

//endregion BodaSlipManager
// region LetterBooking
class LetterBooking extends TableBase {
  LetterBooking(
      {this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.VAS,
      this.VASValue,
      this.ElapsedTime,
      this.IsFullyPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.FileCreated,
      this.BagNumber,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  LetterBooking.withFields(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.VAS,
      this.VASValue,
      this.ElapsedTime,
      this.IsFullyPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.FileCreated,
      this.BagNumber,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  LetterBooking.withId(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.TaxAmount,
      this.RepaymentMode,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.VAS,
      this.VASValue,
      this.ElapsedTime,
      this.IsFullyPrepaid,
      this.IsOnPostalService,
      this.Status,
      this.FileCreated,
      this.BagNumber,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  LetterBooking.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserID'] != null) {
      UserID = o['UserID'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyID'] != null) {
      CurrencyID = o['CurrencyID'].toString();
    }
    if (o['TenderID'] != null) {
      TenderID = o['TenderID'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['WeightCode'] != null) {
      WeightCode = o['WeightCode'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerNumber'] != null) {
      SenderCustomerNumber = o['SenderCustomerNumber'].toString();
    }
    if (o['SenderName'] != null) {
      SenderName = o['SenderName'].toString();
    }
    if (o['SenderAddress'] != null) {
      SenderAddress = o['SenderAddress'].toString();
    }
    if (o['SenderCity'] != null) {
      SenderCity = o['SenderCity'].toString();
    }
    if (o['SenderState'] != null) {
      SenderState = o['SenderState'].toString();
    }
    if (o['SenderZip'] != null) {
      SenderZip = o['SenderZip'].toString();
    }
    if (o['SenderCountry'] != null) {
      SenderCountry = o['SenderCountry'].toString();
    }
    if (o['RecipientName'] != null) {
      RecipientName = o['RecipientName'].toString();
    }
    if (o['RecipientAddress'] != null) {
      RecipientAddress = o['RecipientAddress'].toString();
    }
    if (o['RecipientCity'] != null) {
      RecipientCity = o['RecipientCity'].toString();
    }
    if (o['RecipientState'] != null) {
      RecipientState = o['RecipientState'].toString();
    }
    if (o['RecipientZip'] != null) {
      RecipientZip = o['RecipientZip'].toString();
    }
    if (o['RecipientCountryID'] != null) {
      RecipientCountryID = o['RecipientCountryID'].toString();
    }
    if (o['RecipientMobile'] != null) {
      RecipientMobile = o['RecipientMobile'].toString();
    }
    if (o['RecipientEmail'] != null) {
      RecipientEmail = o['RecipientEmail'].toString();
    }
    if (o['ReturnName'] != null) {
      ReturnName = o['ReturnName'].toString();
    }
    if (o['ReturnAddress'] != null) {
      ReturnAddress = o['ReturnAddress'].toString();
    }
    if (o['ReturnCity'] != null) {
      ReturnCity = o['ReturnCity'].toString();
    }
    if (o['ReturnState'] != null) {
      ReturnState = o['ReturnState'].toString();
    }
    if (o['ReturnZip'] != null) {
      ReturnZip = o['ReturnZip'].toString();
    }
    if (o['ReturnCountryID'] != null) {
      ReturnCountryID = o['ReturnCountryID'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['TaxAmount'] != null) {
      TaxAmount = o['TaxAmount'].toString();
    }
    if (o['RepaymentMode'] != null) {
      RepaymentMode = o['RepaymentMode'].toString();
    }
    if (o['PostageDue'] != null) {
      PostageDue = o['PostageDue'].toString();
    }
    if (o['PrepaidAmount'] != null) {
      PrepaidAmount = o['PrepaidAmount'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacility'] != null) {
      DestinationFacility = o['DestinationFacility'].toString();
    }
    if (o['VAS'] != null) {
      VAS = o['VAS'].toString();
    }
    if (o['VASValue'] != null) {
      VASValue = o['VASValue'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['IsFullyPrepaid'] != null) {
      IsFullyPrepaid = o['IsFullyPrepaid'].toString();
    }
    if (o['IsOnPostalService'] != null) {
      IsOnPostalService = o['IsOnPostalService'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['CancellationReason'] != null) {
      CancellationReason = o['CancellationReason'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }

    isSaved = true;
  }
  // FIELDS (LetterBooking)
  String? ArticleNumber;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserID;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyID;
  String? TenderID;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? WeightCode;
  String? Weight;
  String? Quantity;
  String? SenderCustomerNumber;
  String? SenderName;
  String? SenderAddress;
  String? SenderCity;
  String? SenderState;
  String? SenderZip;
  String? SenderCountry;
  String? RecipientName;
  String? RecipientAddress;
  String? RecipientCity;
  String? RecipientState;
  String? RecipientZip;
  String? RecipientCountryID;
  String? RecipientMobile;
  String? RecipientEmail;
  String? ReturnName;
  String? ReturnAddress;
  String? ReturnCity;
  String? ReturnState;
  String? ReturnZip;
  String? ReturnCountryID;
  String? CommissionAmount;
  String? TaxAmount;
  String? RepaymentMode;
  String? PostageDue;
  String? PrepaidAmount;
  String? MaterialGroup;
  String? DestinationFacility;
  String? VAS;
  String? VASValue;
  String? ElapsedTime;
  String? IsFullyPrepaid;
  String? IsOnPostalService;
  String? Status;
  String? FileCreated;
  String? BagNumber;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? CancellationReason;
  String? Authorized;
  bool? isSaved;
  // end FIELDS (LetterBooking)

  static const bool _softDeleteActivated = false;
  LetterBookingManager? __mnLetterBooking;

  LetterBookingManager get _mnLetterBooking {
    return __mnLetterBooking = __mnLetterBooking ?? LetterBookingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullyPrepaid != null || !forView) {
      map['IsFullyPrepaid'] = IsFullyPrepaid;
    }
    if (IsOnPostalService != null || !forView) {
      map['IsOnPostalService'] = IsOnPostalService;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullyPrepaid != null || !forView) {
      map['IsFullyPrepaid'] = IsFullyPrepaid;
    }
    if (IsOnPostalService != null || !forView) {
      map['IsOnPostalService'] = IsOnPostalService;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [LetterBooking]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [LetterBooking]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      TaxAmount,
      RepaymentMode,
      PostageDue,
      PrepaidAmount,
      MaterialGroup,
      DestinationFacility,
      VAS,
      VASValue,
      ElapsedTime,
      IsFullyPrepaid,
      IsOnPostalService,
      Status,
      FileCreated,
      BagNumber,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      TaxAmount,
      RepaymentMode,
      PostageDue,
      PrepaidAmount,
      MaterialGroup,
      DestinationFacility,
      VAS,
      VASValue,
      ElapsedTime,
      IsFullyPrepaid,
      IsOnPostalService,
      Status,
      FileCreated,
      BagNumber,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  static Future<List<LetterBooking>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LetterBooking.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<LetterBooking>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <LetterBooking>[];
    try {
      objList = list
          .map((letterbooking) =>
              LetterBooking.fromMap(letterbooking as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LetterBooking.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<LetterBooking>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<LetterBooking> objList = <LetterBooking>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = LetterBooking.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns LetterBooking by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [LetterBooking] if exist, otherwise returns null
  Future<LetterBooking?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    LetterBooking? obj;
    final data = await _mnLetterBooking.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = LetterBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (LetterBooking) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnLetterBooking.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO letterBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, MaterialGroup, DestinationFacility, VAS, VASValue, ElapsedTime, IsFullyPrepaid, IsOnPostalService, Status, FileCreated, BagNumber, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<LetterBooking> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<LetterBooking> letterbookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in letterbookings) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLetterBooking.rawInsert(
          'INSERT OR REPLACE INTO letterBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, MaterialGroup, DestinationFacility, VAS, VASValue, ElapsedTime, IsFullyPrepaid, IsOnPostalService, Status, FileCreated, BagNumber, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            TaxAmount,
            RepaymentMode,
            PostageDue,
            PrepaidAmount,
            MaterialGroup,
            DestinationFacility,
            VAS,
            VASValue,
            ElapsedTime,
            IsFullyPrepaid,
            IsOnPostalService,
            Status,
            FileCreated,
            BagNumber,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'LetterBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'LetterBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LetterBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLetterBooking.rawInsert(
          'INSERT OR IGNORE INTO letterBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, TaxAmount, RepaymentMode, PostageDue, PrepaidAmount, MaterialGroup, DestinationFacility, VAS, VASValue, ElapsedTime, IsFullyPrepaid, IsOnPostalService, Status, FileCreated, BagNumber, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            TaxAmount,
            RepaymentMode,
            PostageDue,
            PrepaidAmount,
            MaterialGroup,
            DestinationFacility,
            VAS,
            VASValue,
            ElapsedTime,
            IsFullyPrepaid,
            IsOnPostalService,
            Status,
            FileCreated,
            BagNumber,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'LetterBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'LetterBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LetterBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes LetterBooking

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete LetterBooking invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLetterBooking.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnLetterBooking.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [LetterBooking] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LetterBookingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LetterBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LetterBookingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LetterBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion letterbooking

// region LetterBookingField
class LetterBookingField extends FilterBase {
  LetterBookingField(LetterBookingFilterBuilder letterbookingFB)
      : super(letterbookingFB);

  @override
  LetterBookingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder isNull() {
    return super.isNull() as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LetterBookingFilterBuilder;
  }

  @override
  LetterBookingField get not {
    return super.not as LetterBookingField;
  }
}
// endregion LetterBookingField

// region LetterBookingFilterBuilder
class LetterBookingFilterBuilder extends ConjunctionBase {
  LetterBookingFilterBuilder(LetterBooking obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLetterBooking = obj._mnLetterBooking;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LetterBookingManager? _mnLetterBooking;

  /// put the sql keyword 'AND'
  @override
  LetterBookingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LetterBookingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LetterBookingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LetterBookingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LetterBookingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LetterBookingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LetterBookingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LetterBookingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LetterBookingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LetterBookingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LetterBookingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LetterBookingField _setField(
      LetterBookingField? field, String colName, DbType dbtype) {
    return LetterBookingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LetterBookingField? _ArticleNumber;
  LetterBookingField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  LetterBookingField? _FacilityId;
  LetterBookingField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  LetterBookingField? _BookingFacilityZip;
  LetterBookingField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  LetterBookingField? _DistributionChannel;
  LetterBookingField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  LetterBookingField? _UserID;
  LetterBookingField get UserID {
    return _UserID = _setField(_UserID, 'UserID', DbType.text);
  }

  LetterBookingField? _CounterNumber;
  LetterBookingField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  LetterBookingField? _InvoiceNumber;
  LetterBookingField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  LetterBookingField? _TotalAmount;
  LetterBookingField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  LetterBookingField? _BookingDate;
  LetterBookingField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  LetterBookingField? _BookingTime;
  LetterBookingField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  LetterBookingField? _CurrencyID;
  LetterBookingField get CurrencyID {
    return _CurrencyID = _setField(_CurrencyID, 'CurrencyID', DbType.text);
  }

  LetterBookingField? _TenderID;
  LetterBookingField get TenderID {
    return _TenderID = _setField(_TenderID, 'TenderID', DbType.text);
  }

  LetterBookingField? _TotalCashAmount;
  LetterBookingField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  LetterBookingField? _RoundOffDifference;
  LetterBookingField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  LetterBookingField? _CircleCode;
  LetterBookingField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  LetterBookingField? _LineItemNumber;
  LetterBookingField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  LetterBookingField? _BasePrice;
  LetterBookingField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  LetterBookingField? _LineItemTotalAmount;
  LetterBookingField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  LetterBookingField? _Division;
  LetterBookingField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  LetterBookingField? _OrderType;
  LetterBookingField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  LetterBookingField? _ProductType;
  LetterBookingField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  LetterBookingField? _ProductCode;
  LetterBookingField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  LetterBookingField? _WeightCode;
  LetterBookingField get WeightCode {
    return _WeightCode = _setField(_WeightCode, 'WeightCode', DbType.text);
  }

  LetterBookingField? _Weight;
  LetterBookingField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  LetterBookingField? _Quantity;
  LetterBookingField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  LetterBookingField? _SenderCustomerNumber;
  LetterBookingField get SenderCustomerNumber {
    return _SenderCustomerNumber =
        _setField(_SenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  LetterBookingField? _SenderName;
  LetterBookingField get SenderName {
    return _SenderName = _setField(_SenderName, 'SenderName', DbType.text);
  }

  LetterBookingField? _SenderAddress;
  LetterBookingField get SenderAddress {
    return _SenderAddress =
        _setField(_SenderAddress, 'SenderAddress', DbType.text);
  }

  LetterBookingField? _SenderCity;
  LetterBookingField get SenderCity {
    return _SenderCity = _setField(_SenderCity, 'SenderCity', DbType.text);
  }

  LetterBookingField? _SenderState;
  LetterBookingField get SenderState {
    return _SenderState = _setField(_SenderState, 'SenderState', DbType.text);
  }

  LetterBookingField? _SenderZip;
  LetterBookingField get SenderZip {
    return _SenderZip = _setField(_SenderZip, 'SenderZip', DbType.text);
  }

  LetterBookingField? _SenderCountry;
  LetterBookingField get SenderCountry {
    return _SenderCountry =
        _setField(_SenderCountry, 'SenderCountry', DbType.text);
  }

  LetterBookingField? _RecipientName;
  LetterBookingField get RecipientName {
    return _RecipientName =
        _setField(_RecipientName, 'RecipientName', DbType.text);
  }

  LetterBookingField? _RecipientAddress;
  LetterBookingField get RecipientAddress {
    return _RecipientAddress =
        _setField(_RecipientAddress, 'RecipientAddress', DbType.text);
  }

  LetterBookingField? _RecipientCity;
  LetterBookingField get RecipientCity {
    return _RecipientCity =
        _setField(_RecipientCity, 'RecipientCity', DbType.text);
  }

  LetterBookingField? _RecipientState;
  LetterBookingField get RecipientState {
    return _RecipientState =
        _setField(_RecipientState, 'RecipientState', DbType.text);
  }

  LetterBookingField? _RecipientZip;
  LetterBookingField get RecipientZip {
    return _RecipientZip =
        _setField(_RecipientZip, 'RecipientZip', DbType.text);
  }

  LetterBookingField? _RecipientCountryID;
  LetterBookingField get RecipientCountryID {
    return _RecipientCountryID =
        _setField(_RecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  LetterBookingField? _RecipientMobile;
  LetterBookingField get RecipientMobile {
    return _RecipientMobile =
        _setField(_RecipientMobile, 'RecipientMobile', DbType.text);
  }

  LetterBookingField? _RecipientEmail;
  LetterBookingField get RecipientEmail {
    return _RecipientEmail =
        _setField(_RecipientEmail, 'RecipientEmail', DbType.text);
  }

  LetterBookingField? _ReturnName;
  LetterBookingField get ReturnName {
    return _ReturnName = _setField(_ReturnName, 'ReturnName', DbType.text);
  }

  LetterBookingField? _ReturnAddress;
  LetterBookingField get ReturnAddress {
    return _ReturnAddress =
        _setField(_ReturnAddress, 'ReturnAddress', DbType.text);
  }

  LetterBookingField? _ReturnCity;
  LetterBookingField get ReturnCity {
    return _ReturnCity = _setField(_ReturnCity, 'ReturnCity', DbType.text);
  }

  LetterBookingField? _ReturnState;
  LetterBookingField get ReturnState {
    return _ReturnState = _setField(_ReturnState, 'ReturnState', DbType.text);
  }

  LetterBookingField? _ReturnZip;
  LetterBookingField get ReturnZip {
    return _ReturnZip = _setField(_ReturnZip, 'ReturnZip', DbType.text);
  }

  LetterBookingField? _ReturnCountryID;
  LetterBookingField get ReturnCountryID {
    return _ReturnCountryID =
        _setField(_ReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  LetterBookingField? _CommissionAmount;
  LetterBookingField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  LetterBookingField? _TaxAmount;
  LetterBookingField get TaxAmount {
    return _TaxAmount = _setField(_TaxAmount, 'TaxAmount', DbType.text);
  }

  LetterBookingField? _RepaymentMode;
  LetterBookingField get RepaymentMode {
    return _RepaymentMode =
        _setField(_RepaymentMode, 'RepaymentMode', DbType.text);
  }

  LetterBookingField? _PostageDue;
  LetterBookingField get PostageDue {
    return _PostageDue = _setField(_PostageDue, 'PostageDue', DbType.text);
  }

  LetterBookingField? _PrepaidAmount;
  LetterBookingField get PrepaidAmount {
    return _PrepaidAmount =
        _setField(_PrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  LetterBookingField? _MaterialGroup;
  LetterBookingField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  LetterBookingField? _DestinationFacility;
  LetterBookingField get DestinationFacility {
    return _DestinationFacility =
        _setField(_DestinationFacility, 'DestinationFacility', DbType.text);
  }

  LetterBookingField? _VAS;
  LetterBookingField get VAS {
    return _VAS = _setField(_VAS, 'VAS', DbType.text);
  }

  LetterBookingField? _VASValue;
  LetterBookingField get VASValue {
    return _VASValue = _setField(_VASValue, 'VASValue', DbType.text);
  }

  LetterBookingField? _ElapsedTime;
  LetterBookingField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  LetterBookingField? _IsFullyPrepaid;
  LetterBookingField get IsFullyPrepaid {
    return _IsFullyPrepaid =
        _setField(_IsFullyPrepaid, 'IsFullyPrepaid', DbType.text);
  }

  LetterBookingField? _IsOnPostalService;
  LetterBookingField get IsOnPostalService {
    return _IsOnPostalService =
        _setField(_IsOnPostalService, 'IsOnPostalService', DbType.text);
  }

  LetterBookingField? _Status;
  LetterBookingField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  LetterBookingField? _FileCreated;
  LetterBookingField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  LetterBookingField? _BagNumber;
  LetterBookingField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  LetterBookingField? _FileName;
  LetterBookingField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  LetterBookingField? _FileCreatedDateTime;
  LetterBookingField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  LetterBookingField? _FileTransmitted;
  LetterBookingField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  LetterBookingField? _FileTransmittedDateTime;
  LetterBookingField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  LetterBookingField? _CancellationReason;
  LetterBookingField get CancellationReason {
    return _CancellationReason =
        _setField(_CancellationReason, 'CancellationReason', DbType.text);
  }

  LetterBookingField? _Authorized;
  LetterBookingField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<LetterBooking> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLetterBooking!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLetterBooking!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from letterBooking ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLetterBooking!.updateBatch(qparams, values);
  }

  /// This method always returns [LetterBooking] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LetterBooking?
  @override
  Future<LetterBooking?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLetterBooking!.toList(qparams);
    final data = await objFuture;
    LetterBooking? obj;
    if (data.isNotEmpty) {
      obj = LetterBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [LetterBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LetterBooking?
  @override
  Future<LetterBooking> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        LetterBooking();
  }

  /// This method returns int. [LetterBooking]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? letterbookingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final letterbookingsFuture = await _mnLetterBooking!.toList(qparams);
    final int count = letterbookingsFuture[0]['CNT'] as int;
    if (letterbookingCount != null) {
      letterbookingCount(count);
    }
    return count;
  }

  /// This method returns List<LetterBooking> [LetterBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<LetterBooking>
  @override
  Future<List<LetterBooking>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<LetterBooking> letterbookingsData =
        await LetterBooking.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return letterbookingsData;
  }

  /// This method returns Json String [LetterBooking]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [LetterBooking]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [LetterBooking]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLetterBooking!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [LetterBooking]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM letterBooking WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnLetterBooking!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [LetterBooking]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLetterBooking!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await LetterBooking.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLetterBooking!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LetterBookingFilterBuilder

// region LetterBookingFields
class LetterBookingFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserID;
  static TableField get UserID {
    return _fUserID =
        _fUserID ?? SqlSyntax.setField(_fUserID, 'UserID', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyID;
  static TableField get CurrencyID {
    return _fCurrencyID = _fCurrencyID ??
        SqlSyntax.setField(_fCurrencyID, 'CurrencyID', DbType.text);
  }

  static TableField? _fTenderID;
  static TableField get TenderID {
    return _fTenderID =
        _fTenderID ?? SqlSyntax.setField(_fTenderID, 'TenderID', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fWeightCode;
  static TableField get WeightCode {
    return _fWeightCode = _fWeightCode ??
        SqlSyntax.setField(_fWeightCode, 'WeightCode', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerNumber;
  static TableField get SenderCustomerNumber {
    return _fSenderCustomerNumber = _fSenderCustomerNumber ??
        SqlSyntax.setField(
            _fSenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  static TableField? _fSenderName;
  static TableField get SenderName {
    return _fSenderName = _fSenderName ??
        SqlSyntax.setField(_fSenderName, 'SenderName', DbType.text);
  }

  static TableField? _fSenderAddress;
  static TableField get SenderAddress {
    return _fSenderAddress = _fSenderAddress ??
        SqlSyntax.setField(_fSenderAddress, 'SenderAddress', DbType.text);
  }

  static TableField? _fSenderCity;
  static TableField get SenderCity {
    return _fSenderCity = _fSenderCity ??
        SqlSyntax.setField(_fSenderCity, 'SenderCity', DbType.text);
  }

  static TableField? _fSenderState;
  static TableField get SenderState {
    return _fSenderState = _fSenderState ??
        SqlSyntax.setField(_fSenderState, 'SenderState', DbType.text);
  }

  static TableField? _fSenderZip;
  static TableField get SenderZip {
    return _fSenderZip = _fSenderZip ??
        SqlSyntax.setField(_fSenderZip, 'SenderZip', DbType.text);
  }

  static TableField? _fSenderCountry;
  static TableField get SenderCountry {
    return _fSenderCountry = _fSenderCountry ??
        SqlSyntax.setField(_fSenderCountry, 'SenderCountry', DbType.text);
  }

  static TableField? _fRecipientName;
  static TableField get RecipientName {
    return _fRecipientName = _fRecipientName ??
        SqlSyntax.setField(_fRecipientName, 'RecipientName', DbType.text);
  }

  static TableField? _fRecipientAddress;
  static TableField get RecipientAddress {
    return _fRecipientAddress = _fRecipientAddress ??
        SqlSyntax.setField(_fRecipientAddress, 'RecipientAddress', DbType.text);
  }

  static TableField? _fRecipientCity;
  static TableField get RecipientCity {
    return _fRecipientCity = _fRecipientCity ??
        SqlSyntax.setField(_fRecipientCity, 'RecipientCity', DbType.text);
  }

  static TableField? _fRecipientState;
  static TableField get RecipientState {
    return _fRecipientState = _fRecipientState ??
        SqlSyntax.setField(_fRecipientState, 'RecipientState', DbType.text);
  }

  static TableField? _fRecipientZip;
  static TableField get RecipientZip {
    return _fRecipientZip = _fRecipientZip ??
        SqlSyntax.setField(_fRecipientZip, 'RecipientZip', DbType.text);
  }

  static TableField? _fRecipientCountryID;
  static TableField get RecipientCountryID {
    return _fRecipientCountryID = _fRecipientCountryID ??
        SqlSyntax.setField(
            _fRecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  static TableField? _fRecipientMobile;
  static TableField get RecipientMobile {
    return _fRecipientMobile = _fRecipientMobile ??
        SqlSyntax.setField(_fRecipientMobile, 'RecipientMobile', DbType.text);
  }

  static TableField? _fRecipientEmail;
  static TableField get RecipientEmail {
    return _fRecipientEmail = _fRecipientEmail ??
        SqlSyntax.setField(_fRecipientEmail, 'RecipientEmail', DbType.text);
  }

  static TableField? _fReturnName;
  static TableField get ReturnName {
    return _fReturnName = _fReturnName ??
        SqlSyntax.setField(_fReturnName, 'ReturnName', DbType.text);
  }

  static TableField? _fReturnAddress;
  static TableField get ReturnAddress {
    return _fReturnAddress = _fReturnAddress ??
        SqlSyntax.setField(_fReturnAddress, 'ReturnAddress', DbType.text);
  }

  static TableField? _fReturnCity;
  static TableField get ReturnCity {
    return _fReturnCity = _fReturnCity ??
        SqlSyntax.setField(_fReturnCity, 'ReturnCity', DbType.text);
  }

  static TableField? _fReturnState;
  static TableField get ReturnState {
    return _fReturnState = _fReturnState ??
        SqlSyntax.setField(_fReturnState, 'ReturnState', DbType.text);
  }

  static TableField? _fReturnZip;
  static TableField get ReturnZip {
    return _fReturnZip = _fReturnZip ??
        SqlSyntax.setField(_fReturnZip, 'ReturnZip', DbType.text);
  }

  static TableField? _fReturnCountryID;
  static TableField get ReturnCountryID {
    return _fReturnCountryID = _fReturnCountryID ??
        SqlSyntax.setField(_fReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fTaxAmount;
  static TableField get TaxAmount {
    return _fTaxAmount = _fTaxAmount ??
        SqlSyntax.setField(_fTaxAmount, 'TaxAmount', DbType.text);
  }

  static TableField? _fRepaymentMode;
  static TableField get RepaymentMode {
    return _fRepaymentMode = _fRepaymentMode ??
        SqlSyntax.setField(_fRepaymentMode, 'RepaymentMode', DbType.text);
  }

  static TableField? _fPostageDue;
  static TableField get PostageDue {
    return _fPostageDue = _fPostageDue ??
        SqlSyntax.setField(_fPostageDue, 'PostageDue', DbType.text);
  }

  static TableField? _fPrepaidAmount;
  static TableField get PrepaidAmount {
    return _fPrepaidAmount = _fPrepaidAmount ??
        SqlSyntax.setField(_fPrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacility;
  static TableField get DestinationFacility {
    return _fDestinationFacility = _fDestinationFacility ??
        SqlSyntax.setField(
            _fDestinationFacility, 'DestinationFacility', DbType.text);
  }

  static TableField? _fVAS;
  static TableField get VAS {
    return _fVAS = _fVAS ?? SqlSyntax.setField(_fVAS, 'VAS', DbType.text);
  }

  static TableField? _fVASValue;
  static TableField get VASValue {
    return _fVASValue =
        _fVASValue ?? SqlSyntax.setField(_fVASValue, 'VASValue', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fIsFullyPrepaid;
  static TableField get IsFullyPrepaid {
    return _fIsFullyPrepaid = _fIsFullyPrepaid ??
        SqlSyntax.setField(_fIsFullyPrepaid, 'IsFullyPrepaid', DbType.text);
  }

  static TableField? _fIsOnPostalService;
  static TableField get IsOnPostalService {
    return _fIsOnPostalService = _fIsOnPostalService ??
        SqlSyntax.setField(
            _fIsOnPostalService, 'IsOnPostalService', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fCancellationReason;
  static TableField get CancellationReason {
    return _fCancellationReason = _fCancellationReason ??
        SqlSyntax.setField(
            _fCancellationReason, 'CancellationReason', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion LetterBookingFields

//region LetterBookingManager
class LetterBookingManager extends SqfEntityProvider {
  LetterBookingManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'letterBooking';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion LetterBookingManager
// region EmoBooking
class EmoBooking extends TableBase {
  EmoBooking(
      {this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.RepaymentMode,
      this.MaterialGroup,
      this.DestinationFacility,
      this.SenderMoneyTransferValue,
      this.MOTrackingID,
      this.MOMessage,
      this.ElapsedTime,
      this.BulkAddressType,
      this.VPMOIdentifier,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  EmoBooking.withFields(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.RepaymentMode,
      this.MaterialGroup,
      this.DestinationFacility,
      this.SenderMoneyTransferValue,
      this.MOTrackingID,
      this.MOMessage,
      this.ElapsedTime,
      this.BulkAddressType,
      this.VPMOIdentifier,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.Authorized) {
    _setDefaultValues();
  }
  EmoBooking.withId(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CheckerUserID,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.RecipientMobile,
      this.RecipientEmail,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.CommissionAmount,
      this.RepaymentMode,
      this.MaterialGroup,
      this.DestinationFacility,
      this.SenderMoneyTransferValue,
      this.MOTrackingID,
      this.MOMessage,
      this.ElapsedTime,
      this.BulkAddressType,
      this.VPMOIdentifier,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  EmoBooking.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserID'] != null) {
      UserID = o['UserID'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyID'] != null) {
      CurrencyID = o['CurrencyID'].toString();
    }
    if (o['TenderID'] != null) {
      TenderID = o['TenderID'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CheckerUserID'] != null) {
      CheckerUserID = o['CheckerUserID'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['ValueCode'] != null) {
      ValueCode = o['ValueCode'].toString();
    }
    if (o['Value'] != null) {
      Value = o['Value'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerNumber'] != null) {
      SenderCustomerNumber = o['SenderCustomerNumber'].toString();
    }
    if (o['SenderName'] != null) {
      SenderName = o['SenderName'].toString();
    }
    if (o['SenderAddress'] != null) {
      SenderAddress = o['SenderAddress'].toString();
    }
    if (o['SenderCity'] != null) {
      SenderCity = o['SenderCity'].toString();
    }
    if (o['SenderState'] != null) {
      SenderState = o['SenderState'].toString();
    }
    if (o['SenderZip'] != null) {
      SenderZip = o['SenderZip'].toString();
    }
    if (o['SenderCountry'] != null) {
      SenderCountry = o['SenderCountry'].toString();
    }
    if (o['RecipientName'] != null) {
      RecipientName = o['RecipientName'].toString();
    }
    if (o['RecipientAddress'] != null) {
      RecipientAddress = o['RecipientAddress'].toString();
    }
    if (o['RecipientCity'] != null) {
      RecipientCity = o['RecipientCity'].toString();
    }
    if (o['RecipientState'] != null) {
      RecipientState = o['RecipientState'].toString();
    }
    if (o['RecipientZip'] != null) {
      RecipientZip = o['RecipientZip'].toString();
    }
    if (o['RecipientCountryID'] != null) {
      RecipientCountryID = o['RecipientCountryID'].toString();
    }
    if (o['RecipientMobile'] != null) {
      RecipientMobile = o['RecipientMobile'].toString();
    }
    if (o['RecipientEmail'] != null) {
      RecipientEmail = o['RecipientEmail'].toString();
    }
    if (o['ReturnName'] != null) {
      ReturnName = o['ReturnName'].toString();
    }
    if (o['ReturnAddress'] != null) {
      ReturnAddress = o['ReturnAddress'].toString();
    }
    if (o['ReturnCity'] != null) {
      ReturnCity = o['ReturnCity'].toString();
    }
    if (o['ReturnState'] != null) {
      ReturnState = o['ReturnState'].toString();
    }
    if (o['ReturnZip'] != null) {
      ReturnZip = o['ReturnZip'].toString();
    }
    if (o['ReturnCountryID'] != null) {
      ReturnCountryID = o['ReturnCountryID'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['RepaymentMode'] != null) {
      RepaymentMode = o['RepaymentMode'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacility'] != null) {
      DestinationFacility = o['DestinationFacility'].toString();
    }
    if (o['SenderMoneyTransferValue'] != null) {
      SenderMoneyTransferValue = o['SenderMoneyTransferValue'].toString();
    }
    if (o['MOTrackingID'] != null) {
      MOTrackingID = o['MOTrackingID'].toString();
    }
    if (o['MOMessage'] != null) {
      MOMessage = o['MOMessage'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['BulkAddressType'] != null) {
      BulkAddressType = o['BulkAddressType'].toString();
    }
    if (o['VPMOIdentifier'] != null) {
      VPMOIdentifier = o['VPMOIdentifier'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }

    isSaved = true;
  }
  // FIELDS (EmoBooking)
  String? ArticleNumber;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserID;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyID;
  String? TenderID;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CheckerUserID;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? ValueCode;
  String? Value;
  String? Quantity;
  String? SenderCustomerNumber;
  String? SenderName;
  String? SenderAddress;
  String? SenderCity;
  String? SenderState;
  String? SenderZip;
  String? SenderCountry;
  String? RecipientName;
  String? RecipientAddress;
  String? RecipientCity;
  String? RecipientState;
  String? RecipientZip;
  String? RecipientCountryID;
  String? RecipientMobile;
  String? RecipientEmail;
  String? ReturnName;
  String? ReturnAddress;
  String? ReturnCity;
  String? ReturnState;
  String? ReturnZip;
  String? ReturnCountryID;
  String? CommissionAmount;
  String? RepaymentMode;
  String? MaterialGroup;
  String? DestinationFacility;
  String? SenderMoneyTransferValue;
  String? MOTrackingID;
  String? MOMessage;
  String? ElapsedTime;
  String? BulkAddressType;
  String? VPMOIdentifier;
  String? Status;
  String? BagNumber;
  String? FileCreated;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? Authorized;
  bool? isSaved;
  // end FIELDS (EmoBooking)

  static const bool _softDeleteActivated = false;
  EmoBookingManager? __mnEmoBooking;

  EmoBookingManager get _mnEmoBooking {
    return __mnEmoBooking = __mnEmoBooking ?? EmoBookingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CheckerUserID != null || !forView) {
      map['CheckerUserID'] = CheckerUserID;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (SenderMoneyTransferValue != null || !forView) {
      map['SenderMoneyTransferValue'] = SenderMoneyTransferValue;
    }
    if (MOTrackingID != null || !forView) {
      map['MOTrackingID'] = MOTrackingID;
    }
    if (MOMessage != null || !forView) {
      map['MOMessage'] = MOMessage;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (BulkAddressType != null || !forView) {
      map['BulkAddressType'] = BulkAddressType;
    }
    if (VPMOIdentifier != null || !forView) {
      map['VPMOIdentifier'] = VPMOIdentifier;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CheckerUserID != null || !forView) {
      map['CheckerUserID'] = CheckerUserID;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (RecipientMobile != null || !forView) {
      map['RecipientMobile'] = RecipientMobile;
    }
    if (RecipientEmail != null || !forView) {
      map['RecipientEmail'] = RecipientEmail;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (SenderMoneyTransferValue != null || !forView) {
      map['SenderMoneyTransferValue'] = SenderMoneyTransferValue;
    }
    if (MOTrackingID != null || !forView) {
      map['MOTrackingID'] = MOTrackingID;
    }
    if (MOMessage != null || !forView) {
      map['MOMessage'] = MOMessage;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (BulkAddressType != null || !forView) {
      map['BulkAddressType'] = BulkAddressType;
    }
    if (VPMOIdentifier != null || !forView) {
      map['VPMOIdentifier'] = VPMOIdentifier;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [EmoBooking]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [EmoBooking]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CheckerUserID,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      RepaymentMode,
      MaterialGroup,
      DestinationFacility,
      SenderMoneyTransferValue,
      MOTrackingID,
      MOMessage,
      ElapsedTime,
      BulkAddressType,
      VPMOIdentifier,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CheckerUserID,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      RecipientMobile,
      RecipientEmail,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      CommissionAmount,
      RepaymentMode,
      MaterialGroup,
      DestinationFacility,
      SenderMoneyTransferValue,
      MOTrackingID,
      MOMessage,
      ElapsedTime,
      BulkAddressType,
      VPMOIdentifier,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      Authorized
    ];
  }

  static Future<List<EmoBooking>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EmoBooking.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<EmoBooking>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <EmoBooking>[];
    try {
      objList = list
          .map((emobooking) =>
              EmoBooking.fromMap(emobooking as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EmoBooking.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<EmoBooking>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<EmoBooking> objList = <EmoBooking>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = EmoBooking.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns EmoBooking by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [EmoBooking] if exist, otherwise returns null
  Future<EmoBooking?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    EmoBooking? obj;
    final data = await _mnEmoBooking.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = EmoBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (EmoBooking) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnEmoBooking.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO emoBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, RepaymentMode, MaterialGroup, DestinationFacility, SenderMoneyTransferValue, MOTrackingID, MOMessage, ElapsedTime, BulkAddressType, VPMOIdentifier, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<EmoBooking> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<EmoBooking> emobookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in emobookings) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEmoBooking.rawInsert(
          'INSERT OR REPLACE INTO emoBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, RepaymentMode, MaterialGroup, DestinationFacility, SenderMoneyTransferValue, MOTrackingID, MOMessage, ElapsedTime, BulkAddressType, VPMOIdentifier, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CheckerUserID,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            RepaymentMode,
            MaterialGroup,
            DestinationFacility,
            SenderMoneyTransferValue,
            MOTrackingID,
            MOMessage,
            ElapsedTime,
            BulkAddressType,
            VPMOIdentifier,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'EmoBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'EmoBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EmoBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEmoBooking.rawInsert(
          'INSERT OR IGNORE INTO emoBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CheckerUserID, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, RecipientMobile, RecipientEmail, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, CommissionAmount, RepaymentMode, MaterialGroup, DestinationFacility, SenderMoneyTransferValue, MOTrackingID, MOMessage, ElapsedTime, BulkAddressType, VPMOIdentifier, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CheckerUserID,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            RecipientMobile,
            RecipientEmail,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            CommissionAmount,
            RepaymentMode,
            MaterialGroup,
            DestinationFacility,
            SenderMoneyTransferValue,
            MOTrackingID,
            MOMessage,
            ElapsedTime,
            BulkAddressType,
            VPMOIdentifier,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'EmoBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'EmoBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EmoBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes EmoBooking

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete EmoBooking invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnEmoBooking.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnEmoBooking.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [EmoBooking] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  EmoBookingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmoBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  EmoBookingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmoBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion emobooking

// region EmoBookingField
class EmoBookingField extends FilterBase {
  EmoBookingField(EmoBookingFilterBuilder emobookingFB) : super(emobookingFB);

  @override
  EmoBookingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder isNull() {
    return super.isNull() as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as EmoBookingFilterBuilder;
  }

  @override
  EmoBookingField get not {
    return super.not as EmoBookingField;
  }
}
// endregion EmoBookingField

// region EmoBookingFilterBuilder
class EmoBookingFilterBuilder extends ConjunctionBase {
  EmoBookingFilterBuilder(EmoBooking obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnEmoBooking = obj._mnEmoBooking;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  EmoBookingManager? _mnEmoBooking;

  /// put the sql keyword 'AND'
  @override
  EmoBookingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  EmoBookingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  EmoBookingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  EmoBookingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  EmoBookingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  EmoBookingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  EmoBookingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmoBookingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmoBookingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmoBookingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmoBookingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  EmoBookingField _setField(
      EmoBookingField? field, String colName, DbType dbtype) {
    return EmoBookingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  EmoBookingField? _ArticleNumber;
  EmoBookingField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  EmoBookingField? _FacilityId;
  EmoBookingField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  EmoBookingField? _BookingFacilityZip;
  EmoBookingField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  EmoBookingField? _DistributionChannel;
  EmoBookingField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  EmoBookingField? _UserID;
  EmoBookingField get UserID {
    return _UserID = _setField(_UserID, 'UserID', DbType.text);
  }

  EmoBookingField? _CounterNumber;
  EmoBookingField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  EmoBookingField? _InvoiceNumber;
  EmoBookingField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  EmoBookingField? _TotalAmount;
  EmoBookingField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  EmoBookingField? _BookingDate;
  EmoBookingField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  EmoBookingField? _BookingTime;
  EmoBookingField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  EmoBookingField? _CurrencyID;
  EmoBookingField get CurrencyID {
    return _CurrencyID = _setField(_CurrencyID, 'CurrencyID', DbType.text);
  }

  EmoBookingField? _TenderID;
  EmoBookingField get TenderID {
    return _TenderID = _setField(_TenderID, 'TenderID', DbType.text);
  }

  EmoBookingField? _TotalCashAmount;
  EmoBookingField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  EmoBookingField? _RoundOffDifference;
  EmoBookingField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  EmoBookingField? _CheckerUserID;
  EmoBookingField get CheckerUserID {
    return _CheckerUserID =
        _setField(_CheckerUserID, 'CheckerUserID', DbType.text);
  }

  EmoBookingField? _CircleCode;
  EmoBookingField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  EmoBookingField? _LineItemNumber;
  EmoBookingField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  EmoBookingField? _BasePrice;
  EmoBookingField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  EmoBookingField? _LineItemTotalAmount;
  EmoBookingField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  EmoBookingField? _Division;
  EmoBookingField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  EmoBookingField? _OrderType;
  EmoBookingField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  EmoBookingField? _ProductType;
  EmoBookingField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  EmoBookingField? _ProductCode;
  EmoBookingField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  EmoBookingField? _ValueCode;
  EmoBookingField get ValueCode {
    return _ValueCode = _setField(_ValueCode, 'ValueCode', DbType.text);
  }

  EmoBookingField? _Value;
  EmoBookingField get Value {
    return _Value = _setField(_Value, 'Value', DbType.text);
  }

  EmoBookingField? _Quantity;
  EmoBookingField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  EmoBookingField? _SenderCustomerNumber;
  EmoBookingField get SenderCustomerNumber {
    return _SenderCustomerNumber =
        _setField(_SenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  EmoBookingField? _SenderName;
  EmoBookingField get SenderName {
    return _SenderName = _setField(_SenderName, 'SenderName', DbType.text);
  }

  EmoBookingField? _SenderAddress;
  EmoBookingField get SenderAddress {
    return _SenderAddress =
        _setField(_SenderAddress, 'SenderAddress', DbType.text);
  }

  EmoBookingField? _SenderCity;
  EmoBookingField get SenderCity {
    return _SenderCity = _setField(_SenderCity, 'SenderCity', DbType.text);
  }

  EmoBookingField? _SenderState;
  EmoBookingField get SenderState {
    return _SenderState = _setField(_SenderState, 'SenderState', DbType.text);
  }

  EmoBookingField? _SenderZip;
  EmoBookingField get SenderZip {
    return _SenderZip = _setField(_SenderZip, 'SenderZip', DbType.text);
  }

  EmoBookingField? _SenderCountry;
  EmoBookingField get SenderCountry {
    return _SenderCountry =
        _setField(_SenderCountry, 'SenderCountry', DbType.text);
  }

  EmoBookingField? _RecipientName;
  EmoBookingField get RecipientName {
    return _RecipientName =
        _setField(_RecipientName, 'RecipientName', DbType.text);
  }

  EmoBookingField? _RecipientAddress;
  EmoBookingField get RecipientAddress {
    return _RecipientAddress =
        _setField(_RecipientAddress, 'RecipientAddress', DbType.text);
  }

  EmoBookingField? _RecipientCity;
  EmoBookingField get RecipientCity {
    return _RecipientCity =
        _setField(_RecipientCity, 'RecipientCity', DbType.text);
  }

  EmoBookingField? _RecipientState;
  EmoBookingField get RecipientState {
    return _RecipientState =
        _setField(_RecipientState, 'RecipientState', DbType.text);
  }

  EmoBookingField? _RecipientZip;
  EmoBookingField get RecipientZip {
    return _RecipientZip =
        _setField(_RecipientZip, 'RecipientZip', DbType.text);
  }

  EmoBookingField? _RecipientCountryID;
  EmoBookingField get RecipientCountryID {
    return _RecipientCountryID =
        _setField(_RecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  EmoBookingField? _RecipientMobile;
  EmoBookingField get RecipientMobile {
    return _RecipientMobile =
        _setField(_RecipientMobile, 'RecipientMobile', DbType.text);
  }

  EmoBookingField? _RecipientEmail;
  EmoBookingField get RecipientEmail {
    return _RecipientEmail =
        _setField(_RecipientEmail, 'RecipientEmail', DbType.text);
  }

  EmoBookingField? _ReturnName;
  EmoBookingField get ReturnName {
    return _ReturnName = _setField(_ReturnName, 'ReturnName', DbType.text);
  }

  EmoBookingField? _ReturnAddress;
  EmoBookingField get ReturnAddress {
    return _ReturnAddress =
        _setField(_ReturnAddress, 'ReturnAddress', DbType.text);
  }

  EmoBookingField? _ReturnCity;
  EmoBookingField get ReturnCity {
    return _ReturnCity = _setField(_ReturnCity, 'ReturnCity', DbType.text);
  }

  EmoBookingField? _ReturnState;
  EmoBookingField get ReturnState {
    return _ReturnState = _setField(_ReturnState, 'ReturnState', DbType.text);
  }

  EmoBookingField? _ReturnZip;
  EmoBookingField get ReturnZip {
    return _ReturnZip = _setField(_ReturnZip, 'ReturnZip', DbType.text);
  }

  EmoBookingField? _ReturnCountryID;
  EmoBookingField get ReturnCountryID {
    return _ReturnCountryID =
        _setField(_ReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  EmoBookingField? _CommissionAmount;
  EmoBookingField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  EmoBookingField? _RepaymentMode;
  EmoBookingField get RepaymentMode {
    return _RepaymentMode =
        _setField(_RepaymentMode, 'RepaymentMode', DbType.text);
  }

  EmoBookingField? _MaterialGroup;
  EmoBookingField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  EmoBookingField? _DestinationFacility;
  EmoBookingField get DestinationFacility {
    return _DestinationFacility =
        _setField(_DestinationFacility, 'DestinationFacility', DbType.text);
  }

  EmoBookingField? _SenderMoneyTransferValue;
  EmoBookingField get SenderMoneyTransferValue {
    return _SenderMoneyTransferValue = _setField(
        _SenderMoneyTransferValue, 'SenderMoneyTransferValue', DbType.text);
  }

  EmoBookingField? _MOTrackingID;
  EmoBookingField get MOTrackingID {
    return _MOTrackingID =
        _setField(_MOTrackingID, 'MOTrackingID', DbType.text);
  }

  EmoBookingField? _MOMessage;
  EmoBookingField get MOMessage {
    return _MOMessage = _setField(_MOMessage, 'MOMessage', DbType.text);
  }

  EmoBookingField? _ElapsedTime;
  EmoBookingField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  EmoBookingField? _BulkAddressType;
  EmoBookingField get BulkAddressType {
    return _BulkAddressType =
        _setField(_BulkAddressType, 'BulkAddressType', DbType.text);
  }

  EmoBookingField? _VPMOIdentifier;
  EmoBookingField get VPMOIdentifier {
    return _VPMOIdentifier =
        _setField(_VPMOIdentifier, 'VPMOIdentifier', DbType.text);
  }

  EmoBookingField? _Status;
  EmoBookingField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  EmoBookingField? _BagNumber;
  EmoBookingField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  EmoBookingField? _FileCreated;
  EmoBookingField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  EmoBookingField? _FileName;
  EmoBookingField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  EmoBookingField? _FileCreatedDateTime;
  EmoBookingField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  EmoBookingField? _FileTransmitted;
  EmoBookingField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  EmoBookingField? _FileTransmittedDateTime;
  EmoBookingField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  EmoBookingField? _Authorized;
  EmoBookingField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<EmoBooking> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnEmoBooking!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnEmoBooking!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from emoBooking ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnEmoBooking!.updateBatch(qparams, values);
  }

  /// This method always returns [EmoBooking] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EmoBooking?
  @override
  Future<EmoBooking?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnEmoBooking!.toList(qparams);
    final data = await objFuture;
    EmoBooking? obj;
    if (data.isNotEmpty) {
      obj = EmoBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [EmoBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EmoBooking?
  @override
  Future<EmoBooking> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        EmoBooking();
  }

  /// This method returns int. [EmoBooking]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? emobookingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final emobookingsFuture = await _mnEmoBooking!.toList(qparams);
    final int count = emobookingsFuture[0]['CNT'] as int;
    if (emobookingCount != null) {
      emobookingCount(count);
    }
    return count;
  }

  /// This method returns List<EmoBooking> [EmoBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<EmoBooking>
  @override
  Future<List<EmoBooking>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<EmoBooking> emobookingsData = await EmoBooking.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return emobookingsData;
  }

  /// This method returns Json String [EmoBooking]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [EmoBooking]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [EmoBooking]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnEmoBooking!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [EmoBooking]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM emoBooking WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnEmoBooking!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [EmoBooking]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnEmoBooking!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await EmoBooking.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnEmoBooking!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EmoBookingFilterBuilder

// region EmoBookingFields
class EmoBookingFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserID;
  static TableField get UserID {
    return _fUserID =
        _fUserID ?? SqlSyntax.setField(_fUserID, 'UserID', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyID;
  static TableField get CurrencyID {
    return _fCurrencyID = _fCurrencyID ??
        SqlSyntax.setField(_fCurrencyID, 'CurrencyID', DbType.text);
  }

  static TableField? _fTenderID;
  static TableField get TenderID {
    return _fTenderID =
        _fTenderID ?? SqlSyntax.setField(_fTenderID, 'TenderID', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCheckerUserID;
  static TableField get CheckerUserID {
    return _fCheckerUserID = _fCheckerUserID ??
        SqlSyntax.setField(_fCheckerUserID, 'CheckerUserID', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fValueCode;
  static TableField get ValueCode {
    return _fValueCode = _fValueCode ??
        SqlSyntax.setField(_fValueCode, 'ValueCode', DbType.text);
  }

  static TableField? _fValue;
  static TableField get Value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'Value', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerNumber;
  static TableField get SenderCustomerNumber {
    return _fSenderCustomerNumber = _fSenderCustomerNumber ??
        SqlSyntax.setField(
            _fSenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  static TableField? _fSenderName;
  static TableField get SenderName {
    return _fSenderName = _fSenderName ??
        SqlSyntax.setField(_fSenderName, 'SenderName', DbType.text);
  }

  static TableField? _fSenderAddress;
  static TableField get SenderAddress {
    return _fSenderAddress = _fSenderAddress ??
        SqlSyntax.setField(_fSenderAddress, 'SenderAddress', DbType.text);
  }

  static TableField? _fSenderCity;
  static TableField get SenderCity {
    return _fSenderCity = _fSenderCity ??
        SqlSyntax.setField(_fSenderCity, 'SenderCity', DbType.text);
  }

  static TableField? _fSenderState;
  static TableField get SenderState {
    return _fSenderState = _fSenderState ??
        SqlSyntax.setField(_fSenderState, 'SenderState', DbType.text);
  }

  static TableField? _fSenderZip;
  static TableField get SenderZip {
    return _fSenderZip = _fSenderZip ??
        SqlSyntax.setField(_fSenderZip, 'SenderZip', DbType.text);
  }

  static TableField? _fSenderCountry;
  static TableField get SenderCountry {
    return _fSenderCountry = _fSenderCountry ??
        SqlSyntax.setField(_fSenderCountry, 'SenderCountry', DbType.text);
  }

  static TableField? _fRecipientName;
  static TableField get RecipientName {
    return _fRecipientName = _fRecipientName ??
        SqlSyntax.setField(_fRecipientName, 'RecipientName', DbType.text);
  }

  static TableField? _fRecipientAddress;
  static TableField get RecipientAddress {
    return _fRecipientAddress = _fRecipientAddress ??
        SqlSyntax.setField(_fRecipientAddress, 'RecipientAddress', DbType.text);
  }

  static TableField? _fRecipientCity;
  static TableField get RecipientCity {
    return _fRecipientCity = _fRecipientCity ??
        SqlSyntax.setField(_fRecipientCity, 'RecipientCity', DbType.text);
  }

  static TableField? _fRecipientState;
  static TableField get RecipientState {
    return _fRecipientState = _fRecipientState ??
        SqlSyntax.setField(_fRecipientState, 'RecipientState', DbType.text);
  }

  static TableField? _fRecipientZip;
  static TableField get RecipientZip {
    return _fRecipientZip = _fRecipientZip ??
        SqlSyntax.setField(_fRecipientZip, 'RecipientZip', DbType.text);
  }

  static TableField? _fRecipientCountryID;
  static TableField get RecipientCountryID {
    return _fRecipientCountryID = _fRecipientCountryID ??
        SqlSyntax.setField(
            _fRecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  static TableField? _fRecipientMobile;
  static TableField get RecipientMobile {
    return _fRecipientMobile = _fRecipientMobile ??
        SqlSyntax.setField(_fRecipientMobile, 'RecipientMobile', DbType.text);
  }

  static TableField? _fRecipientEmail;
  static TableField get RecipientEmail {
    return _fRecipientEmail = _fRecipientEmail ??
        SqlSyntax.setField(_fRecipientEmail, 'RecipientEmail', DbType.text);
  }

  static TableField? _fReturnName;
  static TableField get ReturnName {
    return _fReturnName = _fReturnName ??
        SqlSyntax.setField(_fReturnName, 'ReturnName', DbType.text);
  }

  static TableField? _fReturnAddress;
  static TableField get ReturnAddress {
    return _fReturnAddress = _fReturnAddress ??
        SqlSyntax.setField(_fReturnAddress, 'ReturnAddress', DbType.text);
  }

  static TableField? _fReturnCity;
  static TableField get ReturnCity {
    return _fReturnCity = _fReturnCity ??
        SqlSyntax.setField(_fReturnCity, 'ReturnCity', DbType.text);
  }

  static TableField? _fReturnState;
  static TableField get ReturnState {
    return _fReturnState = _fReturnState ??
        SqlSyntax.setField(_fReturnState, 'ReturnState', DbType.text);
  }

  static TableField? _fReturnZip;
  static TableField get ReturnZip {
    return _fReturnZip = _fReturnZip ??
        SqlSyntax.setField(_fReturnZip, 'ReturnZip', DbType.text);
  }

  static TableField? _fReturnCountryID;
  static TableField get ReturnCountryID {
    return _fReturnCountryID = _fReturnCountryID ??
        SqlSyntax.setField(_fReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fRepaymentMode;
  static TableField get RepaymentMode {
    return _fRepaymentMode = _fRepaymentMode ??
        SqlSyntax.setField(_fRepaymentMode, 'RepaymentMode', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacility;
  static TableField get DestinationFacility {
    return _fDestinationFacility = _fDestinationFacility ??
        SqlSyntax.setField(
            _fDestinationFacility, 'DestinationFacility', DbType.text);
  }

  static TableField? _fSenderMoneyTransferValue;
  static TableField get SenderMoneyTransferValue {
    return _fSenderMoneyTransferValue = _fSenderMoneyTransferValue ??
        SqlSyntax.setField(_fSenderMoneyTransferValue,
            'SenderMoneyTransferValue', DbType.text);
  }

  static TableField? _fMOTrackingID;
  static TableField get MOTrackingID {
    return _fMOTrackingID = _fMOTrackingID ??
        SqlSyntax.setField(_fMOTrackingID, 'MOTrackingID', DbType.text);
  }

  static TableField? _fMOMessage;
  static TableField get MOMessage {
    return _fMOMessage = _fMOMessage ??
        SqlSyntax.setField(_fMOMessage, 'MOMessage', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fBulkAddressType;
  static TableField get BulkAddressType {
    return _fBulkAddressType = _fBulkAddressType ??
        SqlSyntax.setField(_fBulkAddressType, 'BulkAddressType', DbType.text);
  }

  static TableField? _fVPMOIdentifier;
  static TableField get VPMOIdentifier {
    return _fVPMOIdentifier = _fVPMOIdentifier ??
        SqlSyntax.setField(_fVPMOIdentifier, 'VPMOIdentifier', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion EmoBookingFields

//region EmoBookingManager
class EmoBookingManager extends SqfEntityProvider {
  EmoBookingManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'emoBooking';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion EmoBookingManager
// region SpeedBooking
class SpeedBooking extends TableBase {
  SpeedBooking(
      {this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.DistanceCode,
      this.Distance,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.SenderMobile,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.TaxAmount,
      this.PostageDue,
      this.RepaymentMode,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SpeedBooking.withFields(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.DistanceCode,
      this.Distance,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.SenderMobile,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.TaxAmount,
      this.PostageDue,
      this.RepaymentMode,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  SpeedBooking.withId(
      this.ArticleNumber,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserID,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyID,
      this.TenderID,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.DistanceCode,
      this.Distance,
      this.Quantity,
      this.SenderCustomerNumber,
      this.SenderName,
      this.SenderAddress,
      this.SenderCity,
      this.SenderState,
      this.SenderZip,
      this.SenderCountry,
      this.SenderMobile,
      this.RecipientName,
      this.RecipientAddress,
      this.RecipientCity,
      this.RecipientState,
      this.RecipientZip,
      this.RecipientCountryID,
      this.ReturnName,
      this.ReturnAddress,
      this.ReturnCity,
      this.ReturnState,
      this.ReturnZip,
      this.ReturnCountryID,
      this.TaxAmount,
      this.PostageDue,
      this.RepaymentMode,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.DestinationFacility,
      this.ElapsedTime,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.Status,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SpeedBooking.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserID'] != null) {
      UserID = o['UserID'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyID'] != null) {
      CurrencyID = o['CurrencyID'].toString();
    }
    if (o['TenderID'] != null) {
      TenderID = o['TenderID'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['WeightCode'] != null) {
      WeightCode = o['WeightCode'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['DistanceCode'] != null) {
      DistanceCode = o['DistanceCode'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerNumber'] != null) {
      SenderCustomerNumber = o['SenderCustomerNumber'].toString();
    }
    if (o['SenderName'] != null) {
      SenderName = o['SenderName'].toString();
    }
    if (o['SenderAddress'] != null) {
      SenderAddress = o['SenderAddress'].toString();
    }
    if (o['SenderCity'] != null) {
      SenderCity = o['SenderCity'].toString();
    }
    if (o['SenderState'] != null) {
      SenderState = o['SenderState'].toString();
    }
    if (o['SenderZip'] != null) {
      SenderZip = o['SenderZip'].toString();
    }
    if (o['SenderCountry'] != null) {
      SenderCountry = o['SenderCountry'].toString();
    }
    if (o['SenderMobile'] != null) {
      SenderMobile = o['SenderMobile'].toString();
    }
    if (o['RecipientName'] != null) {
      RecipientName = o['RecipientName'].toString();
    }
    if (o['RecipientAddress'] != null) {
      RecipientAddress = o['RecipientAddress'].toString();
    }
    if (o['RecipientCity'] != null) {
      RecipientCity = o['RecipientCity'].toString();
    }
    if (o['RecipientState'] != null) {
      RecipientState = o['RecipientState'].toString();
    }
    if (o['RecipientZip'] != null) {
      RecipientZip = o['RecipientZip'].toString();
    }
    if (o['RecipientCountryID'] != null) {
      RecipientCountryID = o['RecipientCountryID'].toString();
    }
    if (o['ReturnName'] != null) {
      ReturnName = o['ReturnName'].toString();
    }
    if (o['ReturnAddress'] != null) {
      ReturnAddress = o['ReturnAddress'].toString();
    }
    if (o['ReturnCity'] != null) {
      ReturnCity = o['ReturnCity'].toString();
    }
    if (o['ReturnState'] != null) {
      ReturnState = o['ReturnState'].toString();
    }
    if (o['ReturnZip'] != null) {
      ReturnZip = o['ReturnZip'].toString();
    }
    if (o['ReturnCountryID'] != null) {
      ReturnCountryID = o['ReturnCountryID'].toString();
    }
    if (o['TaxAmount'] != null) {
      TaxAmount = o['TaxAmount'].toString();
    }
    if (o['PostageDue'] != null) {
      PostageDue = o['PostageDue'].toString();
    }
    if (o['RepaymentMode'] != null) {
      RepaymentMode = o['RepaymentMode'].toString();
    }
    if (o['PrepaidAmount'] != null) {
      PrepaidAmount = o['PrepaidAmount'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacility'] != null) {
      DestinationFacility = o['DestinationFacility'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['IsFullPrepaid'] != null) {
      IsFullPrepaid = o['IsFullPrepaid'].toString();
    }
    if (o['VAS'] != null) {
      VAS = o['VAS'].toString();
    }
    if (o['VASValue'] != null) {
      VASValue = o['VASValue'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['CancellationReason'] != null) {
      CancellationReason = o['CancellationReason'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }

    isSaved = true;
  }
  // FIELDS (SpeedBooking)
  String? ArticleNumber;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserID;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyID;
  String? TenderID;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? WeightCode;
  String? Weight;
  String? DistanceCode;
  String? Distance;
  String? Quantity;
  String? SenderCustomerNumber;
  String? SenderName;
  String? SenderAddress;
  String? SenderCity;
  String? SenderState;
  String? SenderZip;
  String? SenderCountry;
  String? SenderMobile;
  String? RecipientName;
  String? RecipientAddress;
  String? RecipientCity;
  String? RecipientState;
  String? RecipientZip;
  String? RecipientCountryID;
  String? ReturnName;
  String? ReturnAddress;
  String? ReturnCity;
  String? ReturnState;
  String? ReturnZip;
  String? ReturnCountryID;
  String? TaxAmount;
  String? PostageDue;
  String? RepaymentMode;
  String? PrepaidAmount;
  String? MaterialGroup;
  String? DestinationFacility;
  String? ElapsedTime;
  String? IsFullPrepaid;
  String? VAS;
  String? VASValue;
  String? Status;
  String? BagNumber;
  String? FileCreated;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? CancellationReason;
  String? Authorized;
  bool? isSaved;
  // end FIELDS (SpeedBooking)

  static const bool _softDeleteActivated = false;
  SpeedBookingManager? __mnSpeedBooking;

  SpeedBookingManager get _mnSpeedBooking {
    return __mnSpeedBooking = __mnSpeedBooking ?? SpeedBookingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (DistanceCode != null || !forView) {
      map['DistanceCode'] = DistanceCode;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (SenderMobile != null || !forView) {
      map['SenderMobile'] = SenderMobile;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserID != null || !forView) {
      map['UserID'] = UserID;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyID != null || !forView) {
      map['CurrencyID'] = CurrencyID;
    }
    if (TenderID != null || !forView) {
      map['TenderID'] = TenderID;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (DistanceCode != null || !forView) {
      map['DistanceCode'] = DistanceCode;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerNumber != null || !forView) {
      map['SenderCustomerNumber'] = SenderCustomerNumber;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderZip != null || !forView) {
      map['SenderZip'] = SenderZip;
    }
    if (SenderCountry != null || !forView) {
      map['SenderCountry'] = SenderCountry;
    }
    if (SenderMobile != null || !forView) {
      map['SenderMobile'] = SenderMobile;
    }
    if (RecipientName != null || !forView) {
      map['RecipientName'] = RecipientName;
    }
    if (RecipientAddress != null || !forView) {
      map['RecipientAddress'] = RecipientAddress;
    }
    if (RecipientCity != null || !forView) {
      map['RecipientCity'] = RecipientCity;
    }
    if (RecipientState != null || !forView) {
      map['RecipientState'] = RecipientState;
    }
    if (RecipientZip != null || !forView) {
      map['RecipientZip'] = RecipientZip;
    }
    if (RecipientCountryID != null || !forView) {
      map['RecipientCountryID'] = RecipientCountryID;
    }
    if (ReturnName != null || !forView) {
      map['ReturnName'] = ReturnName;
    }
    if (ReturnAddress != null || !forView) {
      map['ReturnAddress'] = ReturnAddress;
    }
    if (ReturnCity != null || !forView) {
      map['ReturnCity'] = ReturnCity;
    }
    if (ReturnState != null || !forView) {
      map['ReturnState'] = ReturnState;
    }
    if (ReturnZip != null || !forView) {
      map['ReturnZip'] = ReturnZip;
    }
    if (ReturnCountryID != null || !forView) {
      map['ReturnCountryID'] = ReturnCountryID;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (RepaymentMode != null || !forView) {
      map['RepaymentMode'] = RepaymentMode;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacility != null || !forView) {
      map['DestinationFacility'] = DestinationFacility;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [SpeedBooking]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SpeedBooking]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      DistanceCode,
      Distance,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      SenderMobile,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      TaxAmount,
      PostageDue,
      RepaymentMode,
      PrepaidAmount,
      MaterialGroup,
      DestinationFacility,
      ElapsedTime,
      IsFullPrepaid,
      VAS,
      VASValue,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ArticleNumber,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserID,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyID,
      TenderID,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      DistanceCode,
      Distance,
      Quantity,
      SenderCustomerNumber,
      SenderName,
      SenderAddress,
      SenderCity,
      SenderState,
      SenderZip,
      SenderCountry,
      SenderMobile,
      RecipientName,
      RecipientAddress,
      RecipientCity,
      RecipientState,
      RecipientZip,
      RecipientCountryID,
      ReturnName,
      ReturnAddress,
      ReturnCity,
      ReturnState,
      ReturnZip,
      ReturnCountryID,
      TaxAmount,
      PostageDue,
      RepaymentMode,
      PrepaidAmount,
      MaterialGroup,
      DestinationFacility,
      ElapsedTime,
      IsFullPrepaid,
      VAS,
      VASValue,
      Status,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  static Future<List<SpeedBooking>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpeedBooking.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SpeedBooking>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SpeedBooking>[];
    try {
      objList = list
          .map((speedbooking) =>
              SpeedBooking.fromMap(speedbooking as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpeedBooking.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SpeedBooking>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SpeedBooking> objList = <SpeedBooking>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SpeedBooking.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SpeedBooking by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SpeedBooking] if exist, otherwise returns null
  Future<SpeedBooking?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    SpeedBooking? obj;
    final data = await _mnSpeedBooking.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = SpeedBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SpeedBooking) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnSpeedBooking.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO speedBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, DistanceCode, Distance, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, SenderMobile, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, TaxAmount, PostageDue, RepaymentMode, PrepaidAmount, MaterialGroup, DestinationFacility, ElapsedTime, IsFullPrepaid, VAS, VASValue, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<SpeedBooking> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SpeedBooking> speedbookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in speedbookings) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpeedBooking.rawInsert(
          'INSERT OR REPLACE INTO speedBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, DistanceCode, Distance, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, SenderMobile, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, TaxAmount, PostageDue, RepaymentMode, PrepaidAmount, MaterialGroup, DestinationFacility, ElapsedTime, IsFullPrepaid, VAS, VASValue, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            DistanceCode,
            Distance,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            SenderMobile,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            TaxAmount,
            PostageDue,
            RepaymentMode,
            PrepaidAmount,
            MaterialGroup,
            DestinationFacility,
            ElapsedTime,
            IsFullPrepaid,
            VAS,
            VASValue,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpeedBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'SpeedBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SpeedBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpeedBooking.rawInsert(
          'INSERT OR IGNORE INTO speedBooking (ArticleNumber, FacilityId, BookingFacilityZip, DistributionChannel, UserID, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyID, TenderID, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, DistanceCode, Distance, Quantity, SenderCustomerNumber, SenderName, SenderAddress, SenderCity, SenderState, SenderZip, SenderCountry, SenderMobile, RecipientName, RecipientAddress, RecipientCity, RecipientState, RecipientZip, RecipientCountryID, ReturnName, ReturnAddress, ReturnCity, ReturnState, ReturnZip, ReturnCountryID, TaxAmount, PostageDue, RepaymentMode, PrepaidAmount, MaterialGroup, DestinationFacility, ElapsedTime, IsFullPrepaid, VAS, VASValue, Status, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserID,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyID,
            TenderID,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            DistanceCode,
            Distance,
            Quantity,
            SenderCustomerNumber,
            SenderName,
            SenderAddress,
            SenderCity,
            SenderState,
            SenderZip,
            SenderCountry,
            SenderMobile,
            RecipientName,
            RecipientAddress,
            RecipientCity,
            RecipientState,
            RecipientZip,
            RecipientCountryID,
            ReturnName,
            ReturnAddress,
            ReturnCity,
            ReturnState,
            ReturnZip,
            ReturnCountryID,
            TaxAmount,
            PostageDue,
            RepaymentMode,
            PrepaidAmount,
            MaterialGroup,
            DestinationFacility,
            ElapsedTime,
            IsFullPrepaid,
            VAS,
            VASValue,
            Status,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpeedBooking ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'SpeedBooking ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SpeedBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes SpeedBooking

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete SpeedBooking invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSpeedBooking.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnSpeedBooking.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SpeedBooking] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SpeedBookingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpeedBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SpeedBookingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpeedBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion speedbooking

// region SpeedBookingField
class SpeedBookingField extends FilterBase {
  SpeedBookingField(SpeedBookingFilterBuilder speedbookingFB)
      : super(speedbookingFB);

  @override
  SpeedBookingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder isNull() {
    return super.isNull() as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SpeedBookingFilterBuilder;
  }

  @override
  SpeedBookingField get not {
    return super.not as SpeedBookingField;
  }
}
// endregion SpeedBookingField

// region SpeedBookingFilterBuilder
class SpeedBookingFilterBuilder extends ConjunctionBase {
  SpeedBookingFilterBuilder(SpeedBooking obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSpeedBooking = obj._mnSpeedBooking;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SpeedBookingManager? _mnSpeedBooking;

  /// put the sql keyword 'AND'
  @override
  SpeedBookingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SpeedBookingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SpeedBookingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SpeedBookingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SpeedBookingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SpeedBookingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SpeedBookingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpeedBookingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpeedBookingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpeedBookingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpeedBookingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SpeedBookingField _setField(
      SpeedBookingField? field, String colName, DbType dbtype) {
    return SpeedBookingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SpeedBookingField? _ArticleNumber;
  SpeedBookingField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  SpeedBookingField? _FacilityId;
  SpeedBookingField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  SpeedBookingField? _BookingFacilityZip;
  SpeedBookingField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  SpeedBookingField? _DistributionChannel;
  SpeedBookingField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  SpeedBookingField? _UserID;
  SpeedBookingField get UserID {
    return _UserID = _setField(_UserID, 'UserID', DbType.text);
  }

  SpeedBookingField? _CounterNumber;
  SpeedBookingField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  SpeedBookingField? _InvoiceNumber;
  SpeedBookingField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  SpeedBookingField? _TotalAmount;
  SpeedBookingField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  SpeedBookingField? _BookingDate;
  SpeedBookingField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  SpeedBookingField? _BookingTime;
  SpeedBookingField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  SpeedBookingField? _CurrencyID;
  SpeedBookingField get CurrencyID {
    return _CurrencyID = _setField(_CurrencyID, 'CurrencyID', DbType.text);
  }

  SpeedBookingField? _TenderID;
  SpeedBookingField get TenderID {
    return _TenderID = _setField(_TenderID, 'TenderID', DbType.text);
  }

  SpeedBookingField? _TotalCashAmount;
  SpeedBookingField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  SpeedBookingField? _RoundOffDifference;
  SpeedBookingField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  SpeedBookingField? _CircleCode;
  SpeedBookingField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  SpeedBookingField? _LineItemNumber;
  SpeedBookingField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  SpeedBookingField? _BasePrice;
  SpeedBookingField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  SpeedBookingField? _LineItemTotalAmount;
  SpeedBookingField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  SpeedBookingField? _Division;
  SpeedBookingField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  SpeedBookingField? _OrderType;
  SpeedBookingField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  SpeedBookingField? _ProductType;
  SpeedBookingField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  SpeedBookingField? _ProductCode;
  SpeedBookingField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  SpeedBookingField? _WeightCode;
  SpeedBookingField get WeightCode {
    return _WeightCode = _setField(_WeightCode, 'WeightCode', DbType.text);
  }

  SpeedBookingField? _Weight;
  SpeedBookingField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  SpeedBookingField? _DistanceCode;
  SpeedBookingField get DistanceCode {
    return _DistanceCode =
        _setField(_DistanceCode, 'DistanceCode', DbType.text);
  }

  SpeedBookingField? _Distance;
  SpeedBookingField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  SpeedBookingField? _Quantity;
  SpeedBookingField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  SpeedBookingField? _SenderCustomerNumber;
  SpeedBookingField get SenderCustomerNumber {
    return _SenderCustomerNumber =
        _setField(_SenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  SpeedBookingField? _SenderName;
  SpeedBookingField get SenderName {
    return _SenderName = _setField(_SenderName, 'SenderName', DbType.text);
  }

  SpeedBookingField? _SenderAddress;
  SpeedBookingField get SenderAddress {
    return _SenderAddress =
        _setField(_SenderAddress, 'SenderAddress', DbType.text);
  }

  SpeedBookingField? _SenderCity;
  SpeedBookingField get SenderCity {
    return _SenderCity = _setField(_SenderCity, 'SenderCity', DbType.text);
  }

  SpeedBookingField? _SenderState;
  SpeedBookingField get SenderState {
    return _SenderState = _setField(_SenderState, 'SenderState', DbType.text);
  }

  SpeedBookingField? _SenderZip;
  SpeedBookingField get SenderZip {
    return _SenderZip = _setField(_SenderZip, 'SenderZip', DbType.text);
  }

  SpeedBookingField? _SenderCountry;
  SpeedBookingField get SenderCountry {
    return _SenderCountry =
        _setField(_SenderCountry, 'SenderCountry', DbType.text);
  }

  SpeedBookingField? _SenderMobile;
  SpeedBookingField get SenderMobile {
    return _SenderMobile =
        _setField(_SenderMobile, 'SenderMobile', DbType.text);
  }

  SpeedBookingField? _RecipientName;
  SpeedBookingField get RecipientName {
    return _RecipientName =
        _setField(_RecipientName, 'RecipientName', DbType.text);
  }

  SpeedBookingField? _RecipientAddress;
  SpeedBookingField get RecipientAddress {
    return _RecipientAddress =
        _setField(_RecipientAddress, 'RecipientAddress', DbType.text);
  }

  SpeedBookingField? _RecipientCity;
  SpeedBookingField get RecipientCity {
    return _RecipientCity =
        _setField(_RecipientCity, 'RecipientCity', DbType.text);
  }

  SpeedBookingField? _RecipientState;
  SpeedBookingField get RecipientState {
    return _RecipientState =
        _setField(_RecipientState, 'RecipientState', DbType.text);
  }

  SpeedBookingField? _RecipientZip;
  SpeedBookingField get RecipientZip {
    return _RecipientZip =
        _setField(_RecipientZip, 'RecipientZip', DbType.text);
  }

  SpeedBookingField? _RecipientCountryID;
  SpeedBookingField get RecipientCountryID {
    return _RecipientCountryID =
        _setField(_RecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  SpeedBookingField? _ReturnName;
  SpeedBookingField get ReturnName {
    return _ReturnName = _setField(_ReturnName, 'ReturnName', DbType.text);
  }

  SpeedBookingField? _ReturnAddress;
  SpeedBookingField get ReturnAddress {
    return _ReturnAddress =
        _setField(_ReturnAddress, 'ReturnAddress', DbType.text);
  }

  SpeedBookingField? _ReturnCity;
  SpeedBookingField get ReturnCity {
    return _ReturnCity = _setField(_ReturnCity, 'ReturnCity', DbType.text);
  }

  SpeedBookingField? _ReturnState;
  SpeedBookingField get ReturnState {
    return _ReturnState = _setField(_ReturnState, 'ReturnState', DbType.text);
  }

  SpeedBookingField? _ReturnZip;
  SpeedBookingField get ReturnZip {
    return _ReturnZip = _setField(_ReturnZip, 'ReturnZip', DbType.text);
  }

  SpeedBookingField? _ReturnCountryID;
  SpeedBookingField get ReturnCountryID {
    return _ReturnCountryID =
        _setField(_ReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  SpeedBookingField? _TaxAmount;
  SpeedBookingField get TaxAmount {
    return _TaxAmount = _setField(_TaxAmount, 'TaxAmount', DbType.text);
  }

  SpeedBookingField? _PostageDue;
  SpeedBookingField get PostageDue {
    return _PostageDue = _setField(_PostageDue, 'PostageDue', DbType.text);
  }

  SpeedBookingField? _RepaymentMode;
  SpeedBookingField get RepaymentMode {
    return _RepaymentMode =
        _setField(_RepaymentMode, 'RepaymentMode', DbType.text);
  }

  SpeedBookingField? _PrepaidAmount;
  SpeedBookingField get PrepaidAmount {
    return _PrepaidAmount =
        _setField(_PrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  SpeedBookingField? _MaterialGroup;
  SpeedBookingField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  SpeedBookingField? _DestinationFacility;
  SpeedBookingField get DestinationFacility {
    return _DestinationFacility =
        _setField(_DestinationFacility, 'DestinationFacility', DbType.text);
  }

  SpeedBookingField? _ElapsedTime;
  SpeedBookingField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  SpeedBookingField? _IsFullPrepaid;
  SpeedBookingField get IsFullPrepaid {
    return _IsFullPrepaid =
        _setField(_IsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  SpeedBookingField? _VAS;
  SpeedBookingField get VAS {
    return _VAS = _setField(_VAS, 'VAS', DbType.text);
  }

  SpeedBookingField? _VASValue;
  SpeedBookingField get VASValue {
    return _VASValue = _setField(_VASValue, 'VASValue', DbType.text);
  }

  SpeedBookingField? _Status;
  SpeedBookingField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  SpeedBookingField? _BagNumber;
  SpeedBookingField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  SpeedBookingField? _FileCreated;
  SpeedBookingField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  SpeedBookingField? _FileName;
  SpeedBookingField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  SpeedBookingField? _FileCreatedDateTime;
  SpeedBookingField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  SpeedBookingField? _FileTransmitted;
  SpeedBookingField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  SpeedBookingField? _FileTransmittedDateTime;
  SpeedBookingField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  SpeedBookingField? _CancellationReason;
  SpeedBookingField get CancellationReason {
    return _CancellationReason =
        _setField(_CancellationReason, 'CancellationReason', DbType.text);
  }

  SpeedBookingField? _Authorized;
  SpeedBookingField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<SpeedBooking> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSpeedBooking!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSpeedBooking!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from speedBooking ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSpeedBooking!.updateBatch(qparams, values);
  }

  /// This method always returns [SpeedBooking] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpeedBooking?
  @override
  Future<SpeedBooking?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSpeedBooking!.toList(qparams);
    final data = await objFuture;
    SpeedBooking? obj;
    if (data.isNotEmpty) {
      obj = SpeedBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SpeedBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpeedBooking?
  @override
  Future<SpeedBooking> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SpeedBooking();
  }

  /// This method returns int. [SpeedBooking]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? speedbookingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final speedbookingsFuture = await _mnSpeedBooking!.toList(qparams);
    final int count = speedbookingsFuture[0]['CNT'] as int;
    if (speedbookingCount != null) {
      speedbookingCount(count);
    }
    return count;
  }

  /// This method returns List<SpeedBooking> [SpeedBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SpeedBooking>
  @override
  Future<List<SpeedBooking>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SpeedBooking> speedbookingsData = await SpeedBooking.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return speedbookingsData;
  }

  /// This method returns Json String [SpeedBooking]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SpeedBooking]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SpeedBooking]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSpeedBooking!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SpeedBooking]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM speedBooking WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnSpeedBooking!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SpeedBooking]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSpeedBooking!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SpeedBooking.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSpeedBooking!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SpeedBookingFilterBuilder

// region SpeedBookingFields
class SpeedBookingFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserID;
  static TableField get UserID {
    return _fUserID =
        _fUserID ?? SqlSyntax.setField(_fUserID, 'UserID', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyID;
  static TableField get CurrencyID {
    return _fCurrencyID = _fCurrencyID ??
        SqlSyntax.setField(_fCurrencyID, 'CurrencyID', DbType.text);
  }

  static TableField? _fTenderID;
  static TableField get TenderID {
    return _fTenderID =
        _fTenderID ?? SqlSyntax.setField(_fTenderID, 'TenderID', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fWeightCode;
  static TableField get WeightCode {
    return _fWeightCode = _fWeightCode ??
        SqlSyntax.setField(_fWeightCode, 'WeightCode', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fDistanceCode;
  static TableField get DistanceCode {
    return _fDistanceCode = _fDistanceCode ??
        SqlSyntax.setField(_fDistanceCode, 'DistanceCode', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerNumber;
  static TableField get SenderCustomerNumber {
    return _fSenderCustomerNumber = _fSenderCustomerNumber ??
        SqlSyntax.setField(
            _fSenderCustomerNumber, 'SenderCustomerNumber', DbType.text);
  }

  static TableField? _fSenderName;
  static TableField get SenderName {
    return _fSenderName = _fSenderName ??
        SqlSyntax.setField(_fSenderName, 'SenderName', DbType.text);
  }

  static TableField? _fSenderAddress;
  static TableField get SenderAddress {
    return _fSenderAddress = _fSenderAddress ??
        SqlSyntax.setField(_fSenderAddress, 'SenderAddress', DbType.text);
  }

  static TableField? _fSenderCity;
  static TableField get SenderCity {
    return _fSenderCity = _fSenderCity ??
        SqlSyntax.setField(_fSenderCity, 'SenderCity', DbType.text);
  }

  static TableField? _fSenderState;
  static TableField get SenderState {
    return _fSenderState = _fSenderState ??
        SqlSyntax.setField(_fSenderState, 'SenderState', DbType.text);
  }

  static TableField? _fSenderZip;
  static TableField get SenderZip {
    return _fSenderZip = _fSenderZip ??
        SqlSyntax.setField(_fSenderZip, 'SenderZip', DbType.text);
  }

  static TableField? _fSenderCountry;
  static TableField get SenderCountry {
    return _fSenderCountry = _fSenderCountry ??
        SqlSyntax.setField(_fSenderCountry, 'SenderCountry', DbType.text);
  }

  static TableField? _fSenderMobile;
  static TableField get SenderMobile {
    return _fSenderMobile = _fSenderMobile ??
        SqlSyntax.setField(_fSenderMobile, 'SenderMobile', DbType.text);
  }

  static TableField? _fRecipientName;
  static TableField get RecipientName {
    return _fRecipientName = _fRecipientName ??
        SqlSyntax.setField(_fRecipientName, 'RecipientName', DbType.text);
  }

  static TableField? _fRecipientAddress;
  static TableField get RecipientAddress {
    return _fRecipientAddress = _fRecipientAddress ??
        SqlSyntax.setField(_fRecipientAddress, 'RecipientAddress', DbType.text);
  }

  static TableField? _fRecipientCity;
  static TableField get RecipientCity {
    return _fRecipientCity = _fRecipientCity ??
        SqlSyntax.setField(_fRecipientCity, 'RecipientCity', DbType.text);
  }

  static TableField? _fRecipientState;
  static TableField get RecipientState {
    return _fRecipientState = _fRecipientState ??
        SqlSyntax.setField(_fRecipientState, 'RecipientState', DbType.text);
  }

  static TableField? _fRecipientZip;
  static TableField get RecipientZip {
    return _fRecipientZip = _fRecipientZip ??
        SqlSyntax.setField(_fRecipientZip, 'RecipientZip', DbType.text);
  }

  static TableField? _fRecipientCountryID;
  static TableField get RecipientCountryID {
    return _fRecipientCountryID = _fRecipientCountryID ??
        SqlSyntax.setField(
            _fRecipientCountryID, 'RecipientCountryID', DbType.text);
  }

  static TableField? _fReturnName;
  static TableField get ReturnName {
    return _fReturnName = _fReturnName ??
        SqlSyntax.setField(_fReturnName, 'ReturnName', DbType.text);
  }

  static TableField? _fReturnAddress;
  static TableField get ReturnAddress {
    return _fReturnAddress = _fReturnAddress ??
        SqlSyntax.setField(_fReturnAddress, 'ReturnAddress', DbType.text);
  }

  static TableField? _fReturnCity;
  static TableField get ReturnCity {
    return _fReturnCity = _fReturnCity ??
        SqlSyntax.setField(_fReturnCity, 'ReturnCity', DbType.text);
  }

  static TableField? _fReturnState;
  static TableField get ReturnState {
    return _fReturnState = _fReturnState ??
        SqlSyntax.setField(_fReturnState, 'ReturnState', DbType.text);
  }

  static TableField? _fReturnZip;
  static TableField get ReturnZip {
    return _fReturnZip = _fReturnZip ??
        SqlSyntax.setField(_fReturnZip, 'ReturnZip', DbType.text);
  }

  static TableField? _fReturnCountryID;
  static TableField get ReturnCountryID {
    return _fReturnCountryID = _fReturnCountryID ??
        SqlSyntax.setField(_fReturnCountryID, 'ReturnCountryID', DbType.text);
  }

  static TableField? _fTaxAmount;
  static TableField get TaxAmount {
    return _fTaxAmount = _fTaxAmount ??
        SqlSyntax.setField(_fTaxAmount, 'TaxAmount', DbType.text);
  }

  static TableField? _fPostageDue;
  static TableField get PostageDue {
    return _fPostageDue = _fPostageDue ??
        SqlSyntax.setField(_fPostageDue, 'PostageDue', DbType.text);
  }

  static TableField? _fRepaymentMode;
  static TableField get RepaymentMode {
    return _fRepaymentMode = _fRepaymentMode ??
        SqlSyntax.setField(_fRepaymentMode, 'RepaymentMode', DbType.text);
  }

  static TableField? _fPrepaidAmount;
  static TableField get PrepaidAmount {
    return _fPrepaidAmount = _fPrepaidAmount ??
        SqlSyntax.setField(_fPrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacility;
  static TableField get DestinationFacility {
    return _fDestinationFacility = _fDestinationFacility ??
        SqlSyntax.setField(
            _fDestinationFacility, 'DestinationFacility', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fIsFullPrepaid;
  static TableField get IsFullPrepaid {
    return _fIsFullPrepaid = _fIsFullPrepaid ??
        SqlSyntax.setField(_fIsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  static TableField? _fVAS;
  static TableField get VAS {
    return _fVAS = _fVAS ?? SqlSyntax.setField(_fVAS, 'VAS', DbType.text);
  }

  static TableField? _fVASValue;
  static TableField get VASValue {
    return _fVASValue =
        _fVASValue ?? SqlSyntax.setField(_fVASValue, 'VASValue', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fCancellationReason;
  static TableField get CancellationReason {
    return _fCancellationReason = _fCancellationReason ??
        SqlSyntax.setField(
            _fCancellationReason, 'CancellationReason', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion SpeedBookingFields

//region SpeedBookingManager
class SpeedBookingManager extends SqfEntityProvider {
  SpeedBookingManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'speedBooking';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion SpeedBookingManager
// region ProductsMaster
class ProductsMaster extends TableBase {
  ProductsMaster(
      {this.id,
      this.ItemCode,
      this.ShortDescription,
      this.CategoryDescription,
      this.SalePrice,
      this.EffStartDate,
      this.EffEndDate,
      this.POSCurrentStock,
      this.OpeningStock,
      this.Division,
      this.OrderType,
      this.MaterialGroup,
      this.UnitMeasurement,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ProductsMaster.withFields(
      this.ItemCode,
      this.ShortDescription,
      this.CategoryDescription,
      this.SalePrice,
      this.EffStartDate,
      this.EffEndDate,
      this.POSCurrentStock,
      this.OpeningStock,
      this.Division,
      this.OrderType,
      this.MaterialGroup,
      this.UnitMeasurement,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.Identifier) {
    _setDefaultValues();
  }
  ProductsMaster.withId(
      this.id,
      this.ItemCode,
      this.ShortDescription,
      this.CategoryDescription,
      this.SalePrice,
      this.EffStartDate,
      this.EffEndDate,
      this.POSCurrentStock,
      this.OpeningStock,
      this.Division,
      this.OrderType,
      this.MaterialGroup,
      this.UnitMeasurement,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ProductsMaster.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ItemCode'] != null) {
      ItemCode = o['ItemCode'].toString();
    }
    if (o['ShortDescription'] != null) {
      ShortDescription = o['ShortDescription'].toString();
    }
    if (o['CategoryDescription'] != null) {
      CategoryDescription = o['CategoryDescription'].toString();
    }
    if (o['SalePrice'] != null) {
      SalePrice = o['SalePrice'].toString();
    }
    if (o['EffStartDate'] != null) {
      EffStartDate = o['EffStartDate'].toString();
    }
    if (o['EffEndDate'] != null) {
      EffEndDate = o['EffEndDate'].toString();
    }
    if (o['POSCurrentStock'] != null) {
      POSCurrentStock = o['POSCurrentStock'].toString();
    }
    if (o['OpeningStock'] != null) {
      OpeningStock = o['OpeningStock'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['UnitMeasurement'] != null) {
      UnitMeasurement = o['UnitMeasurement'].toString();
    }
    if (o['CreatedBy'] != null) {
      CreatedBy = o['CreatedBy'].toString();
    }
    if (o['CreatedOn'] != null) {
      CreatedOn = o['CreatedOn'].toString();
    }
    if (o['ModifiedBy'] != null) {
      ModifiedBy = o['ModifiedBy'].toString();
    }
    if (o['ModifiedOn'] != null) {
      ModifiedOn = o['ModifiedOn'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (ProductsMaster)
  int? id;
  String? ItemCode;
  String? ShortDescription;
  String? CategoryDescription;
  String? SalePrice;
  String? EffStartDate;
  String? EffEndDate;
  String? POSCurrentStock;
  String? OpeningStock;
  String? Division;
  String? OrderType;
  String? MaterialGroup;
  String? UnitMeasurement;
  String? CreatedBy;
  String? CreatedOn;
  String? ModifiedBy;
  String? ModifiedOn;
  String? Identifier;

  // end FIELDS (ProductsMaster)

  static const bool _softDeleteActivated = false;
  ProductsMasterManager? __mnProductsMaster;

  ProductsMasterManager get _mnProductsMaster {
    return __mnProductsMaster = __mnProductsMaster ?? ProductsMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ItemCode != null || !forView) {
      map['ItemCode'] = ItemCode;
    }
    if (ShortDescription != null || !forView) {
      map['ShortDescription'] = ShortDescription;
    }
    if (CategoryDescription != null || !forView) {
      map['CategoryDescription'] = CategoryDescription;
    }
    if (SalePrice != null || !forView) {
      map['SalePrice'] = SalePrice;
    }
    if (EffStartDate != null || !forView) {
      map['EffStartDate'] = EffStartDate;
    }
    if (EffEndDate != null || !forView) {
      map['EffEndDate'] = EffEndDate;
    }
    if (POSCurrentStock != null || !forView) {
      map['POSCurrentStock'] = POSCurrentStock;
    }
    if (OpeningStock != null || !forView) {
      map['OpeningStock'] = OpeningStock;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (UnitMeasurement != null || !forView) {
      map['UnitMeasurement'] = UnitMeasurement;
    }
    if (CreatedBy != null || !forView) {
      map['CreatedBy'] = CreatedBy;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (ModifiedBy != null || !forView) {
      map['ModifiedBy'] = ModifiedBy;
    }
    if (ModifiedOn != null || !forView) {
      map['ModifiedOn'] = ModifiedOn;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ItemCode != null || !forView) {
      map['ItemCode'] = ItemCode;
    }
    if (ShortDescription != null || !forView) {
      map['ShortDescription'] = ShortDescription;
    }
    if (CategoryDescription != null || !forView) {
      map['CategoryDescription'] = CategoryDescription;
    }
    if (SalePrice != null || !forView) {
      map['SalePrice'] = SalePrice;
    }
    if (EffStartDate != null || !forView) {
      map['EffStartDate'] = EffStartDate;
    }
    if (EffEndDate != null || !forView) {
      map['EffEndDate'] = EffEndDate;
    }
    if (POSCurrentStock != null || !forView) {
      map['POSCurrentStock'] = POSCurrentStock;
    }
    if (OpeningStock != null || !forView) {
      map['OpeningStock'] = OpeningStock;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (UnitMeasurement != null || !forView) {
      map['UnitMeasurement'] = UnitMeasurement;
    }
    if (CreatedBy != null || !forView) {
      map['CreatedBy'] = CreatedBy;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (ModifiedBy != null || !forView) {
      map['ModifiedBy'] = ModifiedBy;
    }
    if (ModifiedOn != null || !forView) {
      map['ModifiedOn'] = ModifiedOn;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [ProductsMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ProductsMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ItemCode,
      ShortDescription,
      CategoryDescription,
      SalePrice,
      EffStartDate,
      EffEndDate,
      POSCurrentStock,
      OpeningStock,
      Division,
      OrderType,
      MaterialGroup,
      UnitMeasurement,
      CreatedBy,
      CreatedOn,
      ModifiedBy,
      ModifiedOn,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ItemCode,
      ShortDescription,
      CategoryDescription,
      SalePrice,
      EffStartDate,
      EffEndDate,
      POSCurrentStock,
      OpeningStock,
      Division,
      OrderType,
      MaterialGroup,
      UnitMeasurement,
      CreatedBy,
      CreatedOn,
      ModifiedBy,
      ModifiedOn,
      Identifier
    ];
  }

  static Future<List<ProductsMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductsMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ProductsMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ProductsMaster>[];
    try {
      objList = list
          .map((productsmaster) =>
              ProductsMaster.fromMap(productsmaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductsMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ProductsMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ProductsMaster> objList = <ProductsMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ProductsMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ProductsMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ProductsMaster] if exist, otherwise returns null
  Future<ProductsMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ProductsMaster? obj;
    final data = await _mnProductsMaster.getById([id]);
    if (data.length != 0) {
      obj = ProductsMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ProductsMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProductsMaster.insert(this, ignoreBatch);
    } else {
      await _mnProductsMaster.update(this);
    }

    return id;
  }

  /// Saves the (ProductsMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnProductsMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnProductsMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ProductsMaster. Returns a new Primary Key value of ProductsMaster

  /// <returns>Returns a new Primary Key value of ProductsMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ProductsMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ProductsMaster> productsmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in productsmasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < productsmasters.length; i++) {
        if (productsmasters[i].id == null) {
          productsmasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductsMaster.rawInsert(
          'INSERT OR REPLACE INTO productsMaster (id, ItemCode, ShortDescription, CategoryDescription, SalePrice, EffStartDate, EffEndDate, POSCurrentStock, OpeningStock, Division, OrderType, MaterialGroup, UnitMeasurement, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ItemCode,
            ShortDescription,
            CategoryDescription,
            SalePrice,
            EffStartDate,
            EffEndDate,
            POSCurrentStock,
            OpeningStock,
            Division,
            OrderType,
            MaterialGroup,
            UnitMeasurement,
            CreatedBy,
            CreatedOn,
            ModifiedBy,
            ModifiedOn,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ProductsMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductsMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductsMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductsMaster.rawInsert(
          'INSERT OR IGNORE INTO productsMaster (id, ItemCode, ShortDescription, CategoryDescription, SalePrice, EffStartDate, EffEndDate, POSCurrentStock, OpeningStock, Division, OrderType, MaterialGroup, UnitMeasurement, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ItemCode,
            ShortDescription,
            CategoryDescription,
            SalePrice,
            EffStartDate,
            EffEndDate,
            POSCurrentStock,
            OpeningStock,
            Division,
            OrderType,
            MaterialGroup,
            UnitMeasurement,
            CreatedBy,
            CreatedOn,
            ModifiedBy,
            ModifiedOn,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ProductsMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductsMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductsMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ProductsMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ProductsMaster> productsmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnProductsMaster.rawInsertAll(
        'INSERT OR REPLACE INTO productsMaster (id, ItemCode, ShortDescription, CategoryDescription, SalePrice, EffStartDate, EffEndDate, POSCurrentStock, OpeningStock, Division, OrderType, MaterialGroup, UnitMeasurement, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        productsmasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ProductsMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ProductsMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnProductsMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnProductsMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ProductsMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ProductsMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductsMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProductsMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductsMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion productsmaster

// region ProductsMasterField
class ProductsMasterField extends FilterBase {
  ProductsMasterField(ProductsMasterFilterBuilder productsmasterFB)
      : super(productsmasterFB);

  @override
  ProductsMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder isNull() {
    return super.isNull() as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProductsMasterFilterBuilder;
  }

  @override
  ProductsMasterField get not {
    return super.not as ProductsMasterField;
  }
}
// endregion ProductsMasterField

// region ProductsMasterFilterBuilder
class ProductsMasterFilterBuilder extends ConjunctionBase {
  ProductsMasterFilterBuilder(ProductsMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProductsMaster = obj._mnProductsMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProductsMasterManager? _mnProductsMaster;

  /// put the sql keyword 'AND'
  @override
  ProductsMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProductsMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProductsMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProductsMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProductsMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProductsMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProductsMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductsMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductsMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductsMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductsMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProductsMasterField _setField(
      ProductsMasterField? field, String colName, DbType dbtype) {
    return ProductsMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProductsMasterField? _id;
  ProductsMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ProductsMasterField? _ItemCode;
  ProductsMasterField get ItemCode {
    return _ItemCode = _setField(_ItemCode, 'ItemCode', DbType.text);
  }

  ProductsMasterField? _ShortDescription;
  ProductsMasterField get ShortDescription {
    return _ShortDescription =
        _setField(_ShortDescription, 'ShortDescription', DbType.text);
  }

  ProductsMasterField? _CategoryDescription;
  ProductsMasterField get CategoryDescription {
    return _CategoryDescription =
        _setField(_CategoryDescription, 'CategoryDescription', DbType.text);
  }

  ProductsMasterField? _SalePrice;
  ProductsMasterField get SalePrice {
    return _SalePrice = _setField(_SalePrice, 'SalePrice', DbType.text);
  }

  ProductsMasterField? _EffStartDate;
  ProductsMasterField get EffStartDate {
    return _EffStartDate =
        _setField(_EffStartDate, 'EffStartDate', DbType.text);
  }

  ProductsMasterField? _EffEndDate;
  ProductsMasterField get EffEndDate {
    return _EffEndDate = _setField(_EffEndDate, 'EffEndDate', DbType.text);
  }

  ProductsMasterField? _POSCurrentStock;
  ProductsMasterField get POSCurrentStock {
    return _POSCurrentStock =
        _setField(_POSCurrentStock, 'POSCurrentStock', DbType.text);
  }

  ProductsMasterField? _OpeningStock;
  ProductsMasterField get OpeningStock {
    return _OpeningStock =
        _setField(_OpeningStock, 'OpeningStock', DbType.text);
  }

  ProductsMasterField? _Division;
  ProductsMasterField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  ProductsMasterField? _OrderType;
  ProductsMasterField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  ProductsMasterField? _MaterialGroup;
  ProductsMasterField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  ProductsMasterField? _UnitMeasurement;
  ProductsMasterField get UnitMeasurement {
    return _UnitMeasurement =
        _setField(_UnitMeasurement, 'UnitMeasurement', DbType.text);
  }

  ProductsMasterField? _CreatedBy;
  ProductsMasterField get CreatedBy {
    return _CreatedBy = _setField(_CreatedBy, 'CreatedBy', DbType.text);
  }

  ProductsMasterField? _CreatedOn;
  ProductsMasterField get CreatedOn {
    return _CreatedOn = _setField(_CreatedOn, 'CreatedOn', DbType.text);
  }

  ProductsMasterField? _ModifiedBy;
  ProductsMasterField get ModifiedBy {
    return _ModifiedBy = _setField(_ModifiedBy, 'ModifiedBy', DbType.text);
  }

  ProductsMasterField? _ModifiedOn;
  ProductsMasterField get ModifiedOn {
    return _ModifiedOn = _setField(_ModifiedOn, 'ModifiedOn', DbType.text);
  }

  ProductsMasterField? _Identifier;
  ProductsMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<ProductsMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProductsMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProductsMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from productsMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProductsMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [ProductsMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductsMaster?
  @override
  Future<ProductsMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProductsMaster!.toList(qparams);
    final data = await objFuture;
    ProductsMaster? obj;
    if (data.isNotEmpty) {
      obj = ProductsMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ProductsMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductsMaster?
  @override
  Future<ProductsMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ProductsMaster();
  }

  /// This method returns int. [ProductsMaster]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? productsmasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productsmastersFuture = await _mnProductsMaster!.toList(qparams);
    final int count = productsmastersFuture[0]['CNT'] as int;
    if (productsmasterCount != null) {
      productsmasterCount(count);
    }
    return count;
  }

  /// This method returns List<ProductsMaster> [ProductsMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ProductsMaster>
  @override
  Future<List<ProductsMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ProductsMaster> productsmastersData =
        await ProductsMaster.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return productsmastersData;
  }

  /// This method returns Json String [ProductsMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ProductsMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ProductsMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProductsMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ProductsMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM productsMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnProductsMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ProductsMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProductsMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ProductsMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProductsMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductsMasterFilterBuilder

// region ProductsMasterFields
class ProductsMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fItemCode;
  static TableField get ItemCode {
    return _fItemCode =
        _fItemCode ?? SqlSyntax.setField(_fItemCode, 'ItemCode', DbType.text);
  }

  static TableField? _fShortDescription;
  static TableField get ShortDescription {
    return _fShortDescription = _fShortDescription ??
        SqlSyntax.setField(_fShortDescription, 'ShortDescription', DbType.text);
  }

  static TableField? _fCategoryDescription;
  static TableField get CategoryDescription {
    return _fCategoryDescription = _fCategoryDescription ??
        SqlSyntax.setField(
            _fCategoryDescription, 'CategoryDescription', DbType.text);
  }

  static TableField? _fSalePrice;
  static TableField get SalePrice {
    return _fSalePrice = _fSalePrice ??
        SqlSyntax.setField(_fSalePrice, 'SalePrice', DbType.text);
  }

  static TableField? _fEffStartDate;
  static TableField get EffStartDate {
    return _fEffStartDate = _fEffStartDate ??
        SqlSyntax.setField(_fEffStartDate, 'EffStartDate', DbType.text);
  }

  static TableField? _fEffEndDate;
  static TableField get EffEndDate {
    return _fEffEndDate = _fEffEndDate ??
        SqlSyntax.setField(_fEffEndDate, 'EffEndDate', DbType.text);
  }

  static TableField? _fPOSCurrentStock;
  static TableField get POSCurrentStock {
    return _fPOSCurrentStock = _fPOSCurrentStock ??
        SqlSyntax.setField(_fPOSCurrentStock, 'POSCurrentStock', DbType.text);
  }

  static TableField? _fOpeningStock;
  static TableField get OpeningStock {
    return _fOpeningStock = _fOpeningStock ??
        SqlSyntax.setField(_fOpeningStock, 'OpeningStock', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fUnitMeasurement;
  static TableField get UnitMeasurement {
    return _fUnitMeasurement = _fUnitMeasurement ??
        SqlSyntax.setField(_fUnitMeasurement, 'UnitMeasurement', DbType.text);
  }

  static TableField? _fCreatedBy;
  static TableField get CreatedBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'CreatedBy', DbType.text);
  }

  static TableField? _fCreatedOn;
  static TableField get CreatedOn {
    return _fCreatedOn = _fCreatedOn ??
        SqlSyntax.setField(_fCreatedOn, 'CreatedOn', DbType.text);
  }

  static TableField? _fModifiedBy;
  static TableField get ModifiedBy {
    return _fModifiedBy = _fModifiedBy ??
        SqlSyntax.setField(_fModifiedBy, 'ModifiedBy', DbType.text);
  }

  static TableField? _fModifiedOn;
  static TableField get ModifiedOn {
    return _fModifiedOn = _fModifiedOn ??
        SqlSyntax.setField(_fModifiedOn, 'ModifiedOn', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion ProductsMasterFields

//region ProductsMasterManager
class ProductsMasterManager extends SqfEntityProvider {
  ProductsMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'productsMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ProductsMasterManager
// region EmoMOCommission
class EmoMOCommission extends TableBase {
  EmoMOCommission(
      {this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  EmoMOCommission.withFields(
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  EmoMOCommission.withId(
      this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  EmoMOCommission.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Commission'] != null) {
      Commission = o['Commission'].toString();
    }
    if (o['MinimumAmount'] != null) {
      MinimumAmount = o['MinimumAmount'].toString();
    }
    if (o['MaximumAmount'] != null) {
      MaximumAmount = o['MaximumAmount'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['AdditionalService'] != null) {
      AdditionalService = o['AdditionalService'].toString();
    }
    if (o['ValueID'] != null) {
      ValueID = o['ValueID'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (EmoMOCommission)
  int? id;
  String? Commission;
  String? MinimumAmount;
  String? MaximumAmount;
  String? CommissionAmount;
  String? AdditionalService;
  String? ValueID;
  String? Identifier;

  // end FIELDS (EmoMOCommission)

  static const bool _softDeleteActivated = false;
  EmoMOCommissionManager? __mnEmoMOCommission;

  EmoMOCommissionManager get _mnEmoMOCommission {
    return __mnEmoMOCommission =
        __mnEmoMOCommission ?? EmoMOCommissionManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [EmoMOCommission]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [EmoMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  static Future<List<EmoMOCommission>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EmoMOCommission.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<EmoMOCommission>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <EmoMOCommission>[];
    try {
      objList = list
          .map((emomocommission) =>
              EmoMOCommission.fromMap(emomocommission as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR EmoMOCommission.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<EmoMOCommission>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<EmoMOCommission> objList = <EmoMOCommission>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = EmoMOCommission.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns EmoMOCommission by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [EmoMOCommission] if exist, otherwise returns null
  Future<EmoMOCommission?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    EmoMOCommission? obj;
    final data = await _mnEmoMOCommission.getById([id]);
    if (data.length != 0) {
      obj = EmoMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (EmoMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnEmoMOCommission.insert(this, ignoreBatch);
    } else {
      await _mnEmoMOCommission.update(this);
    }

    return id;
  }

  /// Saves the (EmoMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnEmoMOCommission.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnEmoMOCommission.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs EmoMOCommission. Returns a new Primary Key value of EmoMOCommission

  /// <returns>Returns a new Primary Key value of EmoMOCommission
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<EmoMOCommission> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<EmoMOCommission> emomocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in emomocommissions) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < emomocommissions.length; i++) {
        if (emomocommissions[i].id == null) {
          emomocommissions[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEmoMOCommission.rawInsert(
          'INSERT OR REPLACE INTO emoMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'EmoMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'EmoMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EmoMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnEmoMOCommission.rawInsert(
          'INSERT OR IGNORE INTO emoMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'EmoMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'EmoMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'EmoMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<EmoMOCommission>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<EmoMOCommission> emomocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnEmoMOCommission.rawInsertAll(
        'INSERT OR REPLACE INTO emoMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
        emomocommissions,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes EmoMOCommission

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete EmoMOCommission invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnEmoMOCommission
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnEmoMOCommission.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [EmoMOCommission] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  EmoMOCommissionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmoMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  EmoMOCommissionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return EmoMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion emomocommission

// region EmoMOCommissionField
class EmoMOCommissionField extends FilterBase {
  EmoMOCommissionField(EmoMOCommissionFilterBuilder emomocommissionFB)
      : super(emomocommissionFB);

  @override
  EmoMOCommissionFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder isNull() {
    return super.isNull() as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as EmoMOCommissionFilterBuilder;
  }

  @override
  EmoMOCommissionField get not {
    return super.not as EmoMOCommissionField;
  }
}
// endregion EmoMOCommissionField

// region EmoMOCommissionFilterBuilder
class EmoMOCommissionFilterBuilder extends ConjunctionBase {
  EmoMOCommissionFilterBuilder(EmoMOCommission obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnEmoMOCommission = obj._mnEmoMOCommission;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  EmoMOCommissionManager? _mnEmoMOCommission;

  /// put the sql keyword 'AND'
  @override
  EmoMOCommissionFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  EmoMOCommissionFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  EmoMOCommissionFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  EmoMOCommissionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  EmoMOCommissionFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  EmoMOCommissionFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  EmoMOCommissionFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmoMOCommissionFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmoMOCommissionFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  EmoMOCommissionFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  EmoMOCommissionFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  EmoMOCommissionField _setField(
      EmoMOCommissionField? field, String colName, DbType dbtype) {
    return EmoMOCommissionField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  EmoMOCommissionField? _id;
  EmoMOCommissionField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  EmoMOCommissionField? _Commission;
  EmoMOCommissionField get Commission {
    return _Commission = _setField(_Commission, 'Commission', DbType.text);
  }

  EmoMOCommissionField? _MinimumAmount;
  EmoMOCommissionField get MinimumAmount {
    return _MinimumAmount =
        _setField(_MinimumAmount, 'MinimumAmount', DbType.text);
  }

  EmoMOCommissionField? _MaximumAmount;
  EmoMOCommissionField get MaximumAmount {
    return _MaximumAmount =
        _setField(_MaximumAmount, 'MaximumAmount', DbType.text);
  }

  EmoMOCommissionField? _CommissionAmount;
  EmoMOCommissionField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  EmoMOCommissionField? _AdditionalService;
  EmoMOCommissionField get AdditionalService {
    return _AdditionalService =
        _setField(_AdditionalService, 'AdditionalService', DbType.text);
  }

  EmoMOCommissionField? _ValueID;
  EmoMOCommissionField get ValueID {
    return _ValueID = _setField(_ValueID, 'ValueID', DbType.text);
  }

  EmoMOCommissionField? _Identifier;
  EmoMOCommissionField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<EmoMOCommission> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnEmoMOCommission!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnEmoMOCommission!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from emoMOCommission ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnEmoMOCommission!.updateBatch(qparams, values);
  }

  /// This method always returns [EmoMOCommission] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EmoMOCommission?
  @override
  Future<EmoMOCommission?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnEmoMOCommission!.toList(qparams);
    final data = await objFuture;
    EmoMOCommission? obj;
    if (data.isNotEmpty) {
      obj = EmoMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [EmoMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> EmoMOCommission?
  @override
  Future<EmoMOCommission> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        EmoMOCommission();
  }

  /// This method returns int. [EmoMOCommission]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? emomocommissionCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final emomocommissionsFuture = await _mnEmoMOCommission!.toList(qparams);
    final int count = emomocommissionsFuture[0]['CNT'] as int;
    if (emomocommissionCount != null) {
      emomocommissionCount(count);
    }
    return count;
  }

  /// This method returns List<EmoMOCommission> [EmoMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<EmoMOCommission>
  @override
  Future<List<EmoMOCommission>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<EmoMOCommission> emomocommissionsData =
        await EmoMOCommission.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return emomocommissionsData;
  }

  /// This method returns Json String [EmoMOCommission]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [EmoMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [EmoMOCommission]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnEmoMOCommission!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [EmoMOCommission]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM emoMOCommission WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnEmoMOCommission!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [EmoMOCommission]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnEmoMOCommission!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await EmoMOCommission.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnEmoMOCommission!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion EmoMOCommissionFilterBuilder

// region EmoMOCommissionFields
class EmoMOCommissionFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCommission;
  static TableField get Commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'Commission', DbType.text);
  }

  static TableField? _fMinimumAmount;
  static TableField get MinimumAmount {
    return _fMinimumAmount = _fMinimumAmount ??
        SqlSyntax.setField(_fMinimumAmount, 'MinimumAmount', DbType.text);
  }

  static TableField? _fMaximumAmount;
  static TableField get MaximumAmount {
    return _fMaximumAmount = _fMaximumAmount ??
        SqlSyntax.setField(_fMaximumAmount, 'MaximumAmount', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fAdditionalService;
  static TableField get AdditionalService {
    return _fAdditionalService = _fAdditionalService ??
        SqlSyntax.setField(
            _fAdditionalService, 'AdditionalService', DbType.text);
  }

  static TableField? _fValueID;
  static TableField get ValueID {
    return _fValueID =
        _fValueID ?? SqlSyntax.setField(_fValueID, 'ValueID', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion EmoMOCommissionFields

//region EmoMOCommissionManager
class EmoMOCommissionManager extends SqfEntityProvider {
  EmoMOCommissionManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'emoMOCommission';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion EmoMOCommissionManager
// region InsMOCommission
class InsMOCommission extends TableBase {
  InsMOCommission(
      {this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  InsMOCommission.withFields(
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  InsMOCommission.withId(
      this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  InsMOCommission.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Commission'] != null) {
      Commission = o['Commission'].toString();
    }
    if (o['MinimumAmount'] != null) {
      MinimumAmount = o['MinimumAmount'].toString();
    }
    if (o['MaximumAmount'] != null) {
      MaximumAmount = o['MaximumAmount'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['AdditionalService'] != null) {
      AdditionalService = o['AdditionalService'].toString();
    }
    if (o['ValueID'] != null) {
      ValueID = o['ValueID'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (InsMOCommission)
  int? id;
  String? Commission;
  String? MinimumAmount;
  String? MaximumAmount;
  String? CommissionAmount;
  String? AdditionalService;
  String? ValueID;
  String? Identifier;

  // end FIELDS (InsMOCommission)

  static const bool _softDeleteActivated = false;
  InsMOCommissionManager? __mnInsMOCommission;

  InsMOCommissionManager get _mnInsMOCommission {
    return __mnInsMOCommission =
        __mnInsMOCommission ?? InsMOCommissionManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [InsMOCommission]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [InsMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  static Future<List<InsMOCommission>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InsMOCommission.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<InsMOCommission>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <InsMOCommission>[];
    try {
      objList = list
          .map((insmocommission) =>
              InsMOCommission.fromMap(insmocommission as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR InsMOCommission.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<InsMOCommission>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<InsMOCommission> objList = <InsMOCommission>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = InsMOCommission.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns InsMOCommission by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [InsMOCommission] if exist, otherwise returns null
  Future<InsMOCommission?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    InsMOCommission? obj;
    final data = await _mnInsMOCommission.getById([id]);
    if (data.length != 0) {
      obj = InsMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (InsMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInsMOCommission.insert(this, ignoreBatch);
    } else {
      await _mnInsMOCommission.update(this);
    }

    return id;
  }

  /// Saves the (InsMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnInsMOCommission.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnInsMOCommission.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs InsMOCommission. Returns a new Primary Key value of InsMOCommission

  /// <returns>Returns a new Primary Key value of InsMOCommission
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<InsMOCommission> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<InsMOCommission> insmocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in insmocommissions) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < insmocommissions.length; i++) {
        if (insmocommissions[i].id == null) {
          insmocommissions[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInsMOCommission.rawInsert(
          'INSERT OR REPLACE INTO insMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'InsMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'InsMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'InsMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnInsMOCommission.rawInsert(
          'INSERT OR IGNORE INTO insMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'InsMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'InsMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'InsMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<InsMOCommission>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<InsMOCommission> insmocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnInsMOCommission.rawInsertAll(
        'INSERT OR REPLACE INTO insMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
        insmocommissions,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes InsMOCommission

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete InsMOCommission invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnInsMOCommission
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnInsMOCommission.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [InsMOCommission] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  InsMOCommissionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InsMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  InsMOCommissionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return InsMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion insmocommission

// region InsMOCommissionField
class InsMOCommissionField extends FilterBase {
  InsMOCommissionField(InsMOCommissionFilterBuilder insmocommissionFB)
      : super(insmocommissionFB);

  @override
  InsMOCommissionFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder isNull() {
    return super.isNull() as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as InsMOCommissionFilterBuilder;
  }

  @override
  InsMOCommissionField get not {
    return super.not as InsMOCommissionField;
  }
}
// endregion InsMOCommissionField

// region InsMOCommissionFilterBuilder
class InsMOCommissionFilterBuilder extends ConjunctionBase {
  InsMOCommissionFilterBuilder(InsMOCommission obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnInsMOCommission = obj._mnInsMOCommission;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  InsMOCommissionManager? _mnInsMOCommission;

  /// put the sql keyword 'AND'
  @override
  InsMOCommissionFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  InsMOCommissionFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  InsMOCommissionFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  InsMOCommissionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  InsMOCommissionFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  InsMOCommissionFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  InsMOCommissionFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InsMOCommissionFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InsMOCommissionFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  InsMOCommissionFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  InsMOCommissionFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  InsMOCommissionField _setField(
      InsMOCommissionField? field, String colName, DbType dbtype) {
    return InsMOCommissionField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  InsMOCommissionField? _id;
  InsMOCommissionField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  InsMOCommissionField? _Commission;
  InsMOCommissionField get Commission {
    return _Commission = _setField(_Commission, 'Commission', DbType.text);
  }

  InsMOCommissionField? _MinimumAmount;
  InsMOCommissionField get MinimumAmount {
    return _MinimumAmount =
        _setField(_MinimumAmount, 'MinimumAmount', DbType.text);
  }

  InsMOCommissionField? _MaximumAmount;
  InsMOCommissionField get MaximumAmount {
    return _MaximumAmount =
        _setField(_MaximumAmount, 'MaximumAmount', DbType.text);
  }

  InsMOCommissionField? _CommissionAmount;
  InsMOCommissionField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  InsMOCommissionField? _AdditionalService;
  InsMOCommissionField get AdditionalService {
    return _AdditionalService =
        _setField(_AdditionalService, 'AdditionalService', DbType.text);
  }

  InsMOCommissionField? _ValueID;
  InsMOCommissionField get ValueID {
    return _ValueID = _setField(_ValueID, 'ValueID', DbType.text);
  }

  InsMOCommissionField? _Identifier;
  InsMOCommissionField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<InsMOCommission> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnInsMOCommission!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnInsMOCommission!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from insMOCommission ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnInsMOCommission!.updateBatch(qparams, values);
  }

  /// This method always returns [InsMOCommission] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InsMOCommission?
  @override
  Future<InsMOCommission?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnInsMOCommission!.toList(qparams);
    final data = await objFuture;
    InsMOCommission? obj;
    if (data.isNotEmpty) {
      obj = InsMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [InsMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> InsMOCommission?
  @override
  Future<InsMOCommission> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        InsMOCommission();
  }

  /// This method returns int. [InsMOCommission]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? insmocommissionCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final insmocommissionsFuture = await _mnInsMOCommission!.toList(qparams);
    final int count = insmocommissionsFuture[0]['CNT'] as int;
    if (insmocommissionCount != null) {
      insmocommissionCount(count);
    }
    return count;
  }

  /// This method returns List<InsMOCommission> [InsMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<InsMOCommission>
  @override
  Future<List<InsMOCommission>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<InsMOCommission> insmocommissionsData =
        await InsMOCommission.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return insmocommissionsData;
  }

  /// This method returns Json String [InsMOCommission]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [InsMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [InsMOCommission]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnInsMOCommission!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [InsMOCommission]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM insMOCommission WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnInsMOCommission!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [InsMOCommission]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnInsMOCommission!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await InsMOCommission.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnInsMOCommission!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion InsMOCommissionFilterBuilder

// region InsMOCommissionFields
class InsMOCommissionFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCommission;
  static TableField get Commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'Commission', DbType.text);
  }

  static TableField? _fMinimumAmount;
  static TableField get MinimumAmount {
    return _fMinimumAmount = _fMinimumAmount ??
        SqlSyntax.setField(_fMinimumAmount, 'MinimumAmount', DbType.text);
  }

  static TableField? _fMaximumAmount;
  static TableField get MaximumAmount {
    return _fMaximumAmount = _fMaximumAmount ??
        SqlSyntax.setField(_fMaximumAmount, 'MaximumAmount', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fAdditionalService;
  static TableField get AdditionalService {
    return _fAdditionalService = _fAdditionalService ??
        SqlSyntax.setField(
            _fAdditionalService, 'AdditionalService', DbType.text);
  }

  static TableField? _fValueID;
  static TableField get ValueID {
    return _fValueID =
        _fValueID ?? SqlSyntax.setField(_fValueID, 'ValueID', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion InsMOCommissionFields

//region InsMOCommissionManager
class InsMOCommissionManager extends SqfEntityProvider {
  InsMOCommissionManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'insMOCommission';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion InsMOCommissionManager
// region VppMOCommission
class VppMOCommission extends TableBase {
  VppMOCommission(
      {this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  VppMOCommission.withFields(
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  VppMOCommission.withId(
      this.id,
      this.Commission,
      this.MinimumAmount,
      this.MaximumAmount,
      this.CommissionAmount,
      this.AdditionalService,
      this.ValueID,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  VppMOCommission.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Commission'] != null) {
      Commission = o['Commission'].toString();
    }
    if (o['MinimumAmount'] != null) {
      MinimumAmount = o['MinimumAmount'].toString();
    }
    if (o['MaximumAmount'] != null) {
      MaximumAmount = o['MaximumAmount'].toString();
    }
    if (o['CommissionAmount'] != null) {
      CommissionAmount = o['CommissionAmount'].toString();
    }
    if (o['AdditionalService'] != null) {
      AdditionalService = o['AdditionalService'].toString();
    }
    if (o['ValueID'] != null) {
      ValueID = o['ValueID'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (VppMOCommission)
  int? id;
  String? Commission;
  String? MinimumAmount;
  String? MaximumAmount;
  String? CommissionAmount;
  String? AdditionalService;
  String? ValueID;
  String? Identifier;

  // end FIELDS (VppMOCommission)

  static const bool _softDeleteActivated = false;
  VppMOCommissionManager? __mnVppMOCommission;

  VppMOCommissionManager get _mnVppMOCommission {
    return __mnVppMOCommission =
        __mnVppMOCommission ?? VppMOCommissionManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Commission != null || !forView) {
      map['Commission'] = Commission;
    }
    if (MinimumAmount != null || !forView) {
      map['MinimumAmount'] = MinimumAmount;
    }
    if (MaximumAmount != null || !forView) {
      map['MaximumAmount'] = MaximumAmount;
    }
    if (CommissionAmount != null || !forView) {
      map['CommissionAmount'] = CommissionAmount;
    }
    if (AdditionalService != null || !forView) {
      map['AdditionalService'] = AdditionalService;
    }
    if (ValueID != null || !forView) {
      map['ValueID'] = ValueID;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [VppMOCommission]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [VppMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      Commission,
      MinimumAmount,
      MaximumAmount,
      CommissionAmount,
      AdditionalService,
      ValueID,
      Identifier
    ];
  }

  static Future<List<VppMOCommission>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VppMOCommission.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<VppMOCommission>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <VppMOCommission>[];
    try {
      objList = list
          .map((vppmocommission) =>
              VppMOCommission.fromMap(vppmocommission as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR VppMOCommission.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<VppMOCommission>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<VppMOCommission> objList = <VppMOCommission>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = VppMOCommission.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns VppMOCommission by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [VppMOCommission] if exist, otherwise returns null
  Future<VppMOCommission?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    VppMOCommission? obj;
    final data = await _mnVppMOCommission.getById([id]);
    if (data.length != 0) {
      obj = VppMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (VppMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVppMOCommission.insert(this, ignoreBatch);
    } else {
      await _mnVppMOCommission.update(this);
    }

    return id;
  }

  /// Saves the (VppMOCommission) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnVppMOCommission.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnVppMOCommission.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs VppMOCommission. Returns a new Primary Key value of VppMOCommission

  /// <returns>Returns a new Primary Key value of VppMOCommission
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<VppMOCommission> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<VppMOCommission> vppmocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in vppmocommissions) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < vppmocommissions.length; i++) {
        if (vppmocommissions[i].id == null) {
          vppmocommissions[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVppMOCommission.rawInsert(
          'INSERT OR REPLACE INTO vppMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'VppMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'VppMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'VppMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnVppMOCommission.rawInsert(
          'INSERT OR IGNORE INTO vppMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            Commission,
            MinimumAmount,
            MaximumAmount,
            CommissionAmount,
            AdditionalService,
            ValueID,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'VppMOCommission id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'VppMOCommission id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'VppMOCommission Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<VppMOCommission>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<VppMOCommission> vppmocommissions,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnVppMOCommission.rawInsertAll(
        'INSERT OR REPLACE INTO vppMOCommission (id, Commission, MinimumAmount, MaximumAmount, CommissionAmount, AdditionalService, ValueID, Identifier)  VALUES (?,?,?,?,?,?,?,?)',
        vppmocommissions,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes VppMOCommission

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete VppMOCommission invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnVppMOCommission
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnVppMOCommission.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [VppMOCommission] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  VppMOCommissionFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VppMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  VppMOCommissionFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return VppMOCommissionFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion vppmocommission

// region VppMOCommissionField
class VppMOCommissionField extends FilterBase {
  VppMOCommissionField(VppMOCommissionFilterBuilder vppmocommissionFB)
      : super(vppmocommissionFB);

  @override
  VppMOCommissionFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder isNull() {
    return super.isNull() as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as VppMOCommissionFilterBuilder;
  }

  @override
  VppMOCommissionField get not {
    return super.not as VppMOCommissionField;
  }
}
// endregion VppMOCommissionField

// region VppMOCommissionFilterBuilder
class VppMOCommissionFilterBuilder extends ConjunctionBase {
  VppMOCommissionFilterBuilder(VppMOCommission obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnVppMOCommission = obj._mnVppMOCommission;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  VppMOCommissionManager? _mnVppMOCommission;

  /// put the sql keyword 'AND'
  @override
  VppMOCommissionFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  VppMOCommissionFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  VppMOCommissionFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  VppMOCommissionFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  VppMOCommissionFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  VppMOCommissionFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  VppMOCommissionFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VppMOCommissionFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VppMOCommissionFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  VppMOCommissionFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  VppMOCommissionFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  VppMOCommissionField _setField(
      VppMOCommissionField? field, String colName, DbType dbtype) {
    return VppMOCommissionField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  VppMOCommissionField? _id;
  VppMOCommissionField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  VppMOCommissionField? _Commission;
  VppMOCommissionField get Commission {
    return _Commission = _setField(_Commission, 'Commission', DbType.text);
  }

  VppMOCommissionField? _MinimumAmount;
  VppMOCommissionField get MinimumAmount {
    return _MinimumAmount =
        _setField(_MinimumAmount, 'MinimumAmount', DbType.text);
  }

  VppMOCommissionField? _MaximumAmount;
  VppMOCommissionField get MaximumAmount {
    return _MaximumAmount =
        _setField(_MaximumAmount, 'MaximumAmount', DbType.text);
  }

  VppMOCommissionField? _CommissionAmount;
  VppMOCommissionField get CommissionAmount {
    return _CommissionAmount =
        _setField(_CommissionAmount, 'CommissionAmount', DbType.text);
  }

  VppMOCommissionField? _AdditionalService;
  VppMOCommissionField get AdditionalService {
    return _AdditionalService =
        _setField(_AdditionalService, 'AdditionalService', DbType.text);
  }

  VppMOCommissionField? _ValueID;
  VppMOCommissionField get ValueID {
    return _ValueID = _setField(_ValueID, 'ValueID', DbType.text);
  }

  VppMOCommissionField? _Identifier;
  VppMOCommissionField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<VppMOCommission> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnVppMOCommission!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnVppMOCommission!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from vppMOCommission ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnVppMOCommission!.updateBatch(qparams, values);
  }

  /// This method always returns [VppMOCommission] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VppMOCommission?
  @override
  Future<VppMOCommission?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnVppMOCommission!.toList(qparams);
    final data = await objFuture;
    VppMOCommission? obj;
    if (data.isNotEmpty) {
      obj = VppMOCommission.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [VppMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> VppMOCommission?
  @override
  Future<VppMOCommission> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        VppMOCommission();
  }

  /// This method returns int. [VppMOCommission]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? vppmocommissionCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final vppmocommissionsFuture = await _mnVppMOCommission!.toList(qparams);
    final int count = vppmocommissionsFuture[0]['CNT'] as int;
    if (vppmocommissionCount != null) {
      vppmocommissionCount(count);
    }
    return count;
  }

  /// This method returns List<VppMOCommission> [VppMOCommission]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<VppMOCommission>
  @override
  Future<List<VppMOCommission>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<VppMOCommission> vppmocommissionsData =
        await VppMOCommission.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return vppmocommissionsData;
  }

  /// This method returns Json String [VppMOCommission]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [VppMOCommission]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [VppMOCommission]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnVppMOCommission!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [VppMOCommission]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM vppMOCommission WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnVppMOCommission!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [VppMOCommission]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnVppMOCommission!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await VppMOCommission.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnVppMOCommission!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion VppMOCommissionFilterBuilder

// region VppMOCommissionFields
class VppMOCommissionFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fCommission;
  static TableField get Commission {
    return _fCommission = _fCommission ??
        SqlSyntax.setField(_fCommission, 'Commission', DbType.text);
  }

  static TableField? _fMinimumAmount;
  static TableField get MinimumAmount {
    return _fMinimumAmount = _fMinimumAmount ??
        SqlSyntax.setField(_fMinimumAmount, 'MinimumAmount', DbType.text);
  }

  static TableField? _fMaximumAmount;
  static TableField get MaximumAmount {
    return _fMaximumAmount = _fMaximumAmount ??
        SqlSyntax.setField(_fMaximumAmount, 'MaximumAmount', DbType.text);
  }

  static TableField? _fCommissionAmount;
  static TableField get CommissionAmount {
    return _fCommissionAmount = _fCommissionAmount ??
        SqlSyntax.setField(_fCommissionAmount, 'CommissionAmount', DbType.text);
  }

  static TableField? _fAdditionalService;
  static TableField get AdditionalService {
    return _fAdditionalService = _fAdditionalService ??
        SqlSyntax.setField(
            _fAdditionalService, 'AdditionalService', DbType.text);
  }

  static TableField? _fValueID;
  static TableField get ValueID {
    return _fValueID =
        _fValueID ?? SqlSyntax.setField(_fValueID, 'ValueID', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion VppMOCommissionFields

//region VppMOCommissionManager
class VppMOCommissionManager extends SqfEntityProvider {
  VppMOCommissionManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'vppMOCommission';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion VppMOCommissionManager
// region DistanceMaster
class DistanceMaster extends TableBase {
  DistanceMaster(
      {this.id,
      this.Distance,
      this.MinDistance,
      this.MaxDistance,
      this.Service,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DistanceMaster.withFields(this.Distance, this.MinDistance, this.MaxDistance,
      this.Service, this.Identifier) {
    _setDefaultValues();
  }
  DistanceMaster.withId(this.id, this.Distance, this.MinDistance,
      this.MaxDistance, this.Service, this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DistanceMaster.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['MinDistance'] != null) {
      MinDistance = o['MinDistance'].toString();
    }
    if (o['MaxDistance'] != null) {
      MaxDistance = o['MaxDistance'].toString();
    }
    if (o['Service'] != null) {
      Service = o['Service'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (DistanceMaster)
  int? id;
  String? Distance;
  String? MinDistance;
  String? MaxDistance;
  String? Service;
  String? Identifier;

  // end FIELDS (DistanceMaster)

  static const bool _softDeleteActivated = false;
  DistanceMasterManager? __mnDistanceMaster;

  DistanceMasterManager get _mnDistanceMaster {
    return __mnDistanceMaster = __mnDistanceMaster ?? DistanceMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (MinDistance != null || !forView) {
      map['MinDistance'] = MinDistance;
    }
    if (MaxDistance != null || !forView) {
      map['MaxDistance'] = MaxDistance;
    }
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (MinDistance != null || !forView) {
      map['MinDistance'] = MinDistance;
    }
    if (MaxDistance != null || !forView) {
      map['MaxDistance'] = MaxDistance;
    }
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [DistanceMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DistanceMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Distance, MinDistance, MaxDistance, Service, Identifier];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, Distance, MinDistance, MaxDistance, Service, Identifier];
  }

  static Future<List<DistanceMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DistanceMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DistanceMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DistanceMaster>[];
    try {
      objList = list
          .map((distancemaster) =>
              DistanceMaster.fromMap(distancemaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DistanceMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DistanceMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DistanceMaster> objList = <DistanceMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DistanceMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DistanceMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DistanceMaster] if exist, otherwise returns null
  Future<DistanceMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    DistanceMaster? obj;
    final data = await _mnDistanceMaster.getById([id]);
    if (data.length != 0) {
      obj = DistanceMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DistanceMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnDistanceMaster.insert(this, ignoreBatch);
    } else {
      await _mnDistanceMaster.update(this);
    }

    return id;
  }

  /// Saves the (DistanceMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnDistanceMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDistanceMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs DistanceMaster. Returns a new Primary Key value of DistanceMaster

  /// <returns>Returns a new Primary Key value of DistanceMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<DistanceMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DistanceMaster> distancemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in distancemasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < distancemasters.length; i++) {
        if (distancemasters[i].id == null) {
          distancemasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDistanceMaster.rawInsert(
          'INSERT OR REPLACE INTO distanceMaster (id, Distance, MinDistance, MaxDistance, Service, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, Distance, MinDistance, MaxDistance, Service, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DistanceMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DistanceMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DistanceMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDistanceMaster.rawInsert(
          'INSERT OR IGNORE INTO distanceMaster (id, Distance, MinDistance, MaxDistance, Service, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, Distance, MinDistance, MaxDistance, Service, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DistanceMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DistanceMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DistanceMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<DistanceMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<DistanceMaster> distancemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnDistanceMaster.rawInsertAll(
        'INSERT OR REPLACE INTO distanceMaster (id, Distance, MinDistance, MaxDistance, Service, Identifier)  VALUES (?,?,?,?,?,?)',
        distancemasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes DistanceMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete DistanceMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDistanceMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDistanceMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DistanceMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DistanceMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DistanceMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DistanceMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DistanceMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion distancemaster

// region DistanceMasterField
class DistanceMasterField extends FilterBase {
  DistanceMasterField(DistanceMasterFilterBuilder distancemasterFB)
      : super(distancemasterFB);

  @override
  DistanceMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder isNull() {
    return super.isNull() as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DistanceMasterFilterBuilder;
  }

  @override
  DistanceMasterField get not {
    return super.not as DistanceMasterField;
  }
}
// endregion DistanceMasterField

// region DistanceMasterFilterBuilder
class DistanceMasterFilterBuilder extends ConjunctionBase {
  DistanceMasterFilterBuilder(DistanceMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDistanceMaster = obj._mnDistanceMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DistanceMasterManager? _mnDistanceMaster;

  /// put the sql keyword 'AND'
  @override
  DistanceMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DistanceMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DistanceMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DistanceMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DistanceMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DistanceMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DistanceMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DistanceMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DistanceMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DistanceMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DistanceMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DistanceMasterField _setField(
      DistanceMasterField? field, String colName, DbType dbtype) {
    return DistanceMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DistanceMasterField? _id;
  DistanceMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  DistanceMasterField? _Distance;
  DistanceMasterField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  DistanceMasterField? _MinDistance;
  DistanceMasterField get MinDistance {
    return _MinDistance = _setField(_MinDistance, 'MinDistance', DbType.text);
  }

  DistanceMasterField? _MaxDistance;
  DistanceMasterField get MaxDistance {
    return _MaxDistance = _setField(_MaxDistance, 'MaxDistance', DbType.text);
  }

  DistanceMasterField? _Service;
  DistanceMasterField get Service {
    return _Service = _setField(_Service, 'Service', DbType.text);
  }

  DistanceMasterField? _Identifier;
  DistanceMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<DistanceMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDistanceMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDistanceMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from distanceMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDistanceMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [DistanceMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DistanceMaster?
  @override
  Future<DistanceMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDistanceMaster!.toList(qparams);
    final data = await objFuture;
    DistanceMaster? obj;
    if (data.isNotEmpty) {
      obj = DistanceMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DistanceMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DistanceMaster?
  @override
  Future<DistanceMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DistanceMaster();
  }

  /// This method returns int. [DistanceMaster]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? distancemasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final distancemastersFuture = await _mnDistanceMaster!.toList(qparams);
    final int count = distancemastersFuture[0]['CNT'] as int;
    if (distancemasterCount != null) {
      distancemasterCount(count);
    }
    return count;
  }

  /// This method returns List<DistanceMaster> [DistanceMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DistanceMaster>
  @override
  Future<List<DistanceMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DistanceMaster> distancemastersData =
        await DistanceMaster.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return distancemastersData;
  }

  /// This method returns Json String [DistanceMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DistanceMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DistanceMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDistanceMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DistanceMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM distanceMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnDistanceMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DistanceMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDistanceMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DistanceMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDistanceMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DistanceMasterFilterBuilder

// region DistanceMasterFields
class DistanceMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fMinDistance;
  static TableField get MinDistance {
    return _fMinDistance = _fMinDistance ??
        SqlSyntax.setField(_fMinDistance, 'MinDistance', DbType.text);
  }

  static TableField? _fMaxDistance;
  static TableField get MaxDistance {
    return _fMaxDistance = _fMaxDistance ??
        SqlSyntax.setField(_fMaxDistance, 'MaxDistance', DbType.text);
  }

  static TableField? _fService;
  static TableField get Service {
    return _fService =
        _fService ?? SqlSyntax.setField(_fService, 'Service', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion DistanceMasterFields

//region DistanceMasterManager
class DistanceMasterManager extends SqfEntityProvider {
  DistanceMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'distanceMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion DistanceMasterManager
// region TaxMaster
class TaxMaster extends TableBase {
  TaxMaster(
      {this.id,
      this.Service,
      this.PercentageValue,
      this.TaxDescription,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TaxMaster.withFields(this.Service, this.PercentageValue, this.TaxDescription,
      this.Identifier) {
    _setDefaultValues();
  }
  TaxMaster.withId(this.id, this.Service, this.PercentageValue,
      this.TaxDescription, this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TaxMaster.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Service'] != null) {
      Service = o['Service'].toString();
    }
    if (o['PercentageValue'] != null) {
      PercentageValue = o['PercentageValue'].toString();
    }
    if (o['TaxDescription'] != null) {
      TaxDescription = o['TaxDescription'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (TaxMaster)
  int? id;
  String? Service;
  String? PercentageValue;
  String? TaxDescription;
  String? Identifier;

  // end FIELDS (TaxMaster)

  static const bool _softDeleteActivated = false;
  TaxMasterManager? __mnTaxMaster;

  TaxMasterManager get _mnTaxMaster {
    return __mnTaxMaster = __mnTaxMaster ?? TaxMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (PercentageValue != null || !forView) {
      map['PercentageValue'] = PercentageValue;
    }
    if (TaxDescription != null || !forView) {
      map['TaxDescription'] = TaxDescription;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (PercentageValue != null || !forView) {
      map['PercentageValue'] = PercentageValue;
    }
    if (TaxDescription != null || !forView) {
      map['TaxDescription'] = TaxDescription;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [TaxMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TaxMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Service, PercentageValue, TaxDescription, Identifier];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, Service, PercentageValue, TaxDescription, Identifier];
  }

  static Future<List<TaxMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TaxMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TaxMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TaxMaster>[];
    try {
      objList = list
          .map((taxmaster) =>
              TaxMaster.fromMap(taxmaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TaxMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TaxMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TaxMaster> objList = <TaxMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TaxMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TaxMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TaxMaster] if exist, otherwise returns null
  Future<TaxMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    TaxMaster? obj;
    final data = await _mnTaxMaster.getById([id]);
    if (data.length != 0) {
      obj = TaxMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TaxMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTaxMaster.insert(this, ignoreBatch);
    } else {
      await _mnTaxMaster.update(this);
    }

    return id;
  }

  /// Saves the (TaxMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTaxMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTaxMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs TaxMaster. Returns a new Primary Key value of TaxMaster

  /// <returns>Returns a new Primary Key value of TaxMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<TaxMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TaxMaster> taxmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in taxmasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < taxmasters.length; i++) {
        if (taxmasters[i].id == null) {
          taxmasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTaxMaster.rawInsert(
          'INSERT OR REPLACE INTO taxMaster (id, Service, PercentageValue, TaxDescription, Identifier)  VALUES (?,?,?,?,?)',
          [id, Service, PercentageValue, TaxDescription, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TaxMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TaxMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TaxMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTaxMaster.rawInsert(
          'INSERT OR IGNORE INTO taxMaster (id, Service, PercentageValue, TaxDescription, Identifier)  VALUES (?,?,?,?,?)',
          [id, Service, PercentageValue, TaxDescription, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TaxMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TaxMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TaxMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<TaxMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<TaxMaster> taxmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnTaxMaster.rawInsertAll(
        'INSERT OR REPLACE INTO taxMaster (id, Service, PercentageValue, TaxDescription, Identifier)  VALUES (?,?,?,?,?)',
        taxmasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes TaxMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TaxMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTaxMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTaxMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TaxMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TaxMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TaxMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TaxMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TaxMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion taxmaster

// region TaxMasterField
class TaxMasterField extends FilterBase {
  TaxMasterField(TaxMasterFilterBuilder taxmasterFB) : super(taxmasterFB);

  @override
  TaxMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder isNull() {
    return super.isNull() as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TaxMasterFilterBuilder;
  }

  @override
  TaxMasterField get not {
    return super.not as TaxMasterField;
  }
}
// endregion TaxMasterField

// region TaxMasterFilterBuilder
class TaxMasterFilterBuilder extends ConjunctionBase {
  TaxMasterFilterBuilder(TaxMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTaxMaster = obj._mnTaxMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TaxMasterManager? _mnTaxMaster;

  /// put the sql keyword 'AND'
  @override
  TaxMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TaxMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TaxMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TaxMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TaxMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TaxMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TaxMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TaxMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TaxMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TaxMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TaxMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TaxMasterField _setField(
      TaxMasterField? field, String colName, DbType dbtype) {
    return TaxMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TaxMasterField? _id;
  TaxMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  TaxMasterField? _Service;
  TaxMasterField get Service {
    return _Service = _setField(_Service, 'Service', DbType.text);
  }

  TaxMasterField? _PercentageValue;
  TaxMasterField get PercentageValue {
    return _PercentageValue =
        _setField(_PercentageValue, 'PercentageValue', DbType.text);
  }

  TaxMasterField? _TaxDescription;
  TaxMasterField get TaxDescription {
    return _TaxDescription =
        _setField(_TaxDescription, 'TaxDescription', DbType.text);
  }

  TaxMasterField? _Identifier;
  TaxMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<TaxMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTaxMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTaxMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from taxMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTaxMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [TaxMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TaxMaster?
  @override
  Future<TaxMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTaxMaster!.toList(qparams);
    final data = await objFuture;
    TaxMaster? obj;
    if (data.isNotEmpty) {
      obj = TaxMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TaxMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TaxMaster?
  @override
  Future<TaxMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TaxMaster();
  }

  /// This method returns int. [TaxMaster]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? taxmasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final taxmastersFuture = await _mnTaxMaster!.toList(qparams);
    final int count = taxmastersFuture[0]['CNT'] as int;
    if (taxmasterCount != null) {
      taxmasterCount(count);
    }
    return count;
  }

  /// This method returns List<TaxMaster> [TaxMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TaxMaster>
  @override
  Future<List<TaxMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TaxMaster> taxmastersData = await TaxMaster.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return taxmastersData;
  }

  /// This method returns Json String [TaxMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TaxMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TaxMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTaxMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TaxMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM taxMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnTaxMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TaxMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTaxMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TaxMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTaxMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TaxMasterFilterBuilder

// region TaxMasterFields
class TaxMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fService;
  static TableField get Service {
    return _fService =
        _fService ?? SqlSyntax.setField(_fService, 'Service', DbType.text);
  }

  static TableField? _fPercentageValue;
  static TableField get PercentageValue {
    return _fPercentageValue = _fPercentageValue ??
        SqlSyntax.setField(_fPercentageValue, 'PercentageValue', DbType.text);
  }

  static TableField? _fTaxDescription;
  static TableField get TaxDescription {
    return _fTaxDescription = _fTaxDescription ??
        SqlSyntax.setField(_fTaxDescription, 'TaxDescription', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion TaxMasterFields

//region TaxMasterManager
class TaxMasterManager extends SqfEntityProvider {
  TaxMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'taxMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TaxMasterManager
// region TariffMaster
class TariffMaster extends TableBase {
  TariffMaster(
      {this.id,
      this.Service,
      this.WeightId,
      this.Distance,
      this.BasePrice,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TariffMaster.withFields(this.Service, this.WeightId, this.Distance,
      this.BasePrice, this.Identifier) {
    _setDefaultValues();
  }
  TariffMaster.withId(this.id, this.Service, this.WeightId, this.Distance,
      this.BasePrice, this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TariffMaster.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['Service'] != null) {
      Service = o['Service'].toString();
    }
    if (o['WeightId'] != null) {
      WeightId = o['WeightId'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (TariffMaster)
  int? id;
  String? Service;
  String? WeightId;
  String? Distance;
  String? BasePrice;
  String? Identifier;

  // end FIELDS (TariffMaster)

  static const bool _softDeleteActivated = false;
  TariffMasterManager? __mnTariffMaster;

  TariffMasterManager get _mnTariffMaster {
    return __mnTariffMaster = __mnTariffMaster ?? TariffMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (WeightId != null || !forView) {
      map['WeightId'] = WeightId;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (Service != null || !forView) {
      map['Service'] = Service;
    }
    if (WeightId != null || !forView) {
      map['WeightId'] = WeightId;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [TariffMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TariffMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Service, WeightId, Distance, BasePrice, Identifier];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, Service, WeightId, Distance, BasePrice, Identifier];
  }

  static Future<List<TariffMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TariffMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TariffMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TariffMaster>[];
    try {
      objList = list
          .map((tariffmaster) =>
              TariffMaster.fromMap(tariffmaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TariffMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TariffMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TariffMaster> objList = <TariffMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TariffMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TariffMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TariffMaster] if exist, otherwise returns null
  Future<TariffMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    TariffMaster? obj;
    final data = await _mnTariffMaster.getById([id]);
    if (data.length != 0) {
      obj = TariffMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TariffMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTariffMaster.insert(this, ignoreBatch);
    } else {
      await _mnTariffMaster.update(this);
    }

    return id;
  }

  /// Saves the (TariffMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnTariffMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnTariffMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs TariffMaster. Returns a new Primary Key value of TariffMaster

  /// <returns>Returns a new Primary Key value of TariffMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<TariffMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<TariffMaster> tariffmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in tariffmasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < tariffmasters.length; i++) {
        if (tariffmasters[i].id == null) {
          tariffmasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariffMaster.rawInsert(
          'INSERT OR REPLACE INTO tariffMaster (id, Service, WeightId, Distance, BasePrice, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, Service, WeightId, Distance, BasePrice, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TariffMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TariffMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TariffMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTariffMaster.rawInsert(
          'INSERT OR IGNORE INTO tariffMaster (id, Service, WeightId, Distance, BasePrice, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, Service, WeightId, Distance, BasePrice, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'TariffMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'TariffMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'TariffMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<TariffMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<TariffMaster> tariffmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnTariffMaster.rawInsertAll(
        'INSERT OR REPLACE INTO tariffMaster (id, Service, WeightId, Distance, BasePrice, Identifier)  VALUES (?,?,?,?,?,?)',
        tariffmasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes TariffMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TariffMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTariffMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnTariffMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TariffMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TariffMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TariffMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TariffMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TariffMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tariffmaster

// region TariffMasterField
class TariffMasterField extends FilterBase {
  TariffMasterField(TariffMasterFilterBuilder tariffmasterFB)
      : super(tariffmasterFB);

  @override
  TariffMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder isNull() {
    return super.isNull() as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TariffMasterFilterBuilder;
  }

  @override
  TariffMasterField get not {
    return super.not as TariffMasterField;
  }
}
// endregion TariffMasterField

// region TariffMasterFilterBuilder
class TariffMasterFilterBuilder extends ConjunctionBase {
  TariffMasterFilterBuilder(TariffMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTariffMaster = obj._mnTariffMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TariffMasterManager? _mnTariffMaster;

  /// put the sql keyword 'AND'
  @override
  TariffMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TariffMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TariffMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TariffMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TariffMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TariffMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TariffMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TariffMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TariffMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TariffMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TariffMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TariffMasterField _setField(
      TariffMasterField? field, String colName, DbType dbtype) {
    return TariffMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TariffMasterField? _id;
  TariffMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  TariffMasterField? _Service;
  TariffMasterField get Service {
    return _Service = _setField(_Service, 'Service', DbType.text);
  }

  TariffMasterField? _WeightId;
  TariffMasterField get WeightId {
    return _WeightId = _setField(_WeightId, 'WeightId', DbType.text);
  }

  TariffMasterField? _Distance;
  TariffMasterField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  TariffMasterField? _BasePrice;
  TariffMasterField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  TariffMasterField? _Identifier;
  TariffMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<TariffMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTariffMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTariffMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from tariffMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTariffMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [TariffMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TariffMaster?
  @override
  Future<TariffMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTariffMaster!.toList(qparams);
    final data = await objFuture;
    TariffMaster? obj;
    if (data.isNotEmpty) {
      obj = TariffMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TariffMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TariffMaster?
  @override
  Future<TariffMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TariffMaster();
  }

  /// This method returns int. [TariffMaster]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? tariffmasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tariffmastersFuture = await _mnTariffMaster!.toList(qparams);
    final int count = tariffmastersFuture[0]['CNT'] as int;
    if (tariffmasterCount != null) {
      tariffmasterCount(count);
    }
    return count;
  }

  /// This method returns List<TariffMaster> [TariffMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TariffMaster>
  @override
  Future<List<TariffMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TariffMaster> tariffmastersData = await TariffMaster.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return tariffmastersData;
  }

  /// This method returns Json String [TariffMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TariffMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TariffMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTariffMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TariffMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM tariffMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnTariffMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TariffMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTariffMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TariffMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTariffMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TariffMasterFilterBuilder

// region TariffMasterFields
class TariffMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fService;
  static TableField get Service {
    return _fService =
        _fService ?? SqlSyntax.setField(_fService, 'Service', DbType.text);
  }

  static TableField? _fWeightId;
  static TableField get WeightId {
    return _fWeightId =
        _fWeightId ?? SqlSyntax.setField(_fWeightId, 'WeightId', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion TariffMasterFields

//region TariffMasterManager
class TariffMasterManager extends SqfEntityProvider {
  TariffMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'tariffMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion TariffMasterManager
// region ServiceMaster
class ServiceMaster extends TableBase {
  ServiceMaster(
      {this.id,
      this.ServiceId,
      this.ServiceName,
      this.MinimumWeight,
      this.MaximumWeight,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.MaterialGroup,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ServiceMaster.withFields(
      this.ServiceId,
      this.ServiceName,
      this.MinimumWeight,
      this.MaximumWeight,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.MaterialGroup,
      this.Identifier) {
    _setDefaultValues();
  }
  ServiceMaster.withId(
      this.id,
      this.ServiceId,
      this.ServiceName,
      this.MinimumWeight,
      this.MaximumWeight,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.MaterialGroup,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ServiceMaster.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ServiceId'] != null) {
      ServiceId = o['ServiceId'].toString();
    }
    if (o['ServiceName'] != null) {
      ServiceName = o['ServiceName'].toString();
    }
    if (o['MinimumWeight'] != null) {
      MinimumWeight = o['MinimumWeight'].toString();
    }
    if (o['MaximumWeight'] != null) {
      MaximumWeight = o['MaximumWeight'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (ServiceMaster)
  int? id;
  String? ServiceId;
  String? ServiceName;
  String? MinimumWeight;
  String? MaximumWeight;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? MaterialGroup;
  String? Identifier;

  // end FIELDS (ServiceMaster)

  static const bool _softDeleteActivated = false;
  ServiceMasterManager? __mnServiceMaster;

  ServiceMasterManager get _mnServiceMaster {
    return __mnServiceMaster = __mnServiceMaster ?? ServiceMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (ServiceName != null || !forView) {
      map['ServiceName'] = ServiceName;
    }
    if (MinimumWeight != null || !forView) {
      map['MinimumWeight'] = MinimumWeight;
    }
    if (MaximumWeight != null || !forView) {
      map['MaximumWeight'] = MaximumWeight;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (ServiceName != null || !forView) {
      map['ServiceName'] = ServiceName;
    }
    if (MinimumWeight != null || !forView) {
      map['MinimumWeight'] = MinimumWeight;
    }
    if (MaximumWeight != null || !forView) {
      map['MaximumWeight'] = MaximumWeight;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [ServiceMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ServiceMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ServiceId,
      ServiceName,
      MinimumWeight,
      MaximumWeight,
      Division,
      OrderType,
      ProductType,
      MaterialGroup,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ServiceId,
      ServiceName,
      MinimumWeight,
      MaximumWeight,
      Division,
      OrderType,
      ProductType,
      MaterialGroup,
      Identifier
    ];
  }

  static Future<List<ServiceMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ServiceMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ServiceMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ServiceMaster>[];
    try {
      objList = list
          .map((servicemaster) =>
              ServiceMaster.fromMap(servicemaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ServiceMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ServiceMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ServiceMaster> objList = <ServiceMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ServiceMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ServiceMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ServiceMaster] if exist, otherwise returns null
  Future<ServiceMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ServiceMaster? obj;
    final data = await _mnServiceMaster.getById([id]);
    if (data.length != 0) {
      obj = ServiceMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ServiceMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnServiceMaster.insert(this, ignoreBatch);
    } else {
      await _mnServiceMaster.update(this);
    }

    return id;
  }

  /// Saves the (ServiceMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnServiceMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnServiceMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ServiceMaster. Returns a new Primary Key value of ServiceMaster

  /// <returns>Returns a new Primary Key value of ServiceMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ServiceMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ServiceMaster> servicemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in servicemasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < servicemasters.length; i++) {
        if (servicemasters[i].id == null) {
          servicemasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnServiceMaster.rawInsert(
          'INSERT OR REPLACE INTO serviceMaster (id, ServiceId, ServiceName, MinimumWeight, MaximumWeight, Division, OrderType, ProductType, MaterialGroup, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ServiceId,
            ServiceName,
            MinimumWeight,
            MaximumWeight,
            Division,
            OrderType,
            ProductType,
            MaterialGroup,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ServiceMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ServiceMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ServiceMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnServiceMaster.rawInsert(
          'INSERT OR IGNORE INTO serviceMaster (id, ServiceId, ServiceName, MinimumWeight, MaximumWeight, Division, OrderType, ProductType, MaterialGroup, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ServiceId,
            ServiceName,
            MinimumWeight,
            MaximumWeight,
            Division,
            OrderType,
            ProductType,
            MaterialGroup,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ServiceMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ServiceMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ServiceMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ServiceMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ServiceMaster> servicemasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnServiceMaster.rawInsertAll(
        'INSERT OR REPLACE INTO serviceMaster (id, ServiceId, ServiceName, MinimumWeight, MaximumWeight, Division, OrderType, ProductType, MaterialGroup, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        servicemasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ServiceMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ServiceMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnServiceMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnServiceMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ServiceMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ServiceMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ServiceMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ServiceMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ServiceMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion servicemaster

// region ServiceMasterField
class ServiceMasterField extends FilterBase {
  ServiceMasterField(ServiceMasterFilterBuilder servicemasterFB)
      : super(servicemasterFB);

  @override
  ServiceMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder isNull() {
    return super.isNull() as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ServiceMasterFilterBuilder;
  }

  @override
  ServiceMasterField get not {
    return super.not as ServiceMasterField;
  }
}
// endregion ServiceMasterField

// region ServiceMasterFilterBuilder
class ServiceMasterFilterBuilder extends ConjunctionBase {
  ServiceMasterFilterBuilder(ServiceMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnServiceMaster = obj._mnServiceMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ServiceMasterManager? _mnServiceMaster;

  /// put the sql keyword 'AND'
  @override
  ServiceMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ServiceMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ServiceMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ServiceMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ServiceMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ServiceMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ServiceMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ServiceMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ServiceMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ServiceMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ServiceMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ServiceMasterField _setField(
      ServiceMasterField? field, String colName, DbType dbtype) {
    return ServiceMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ServiceMasterField? _id;
  ServiceMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ServiceMasterField? _ServiceId;
  ServiceMasterField get ServiceId {
    return _ServiceId = _setField(_ServiceId, 'ServiceId', DbType.text);
  }

  ServiceMasterField? _ServiceName;
  ServiceMasterField get ServiceName {
    return _ServiceName = _setField(_ServiceName, 'ServiceName', DbType.text);
  }

  ServiceMasterField? _MinimumWeight;
  ServiceMasterField get MinimumWeight {
    return _MinimumWeight =
        _setField(_MinimumWeight, 'MinimumWeight', DbType.text);
  }

  ServiceMasterField? _MaximumWeight;
  ServiceMasterField get MaximumWeight {
    return _MaximumWeight =
        _setField(_MaximumWeight, 'MaximumWeight', DbType.text);
  }

  ServiceMasterField? _Division;
  ServiceMasterField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  ServiceMasterField? _OrderType;
  ServiceMasterField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  ServiceMasterField? _ProductType;
  ServiceMasterField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  ServiceMasterField? _MaterialGroup;
  ServiceMasterField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  ServiceMasterField? _Identifier;
  ServiceMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<ServiceMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnServiceMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnServiceMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from serviceMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnServiceMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [ServiceMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ServiceMaster?
  @override
  Future<ServiceMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnServiceMaster!.toList(qparams);
    final data = await objFuture;
    ServiceMaster? obj;
    if (data.isNotEmpty) {
      obj = ServiceMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ServiceMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ServiceMaster?
  @override
  Future<ServiceMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ServiceMaster();
  }

  /// This method returns int. [ServiceMaster]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? servicemasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final servicemastersFuture = await _mnServiceMaster!.toList(qparams);
    final int count = servicemastersFuture[0]['CNT'] as int;
    if (servicemasterCount != null) {
      servicemasterCount(count);
    }
    return count;
  }

  /// This method returns List<ServiceMaster> [ServiceMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ServiceMaster>
  @override
  Future<List<ServiceMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ServiceMaster> servicemastersData =
        await ServiceMaster.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return servicemastersData;
  }

  /// This method returns Json String [ServiceMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ServiceMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ServiceMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnServiceMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ServiceMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM serviceMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnServiceMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ServiceMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnServiceMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ServiceMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnServiceMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ServiceMasterFilterBuilder

// region ServiceMasterFields
class ServiceMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServiceId;
  static TableField get ServiceId {
    return _fServiceId = _fServiceId ??
        SqlSyntax.setField(_fServiceId, 'ServiceId', DbType.text);
  }

  static TableField? _fServiceName;
  static TableField get ServiceName {
    return _fServiceName = _fServiceName ??
        SqlSyntax.setField(_fServiceName, 'ServiceName', DbType.text);
  }

  static TableField? _fMinimumWeight;
  static TableField get MinimumWeight {
    return _fMinimumWeight = _fMinimumWeight ??
        SqlSyntax.setField(_fMinimumWeight, 'MinimumWeight', DbType.text);
  }

  static TableField? _fMaximumWeight;
  static TableField get MaximumWeight {
    return _fMaximumWeight = _fMaximumWeight ??
        SqlSyntax.setField(_fMaximumWeight, 'MaximumWeight', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion ServiceMasterFields

//region ServiceMasterManager
class ServiceMasterManager extends SqfEntityProvider {
  ServiceMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'serviceMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ServiceMasterManager
// region WeightMaster
class WeightMaster extends TableBase {
  WeightMaster(
      {this.id,
      this.WeightId,
      this.MinimumWeight,
      this.MaximumWeight,
      this.ServiceId,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  WeightMaster.withFields(this.WeightId, this.MinimumWeight, this.MaximumWeight,
      this.ServiceId, this.Identifier) {
    _setDefaultValues();
  }
  WeightMaster.withId(this.id, this.WeightId, this.MinimumWeight,
      this.MaximumWeight, this.ServiceId, this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  WeightMaster.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['WeightId'] != null) {
      WeightId = o['WeightId'].toString();
    }
    if (o['MinimumWeight'] != null) {
      MinimumWeight = o['MinimumWeight'].toString();
    }
    if (o['MaximumWeight'] != null) {
      MaximumWeight = o['MaximumWeight'].toString();
    }
    if (o['ServiceId'] != null) {
      ServiceId = o['ServiceId'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (WeightMaster)
  int? id;
  String? WeightId;
  String? MinimumWeight;
  String? MaximumWeight;
  String? ServiceId;
  String? Identifier;

  // end FIELDS (WeightMaster)

  static const bool _softDeleteActivated = false;
  WeightMasterManager? __mnWeightMaster;

  WeightMasterManager get _mnWeightMaster {
    return __mnWeightMaster = __mnWeightMaster ?? WeightMasterManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (WeightId != null || !forView) {
      map['WeightId'] = WeightId;
    }
    if (MinimumWeight != null || !forView) {
      map['MinimumWeight'] = MinimumWeight;
    }
    if (MaximumWeight != null || !forView) {
      map['MaximumWeight'] = MaximumWeight;
    }
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (WeightId != null || !forView) {
      map['WeightId'] = WeightId;
    }
    if (MinimumWeight != null || !forView) {
      map['MinimumWeight'] = MinimumWeight;
    }
    if (MaximumWeight != null || !forView) {
      map['MaximumWeight'] = MaximumWeight;
    }
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [WeightMaster]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [WeightMaster]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier];
  }

  static Future<List<WeightMaster>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR WeightMaster.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<WeightMaster>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <WeightMaster>[];
    try {
      objList = list
          .map((weightmaster) =>
              WeightMaster.fromMap(weightmaster as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR WeightMaster.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<WeightMaster>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<WeightMaster> objList = <WeightMaster>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = WeightMaster.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns WeightMaster by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [WeightMaster] if exist, otherwise returns null
  Future<WeightMaster?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    WeightMaster? obj;
    final data = await _mnWeightMaster.getById([id]);
    if (data.length != 0) {
      obj = WeightMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (WeightMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnWeightMaster.insert(this, ignoreBatch);
    } else {
      await _mnWeightMaster.update(this);
    }

    return id;
  }

  /// Saves the (WeightMaster) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnWeightMaster.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnWeightMaster.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs WeightMaster. Returns a new Primary Key value of WeightMaster

  /// <returns>Returns a new Primary Key value of WeightMaster
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<WeightMaster> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<WeightMaster> weightmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in weightmasters) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < weightmasters.length; i++) {
        if (weightmasters[i].id == null) {
          weightmasters[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnWeightMaster.rawInsert(
          'INSERT OR REPLACE INTO weightMaster (id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'WeightMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'WeightMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'WeightMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnWeightMaster.rawInsert(
          'INSERT OR IGNORE INTO weightMaster (id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier)  VALUES (?,?,?,?,?,?)',
          [id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'WeightMaster id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'WeightMaster id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'WeightMaster Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<WeightMaster>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<WeightMaster> weightmasters,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnWeightMaster.rawInsertAll(
        'INSERT OR REPLACE INTO weightMaster (id, WeightId, MinimumWeight, MaximumWeight, ServiceId, Identifier)  VALUES (?,?,?,?,?,?)',
        weightmasters,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes WeightMaster

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete WeightMaster invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnWeightMaster
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnWeightMaster.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [WeightMaster] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  WeightMasterFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return WeightMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  WeightMasterFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return WeightMasterFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion weightmaster

// region WeightMasterField
class WeightMasterField extends FilterBase {
  WeightMasterField(WeightMasterFilterBuilder weightmasterFB)
      : super(weightmasterFB);

  @override
  WeightMasterFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder isNull() {
    return super.isNull() as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as WeightMasterFilterBuilder;
  }

  @override
  WeightMasterField get not {
    return super.not as WeightMasterField;
  }
}
// endregion WeightMasterField

// region WeightMasterFilterBuilder
class WeightMasterFilterBuilder extends ConjunctionBase {
  WeightMasterFilterBuilder(WeightMaster obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnWeightMaster = obj._mnWeightMaster;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  WeightMasterManager? _mnWeightMaster;

  /// put the sql keyword 'AND'
  @override
  WeightMasterFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  WeightMasterFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  WeightMasterFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  WeightMasterFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  WeightMasterFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  WeightMasterFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  WeightMasterFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  WeightMasterFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  WeightMasterFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  WeightMasterFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  WeightMasterFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  WeightMasterField _setField(
      WeightMasterField? field, String colName, DbType dbtype) {
    return WeightMasterField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  WeightMasterField? _id;
  WeightMasterField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  WeightMasterField? _WeightId;
  WeightMasterField get WeightId {
    return _WeightId = _setField(_WeightId, 'WeightId', DbType.text);
  }

  WeightMasterField? _MinimumWeight;
  WeightMasterField get MinimumWeight {
    return _MinimumWeight =
        _setField(_MinimumWeight, 'MinimumWeight', DbType.text);
  }

  WeightMasterField? _MaximumWeight;
  WeightMasterField get MaximumWeight {
    return _MaximumWeight =
        _setField(_MaximumWeight, 'MaximumWeight', DbType.text);
  }

  WeightMasterField? _ServiceId;
  WeightMasterField get ServiceId {
    return _ServiceId = _setField(_ServiceId, 'ServiceId', DbType.text);
  }

  WeightMasterField? _Identifier;
  WeightMasterField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<WeightMaster> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnWeightMaster!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnWeightMaster!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from weightMaster ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnWeightMaster!.updateBatch(qparams, values);
  }

  /// This method always returns [WeightMaster] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> WeightMaster?
  @override
  Future<WeightMaster?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnWeightMaster!.toList(qparams);
    final data = await objFuture;
    WeightMaster? obj;
    if (data.isNotEmpty) {
      obj = WeightMaster.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [WeightMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> WeightMaster?
  @override
  Future<WeightMaster> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        WeightMaster();
  }

  /// This method returns int. [WeightMaster]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? weightmasterCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final weightmastersFuture = await _mnWeightMaster!.toList(qparams);
    final int count = weightmastersFuture[0]['CNT'] as int;
    if (weightmasterCount != null) {
      weightmasterCount(count);
    }
    return count;
  }

  /// This method returns List<WeightMaster> [WeightMaster]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<WeightMaster>
  @override
  Future<List<WeightMaster>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<WeightMaster> weightmastersData = await WeightMaster.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return weightmastersData;
  }

  /// This method returns Json String [WeightMaster]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [WeightMaster]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [WeightMaster]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnWeightMaster!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [WeightMaster]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM weightMaster WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnWeightMaster!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [WeightMaster]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnWeightMaster!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await WeightMaster.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnWeightMaster!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion WeightMasterFilterBuilder

// region WeightMasterFields
class WeightMasterFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fWeightId;
  static TableField get WeightId {
    return _fWeightId =
        _fWeightId ?? SqlSyntax.setField(_fWeightId, 'WeightId', DbType.text);
  }

  static TableField? _fMinimumWeight;
  static TableField get MinimumWeight {
    return _fMinimumWeight = _fMinimumWeight ??
        SqlSyntax.setField(_fMinimumWeight, 'MinimumWeight', DbType.text);
  }

  static TableField? _fMaximumWeight;
  static TableField get MaximumWeight {
    return _fMaximumWeight = _fMaximumWeight ??
        SqlSyntax.setField(_fMaximumWeight, 'MaximumWeight', DbType.text);
  }

  static TableField? _fServiceId;
  static TableField get ServiceId {
    return _fServiceId = _fServiceId ??
        SqlSyntax.setField(_fServiceId, 'ServiceId', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion WeightMasterFields

//region WeightMasterManager
class WeightMasterManager extends SqfEntityProvider {
  WeightMasterManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'weightMaster';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion WeightMasterManager
// region LeaveBalanceTable
class LeaveBalanceTable extends TableBase {
  LeaveBalanceTable({this.EmployeeNumber, this.QuotaType, this.LeaveBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  LeaveBalanceTable.withFields(
      this.EmployeeNumber, this.QuotaType, this.LeaveBalance) {
    _setDefaultValues();
  }
  LeaveBalanceTable.withId(
      this.EmployeeNumber, this.QuotaType, this.LeaveBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  LeaveBalanceTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    EmployeeNumber = o['EmployeeNumber'].toString();
    if (o['QuotaType'] != null) {
      QuotaType = o['QuotaType'].toString();
    }
    if (o['LeaveBalance'] != null) {
      LeaveBalance = o['LeaveBalance'].toString();
    }

    isSaved = true;
  }
  // FIELDS (LeaveBalanceTable)
  String? EmployeeNumber;
  String? QuotaType;
  String? LeaveBalance;
  bool? isSaved;
  // end FIELDS (LeaveBalanceTable)

  static const bool _softDeleteActivated = false;
  LeaveBalanceTableManager? __mnLeaveBalanceTable;

  LeaveBalanceTableManager get _mnLeaveBalanceTable {
    return __mnLeaveBalanceTable =
        __mnLeaveBalanceTable ?? LeaveBalanceTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['EmployeeNumber'] = EmployeeNumber;
    if (QuotaType != null || !forView) {
      map['QuotaType'] = QuotaType;
    }
    if (LeaveBalance != null || !forView) {
      map['LeaveBalance'] = LeaveBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['EmployeeNumber'] = EmployeeNumber;
    if (QuotaType != null || !forView) {
      map['QuotaType'] = QuotaType;
    }
    if (LeaveBalance != null || !forView) {
      map['LeaveBalance'] = LeaveBalance;
    }

    return map;
  }

  /// This method returns Json String [LeaveBalanceTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [LeaveBalanceTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [EmployeeNumber, QuotaType, LeaveBalance];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [EmployeeNumber, QuotaType, LeaveBalance];
  }

  static Future<List<LeaveBalanceTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LeaveBalanceTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<LeaveBalanceTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <LeaveBalanceTable>[];
    try {
      objList = list
          .map((leavebalancetable) => LeaveBalanceTable.fromMap(
              leavebalancetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LeaveBalanceTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<LeaveBalanceTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<LeaveBalanceTable> objList = <LeaveBalanceTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = LeaveBalanceTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns LeaveBalanceTable by ID if exist, otherwise returns null
  /// Primary Keys: String? EmployeeNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [LeaveBalanceTable] if exist, otherwise returns null
  Future<LeaveBalanceTable?> getById(String? EmployeeNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (EmployeeNumber == null) {
      return null;
    }
    LeaveBalanceTable? obj;
    final data = await _mnLeaveBalanceTable.getById([EmployeeNumber]);
    if (data.length != 0) {
      obj = LeaveBalanceTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (LeaveBalanceTable) object. If the Primary Key (EmployeeNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same EmployeeNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnLeaveBalanceTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO leaveBalanceTable (EmployeeNumber, QuotaType, LeaveBalance)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<LeaveBalanceTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<LeaveBalanceTable> leavebalancetables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in leavebalancetables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLeaveBalanceTable.rawInsert(
          'INSERT OR REPLACE INTO leaveBalanceTable (EmployeeNumber, QuotaType, LeaveBalance)  VALUES (?,?,?)',
          [EmployeeNumber, QuotaType, LeaveBalance],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'LeaveBalanceTable EmployeeNumber=$EmployeeNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'LeaveBalanceTable EmployeeNumber=$EmployeeNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'LeaveBalanceTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLeaveBalanceTable.rawInsert(
          'INSERT OR IGNORE INTO leaveBalanceTable (EmployeeNumber, QuotaType, LeaveBalance)  VALUES (?,?,?)',
          [EmployeeNumber, QuotaType, LeaveBalance],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'LeaveBalanceTable EmployeeNumber=$EmployeeNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'LeaveBalanceTable EmployeeNumber=$EmployeeNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'LeaveBalanceTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes LeaveBalanceTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete LeaveBalanceTable invoked (EmployeeNumber=$EmployeeNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLeaveBalanceTable.delete(QueryParams(
          whereString: 'EmployeeNumber=?', whereArguments: [EmployeeNumber]));
    } else {
      return _mnLeaveBalanceTable.updateBatch(
          QueryParams(
              whereString: 'EmployeeNumber=?',
              whereArguments: [EmployeeNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [LeaveBalanceTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LeaveBalanceTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LeaveBalanceTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LeaveBalanceTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LeaveBalanceTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      EmployeeNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion leavebalancetable

// region LeaveBalanceTableField
class LeaveBalanceTableField extends FilterBase {
  LeaveBalanceTableField(LeaveBalanceTableFilterBuilder leavebalancetableFB)
      : super(leavebalancetableFB);

  @override
  LeaveBalanceTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder isNull() {
    return super.isNull() as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LeaveBalanceTableFilterBuilder;
  }

  @override
  LeaveBalanceTableField get not {
    return super.not as LeaveBalanceTableField;
  }
}
// endregion LeaveBalanceTableField

// region LeaveBalanceTableFilterBuilder
class LeaveBalanceTableFilterBuilder extends ConjunctionBase {
  LeaveBalanceTableFilterBuilder(LeaveBalanceTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLeaveBalanceTable = obj._mnLeaveBalanceTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LeaveBalanceTableManager? _mnLeaveBalanceTable;

  /// put the sql keyword 'AND'
  @override
  LeaveBalanceTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LeaveBalanceTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LeaveBalanceTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LeaveBalanceTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LeaveBalanceTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LeaveBalanceTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LeaveBalanceTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LeaveBalanceTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LeaveBalanceTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LeaveBalanceTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LeaveBalanceTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LeaveBalanceTableField _setField(
      LeaveBalanceTableField? field, String colName, DbType dbtype) {
    return LeaveBalanceTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LeaveBalanceTableField? _EmployeeNumber;
  LeaveBalanceTableField get EmployeeNumber {
    return _EmployeeNumber =
        _setField(_EmployeeNumber, 'EmployeeNumber', DbType.integer);
  }

  LeaveBalanceTableField? _QuotaType;
  LeaveBalanceTableField get QuotaType {
    return _QuotaType = _setField(_QuotaType, 'QuotaType', DbType.text);
  }

  LeaveBalanceTableField? _LeaveBalance;
  LeaveBalanceTableField get LeaveBalance {
    return _LeaveBalance =
        _setField(_LeaveBalance, 'LeaveBalance', DbType.text);
  }

  /// Deletes List<LeaveBalanceTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLeaveBalanceTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLeaveBalanceTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'EmployeeNumber IN (SELECT EmployeeNumber from leaveBalanceTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLeaveBalanceTable!.updateBatch(qparams, values);
  }

  /// This method always returns [LeaveBalanceTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LeaveBalanceTable?
  @override
  Future<LeaveBalanceTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLeaveBalanceTable!.toList(qparams);
    final data = await objFuture;
    LeaveBalanceTable? obj;
    if (data.isNotEmpty) {
      obj = LeaveBalanceTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [LeaveBalanceTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LeaveBalanceTable?
  @override
  Future<LeaveBalanceTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        LeaveBalanceTable();
  }

  /// This method returns int. [LeaveBalanceTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? leavebalancetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final leavebalancetablesFuture =
        await _mnLeaveBalanceTable!.toList(qparams);
    final int count = leavebalancetablesFuture[0]['CNT'] as int;
    if (leavebalancetableCount != null) {
      leavebalancetableCount(count);
    }
    return count;
  }

  /// This method returns List<LeaveBalanceTable> [LeaveBalanceTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<LeaveBalanceTable>
  @override
  Future<List<LeaveBalanceTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<LeaveBalanceTable> leavebalancetablesData =
        await LeaveBalanceTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return leavebalancetablesData;
  }

  /// This method returns Json String [LeaveBalanceTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [LeaveBalanceTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [LeaveBalanceTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLeaveBalanceTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [LeaveBalanceTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `EmployeeNumber` FROM leaveBalanceTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> EmployeeNumberData = <String>[];
    qparams.selectColumns = ['EmployeeNumber'];
    final EmployeeNumberFuture = await _mnLeaveBalanceTable!.toList(qparams);

    final int count = EmployeeNumberFuture.length;
    for (int i = 0; i < count; i++) {
      EmployeeNumberData.add(
          EmployeeNumberFuture[i]['EmployeeNumber'] as String);
    }
    return EmployeeNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [LeaveBalanceTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLeaveBalanceTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await LeaveBalanceTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLeaveBalanceTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LeaveBalanceTableFilterBuilder

// region LeaveBalanceTableFields
class LeaveBalanceTableFields {
  static TableField? _fEmployeeNumber;
  static TableField get EmployeeNumber {
    return _fEmployeeNumber = _fEmployeeNumber ??
        SqlSyntax.setField(_fEmployeeNumber, 'employeenumber', DbType.integer);
  }

  static TableField? _fQuotaType;
  static TableField get QuotaType {
    return _fQuotaType = _fQuotaType ??
        SqlSyntax.setField(_fQuotaType, 'QuotaType', DbType.text);
  }

  static TableField? _fLeaveBalance;
  static TableField get LeaveBalance {
    return _fLeaveBalance = _fLeaveBalance ??
        SqlSyntax.setField(_fLeaveBalance, 'LeaveBalance', DbType.text);
  }
}
// endregion LeaveBalanceTableFields

//region LeaveBalanceTableManager
class LeaveBalanceTableManager extends SqfEntityProvider {
  LeaveBalanceTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'leaveBalanceTable';
  static const List<String> _primaryKeyList = ['EmployeeNumber'];
  static const String _whereStr = 'EmployeeNumber=?';
}

//endregion LeaveBalanceTableManager
// region CashIndentTable
class CashIndentTable extends TableBase {
  CashIndentTable(
      {this.id,
      this.BOID,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CashIndentTable.withFields(this.BOID, this.Date, this.Time, this.BOName,
      this.HOName, this.Amount1, this.Amount2, this.Amount3, this.AmountType) {
    _setDefaultValues();
  }
  CashIndentTable.withId(this.id, this.BOID, this.Date, this.Time, this.BOName,
      this.HOName, this.Amount1, this.Amount2, this.Amount3, this.AmountType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CashIndentTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['BOID'] != null) {
      BOID = o['BOID'].toString();
    }
    if (o['Date'] != null) {
      Date = o['Date'].toString();
    }
    if (o['Time'] != null) {
      Time = o['Time'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['HOName'] != null) {
      HOName = o['HOName'].toString();
    }
    if (o['Amount1'] != null) {
      Amount1 = o['Amount1'].toString();
    }
    if (o['Amount2'] != null) {
      Amount2 = o['Amount2'].toString();
    }
    if (o['Amount3'] != null) {
      Amount3 = o['Amount3'].toString();
    }
    if (o['AmountType'] != null) {
      AmountType = o['AmountType'].toString();
    }
  }
  // FIELDS (CashIndentTable)
  int? id;
  String? BOID;
  String? Date;
  String? Time;
  String? BOName;
  String? HOName;
  String? Amount1;
  String? Amount2;
  String? Amount3;
  String? AmountType;

  // end FIELDS (CashIndentTable)

  static const bool _softDeleteActivated = false;
  CashIndentTableManager? __mnCashIndentTable;

  CashIndentTableManager get _mnCashIndentTable {
    return __mnCashIndentTable =
        __mnCashIndentTable ?? CashIndentTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOID != null || !forView) {
      map['BOID'] = BOID;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOID != null || !forView) {
      map['BOID'] = BOID;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }

    return map;
  }

  /// This method returns Json String [CashIndentTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CashIndentTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BOID,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      BOID,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType
    ];
  }

  static Future<List<CashIndentTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashIndentTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CashIndentTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CashIndentTable>[];
    try {
      objList = list
          .map((cashindenttable) =>
              CashIndentTable.fromMap(cashindenttable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashIndentTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CashIndentTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CashIndentTable> objList = <CashIndentTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CashIndentTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CashIndentTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CashIndentTable] if exist, otherwise returns null
  Future<CashIndentTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    CashIndentTable? obj;
    final data = await _mnCashIndentTable.getById([id]);
    if (data.length != 0) {
      obj = CashIndentTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CashIndentTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCashIndentTable.insert(this, ignoreBatch);
    } else {
      await _mnCashIndentTable.update(this);
    }

    return id;
  }

  /// Saves the (CashIndentTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCashIndentTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCashIndentTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs CashIndentTable. Returns a new Primary Key value of CashIndentTable

  /// <returns>Returns a new Primary Key value of CashIndentTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<CashIndentTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CashIndentTable> cashindenttables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in cashindenttables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < cashindenttables.length; i++) {
        if (cashindenttables[i].id == null) {
          cashindenttables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashIndentTable.rawInsert(
          'INSERT OR REPLACE INTO cashIndentTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            BOID,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashIndentTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashIndentTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashIndentTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashIndentTable.rawInsert(
          'INSERT OR IGNORE INTO cashIndentTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            BOID,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CashIndentTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CashIndentTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashIndentTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CashIndentTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<CashIndentTable> cashindenttables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCashIndentTable.rawInsertAll(
        'INSERT OR REPLACE INTO cashIndentTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        cashindenttables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CashIndentTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CashIndentTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCashIndentTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCashIndentTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CashIndentTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CashIndentTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashIndentTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CashIndentTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashIndentTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cashindenttable

// region CashIndentTableField
class CashIndentTableField extends FilterBase {
  CashIndentTableField(CashIndentTableFilterBuilder cashindenttableFB)
      : super(cashindenttableFB);

  @override
  CashIndentTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder isNull() {
    return super.isNull() as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CashIndentTableFilterBuilder;
  }

  @override
  CashIndentTableField get not {
    return super.not as CashIndentTableField;
  }
}
// endregion CashIndentTableField

// region CashIndentTableFilterBuilder
class CashIndentTableFilterBuilder extends ConjunctionBase {
  CashIndentTableFilterBuilder(CashIndentTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCashIndentTable = obj._mnCashIndentTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CashIndentTableManager? _mnCashIndentTable;

  /// put the sql keyword 'AND'
  @override
  CashIndentTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CashIndentTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CashIndentTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CashIndentTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CashIndentTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CashIndentTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CashIndentTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashIndentTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashIndentTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashIndentTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashIndentTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CashIndentTableField _setField(
      CashIndentTableField? field, String colName, DbType dbtype) {
    return CashIndentTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CashIndentTableField? _id;
  CashIndentTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  CashIndentTableField? _BOID;
  CashIndentTableField get BOID {
    return _BOID = _setField(_BOID, 'BOID', DbType.text);
  }

  CashIndentTableField? _Date;
  CashIndentTableField get Date {
    return _Date = _setField(_Date, 'Date', DbType.text);
  }

  CashIndentTableField? _Time;
  CashIndentTableField get Time {
    return _Time = _setField(_Time, 'Time', DbType.text);
  }

  CashIndentTableField? _BOName;
  CashIndentTableField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  CashIndentTableField? _HOName;
  CashIndentTableField get HOName {
    return _HOName = _setField(_HOName, 'HOName', DbType.text);
  }

  CashIndentTableField? _Amount1;
  CashIndentTableField get Amount1 {
    return _Amount1 = _setField(_Amount1, 'Amount1', DbType.text);
  }

  CashIndentTableField? _Amount2;
  CashIndentTableField get Amount2 {
    return _Amount2 = _setField(_Amount2, 'Amount2', DbType.text);
  }

  CashIndentTableField? _Amount3;
  CashIndentTableField get Amount3 {
    return _Amount3 = _setField(_Amount3, 'Amount3', DbType.text);
  }

  CashIndentTableField? _AmountType;
  CashIndentTableField get AmountType {
    return _AmountType = _setField(_AmountType, 'AmountType', DbType.text);
  }

  /// Deletes List<CashIndentTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCashIndentTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCashIndentTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from cashIndentTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCashIndentTable!.updateBatch(qparams, values);
  }

  /// This method always returns [CashIndentTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashIndentTable?
  @override
  Future<CashIndentTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCashIndentTable!.toList(qparams);
    final data = await objFuture;
    CashIndentTable? obj;
    if (data.isNotEmpty) {
      obj = CashIndentTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CashIndentTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashIndentTable?
  @override
  Future<CashIndentTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CashIndentTable();
  }

  /// This method returns int. [CashIndentTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cashindenttableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cashindenttablesFuture = await _mnCashIndentTable!.toList(qparams);
    final int count = cashindenttablesFuture[0]['CNT'] as int;
    if (cashindenttableCount != null) {
      cashindenttableCount(count);
    }
    return count;
  }

  /// This method returns List<CashIndentTable> [CashIndentTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CashIndentTable>
  @override
  Future<List<CashIndentTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CashIndentTable> cashindenttablesData =
        await CashIndentTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cashindenttablesData;
  }

  /// This method returns Json String [CashIndentTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CashIndentTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CashIndentTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCashIndentTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CashIndentTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM cashIndentTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCashIndentTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CashIndentTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCashIndentTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CashIndentTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCashIndentTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CashIndentTableFilterBuilder

// region CashIndentTableFields
class CashIndentTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fBOID;
  static TableField get BOID {
    return _fBOID = _fBOID ?? SqlSyntax.setField(_fBOID, 'BOID', DbType.text);
  }

  static TableField? _fDate;
  static TableField get Date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'Date', DbType.text);
  }

  static TableField? _fTime;
  static TableField get Time {
    return _fTime = _fTime ?? SqlSyntax.setField(_fTime, 'Time', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fHOName;
  static TableField get HOName {
    return _fHOName =
        _fHOName ?? SqlSyntax.setField(_fHOName, 'HOName', DbType.text);
  }

  static TableField? _fAmount1;
  static TableField get Amount1 {
    return _fAmount1 =
        _fAmount1 ?? SqlSyntax.setField(_fAmount1, 'Amount1', DbType.text);
  }

  static TableField? _fAmount2;
  static TableField get Amount2 {
    return _fAmount2 =
        _fAmount2 ?? SqlSyntax.setField(_fAmount2, 'Amount2', DbType.text);
  }

  static TableField? _fAmount3;
  static TableField get Amount3 {
    return _fAmount3 =
        _fAmount3 ?? SqlSyntax.setField(_fAmount3, 'Amount3', DbType.text);
  }

  static TableField? _fAmountType;
  static TableField get AmountType {
    return _fAmountType = _fAmountType ??
        SqlSyntax.setField(_fAmountType, 'AmountType', DbType.text);
  }
}
// endregion CashIndentTableFields

//region CashIndentTableManager
class CashIndentTableManager extends SqfEntityProvider {
  CashIndentTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'cashIndentTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CashIndentTableManager
// region SpecialRemittanceTable
class SpecialRemittanceTable extends TableBase {
  SpecialRemittanceTable(
      {this.id,
      this.SpecialRemittanceId,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SpecialRemittanceTable.withFields(
      this.SpecialRemittanceId,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType) {
    _setDefaultValues();
  }
  SpecialRemittanceTable.withId(
      this.id,
      this.SpecialRemittanceId,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SpecialRemittanceTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['SpecialRemittanceId'] != null) {
      SpecialRemittanceId = o['SpecialRemittanceId'].toString();
    }
    if (o['Date'] != null) {
      Date = o['Date'].toString();
    }
    if (o['Time'] != null) {
      Time = o['Time'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['HOName'] != null) {
      HOName = o['HOName'].toString();
    }
    if (o['Amount1'] != null) {
      Amount1 = o['Amount1'].toString();
    }
    if (o['Amount2'] != null) {
      Amount2 = o['Amount2'].toString();
    }
    if (o['Amount3'] != null) {
      Amount3 = o['Amount3'].toString();
    }
    if (o['AmountType'] != null) {
      AmountType = o['AmountType'].toString();
    }
  }
  // FIELDS (SpecialRemittanceTable)
  int? id;
  String? SpecialRemittanceId;
  String? Date;
  String? Time;
  String? BOName;
  String? HOName;
  String? Amount1;
  String? Amount2;
  String? Amount3;
  String? AmountType;

  // end FIELDS (SpecialRemittanceTable)

  static const bool _softDeleteActivated = false;
  SpecialRemittanceTableManager? __mnSpecialRemittanceTable;

  SpecialRemittanceTableManager get _mnSpecialRemittanceTable {
    return __mnSpecialRemittanceTable =
        __mnSpecialRemittanceTable ?? SpecialRemittanceTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SpecialRemittanceId != null || !forView) {
      map['SpecialRemittanceId'] = SpecialRemittanceId;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SpecialRemittanceId != null || !forView) {
      map['SpecialRemittanceId'] = SpecialRemittanceId;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }

    return map;
  }

  /// This method returns Json String [SpecialRemittanceTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SpecialRemittanceTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      SpecialRemittanceId,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      SpecialRemittanceId,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType
    ];
  }

  static Future<List<SpecialRemittanceTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpecialRemittanceTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SpecialRemittanceTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SpecialRemittanceTable>[];
    try {
      objList = list
          .map((specialremittancetable) => SpecialRemittanceTable.fromMap(
              specialremittancetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpecialRemittanceTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SpecialRemittanceTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SpecialRemittanceTable> objList = <SpecialRemittanceTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SpecialRemittanceTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SpecialRemittanceTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SpecialRemittanceTable] if exist, otherwise returns null
  Future<SpecialRemittanceTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SpecialRemittanceTable? obj;
    final data = await _mnSpecialRemittanceTable.getById([id]);
    if (data.length != 0) {
      obj = SpecialRemittanceTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SpecialRemittanceTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSpecialRemittanceTable.insert(this, ignoreBatch);
    } else {
      await _mnSpecialRemittanceTable.update(this);
    }

    return id;
  }

  /// Saves the (SpecialRemittanceTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSpecialRemittanceTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSpecialRemittanceTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SpecialRemittanceTable. Returns a new Primary Key value of SpecialRemittanceTable

  /// <returns>Returns a new Primary Key value of SpecialRemittanceTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SpecialRemittanceTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SpecialRemittanceTable> specialremittancetables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in specialremittancetables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < specialremittancetables.length; i++) {
        if (specialremittancetables[i].id == null) {
          specialremittancetables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpecialRemittanceTable.rawInsert(
          'INSERT OR REPLACE INTO specialRemittanceTable (id, SpecialRemittanceId, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SpecialRemittanceId,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpecialRemittanceTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SpecialRemittanceTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SpecialRemittanceTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpecialRemittanceTable.rawInsert(
          'INSERT OR IGNORE INTO specialRemittanceTable (id, SpecialRemittanceId, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SpecialRemittanceId,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpecialRemittanceTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SpecialRemittanceTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SpecialRemittanceTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SpecialRemittanceTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SpecialRemittanceTable> specialremittancetables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnSpecialRemittanceTable.rawInsertAll(
        'INSERT OR REPLACE INTO specialRemittanceTable (id, SpecialRemittanceId, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType)  VALUES (?,?,?,?,?,?,?,?,?,?)',
        specialremittancetables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SpecialRemittanceTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SpecialRemittanceTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSpecialRemittanceTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSpecialRemittanceTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SpecialRemittanceTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SpecialRemittanceTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpecialRemittanceTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SpecialRemittanceTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpecialRemittanceTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion specialremittancetable

// region SpecialRemittanceTableField
class SpecialRemittanceTableField extends FilterBase {
  SpecialRemittanceTableField(
      SpecialRemittanceTableFilterBuilder specialremittancetableFB)
      : super(specialremittancetableFB);

  @override
  SpecialRemittanceTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder isNull() {
    return super.isNull() as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SpecialRemittanceTableFilterBuilder;
  }

  @override
  SpecialRemittanceTableField get not {
    return super.not as SpecialRemittanceTableField;
  }
}
// endregion SpecialRemittanceTableField

// region SpecialRemittanceTableFilterBuilder
class SpecialRemittanceTableFilterBuilder extends ConjunctionBase {
  SpecialRemittanceTableFilterBuilder(
      SpecialRemittanceTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSpecialRemittanceTable = obj._mnSpecialRemittanceTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SpecialRemittanceTableManager? _mnSpecialRemittanceTable;

  /// put the sql keyword 'AND'
  @override
  SpecialRemittanceTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SpecialRemittanceTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SpecialRemittanceTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SpecialRemittanceTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SpecialRemittanceTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SpecialRemittanceTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SpecialRemittanceTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpecialRemittanceTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpecialRemittanceTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpecialRemittanceTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpecialRemittanceTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SpecialRemittanceTableField _setField(
      SpecialRemittanceTableField? field, String colName, DbType dbtype) {
    return SpecialRemittanceTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SpecialRemittanceTableField? _id;
  SpecialRemittanceTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SpecialRemittanceTableField? _SpecialRemittanceId;
  SpecialRemittanceTableField get SpecialRemittanceId {
    return _SpecialRemittanceId =
        _setField(_SpecialRemittanceId, 'SpecialRemittanceId', DbType.text);
  }

  SpecialRemittanceTableField? _Date;
  SpecialRemittanceTableField get Date {
    return _Date = _setField(_Date, 'Date', DbType.text);
  }

  SpecialRemittanceTableField? _Time;
  SpecialRemittanceTableField get Time {
    return _Time = _setField(_Time, 'Time', DbType.text);
  }

  SpecialRemittanceTableField? _BOName;
  SpecialRemittanceTableField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  SpecialRemittanceTableField? _HOName;
  SpecialRemittanceTableField get HOName {
    return _HOName = _setField(_HOName, 'HOName', DbType.text);
  }

  SpecialRemittanceTableField? _Amount1;
  SpecialRemittanceTableField get Amount1 {
    return _Amount1 = _setField(_Amount1, 'Amount1', DbType.text);
  }

  SpecialRemittanceTableField? _Amount2;
  SpecialRemittanceTableField get Amount2 {
    return _Amount2 = _setField(_Amount2, 'Amount2', DbType.text);
  }

  SpecialRemittanceTableField? _Amount3;
  SpecialRemittanceTableField get Amount3 {
    return _Amount3 = _setField(_Amount3, 'Amount3', DbType.text);
  }

  SpecialRemittanceTableField? _AmountType;
  SpecialRemittanceTableField get AmountType {
    return _AmountType = _setField(_AmountType, 'AmountType', DbType.text);
  }

  /// Deletes List<SpecialRemittanceTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSpecialRemittanceTable!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSpecialRemittanceTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from specialRemittanceTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSpecialRemittanceTable!.updateBatch(qparams, values);
  }

  /// This method always returns [SpecialRemittanceTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpecialRemittanceTable?
  @override
  Future<SpecialRemittanceTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSpecialRemittanceTable!.toList(qparams);
    final data = await objFuture;
    SpecialRemittanceTable? obj;
    if (data.isNotEmpty) {
      obj = SpecialRemittanceTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SpecialRemittanceTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpecialRemittanceTable?
  @override
  Future<SpecialRemittanceTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SpecialRemittanceTable();
  }

  /// This method returns int. [SpecialRemittanceTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? specialremittancetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final specialremittancetablesFuture =
        await _mnSpecialRemittanceTable!.toList(qparams);
    final int count = specialremittancetablesFuture[0]['CNT'] as int;
    if (specialremittancetableCount != null) {
      specialremittancetableCount(count);
    }
    return count;
  }

  /// This method returns List<SpecialRemittanceTable> [SpecialRemittanceTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SpecialRemittanceTable>
  @override
  Future<List<SpecialRemittanceTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SpecialRemittanceTable> specialremittancetablesData =
        await SpecialRemittanceTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return specialremittancetablesData;
  }

  /// This method returns Json String [SpecialRemittanceTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SpecialRemittanceTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SpecialRemittanceTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSpecialRemittanceTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SpecialRemittanceTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM specialRemittanceTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSpecialRemittanceTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SpecialRemittanceTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSpecialRemittanceTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SpecialRemittanceTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSpecialRemittanceTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SpecialRemittanceTableFilterBuilder

// region SpecialRemittanceTableFields
class SpecialRemittanceTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSpecialRemittanceId;
  static TableField get SpecialRemittanceId {
    return _fSpecialRemittanceId = _fSpecialRemittanceId ??
        SqlSyntax.setField(
            _fSpecialRemittanceId, 'SpecialRemittanceId', DbType.text);
  }

  static TableField? _fDate;
  static TableField get Date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'Date', DbType.text);
  }

  static TableField? _fTime;
  static TableField get Time {
    return _fTime = _fTime ?? SqlSyntax.setField(_fTime, 'Time', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fHOName;
  static TableField get HOName {
    return _fHOName =
        _fHOName ?? SqlSyntax.setField(_fHOName, 'HOName', DbType.text);
  }

  static TableField? _fAmount1;
  static TableField get Amount1 {
    return _fAmount1 =
        _fAmount1 ?? SqlSyntax.setField(_fAmount1, 'Amount1', DbType.text);
  }

  static TableField? _fAmount2;
  static TableField get Amount2 {
    return _fAmount2 =
        _fAmount2 ?? SqlSyntax.setField(_fAmount2, 'Amount2', DbType.text);
  }

  static TableField? _fAmount3;
  static TableField get Amount3 {
    return _fAmount3 =
        _fAmount3 ?? SqlSyntax.setField(_fAmount3, 'Amount3', DbType.text);
  }

  static TableField? _fAmountType;
  static TableField get AmountType {
    return _fAmountType = _fAmountType ??
        SqlSyntax.setField(_fAmountType, 'AmountType', DbType.text);
  }
}
// endregion SpecialRemittanceTableFields

//region SpecialRemittanceTableManager
class SpecialRemittanceTableManager extends SqfEntityProvider {
  SpecialRemittanceTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'specialRemittanceTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SpecialRemittanceTableManager
// region ExcessCashTable
class ExcessCashTable extends TableBase {
  ExcessCashTable(
      {this.id,
      this.BOID,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType,
      this.Amount4}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ExcessCashTable.withFields(
      this.BOID,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType,
      this.Amount4) {
    _setDefaultValues();
  }
  ExcessCashTable.withId(
      this.id,
      this.BOID,
      this.Date,
      this.Time,
      this.BOName,
      this.HOName,
      this.Amount1,
      this.Amount2,
      this.Amount3,
      this.AmountType,
      this.Amount4) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ExcessCashTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['BOID'] != null) {
      BOID = o['BOID'].toString();
    }
    if (o['Date'] != null) {
      Date = o['Date'].toString();
    }
    if (o['Time'] != null) {
      Time = o['Time'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['HOName'] != null) {
      HOName = o['HOName'].toString();
    }
    if (o['Amount1'] != null) {
      Amount1 = o['Amount1'].toString();
    }
    if (o['Amount2'] != null) {
      Amount2 = o['Amount2'].toString();
    }
    if (o['Amount3'] != null) {
      Amount3 = o['Amount3'].toString();
    }
    if (o['AmountType'] != null) {
      AmountType = o['AmountType'].toString();
    }
    if (o['Amount4'] != null) {
      Amount4 = o['Amount4'].toString();
    }
  }
  // FIELDS (ExcessCashTable)
  int? id;
  String? BOID;
  String? Date;
  String? Time;
  String? BOName;
  String? HOName;
  String? Amount1;
  String? Amount2;
  String? Amount3;
  String? AmountType;
  String? Amount4;

  // end FIELDS (ExcessCashTable)

  static const bool _softDeleteActivated = false;
  ExcessCashTableManager? __mnExcessCashTable;

  ExcessCashTableManager get _mnExcessCashTable {
    return __mnExcessCashTable =
        __mnExcessCashTable ?? ExcessCashTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOID != null || !forView) {
      map['BOID'] = BOID;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }
    if (Amount4 != null || !forView) {
      map['Amount4'] = Amount4;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOID != null || !forView) {
      map['BOID'] = BOID;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (Time != null || !forView) {
      map['Time'] = Time;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (HOName != null || !forView) {
      map['HOName'] = HOName;
    }
    if (Amount1 != null || !forView) {
      map['Amount1'] = Amount1;
    }
    if (Amount2 != null || !forView) {
      map['Amount2'] = Amount2;
    }
    if (Amount3 != null || !forView) {
      map['Amount3'] = Amount3;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }
    if (Amount4 != null || !forView) {
      map['Amount4'] = Amount4;
    }

    return map;
  }

  /// This method returns Json String [ExcessCashTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExcessCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BOID,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType,
      Amount4
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      BOID,
      Date,
      Time,
      BOName,
      HOName,
      Amount1,
      Amount2,
      Amount3,
      AmountType,
      Amount4
    ];
  }

  static Future<List<ExcessCashTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExcessCashTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ExcessCashTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExcessCashTable>[];
    try {
      objList = list
          .map((excesscashtable) =>
              ExcessCashTable.fromMap(excesscashtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExcessCashTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExcessCashTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExcessCashTable> objList = <ExcessCashTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExcessCashTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExcessCashTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ExcessCashTable] if exist, otherwise returns null
  Future<ExcessCashTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ExcessCashTable? obj;
    final data = await _mnExcessCashTable.getById([id]);
    if (data.length != 0) {
      obj = ExcessCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExcessCashTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExcessCashTable.insert(this, ignoreBatch);
    } else {
      await _mnExcessCashTable.update(this);
    }

    return id;
  }

  /// Saves the (ExcessCashTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExcessCashTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExcessCashTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ExcessCashTable. Returns a new Primary Key value of ExcessCashTable

  /// <returns>Returns a new Primary Key value of ExcessCashTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ExcessCashTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ExcessCashTable> excesscashtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in excesscashtables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < excesscashtables.length; i++) {
        if (excesscashtables[i].id == null) {
          excesscashtables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExcessCashTable.rawInsert(
          'INSERT OR REPLACE INTO excessCashTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType, Amount4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            BOID,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType,
            Amount4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ExcessCashTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ExcessCashTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExcessCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExcessCashTable.rawInsert(
          'INSERT OR IGNORE INTO excessCashTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType, Amount4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            BOID,
            Date,
            Time,
            BOName,
            HOName,
            Amount1,
            Amount2,
            Amount3,
            AmountType,
            Amount4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ExcessCashTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ExcessCashTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ExcessCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ExcessCashTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<ExcessCashTable> excesscashtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnExcessCashTable.rawInsertAll(
        'INSERT OR REPLACE INTO excessCashTable (id, BOID, Date, Time, BOName, HOName, Amount1, Amount2, Amount3, AmountType, Amount4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        excesscashtables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ExcessCashTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ExcessCashTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExcessCashTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExcessCashTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ExcessCashTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ExcessCashTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExcessCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExcessCashTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExcessCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion excesscashtable

// region ExcessCashTableField
class ExcessCashTableField extends FilterBase {
  ExcessCashTableField(ExcessCashTableFilterBuilder excesscashtableFB)
      : super(excesscashtableFB);

  @override
  ExcessCashTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder isNull() {
    return super.isNull() as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExcessCashTableFilterBuilder;
  }

  @override
  ExcessCashTableField get not {
    return super.not as ExcessCashTableField;
  }
}
// endregion ExcessCashTableField

// region ExcessCashTableFilterBuilder
class ExcessCashTableFilterBuilder extends ConjunctionBase {
  ExcessCashTableFilterBuilder(ExcessCashTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExcessCashTable = obj._mnExcessCashTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExcessCashTableManager? _mnExcessCashTable;

  /// put the sql keyword 'AND'
  @override
  ExcessCashTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExcessCashTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExcessCashTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExcessCashTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExcessCashTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExcessCashTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExcessCashTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExcessCashTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExcessCashTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExcessCashTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExcessCashTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExcessCashTableField _setField(
      ExcessCashTableField? field, String colName, DbType dbtype) {
    return ExcessCashTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExcessCashTableField? _id;
  ExcessCashTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ExcessCashTableField? _BOID;
  ExcessCashTableField get BOID {
    return _BOID = _setField(_BOID, 'BOID', DbType.text);
  }

  ExcessCashTableField? _Date;
  ExcessCashTableField get Date {
    return _Date = _setField(_Date, 'Date', DbType.text);
  }

  ExcessCashTableField? _Time;
  ExcessCashTableField get Time {
    return _Time = _setField(_Time, 'Time', DbType.text);
  }

  ExcessCashTableField? _BOName;
  ExcessCashTableField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  ExcessCashTableField? _HOName;
  ExcessCashTableField get HOName {
    return _HOName = _setField(_HOName, 'HOName', DbType.text);
  }

  ExcessCashTableField? _Amount1;
  ExcessCashTableField get Amount1 {
    return _Amount1 = _setField(_Amount1, 'Amount1', DbType.text);
  }

  ExcessCashTableField? _Amount2;
  ExcessCashTableField get Amount2 {
    return _Amount2 = _setField(_Amount2, 'Amount2', DbType.text);
  }

  ExcessCashTableField? _Amount3;
  ExcessCashTableField get Amount3 {
    return _Amount3 = _setField(_Amount3, 'Amount3', DbType.text);
  }

  ExcessCashTableField? _AmountType;
  ExcessCashTableField get AmountType {
    return _AmountType = _setField(_AmountType, 'AmountType', DbType.text);
  }

  ExcessCashTableField? _Amount4;
  ExcessCashTableField get Amount4 {
    return _Amount4 = _setField(_Amount4, 'Amount4', DbType.text);
  }

  /// Deletes List<ExcessCashTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExcessCashTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExcessCashTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from excessCashTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExcessCashTable!.updateBatch(qparams, values);
  }

  /// This method always returns [ExcessCashTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExcessCashTable?
  @override
  Future<ExcessCashTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExcessCashTable!.toList(qparams);
    final data = await objFuture;
    ExcessCashTable? obj;
    if (data.isNotEmpty) {
      obj = ExcessCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ExcessCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExcessCashTable?
  @override
  Future<ExcessCashTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ExcessCashTable();
  }

  /// This method returns int. [ExcessCashTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? excesscashtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final excesscashtablesFuture = await _mnExcessCashTable!.toList(qparams);
    final int count = excesscashtablesFuture[0]['CNT'] as int;
    if (excesscashtableCount != null) {
      excesscashtableCount(count);
    }
    return count;
  }

  /// This method returns List<ExcessCashTable> [ExcessCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ExcessCashTable>
  @override
  Future<List<ExcessCashTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ExcessCashTable> excesscashtablesData =
        await ExcessCashTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return excesscashtablesData;
  }

  /// This method returns Json String [ExcessCashTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExcessCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExcessCashTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExcessCashTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExcessCashTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM excessCashTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnExcessCashTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExcessCashTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExcessCashTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ExcessCashTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExcessCashTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExcessCashTableFilterBuilder

// region ExcessCashTableFields
class ExcessCashTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fBOID;
  static TableField get BOID {
    return _fBOID = _fBOID ?? SqlSyntax.setField(_fBOID, 'BOID', DbType.text);
  }

  static TableField? _fDate;
  static TableField get Date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'Date', DbType.text);
  }

  static TableField? _fTime;
  static TableField get Time {
    return _fTime = _fTime ?? SqlSyntax.setField(_fTime, 'Time', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fHOName;
  static TableField get HOName {
    return _fHOName =
        _fHOName ?? SqlSyntax.setField(_fHOName, 'HOName', DbType.text);
  }

  static TableField? _fAmount1;
  static TableField get Amount1 {
    return _fAmount1 =
        _fAmount1 ?? SqlSyntax.setField(_fAmount1, 'Amount1', DbType.text);
  }

  static TableField? _fAmount2;
  static TableField get Amount2 {
    return _fAmount2 =
        _fAmount2 ?? SqlSyntax.setField(_fAmount2, 'Amount2', DbType.text);
  }

  static TableField? _fAmount3;
  static TableField get Amount3 {
    return _fAmount3 =
        _fAmount3 ?? SqlSyntax.setField(_fAmount3, 'Amount3', DbType.text);
  }

  static TableField? _fAmountType;
  static TableField get AmountType {
    return _fAmountType = _fAmountType ??
        SqlSyntax.setField(_fAmountType, 'AmountType', DbType.text);
  }

  static TableField? _fAmount4;
  static TableField get Amount4 {
    return _fAmount4 =
        _fAmount4 ?? SqlSyntax.setField(_fAmount4, 'Amount4', DbType.text);
  }
}
// endregion ExcessCashTableFields

//region ExcessCashTableManager
class ExcessCashTableManager extends SqfEntityProvider {
  ExcessCashTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'excessCashTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExcessCashTableManager
// region SetUpInventoryTable
class SetUpInventoryTable extends TableBase {
  SetUpInventoryTable(
      {this.id, this.BOId, this.InventoryName, this.Column1, this.Column2}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SetUpInventoryTable.withFields(
      this.BOId, this.InventoryName, this.Column1, this.Column2) {
    _setDefaultValues();
  }
  SetUpInventoryTable.withId(
      this.id, this.BOId, this.InventoryName, this.Column1, this.Column2) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SetUpInventoryTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['BOId'] != null) {
      BOId = o['BOId'].toString();
    }
    if (o['InventoryName'] != null) {
      InventoryName = o['InventoryName'].toString();
    }
    if (o['Column1'] != null) {
      Column1 = o['Column1'].toString();
    }
    if (o['Column2'] != null) {
      Column2 = o['Column2'].toString();
    }
  }
  // FIELDS (SetUpInventoryTable)
  int? id;
  String? BOId;
  String? InventoryName;
  String? Column1;
  String? Column2;

  // end FIELDS (SetUpInventoryTable)

  static const bool _softDeleteActivated = false;
  SetUpInventoryTableManager? __mnSetUpInventoryTable;

  SetUpInventoryTableManager get _mnSetUpInventoryTable {
    return __mnSetUpInventoryTable =
        __mnSetUpInventoryTable ?? SetUpInventoryTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOId != null || !forView) {
      map['BOId'] = BOId;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (Column1 != null || !forView) {
      map['Column1'] = Column1;
    }
    if (Column2 != null || !forView) {
      map['Column2'] = Column2;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BOId != null || !forView) {
      map['BOId'] = BOId;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (Column1 != null || !forView) {
      map['Column1'] = Column1;
    }
    if (Column2 != null || !forView) {
      map['Column2'] = Column2;
    }

    return map;
  }

  /// This method returns Json String [SetUpInventoryTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SetUpInventoryTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [BOId, InventoryName, Column1, Column2];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [id, BOId, InventoryName, Column1, Column2];
  }

  static Future<List<SetUpInventoryTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SetUpInventoryTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SetUpInventoryTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SetUpInventoryTable>[];
    try {
      objList = list
          .map((setupinventorytable) => SetUpInventoryTable.fromMap(
              setupinventorytable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SetUpInventoryTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SetUpInventoryTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SetUpInventoryTable> objList = <SetUpInventoryTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SetUpInventoryTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SetUpInventoryTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SetUpInventoryTable] if exist, otherwise returns null
  Future<SetUpInventoryTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SetUpInventoryTable? obj;
    final data = await _mnSetUpInventoryTable.getById([id]);
    if (data.length != 0) {
      obj = SetUpInventoryTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SetUpInventoryTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSetUpInventoryTable.insert(this, ignoreBatch);
    } else {
      await _mnSetUpInventoryTable.update(this);
    }

    return id;
  }

  /// Saves the (SetUpInventoryTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSetUpInventoryTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSetUpInventoryTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SetUpInventoryTable. Returns a new Primary Key value of SetUpInventoryTable

  /// <returns>Returns a new Primary Key value of SetUpInventoryTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SetUpInventoryTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SetUpInventoryTable> setupinventorytables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in setupinventorytables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < setupinventorytables.length; i++) {
        if (setupinventorytables[i].id == null) {
          setupinventorytables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSetUpInventoryTable.rawInsert(
          'INSERT OR REPLACE INTO setUpInventoryTable (id, BOId, InventoryName, Column1, Column2)  VALUES (?,?,?,?,?)',
          [id, BOId, InventoryName, Column1, Column2],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SetUpInventoryTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SetUpInventoryTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SetUpInventoryTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSetUpInventoryTable.rawInsert(
          'INSERT OR IGNORE INTO setUpInventoryTable (id, BOId, InventoryName, Column1, Column2)  VALUES (?,?,?,?,?)',
          [id, BOId, InventoryName, Column1, Column2],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SetUpInventoryTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SetUpInventoryTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SetUpInventoryTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SetUpInventoryTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SetUpInventoryTable> setupinventorytables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnSetUpInventoryTable.rawInsertAll(
        'INSERT OR REPLACE INTO setUpInventoryTable (id, BOId, InventoryName, Column1, Column2)  VALUES (?,?,?,?,?)',
        setupinventorytables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SetUpInventoryTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SetUpInventoryTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSetUpInventoryTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSetUpInventoryTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SetUpInventoryTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SetUpInventoryTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetUpInventoryTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SetUpInventoryTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SetUpInventoryTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion setupinventorytable

// region SetUpInventoryTableField
class SetUpInventoryTableField extends FilterBase {
  SetUpInventoryTableField(
      SetUpInventoryTableFilterBuilder setupinventorytableFB)
      : super(setupinventorytableFB);

  @override
  SetUpInventoryTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder isNull() {
    return super.isNull() as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SetUpInventoryTableFilterBuilder;
  }

  @override
  SetUpInventoryTableField get not {
    return super.not as SetUpInventoryTableField;
  }
}
// endregion SetUpInventoryTableField

// region SetUpInventoryTableFilterBuilder
class SetUpInventoryTableFilterBuilder extends ConjunctionBase {
  SetUpInventoryTableFilterBuilder(SetUpInventoryTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSetUpInventoryTable = obj._mnSetUpInventoryTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SetUpInventoryTableManager? _mnSetUpInventoryTable;

  /// put the sql keyword 'AND'
  @override
  SetUpInventoryTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SetUpInventoryTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SetUpInventoryTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SetUpInventoryTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SetUpInventoryTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SetUpInventoryTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SetUpInventoryTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetUpInventoryTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetUpInventoryTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SetUpInventoryTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SetUpInventoryTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SetUpInventoryTableField _setField(
      SetUpInventoryTableField? field, String colName, DbType dbtype) {
    return SetUpInventoryTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SetUpInventoryTableField? _id;
  SetUpInventoryTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SetUpInventoryTableField? _BOId;
  SetUpInventoryTableField get BOId {
    return _BOId = _setField(_BOId, 'BOId', DbType.text);
  }

  SetUpInventoryTableField? _InventoryName;
  SetUpInventoryTableField get InventoryName {
    return _InventoryName =
        _setField(_InventoryName, 'InventoryName', DbType.text);
  }

  SetUpInventoryTableField? _Column1;
  SetUpInventoryTableField get Column1 {
    return _Column1 = _setField(_Column1, 'Column1', DbType.text);
  }

  SetUpInventoryTableField? _Column2;
  SetUpInventoryTableField get Column2 {
    return _Column2 = _setField(_Column2, 'Column2', DbType.text);
  }

  /// Deletes List<SetUpInventoryTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSetUpInventoryTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSetUpInventoryTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from setUpInventoryTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSetUpInventoryTable!.updateBatch(qparams, values);
  }

  /// This method always returns [SetUpInventoryTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SetUpInventoryTable?
  @override
  Future<SetUpInventoryTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSetUpInventoryTable!.toList(qparams);
    final data = await objFuture;
    SetUpInventoryTable? obj;
    if (data.isNotEmpty) {
      obj = SetUpInventoryTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SetUpInventoryTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SetUpInventoryTable?
  @override
  Future<SetUpInventoryTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SetUpInventoryTable();
  }

  /// This method returns int. [SetUpInventoryTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? setupinventorytableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final setupinventorytablesFuture =
        await _mnSetUpInventoryTable!.toList(qparams);
    final int count = setupinventorytablesFuture[0]['CNT'] as int;
    if (setupinventorytableCount != null) {
      setupinventorytableCount(count);
    }
    return count;
  }

  /// This method returns List<SetUpInventoryTable> [SetUpInventoryTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SetUpInventoryTable>
  @override
  Future<List<SetUpInventoryTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SetUpInventoryTable> setupinventorytablesData =
        await SetUpInventoryTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return setupinventorytablesData;
  }

  /// This method returns Json String [SetUpInventoryTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SetUpInventoryTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SetUpInventoryTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSetUpInventoryTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SetUpInventoryTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM setUpInventoryTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSetUpInventoryTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SetUpInventoryTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSetUpInventoryTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SetUpInventoryTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSetUpInventoryTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SetUpInventoryTableFilterBuilder

// region SetUpInventoryTableFields
class SetUpInventoryTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fBOId;
  static TableField get BOId {
    return _fBOId = _fBOId ?? SqlSyntax.setField(_fBOId, 'BOId', DbType.text);
  }

  static TableField? _fInventoryName;
  static TableField get InventoryName {
    return _fInventoryName = _fInventoryName ??
        SqlSyntax.setField(_fInventoryName, 'InventoryName', DbType.text);
  }

  static TableField? _fColumn1;
  static TableField get Column1 {
    return _fColumn1 =
        _fColumn1 ?? SqlSyntax.setField(_fColumn1, 'Column1', DbType.text);
  }

  static TableField? _fColumn2;
  static TableField get Column2 {
    return _fColumn2 =
        _fColumn2 ?? SqlSyntax.setField(_fColumn2, 'Column2', DbType.text);
  }
}
// endregion SetUpInventoryTableFields

//region SetUpInventoryTableManager
class SetUpInventoryTableManager extends SqfEntityProvider {
  SetUpInventoryTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'setUpInventoryTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SetUpInventoryTableManager
// region LocalStoreTable
class LocalStoreTable extends TableBase {
  LocalStoreTable(
      {this.id,
      this.ParentOfficeId,
      this.ParentOfficeName,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.Address,
      this.Pin,
      this.Latitude,
      this.Longitude,
      this.City,
      this.StateCode,
      this.StateName,
      this.SolutionId,
      this.LegacyCode,
      this.CircleCode,
      this.Circle,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.IsStoreBegin,
      this.WalkInCustomerId,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  LocalStoreTable.withFields(
      this.ParentOfficeId,
      this.ParentOfficeName,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.Address,
      this.Pin,
      this.Latitude,
      this.Longitude,
      this.City,
      this.StateCode,
      this.StateName,
      this.SolutionId,
      this.LegacyCode,
      this.CircleCode,
      this.Circle,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.IsStoreBegin,
      this.WalkInCustomerId,
      this.Identifier) {
    _setDefaultValues();
  }
  LocalStoreTable.withId(
      this.id,
      this.ParentOfficeId,
      this.ParentOfficeName,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.Address,
      this.Pin,
      this.Latitude,
      this.Longitude,
      this.City,
      this.StateCode,
      this.StateName,
      this.SolutionId,
      this.LegacyCode,
      this.CircleCode,
      this.Circle,
      this.CreatedBy,
      this.CreatedOn,
      this.ModifiedBy,
      this.ModifiedOn,
      this.IsStoreBegin,
      this.WalkInCustomerId,
      this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  LocalStoreTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ParentOfficeId'] != null) {
      ParentOfficeId = o['ParentOfficeId'].toString();
    }
    if (o['ParentOfficeName'] != null) {
      ParentOfficeName = o['ParentOfficeName'].toString();
    }
    if (o['OfficeId'] != null) {
      OfficeId = o['OfficeId'].toString();
    }
    if (o['BOSequenceId'] != null) {
      BOSequenceId = o['BOSequenceId'].toString();
    }
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['Address'] != null) {
      Address = o['Address'].toString();
    }
    if (o['Pin'] != null) {
      Pin = o['Pin'].toString();
    }
    if (o['Latitude'] != null) {
      Latitude = o['Latitude'].toString();
    }
    if (o['Longitude'] != null) {
      Longitude = o['Longitude'].toString();
    }
    if (o['City'] != null) {
      City = o['City'].toString();
    }
    if (o['StateCode'] != null) {
      StateCode = o['StateCode'].toString();
    }
    if (o['StateName'] != null) {
      StateName = o['StateName'].toString();
    }
    if (o['SolutionId'] != null) {
      SolutionId = o['SolutionId'].toString();
    }
    if (o['LegacyCode'] != null) {
      LegacyCode = o['LegacyCode'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['Circle'] != null) {
      Circle = o['Circle'].toString();
    }
    if (o['CreatedBy'] != null) {
      CreatedBy = o['CreatedBy'].toString();
    }
    if (o['CreatedOn'] != null) {
      CreatedOn = o['CreatedOn'].toString();
    }
    if (o['ModifiedBy'] != null) {
      ModifiedBy = o['ModifiedBy'].toString();
    }
    if (o['ModifiedOn'] != null) {
      ModifiedOn = o['ModifiedOn'].toString();
    }
    if (o['IsStoreBegin'] != null) {
      IsStoreBegin = o['IsStoreBegin'].toString();
    }
    if (o['WalkInCustomerId'] != null) {
      WalkInCustomerId = o['WalkInCustomerId'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (LocalStoreTable)
  int? id;
  String? ParentOfficeId;
  String? ParentOfficeName;
  String? OfficeId;
  String? BOSequenceId;
  String? OfficeName;
  String? Address;
  String? Pin;
  String? Latitude;
  String? Longitude;
  String? City;
  String? StateCode;
  String? StateName;
  String? SolutionId;
  String? LegacyCode;
  String? CircleCode;
  String? Circle;
  String? CreatedBy;
  String? CreatedOn;
  String? ModifiedBy;
  String? ModifiedOn;
  String? IsStoreBegin;
  String? WalkInCustomerId;
  String? Identifier;

  // end FIELDS (LocalStoreTable)

  static const bool _softDeleteActivated = false;
  LocalStoreTableManager? __mnLocalStoreTable;

  LocalStoreTableManager get _mnLocalStoreTable {
    return __mnLocalStoreTable =
        __mnLocalStoreTable ?? LocalStoreTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeId != null || !forView) {
      map['ParentOfficeId'] = ParentOfficeId;
    }
    if (ParentOfficeName != null || !forView) {
      map['ParentOfficeName'] = ParentOfficeName;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (Pin != null || !forView) {
      map['Pin'] = Pin;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (StateCode != null || !forView) {
      map['StateCode'] = StateCode;
    }
    if (StateName != null || !forView) {
      map['StateName'] = StateName;
    }
    if (SolutionId != null || !forView) {
      map['SolutionId'] = SolutionId;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (Circle != null || !forView) {
      map['Circle'] = Circle;
    }
    if (CreatedBy != null || !forView) {
      map['CreatedBy'] = CreatedBy;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (ModifiedBy != null || !forView) {
      map['ModifiedBy'] = ModifiedBy;
    }
    if (ModifiedOn != null || !forView) {
      map['ModifiedOn'] = ModifiedOn;
    }
    if (IsStoreBegin != null || !forView) {
      map['IsStoreBegin'] = IsStoreBegin;
    }
    if (WalkInCustomerId != null || !forView) {
      map['WalkInCustomerId'] = WalkInCustomerId;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeId != null || !forView) {
      map['ParentOfficeId'] = ParentOfficeId;
    }
    if (ParentOfficeName != null || !forView) {
      map['ParentOfficeName'] = ParentOfficeName;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (Address != null || !forView) {
      map['Address'] = Address;
    }
    if (Pin != null || !forView) {
      map['Pin'] = Pin;
    }
    if (Latitude != null || !forView) {
      map['Latitude'] = Latitude;
    }
    if (Longitude != null || !forView) {
      map['Longitude'] = Longitude;
    }
    if (City != null || !forView) {
      map['City'] = City;
    }
    if (StateCode != null || !forView) {
      map['StateCode'] = StateCode;
    }
    if (StateName != null || !forView) {
      map['StateName'] = StateName;
    }
    if (SolutionId != null || !forView) {
      map['SolutionId'] = SolutionId;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (Circle != null || !forView) {
      map['Circle'] = Circle;
    }
    if (CreatedBy != null || !forView) {
      map['CreatedBy'] = CreatedBy;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (ModifiedBy != null || !forView) {
      map['ModifiedBy'] = ModifiedBy;
    }
    if (ModifiedOn != null || !forView) {
      map['ModifiedOn'] = ModifiedOn;
    }
    if (IsStoreBegin != null || !forView) {
      map['IsStoreBegin'] = IsStoreBegin;
    }
    if (WalkInCustomerId != null || !forView) {
      map['WalkInCustomerId'] = WalkInCustomerId;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [LocalStoreTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [LocalStoreTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ParentOfficeId,
      ParentOfficeName,
      OfficeId,
      BOSequenceId,
      OfficeName,
      Address,
      Pin,
      Latitude,
      Longitude,
      City,
      StateCode,
      StateName,
      SolutionId,
      LegacyCode,
      CircleCode,
      Circle,
      CreatedBy,
      CreatedOn,
      ModifiedBy,
      ModifiedOn,
      IsStoreBegin,
      WalkInCustomerId,
      Identifier
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ParentOfficeId,
      ParentOfficeName,
      OfficeId,
      BOSequenceId,
      OfficeName,
      Address,
      Pin,
      Latitude,
      Longitude,
      City,
      StateCode,
      StateName,
      SolutionId,
      LegacyCode,
      CircleCode,
      Circle,
      CreatedBy,
      CreatedOn,
      ModifiedBy,
      ModifiedOn,
      IsStoreBegin,
      WalkInCustomerId,
      Identifier
    ];
  }

  static Future<List<LocalStoreTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LocalStoreTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<LocalStoreTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <LocalStoreTable>[];
    try {
      objList = list
          .map((localstoretable) =>
              LocalStoreTable.fromMap(localstoretable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LocalStoreTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<LocalStoreTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<LocalStoreTable> objList = <LocalStoreTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = LocalStoreTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns LocalStoreTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [LocalStoreTable] if exist, otherwise returns null
  Future<LocalStoreTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    LocalStoreTable? obj;
    final data = await _mnLocalStoreTable.getById([id]);
    if (data.length != 0) {
      obj = LocalStoreTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (LocalStoreTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLocalStoreTable.insert(this, ignoreBatch);
    } else {
      await _mnLocalStoreTable.update(this);
    }

    return id;
  }

  /// Saves the (LocalStoreTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnLocalStoreTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnLocalStoreTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs LocalStoreTable. Returns a new Primary Key value of LocalStoreTable

  /// <returns>Returns a new Primary Key value of LocalStoreTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<LocalStoreTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<LocalStoreTable> localstoretables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in localstoretables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < localstoretables.length; i++) {
        if (localstoretables[i].id == null) {
          localstoretables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLocalStoreTable.rawInsert(
          'INSERT OR REPLACE INTO localStoreTable (id, ParentOfficeId, ParentOfficeName, OfficeId, BOSequenceId, OfficeName, Address, Pin, Latitude, Longitude, City, StateCode, StateName, SolutionId, LegacyCode, CircleCode, Circle, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, IsStoreBegin, WalkInCustomerId, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeId,
            ParentOfficeName,
            OfficeId,
            BOSequenceId,
            OfficeName,
            Address,
            Pin,
            Latitude,
            Longitude,
            City,
            StateCode,
            StateName,
            SolutionId,
            LegacyCode,
            CircleCode,
            Circle,
            CreatedBy,
            CreatedOn,
            ModifiedBy,
            ModifiedOn,
            IsStoreBegin,
            WalkInCustomerId,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'LocalStoreTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'LocalStoreTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LocalStoreTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLocalStoreTable.rawInsert(
          'INSERT OR IGNORE INTO localStoreTable (id, ParentOfficeId, ParentOfficeName, OfficeId, BOSequenceId, OfficeName, Address, Pin, Latitude, Longitude, City, StateCode, StateName, SolutionId, LegacyCode, CircleCode, Circle, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, IsStoreBegin, WalkInCustomerId, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeId,
            ParentOfficeName,
            OfficeId,
            BOSequenceId,
            OfficeName,
            Address,
            Pin,
            Latitude,
            Longitude,
            City,
            StateCode,
            StateName,
            SolutionId,
            LegacyCode,
            CircleCode,
            Circle,
            CreatedBy,
            CreatedOn,
            ModifiedBy,
            ModifiedOn,
            IsStoreBegin,
            WalkInCustomerId,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'LocalStoreTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'LocalStoreTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LocalStoreTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<LocalStoreTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<LocalStoreTable> localstoretables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnLocalStoreTable.rawInsertAll(
        'INSERT OR REPLACE INTO localStoreTable (id, ParentOfficeId, ParentOfficeName, OfficeId, BOSequenceId, OfficeName, Address, Pin, Latitude, Longitude, City, StateCode, StateName, SolutionId, LegacyCode, CircleCode, Circle, CreatedBy, CreatedOn, ModifiedBy, ModifiedOn, IsStoreBegin, WalkInCustomerId, Identifier)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        localstoretables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes LocalStoreTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete LocalStoreTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLocalStoreTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnLocalStoreTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [LocalStoreTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LocalStoreTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LocalStoreTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LocalStoreTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LocalStoreTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion localstoretable

// region LocalStoreTableField
class LocalStoreTableField extends FilterBase {
  LocalStoreTableField(LocalStoreTableFilterBuilder localstoretableFB)
      : super(localstoretableFB);

  @override
  LocalStoreTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder isNull() {
    return super.isNull() as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LocalStoreTableFilterBuilder;
  }

  @override
  LocalStoreTableField get not {
    return super.not as LocalStoreTableField;
  }
}
// endregion LocalStoreTableField

// region LocalStoreTableFilterBuilder
class LocalStoreTableFilterBuilder extends ConjunctionBase {
  LocalStoreTableFilterBuilder(LocalStoreTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLocalStoreTable = obj._mnLocalStoreTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LocalStoreTableManager? _mnLocalStoreTable;

  /// put the sql keyword 'AND'
  @override
  LocalStoreTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LocalStoreTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LocalStoreTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LocalStoreTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LocalStoreTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LocalStoreTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LocalStoreTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LocalStoreTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LocalStoreTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LocalStoreTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LocalStoreTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LocalStoreTableField _setField(
      LocalStoreTableField? field, String colName, DbType dbtype) {
    return LocalStoreTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LocalStoreTableField? _id;
  LocalStoreTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  LocalStoreTableField? _ParentOfficeId;
  LocalStoreTableField get ParentOfficeId {
    return _ParentOfficeId =
        _setField(_ParentOfficeId, 'ParentOfficeId', DbType.text);
  }

  LocalStoreTableField? _ParentOfficeName;
  LocalStoreTableField get ParentOfficeName {
    return _ParentOfficeName =
        _setField(_ParentOfficeName, 'ParentOfficeName', DbType.text);
  }

  LocalStoreTableField? _OfficeId;
  LocalStoreTableField get OfficeId {
    return _OfficeId = _setField(_OfficeId, 'OfficeId', DbType.text);
  }

  LocalStoreTableField? _BOSequenceId;
  LocalStoreTableField get BOSequenceId {
    return _BOSequenceId =
        _setField(_BOSequenceId, 'BOSequenceId', DbType.text);
  }

  LocalStoreTableField? _OfficeName;
  LocalStoreTableField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  LocalStoreTableField? _Address;
  LocalStoreTableField get Address {
    return _Address = _setField(_Address, 'Address', DbType.text);
  }

  LocalStoreTableField? _Pin;
  LocalStoreTableField get Pin {
    return _Pin = _setField(_Pin, 'Pin', DbType.text);
  }

  LocalStoreTableField? _Latitude;
  LocalStoreTableField get Latitude {
    return _Latitude = _setField(_Latitude, 'Latitude', DbType.text);
  }

  LocalStoreTableField? _Longitude;
  LocalStoreTableField get Longitude {
    return _Longitude = _setField(_Longitude, 'Longitude', DbType.text);
  }

  LocalStoreTableField? _City;
  LocalStoreTableField get City {
    return _City = _setField(_City, 'City', DbType.text);
  }

  LocalStoreTableField? _StateCode;
  LocalStoreTableField get StateCode {
    return _StateCode = _setField(_StateCode, 'StateCode', DbType.text);
  }

  LocalStoreTableField? _StateName;
  LocalStoreTableField get StateName {
    return _StateName = _setField(_StateName, 'StateName', DbType.text);
  }

  LocalStoreTableField? _SolutionId;
  LocalStoreTableField get SolutionId {
    return _SolutionId = _setField(_SolutionId, 'SolutionId', DbType.text);
  }

  LocalStoreTableField? _LegacyCode;
  LocalStoreTableField get LegacyCode {
    return _LegacyCode = _setField(_LegacyCode, 'LegacyCode', DbType.text);
  }

  LocalStoreTableField? _CircleCode;
  LocalStoreTableField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  LocalStoreTableField? _Circle;
  LocalStoreTableField get Circle {
    return _Circle = _setField(_Circle, 'Circle', DbType.text);
  }

  LocalStoreTableField? _CreatedBy;
  LocalStoreTableField get CreatedBy {
    return _CreatedBy = _setField(_CreatedBy, 'CreatedBy', DbType.text);
  }

  LocalStoreTableField? _CreatedOn;
  LocalStoreTableField get CreatedOn {
    return _CreatedOn = _setField(_CreatedOn, 'CreatedOn', DbType.text);
  }

  LocalStoreTableField? _ModifiedBy;
  LocalStoreTableField get ModifiedBy {
    return _ModifiedBy = _setField(_ModifiedBy, 'ModifiedBy', DbType.text);
  }

  LocalStoreTableField? _ModifiedOn;
  LocalStoreTableField get ModifiedOn {
    return _ModifiedOn = _setField(_ModifiedOn, 'ModifiedOn', DbType.text);
  }

  LocalStoreTableField? _IsStoreBegin;
  LocalStoreTableField get IsStoreBegin {
    return _IsStoreBegin =
        _setField(_IsStoreBegin, 'IsStoreBegin', DbType.text);
  }

  LocalStoreTableField? _WalkInCustomerId;
  LocalStoreTableField get WalkInCustomerId {
    return _WalkInCustomerId =
        _setField(_WalkInCustomerId, 'WalkInCustomerId', DbType.text);
  }

  LocalStoreTableField? _Identifier;
  LocalStoreTableField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<LocalStoreTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLocalStoreTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLocalStoreTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from localStoreTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLocalStoreTable!.updateBatch(qparams, values);
  }

  /// This method always returns [LocalStoreTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LocalStoreTable?
  @override
  Future<LocalStoreTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLocalStoreTable!.toList(qparams);
    final data = await objFuture;
    LocalStoreTable? obj;
    if (data.isNotEmpty) {
      obj = LocalStoreTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [LocalStoreTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LocalStoreTable?
  @override
  Future<LocalStoreTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        LocalStoreTable();
  }

  /// This method returns int. [LocalStoreTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? localstoretableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final localstoretablesFuture = await _mnLocalStoreTable!.toList(qparams);
    final int count = localstoretablesFuture[0]['CNT'] as int;
    if (localstoretableCount != null) {
      localstoretableCount(count);
    }
    return count;
  }

  /// This method returns List<LocalStoreTable> [LocalStoreTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<LocalStoreTable>
  @override
  Future<List<LocalStoreTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<LocalStoreTable> localstoretablesData =
        await LocalStoreTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return localstoretablesData;
  }

  /// This method returns Json String [LocalStoreTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [LocalStoreTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [LocalStoreTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLocalStoreTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [LocalStoreTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM localStoreTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnLocalStoreTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [LocalStoreTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLocalStoreTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await LocalStoreTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLocalStoreTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LocalStoreTableFilterBuilder

// region LocalStoreTableFields
class LocalStoreTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fParentOfficeId;
  static TableField get ParentOfficeId {
    return _fParentOfficeId = _fParentOfficeId ??
        SqlSyntax.setField(_fParentOfficeId, 'ParentOfficeId', DbType.text);
  }

  static TableField? _fParentOfficeName;
  static TableField get ParentOfficeName {
    return _fParentOfficeName = _fParentOfficeName ??
        SqlSyntax.setField(_fParentOfficeName, 'ParentOfficeName', DbType.text);
  }

  static TableField? _fOfficeId;
  static TableField get OfficeId {
    return _fOfficeId =
        _fOfficeId ?? SqlSyntax.setField(_fOfficeId, 'OfficeId', DbType.text);
  }

  static TableField? _fBOSequenceId;
  static TableField get BOSequenceId {
    return _fBOSequenceId = _fBOSequenceId ??
        SqlSyntax.setField(_fBOSequenceId, 'BOSequenceId', DbType.text);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fAddress;
  static TableField get Address {
    return _fAddress =
        _fAddress ?? SqlSyntax.setField(_fAddress, 'Address', DbType.text);
  }

  static TableField? _fPin;
  static TableField get Pin {
    return _fPin = _fPin ?? SqlSyntax.setField(_fPin, 'Pin', DbType.text);
  }

  static TableField? _fLatitude;
  static TableField get Latitude {
    return _fLatitude =
        _fLatitude ?? SqlSyntax.setField(_fLatitude, 'Latitude', DbType.text);
  }

  static TableField? _fLongitude;
  static TableField get Longitude {
    return _fLongitude = _fLongitude ??
        SqlSyntax.setField(_fLongitude, 'Longitude', DbType.text);
  }

  static TableField? _fCity;
  static TableField get City {
    return _fCity = _fCity ?? SqlSyntax.setField(_fCity, 'City', DbType.text);
  }

  static TableField? _fStateCode;
  static TableField get StateCode {
    return _fStateCode = _fStateCode ??
        SqlSyntax.setField(_fStateCode, 'StateCode', DbType.text);
  }

  static TableField? _fStateName;
  static TableField get StateName {
    return _fStateName = _fStateName ??
        SqlSyntax.setField(_fStateName, 'StateName', DbType.text);
  }

  static TableField? _fSolutionId;
  static TableField get SolutionId {
    return _fSolutionId = _fSolutionId ??
        SqlSyntax.setField(_fSolutionId, 'SolutionId', DbType.text);
  }

  static TableField? _fLegacyCode;
  static TableField get LegacyCode {
    return _fLegacyCode = _fLegacyCode ??
        SqlSyntax.setField(_fLegacyCode, 'LegacyCode', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fCircle;
  static TableField get Circle {
    return _fCircle =
        _fCircle ?? SqlSyntax.setField(_fCircle, 'Circle', DbType.text);
  }

  static TableField? _fCreatedBy;
  static TableField get CreatedBy {
    return _fCreatedBy = _fCreatedBy ??
        SqlSyntax.setField(_fCreatedBy, 'CreatedBy', DbType.text);
  }

  static TableField? _fCreatedOn;
  static TableField get CreatedOn {
    return _fCreatedOn = _fCreatedOn ??
        SqlSyntax.setField(_fCreatedOn, 'CreatedOn', DbType.text);
  }

  static TableField? _fModifiedBy;
  static TableField get ModifiedBy {
    return _fModifiedBy = _fModifiedBy ??
        SqlSyntax.setField(_fModifiedBy, 'ModifiedBy', DbType.text);
  }

  static TableField? _fModifiedOn;
  static TableField get ModifiedOn {
    return _fModifiedOn = _fModifiedOn ??
        SqlSyntax.setField(_fModifiedOn, 'ModifiedOn', DbType.text);
  }

  static TableField? _fIsStoreBegin;
  static TableField get IsStoreBegin {
    return _fIsStoreBegin = _fIsStoreBegin ??
        SqlSyntax.setField(_fIsStoreBegin, 'IsStoreBegin', DbType.text);
  }

  static TableField? _fWalkInCustomerId;
  static TableField get WalkInCustomerId {
    return _fWalkInCustomerId = _fWalkInCustomerId ??
        SqlSyntax.setField(_fWalkInCustomerId, 'WalkInCustomerId', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion LocalStoreTableFields

//region LocalStoreTableManager
class LocalStoreTableManager extends SqfEntityProvider {
  LocalStoreTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'localStoreTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion LocalStoreTableManager
// region AdditionalServiceMappingTable
class AdditionalServiceMappingTable extends TableBase {
  AdditionalServiceMappingTable(
      {this.id,
      this.ServiceId,
      this.AdditionalServiceId,
      this.AdditionalServicePrice,
      this.Identifier}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  AdditionalServiceMappingTable.withFields(this.ServiceId,
      this.AdditionalServiceId, this.AdditionalServicePrice, this.Identifier) {
    _setDefaultValues();
  }
  AdditionalServiceMappingTable.withId(this.id, this.ServiceId,
      this.AdditionalServiceId, this.AdditionalServicePrice, this.Identifier) {
    _setDefaultValues();
  }
  // fromMap v2.0
  AdditionalServiceMappingTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ServiceId'] != null) {
      ServiceId = o['ServiceId'].toString();
    }
    if (o['AdditionalServiceId'] != null) {
      AdditionalServiceId = o['AdditionalServiceId'].toString();
    }
    if (o['AdditionalServicePrice'] != null) {
      AdditionalServicePrice = o['AdditionalServicePrice'].toString();
    }
    if (o['Identifier'] != null) {
      Identifier = o['Identifier'].toString();
    }
  }
  // FIELDS (AdditionalServiceMappingTable)
  int? id;
  String? ServiceId;
  String? AdditionalServiceId;
  String? AdditionalServicePrice;
  String? Identifier;

  // end FIELDS (AdditionalServiceMappingTable)

  static const bool _softDeleteActivated = false;
  AdditionalServiceMappingTableManager? __mnAdditionalServiceMappingTable;

  AdditionalServiceMappingTableManager get _mnAdditionalServiceMappingTable {
    return __mnAdditionalServiceMappingTable =
        __mnAdditionalServiceMappingTable ??
            AdditionalServiceMappingTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (AdditionalServiceId != null || !forView) {
      map['AdditionalServiceId'] = AdditionalServiceId;
    }
    if (AdditionalServicePrice != null || !forView) {
      map['AdditionalServicePrice'] = AdditionalServicePrice;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ServiceId != null || !forView) {
      map['ServiceId'] = ServiceId;
    }
    if (AdditionalServiceId != null || !forView) {
      map['AdditionalServiceId'] = AdditionalServiceId;
    }
    if (AdditionalServicePrice != null || !forView) {
      map['AdditionalServicePrice'] = AdditionalServicePrice;
    }
    if (Identifier != null || !forView) {
      map['Identifier'] = Identifier;
    }

    return map;
  }

  /// This method returns Json String [AdditionalServiceMappingTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [AdditionalServiceMappingTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [ServiceId, AdditionalServiceId, AdditionalServicePrice, Identifier];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ServiceId,
      AdditionalServiceId,
      AdditionalServicePrice,
      Identifier
    ];
  }

  static Future<List<AdditionalServiceMappingTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR AdditionalServiceMappingTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<AdditionalServiceMappingTable>> fromJson(
      String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <AdditionalServiceMappingTable>[];
    try {
      objList = list
          .map((additionalservicemappingtable) =>
              AdditionalServiceMappingTable.fromMap(
                  additionalservicemappingtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR AdditionalServiceMappingTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<AdditionalServiceMappingTable>> fromMapList(
      List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<AdditionalServiceMappingTable> objList =
        <AdditionalServiceMappingTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = AdditionalServiceMappingTable.fromMap(
          map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns AdditionalServiceMappingTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [AdditionalServiceMappingTable] if exist, otherwise returns null
  Future<AdditionalServiceMappingTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    AdditionalServiceMappingTable? obj;
    final data = await _mnAdditionalServiceMappingTable.getById([id]);
    if (data.length != 0) {
      obj = AdditionalServiceMappingTable.fromMap(
          data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (AdditionalServiceMappingTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnAdditionalServiceMappingTable.insert(this, ignoreBatch);
    } else {
      await _mnAdditionalServiceMappingTable.update(this);
    }

    return id;
  }

  /// Saves the (AdditionalServiceMappingTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnAdditionalServiceMappingTable.insertOrThrow(
          this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnAdditionalServiceMappingTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs AdditionalServiceMappingTable. Returns a new Primary Key value of AdditionalServiceMappingTable

  /// <returns>Returns a new Primary Key value of AdditionalServiceMappingTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<AdditionalServiceMappingTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<AdditionalServiceMappingTable> additionalservicemappingtables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in additionalservicemappingtables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < additionalservicemappingtables.length; i++) {
        if (additionalservicemappingtables[i].id == null) {
          additionalservicemappingtables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAdditionalServiceMappingTable.rawInsert(
          'INSERT OR REPLACE INTO additionalServiceMappingTable (id, ServiceId, AdditionalServiceId, AdditionalServicePrice, Identifier)  VALUES (?,?,?,?,?)',
          [
            id,
            ServiceId,
            AdditionalServiceId,
            AdditionalServicePrice,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'AdditionalServiceMappingTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'AdditionalServiceMappingTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'AdditionalServiceMappingTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnAdditionalServiceMappingTable.rawInsert(
          'INSERT OR IGNORE INTO additionalServiceMappingTable (id, ServiceId, AdditionalServiceId, AdditionalServicePrice, Identifier)  VALUES (?,?,?,?,?)',
          [
            id,
            ServiceId,
            AdditionalServiceId,
            AdditionalServicePrice,
            Identifier
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'AdditionalServiceMappingTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'AdditionalServiceMappingTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'AdditionalServiceMappingTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<AdditionalServiceMappingTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<AdditionalServiceMappingTable> additionalservicemappingtables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnAdditionalServiceMappingTable.rawInsertAll(
        'INSERT OR REPLACE INTO additionalServiceMappingTable (id, ServiceId, AdditionalServiceId, AdditionalServicePrice, Identifier)  VALUES (?,?,?,?,?)',
        additionalservicemappingtables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes AdditionalServiceMappingTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete AdditionalServiceMappingTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnAdditionalServiceMappingTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnAdditionalServiceMappingTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [AdditionalServiceMappingTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  AdditionalServiceMappingTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AdditionalServiceMappingTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return AdditionalServiceMappingTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion additionalservicemappingtable

// region AdditionalServiceMappingTableField
class AdditionalServiceMappingTableField extends FilterBase {
  AdditionalServiceMappingTableField(
      AdditionalServiceMappingTableFilterBuilder
          additionalservicemappingtableFB)
      : super(additionalservicemappingtableFB);

  @override
  AdditionalServiceMappingTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder isNull() {
    return super.isNull() as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder between(
      dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder greaterThanOrEquals(
      dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as AdditionalServiceMappingTableFilterBuilder;
  }

  @override
  AdditionalServiceMappingTableField get not {
    return super.not as AdditionalServiceMappingTableField;
  }
}
// endregion AdditionalServiceMappingTableField

// region AdditionalServiceMappingTableFilterBuilder
class AdditionalServiceMappingTableFilterBuilder extends ConjunctionBase {
  AdditionalServiceMappingTableFilterBuilder(
      AdditionalServiceMappingTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnAdditionalServiceMappingTable = obj._mnAdditionalServiceMappingTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  AdditionalServiceMappingTableManager? _mnAdditionalServiceMappingTable;

  /// put the sql keyword 'AND'
  @override
  AdditionalServiceMappingTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  AdditionalServiceMappingTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  AdditionalServiceMappingTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  AdditionalServiceMappingTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  AdditionalServiceMappingTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  AdditionalServiceMappingTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  AdditionalServiceMappingTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AdditionalServiceMappingTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AdditionalServiceMappingTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  AdditionalServiceMappingTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  AdditionalServiceMappingTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  AdditionalServiceMappingTableField _setField(
      AdditionalServiceMappingTableField? field,
      String colName,
      DbType dbtype) {
    return AdditionalServiceMappingTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  AdditionalServiceMappingTableField? _id;
  AdditionalServiceMappingTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  AdditionalServiceMappingTableField? _ServiceId;
  AdditionalServiceMappingTableField get ServiceId {
    return _ServiceId = _setField(_ServiceId, 'ServiceId', DbType.text);
  }

  AdditionalServiceMappingTableField? _AdditionalServiceId;
  AdditionalServiceMappingTableField get AdditionalServiceId {
    return _AdditionalServiceId =
        _setField(_AdditionalServiceId, 'AdditionalServiceId', DbType.text);
  }

  AdditionalServiceMappingTableField? _AdditionalServicePrice;
  AdditionalServiceMappingTableField get AdditionalServicePrice {
    return _AdditionalServicePrice = _setField(
        _AdditionalServicePrice, 'AdditionalServicePrice', DbType.text);
  }

  AdditionalServiceMappingTableField? _Identifier;
  AdditionalServiceMappingTableField get Identifier {
    return _Identifier = _setField(_Identifier, 'Identifier', DbType.text);
  }

  /// Deletes List<AdditionalServiceMappingTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnAdditionalServiceMappingTable!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnAdditionalServiceMappingTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from additionalServiceMappingTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnAdditionalServiceMappingTable!.updateBatch(qparams, values);
  }

  /// This method always returns [AdditionalServiceMappingTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> AdditionalServiceMappingTable?
  @override
  Future<AdditionalServiceMappingTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnAdditionalServiceMappingTable!.toList(qparams);
    final data = await objFuture;
    AdditionalServiceMappingTable? obj;
    if (data.isNotEmpty) {
      obj = AdditionalServiceMappingTable.fromMap(
          data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [AdditionalServiceMappingTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> AdditionalServiceMappingTable?
  @override
  Future<AdditionalServiceMappingTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        AdditionalServiceMappingTable();
  }

  /// This method returns int. [AdditionalServiceMappingTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)?
          additionalservicemappingtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final additionalservicemappingtablesFuture =
        await _mnAdditionalServiceMappingTable!.toList(qparams);
    final int count = additionalservicemappingtablesFuture[0]['CNT'] as int;
    if (additionalservicemappingtableCount != null) {
      additionalservicemappingtableCount(count);
    }
    return count;
  }

  /// This method returns List<AdditionalServiceMappingTable> [AdditionalServiceMappingTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<AdditionalServiceMappingTable>
  @override
  Future<List<AdditionalServiceMappingTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<AdditionalServiceMappingTable>
        additionalservicemappingtablesData =
        await AdditionalServiceMappingTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return additionalservicemappingtablesData;
  }

  /// This method returns Json String [AdditionalServiceMappingTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [AdditionalServiceMappingTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [AdditionalServiceMappingTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnAdditionalServiceMappingTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [AdditionalServiceMappingTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM additionalServiceMappingTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnAdditionalServiceMappingTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [AdditionalServiceMappingTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnAdditionalServiceMappingTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await AdditionalServiceMappingTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnAdditionalServiceMappingTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion AdditionalServiceMappingTableFilterBuilder

// region AdditionalServiceMappingTableFields
class AdditionalServiceMappingTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fServiceId;
  static TableField get ServiceId {
    return _fServiceId = _fServiceId ??
        SqlSyntax.setField(_fServiceId, 'ServiceId', DbType.text);
  }

  static TableField? _fAdditionalServiceId;
  static TableField get AdditionalServiceId {
    return _fAdditionalServiceId = _fAdditionalServiceId ??
        SqlSyntax.setField(
            _fAdditionalServiceId, 'AdditionalServiceId', DbType.text);
  }

  static TableField? _fAdditionalServicePrice;
  static TableField get AdditionalServicePrice {
    return _fAdditionalServicePrice = _fAdditionalServicePrice ??
        SqlSyntax.setField(
            _fAdditionalServicePrice, 'AdditionalServicePrice', DbType.text);
  }

  static TableField? _fIdentifier;
  static TableField get Identifier {
    return _fIdentifier = _fIdentifier ??
        SqlSyntax.setField(_fIdentifier, 'Identifier', DbType.text);
  }
}
// endregion AdditionalServiceMappingTableFields

//region AdditionalServiceMappingTableManager
class AdditionalServiceMappingTableManager extends SqfEntityProvider {
  AdditionalServiceMappingTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'additionalServiceMappingTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion AdditionalServiceMappingTableManager
// region SwitchOnTable
class SwitchOnTable extends TableBase {
  SwitchOnTable(
      {this.id,
      this.ParentOfficeId,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SwitchOnTable.withFields(
      this.ParentOfficeId,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance) {
    _setDefaultValues();
  }
  SwitchOnTable.withId(
      this.id,
      this.ParentOfficeId,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SwitchOnTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ParentOfficeId'] != null) {
      ParentOfficeId = o['ParentOfficeId'].toString();
    }
    if (o['OfficeId'] != null) {
      OfficeId = o['OfficeId'].toString();
    }
    if (o['BOSequenceId'] != null) {
      BOSequenceId = o['BOSequenceId'].toString();
    }
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['LegacyCode'] != null) {
      LegacyCode = o['LegacyCode'].toString();
    }
    if (o['SanctionedLimit'] != null) {
      SanctionedLimit = o['SanctionedLimit'].toString();
    }
    if (o['CashBalance'] != null) {
      CashBalance = o['CashBalance'].toString();
    }
  }
  // FIELDS (SwitchOnTable)
  int? id;
  String? ParentOfficeId;
  String? OfficeId;
  String? BOSequenceId;
  String? OfficeName;
  String? LegacyCode;
  String? SanctionedLimit;
  String? CashBalance;

  // end FIELDS (SwitchOnTable)

  static const bool _softDeleteActivated = false;
  SwitchOnTableManager? __mnSwitchOnTable;

  SwitchOnTableManager get _mnSwitchOnTable {
    return __mnSwitchOnTable = __mnSwitchOnTable ?? SwitchOnTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeId != null || !forView) {
      map['ParentOfficeId'] = ParentOfficeId;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (SanctionedLimit != null || !forView) {
      map['SanctionedLimit'] = SanctionedLimit;
    }
    if (CashBalance != null || !forView) {
      map['CashBalance'] = CashBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeId != null || !forView) {
      map['ParentOfficeId'] = ParentOfficeId;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (SanctionedLimit != null || !forView) {
      map['SanctionedLimit'] = SanctionedLimit;
    }
    if (CashBalance != null || !forView) {
      map['CashBalance'] = CashBalance;
    }

    return map;
  }

  /// This method returns Json String [SwitchOnTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SwitchOnTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ParentOfficeId,
      OfficeId,
      BOSequenceId,
      OfficeName,
      LegacyCode,
      SanctionedLimit,
      CashBalance
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ParentOfficeId,
      OfficeId,
      BOSequenceId,
      OfficeName,
      LegacyCode,
      SanctionedLimit,
      CashBalance
    ];
  }

  static Future<List<SwitchOnTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SwitchOnTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SwitchOnTable>[];
    try {
      objList = list
          .map((switchontable) =>
              SwitchOnTable.fromMap(switchontable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SwitchOnTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SwitchOnTable> objList = <SwitchOnTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SwitchOnTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SwitchOnTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SwitchOnTable] if exist, otherwise returns null
  Future<SwitchOnTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SwitchOnTable? obj;
    final data = await _mnSwitchOnTable.getById([id]);
    if (data.length != 0) {
      obj = SwitchOnTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SwitchOnTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnTable.insert(this, ignoreBatch);
    } else {
      await _mnSwitchOnTable.update(this);
    }

    return id;
  }

  /// Saves the (SwitchOnTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSwitchOnTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SwitchOnTable. Returns a new Primary Key value of SwitchOnTable

  /// <returns>Returns a new Primary Key value of SwitchOnTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SwitchOnTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<SwitchOnTable> switchontables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in switchontables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < switchontables.length; i++) {
        if (switchontables[i].id == null) {
          switchontables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnTable.rawInsert(
          'INSERT OR REPLACE INTO switchOnTable (id, ParentOfficeId, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeId,
            OfficeId,
            BOSequenceId,
            OfficeName,
            LegacyCode,
            SanctionedLimit,
            CashBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SwitchOnTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SwitchOnTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnTable.rawInsert(
          'INSERT OR IGNORE INTO switchOnTable (id, ParentOfficeId, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeId,
            OfficeId,
            BOSequenceId,
            OfficeName,
            LegacyCode,
            SanctionedLimit,
            CashBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SwitchOnTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'SwitchOnTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SwitchOnTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<SwitchOnTable> switchontables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnSwitchOnTable.rawInsertAll(
        'INSERT OR REPLACE INTO switchOnTable (id, ParentOfficeId, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
        switchontables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SwitchOnTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SwitchOnTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSwitchOnTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSwitchOnTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SwitchOnTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SwitchOnTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SwitchOnTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion switchontable

// region SwitchOnTableField
class SwitchOnTableField extends FilterBase {
  SwitchOnTableField(SwitchOnTableFilterBuilder switchontableFB)
      : super(switchontableFB);

  @override
  SwitchOnTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder isNull() {
    return super.isNull() as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SwitchOnTableFilterBuilder;
  }

  @override
  SwitchOnTableField get not {
    return super.not as SwitchOnTableField;
  }
}
// endregion SwitchOnTableField

// region SwitchOnTableFilterBuilder
class SwitchOnTableFilterBuilder extends ConjunctionBase {
  SwitchOnTableFilterBuilder(SwitchOnTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSwitchOnTable = obj._mnSwitchOnTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SwitchOnTableManager? _mnSwitchOnTable;

  /// put the sql keyword 'AND'
  @override
  SwitchOnTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SwitchOnTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SwitchOnTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SwitchOnTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SwitchOnTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SwitchOnTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SwitchOnTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SwitchOnTableField _setField(
      SwitchOnTableField? field, String colName, DbType dbtype) {
    return SwitchOnTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SwitchOnTableField? _id;
  SwitchOnTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SwitchOnTableField? _ParentOfficeId;
  SwitchOnTableField get ParentOfficeId {
    return _ParentOfficeId =
        _setField(_ParentOfficeId, 'ParentOfficeId', DbType.text);
  }

  SwitchOnTableField? _OfficeId;
  SwitchOnTableField get OfficeId {
    return _OfficeId = _setField(_OfficeId, 'OfficeId', DbType.text);
  }

  SwitchOnTableField? _BOSequenceId;
  SwitchOnTableField get BOSequenceId {
    return _BOSequenceId =
        _setField(_BOSequenceId, 'BOSequenceId', DbType.text);
  }

  SwitchOnTableField? _OfficeName;
  SwitchOnTableField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  SwitchOnTableField? _LegacyCode;
  SwitchOnTableField get LegacyCode {
    return _LegacyCode = _setField(_LegacyCode, 'LegacyCode', DbType.text);
  }

  SwitchOnTableField? _SanctionedLimit;
  SwitchOnTableField get SanctionedLimit {
    return _SanctionedLimit =
        _setField(_SanctionedLimit, 'SanctionedLimit', DbType.text);
  }

  SwitchOnTableField? _CashBalance;
  SwitchOnTableField get CashBalance {
    return _CashBalance = _setField(_CashBalance, 'CashBalance', DbType.text);
  }

  /// Deletes List<SwitchOnTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSwitchOnTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSwitchOnTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from switchOnTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSwitchOnTable!.updateBatch(qparams, values);
  }

  /// This method always returns [SwitchOnTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnTable?
  @override
  Future<SwitchOnTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSwitchOnTable!.toList(qparams);
    final data = await objFuture;
    SwitchOnTable? obj;
    if (data.isNotEmpty) {
      obj = SwitchOnTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SwitchOnTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnTable?
  @override
  Future<SwitchOnTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SwitchOnTable();
  }

  /// This method returns int. [SwitchOnTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? switchontableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final switchontablesFuture = await _mnSwitchOnTable!.toList(qparams);
    final int count = switchontablesFuture[0]['CNT'] as int;
    if (switchontableCount != null) {
      switchontableCount(count);
    }
    return count;
  }

  /// This method returns List<SwitchOnTable> [SwitchOnTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SwitchOnTable>
  @override
  Future<List<SwitchOnTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SwitchOnTable> switchontablesData =
        await SwitchOnTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return switchontablesData;
  }

  /// This method returns Json String [SwitchOnTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SwitchOnTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SwitchOnTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSwitchOnTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SwitchOnTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM switchOnTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSwitchOnTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SwitchOnTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSwitchOnTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SwitchOnTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSwitchOnTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SwitchOnTableFilterBuilder

// region SwitchOnTableFields
class SwitchOnTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fParentOfficeId;
  static TableField get ParentOfficeId {
    return _fParentOfficeId = _fParentOfficeId ??
        SqlSyntax.setField(_fParentOfficeId, 'ParentOfficeId', DbType.text);
  }

  static TableField? _fOfficeId;
  static TableField get OfficeId {
    return _fOfficeId =
        _fOfficeId ?? SqlSyntax.setField(_fOfficeId, 'OfficeId', DbType.text);
  }

  static TableField? _fBOSequenceId;
  static TableField get BOSequenceId {
    return _fBOSequenceId = _fBOSequenceId ??
        SqlSyntax.setField(_fBOSequenceId, 'BOSequenceId', DbType.text);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fLegacyCode;
  static TableField get LegacyCode {
    return _fLegacyCode = _fLegacyCode ??
        SqlSyntax.setField(_fLegacyCode, 'LegacyCode', DbType.text);
  }

  static TableField? _fSanctionedLimit;
  static TableField get SanctionedLimit {
    return _fSanctionedLimit = _fSanctionedLimit ??
        SqlSyntax.setField(_fSanctionedLimit, 'SanctionedLimit', DbType.text);
  }

  static TableField? _fCashBalance;
  static TableField get CashBalance {
    return _fCashBalance = _fCashBalance ??
        SqlSyntax.setField(_fCashBalance, 'CashBalance', DbType.text);
  }
}
// endregion SwitchOnTableFields

//region SwitchOnTableManager
class SwitchOnTableManager extends SqfEntityProvider {
  SwitchOnTableManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'switchOnTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SwitchOnTableManager
// region DayBegin
class DayBegin extends TableBase {
  DayBegin(
      {this.id,
      this.BPMId,
      this.DayBeginTimeStamp1,
      this.DayBeginTimeStamp2,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DayBegin.withFields(
      this.BPMId,
      this.DayBeginTimeStamp1,
      this.DayBeginTimeStamp2,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  DayBegin.withId(
      this.id,
      this.BPMId,
      this.DayBeginTimeStamp1,
      this.DayBeginTimeStamp2,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DayBegin.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['BPMId'] != null) {
      BPMId = o['BPMId'].toString();
    }
    if (o['DayBeginTimeStamp1'] != null) {
      DayBeginTimeStamp1 = o['DayBeginTimeStamp1'].toString();
    }
    if (o['DayBeginTimeStamp2'] != null) {
      DayBeginTimeStamp2 = o['DayBeginTimeStamp2'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
  }
  // FIELDS (DayBegin)
  int? id;
  String? BPMId;
  String? DayBeginTimeStamp1;
  String? DayBeginTimeStamp2;
  String? FileName;
  String? FileCreated;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;

  // end FIELDS (DayBegin)

  static const bool _softDeleteActivated = false;
  DayBeginManager? __mnDayBegin;

  DayBeginManager get _mnDayBegin {
    return __mnDayBegin = __mnDayBegin ?? DayBeginManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BPMId != null || !forView) {
      map['BPMId'] = BPMId;
    }
    if (DayBeginTimeStamp1 != null || !forView) {
      map['DayBeginTimeStamp1'] = DayBeginTimeStamp1;
    }
    if (DayBeginTimeStamp2 != null || !forView) {
      map['DayBeginTimeStamp2'] = DayBeginTimeStamp2;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (BPMId != null || !forView) {
      map['BPMId'] = BPMId;
    }
    if (DayBeginTimeStamp1 != null || !forView) {
      map['DayBeginTimeStamp1'] = DayBeginTimeStamp1;
    }
    if (DayBeginTimeStamp2 != null || !forView) {
      map['DayBeginTimeStamp2'] = DayBeginTimeStamp2;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  /// This method returns Json String [DayBegin]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DayBegin]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BPMId,
      DayBeginTimeStamp1,
      DayBeginTimeStamp2,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      BPMId,
      DayBeginTimeStamp1,
      DayBeginTimeStamp2,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  static Future<List<DayBegin>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DayBegin.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DayBegin>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DayBegin>[];
    try {
      objList = list
          .map((daybegin) => DayBegin.fromMap(daybegin as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DayBegin.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DayBegin>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DayBegin> objList = <DayBegin>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DayBegin.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DayBegin by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DayBegin] if exist, otherwise returns null
  Future<DayBegin?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    DayBegin? obj;
    final data = await _mnDayBegin.getById([id]);
    if (data.length != 0) {
      obj = DayBegin.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DayBegin) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnDayBegin.insert(this, ignoreBatch);
    } else {
      await _mnDayBegin.update(this);
    }

    return id;
  }

  /// Saves the (DayBegin) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnDayBegin.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDayBegin.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs DayBegin. Returns a new Primary Key value of DayBegin

  /// <returns>Returns a new Primary Key value of DayBegin
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<DayBegin> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DayBegin> daybegins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in daybegins) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < daybegins.length; i++) {
        if (daybegins[i].id == null) {
          daybegins[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDayBegin.rawInsert(
          'INSERT OR REPLACE INTO dayBegin (id, BPMId, DayBeginTimeStamp1, DayBeginTimeStamp2, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            id,
            BPMId,
            DayBeginTimeStamp1,
            DayBeginTimeStamp2,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DayBegin id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DayBegin id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DayBegin Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDayBegin.rawInsert(
          'INSERT OR IGNORE INTO dayBegin (id, BPMId, DayBeginTimeStamp1, DayBeginTimeStamp2, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            id,
            BPMId,
            DayBeginTimeStamp1,
            DayBeginTimeStamp2,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'DayBegin id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'DayBegin id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DayBegin Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<DayBegin>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<DayBegin> daybegins,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnDayBegin.rawInsertAll(
        'INSERT OR REPLACE INTO dayBegin (id, BPMId, DayBeginTimeStamp1, DayBeginTimeStamp2, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?)',
        daybegins,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes DayBegin

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete DayBegin invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDayBegin
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnDayBegin.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DayBegin] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DayBeginFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DayBeginFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DayBeginFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DayBeginFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion daybegin

// region DayBeginField
class DayBeginField extends FilterBase {
  DayBeginField(DayBeginFilterBuilder daybeginFB) : super(daybeginFB);

  @override
  DayBeginFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder isNull() {
    return super.isNull() as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DayBeginFilterBuilder;
  }

  @override
  DayBeginField get not {
    return super.not as DayBeginField;
  }
}
// endregion DayBeginField

// region DayBeginFilterBuilder
class DayBeginFilterBuilder extends ConjunctionBase {
  DayBeginFilterBuilder(DayBegin obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDayBegin = obj._mnDayBegin;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DayBeginManager? _mnDayBegin;

  /// put the sql keyword 'AND'
  @override
  DayBeginFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DayBeginFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DayBeginFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DayBeginFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DayBeginFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DayBeginFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DayBeginFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DayBeginFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DayBeginFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DayBeginFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DayBeginFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DayBeginField _setField(DayBeginField? field, String colName, DbType dbtype) {
    return DayBeginField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DayBeginField? _id;
  DayBeginField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  DayBeginField? _BPMId;
  DayBeginField get BPMId {
    return _BPMId = _setField(_BPMId, 'BPMId', DbType.text);
  }

  DayBeginField? _DayBeginTimeStamp1;
  DayBeginField get DayBeginTimeStamp1 {
    return _DayBeginTimeStamp1 =
        _setField(_DayBeginTimeStamp1, 'DayBeginTimeStamp1', DbType.text);
  }

  DayBeginField? _DayBeginTimeStamp2;
  DayBeginField get DayBeginTimeStamp2 {
    return _DayBeginTimeStamp2 =
        _setField(_DayBeginTimeStamp2, 'DayBeginTimeStamp2', DbType.text);
  }

  DayBeginField? _FileName;
  DayBeginField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  DayBeginField? _FileCreated;
  DayBeginField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  DayBeginField? _FileCreatedDateTime;
  DayBeginField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  DayBeginField? _FileTransmitted;
  DayBeginField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  DayBeginField? _FileTransmittedDateTime;
  DayBeginField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  /// Deletes List<DayBegin> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDayBegin!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDayBegin!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from dayBegin ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDayBegin!.updateBatch(qparams, values);
  }

  /// This method always returns [DayBegin] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DayBegin?
  @override
  Future<DayBegin?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDayBegin!.toList(qparams);
    final data = await objFuture;
    DayBegin? obj;
    if (data.isNotEmpty) {
      obj = DayBegin.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DayBegin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DayBegin?
  @override
  Future<DayBegin> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DayBegin();
  }

  /// This method returns int. [DayBegin]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? daybeginCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final daybeginsFuture = await _mnDayBegin!.toList(qparams);
    final int count = daybeginsFuture[0]['CNT'] as int;
    if (daybeginCount != null) {
      daybeginCount(count);
    }
    return count;
  }

  /// This method returns List<DayBegin> [DayBegin]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DayBegin>
  @override
  Future<List<DayBegin>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DayBegin> daybeginsData = await DayBegin.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return daybeginsData;
  }

  /// This method returns Json String [DayBegin]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DayBegin]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DayBegin]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDayBegin!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DayBegin]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM dayBegin WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnDayBegin!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DayBegin]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDayBegin!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DayBegin.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDayBegin!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DayBeginFilterBuilder

// region DayBeginFields
class DayBeginFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fBPMId;
  static TableField get BPMId {
    return _fBPMId =
        _fBPMId ?? SqlSyntax.setField(_fBPMId, 'BPMId', DbType.text);
  }

  static TableField? _fDayBeginTimeStamp1;
  static TableField get DayBeginTimeStamp1 {
    return _fDayBeginTimeStamp1 = _fDayBeginTimeStamp1 ??
        SqlSyntax.setField(
            _fDayBeginTimeStamp1, 'DayBeginTimeStamp1', DbType.text);
  }

  static TableField? _fDayBeginTimeStamp2;
  static TableField get DayBeginTimeStamp2 {
    return _fDayBeginTimeStamp2 = _fDayBeginTimeStamp2 ??
        SqlSyntax.setField(
            _fDayBeginTimeStamp2, 'DayBeginTimeStamp2', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }
}
// endregion DayBeginFields

//region DayBeginManager
class DayBeginManager extends SqfEntityProvider {
  DayBeginManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'dayBegin';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion DayBeginManager
// region CashIndent
class CashIndent extends TableBase {
  CashIndent(
      {this.SOSlipNumber,
      this.SOGenerationDate,
      this.ChequeNumber,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.AmountType,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CashIndent.withFields(
      this.SOSlipNumber,
      this.SOGenerationDate,
      this.ChequeNumber,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.AmountType,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  CashIndent.withId(
      this.SOSlipNumber,
      this.SOGenerationDate,
      this.ChequeNumber,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.AmountType,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CashIndent.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    SOSlipNumber = o['SOSlipNumber'].toString();
    if (o['SOGenerationDate'] != null) {
      SOGenerationDate = o['SOGenerationDate'].toString();
    }
    if (o['ChequeNumber'] != null) {
      ChequeNumber = o['ChequeNumber'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['SOName'] != null) {
      SOName = o['SOName'].toString();
    }
    if (o['CashAmount'] != null) {
      CashAmount = o['CashAmount'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['ChequeAmount'] != null) {
      ChequeAmount = o['ChequeAmount'].toString();
    }
    if (o['AmountType'] != null) {
      AmountType = o['AmountType'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }

    isSaved = true;
  }
  // FIELDS (CashIndent)
  String? SOSlipNumber;
  String? SOGenerationDate;
  String? ChequeNumber;
  String? BOName;
  String? SOName;
  String? CashAmount;
  String? Weight;
  String? ChequeAmount;
  String? AmountType;
  String? FileName;
  String? FileCreated;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  bool? isSaved;
  // end FIELDS (CashIndent)

  static const bool _softDeleteActivated = false;
  CashIndentManager? __mnCashIndent;

  CashIndentManager get _mnCashIndent {
    return __mnCashIndent = __mnCashIndent ?? CashIndentManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['SOSlipNumber'] = SOSlipNumber;
    if (SOGenerationDate != null || !forView) {
      map['SOGenerationDate'] = SOGenerationDate;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['SOSlipNumber'] = SOSlipNumber;
    if (SOGenerationDate != null || !forView) {
      map['SOGenerationDate'] = SOGenerationDate;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (AmountType != null || !forView) {
      map['AmountType'] = AmountType;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  /// This method returns Json String [CashIndent]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CashIndent]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      SOSlipNumber,
      SOGenerationDate,
      ChequeNumber,
      BOName,
      SOName,
      CashAmount,
      Weight,
      ChequeAmount,
      AmountType,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      SOSlipNumber,
      SOGenerationDate,
      ChequeNumber,
      BOName,
      SOName,
      CashAmount,
      Weight,
      ChequeAmount,
      AmountType,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  static Future<List<CashIndent>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashIndent.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CashIndent>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CashIndent>[];
    try {
      objList = list
          .map((cashindent) =>
              CashIndent.fromMap(cashindent as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CashIndent.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CashIndent>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CashIndent> objList = <CashIndent>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CashIndent.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CashIndent by ID if exist, otherwise returns null
  /// Primary Keys: String? SOSlipNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CashIndent] if exist, otherwise returns null
  Future<CashIndent?> getById(String? SOSlipNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (SOSlipNumber == null) {
      return null;
    }
    CashIndent? obj;
    final data = await _mnCashIndent.getById([SOSlipNumber]);
    if (data.length != 0) {
      obj = CashIndent.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CashIndent) object. If the Primary Key (SOSlipNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same SOSlipNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCashIndent.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO cashIndent (SOSlipNumber, SOGenerationDate, ChequeNumber, BOName, SOName, CashAmount, Weight, ChequeAmount, AmountType, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<CashIndent> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CashIndent> cashindents,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in cashindents) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashIndent.rawInsert(
          'INSERT OR REPLACE INTO cashIndent (SOSlipNumber, SOGenerationDate, ChequeNumber, BOName, SOName, CashAmount, Weight, ChequeAmount, AmountType, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SOSlipNumber,
            SOGenerationDate,
            ChequeNumber,
            BOName,
            SOName,
            CashAmount,
            Weight,
            ChequeAmount,
            AmountType,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CashIndent SOSlipNumber=$SOSlipNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'CashIndent SOSlipNumber=$SOSlipNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashIndent Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCashIndent.rawInsert(
          'INSERT OR IGNORE INTO cashIndent (SOSlipNumber, SOGenerationDate, ChequeNumber, BOName, SOName, CashAmount, Weight, ChequeAmount, AmountType, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            SOSlipNumber,
            SOGenerationDate,
            ChequeNumber,
            BOName,
            SOName,
            CashAmount,
            Weight,
            ChequeAmount,
            AmountType,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CashIndent SOSlipNumber=$SOSlipNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'CashIndent SOSlipNumber=$SOSlipNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CashIndent Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes CashIndent

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete CashIndent invoked (SOSlipNumber=$SOSlipNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCashIndent.delete(QueryParams(
          whereString: 'SOSlipNumber=?', whereArguments: [SOSlipNumber]));
    } else {
      return _mnCashIndent.updateBatch(
          QueryParams(
              whereString: 'SOSlipNumber=?', whereArguments: [SOSlipNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CashIndent] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CashIndentFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashIndentFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CashIndentFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CashIndentFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      SOSlipNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cashindent

// region CashIndentField
class CashIndentField extends FilterBase {
  CashIndentField(CashIndentFilterBuilder cashindentFB) : super(cashindentFB);

  @override
  CashIndentFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder isNull() {
    return super.isNull() as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CashIndentFilterBuilder;
  }

  @override
  CashIndentField get not {
    return super.not as CashIndentField;
  }
}
// endregion CashIndentField

// region CashIndentFilterBuilder
class CashIndentFilterBuilder extends ConjunctionBase {
  CashIndentFilterBuilder(CashIndent obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCashIndent = obj._mnCashIndent;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CashIndentManager? _mnCashIndent;

  /// put the sql keyword 'AND'
  @override
  CashIndentFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CashIndentFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CashIndentFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CashIndentFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CashIndentFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CashIndentFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CashIndentFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashIndentFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashIndentFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CashIndentFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CashIndentFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CashIndentField _setField(
      CashIndentField? field, String colName, DbType dbtype) {
    return CashIndentField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CashIndentField? _SOSlipNumber;
  CashIndentField get SOSlipNumber {
    return _SOSlipNumber =
        _setField(_SOSlipNumber, 'SOSlipNumber', DbType.integer);
  }

  CashIndentField? _SOGenerationDate;
  CashIndentField get SOGenerationDate {
    return _SOGenerationDate =
        _setField(_SOGenerationDate, 'SOGenerationDate', DbType.text);
  }

  CashIndentField? _ChequeNumber;
  CashIndentField get ChequeNumber {
    return _ChequeNumber =
        _setField(_ChequeNumber, 'ChequeNumber', DbType.text);
  }

  CashIndentField? _BOName;
  CashIndentField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  CashIndentField? _SOName;
  CashIndentField get SOName {
    return _SOName = _setField(_SOName, 'SOName', DbType.text);
  }

  CashIndentField? _CashAmount;
  CashIndentField get CashAmount {
    return _CashAmount = _setField(_CashAmount, 'CashAmount', DbType.text);
  }

  CashIndentField? _Weight;
  CashIndentField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  CashIndentField? _ChequeAmount;
  CashIndentField get ChequeAmount {
    return _ChequeAmount =
        _setField(_ChequeAmount, 'ChequeAmount', DbType.text);
  }

  CashIndentField? _AmountType;
  CashIndentField get AmountType {
    return _AmountType = _setField(_AmountType, 'AmountType', DbType.text);
  }

  CashIndentField? _FileName;
  CashIndentField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  CashIndentField? _FileCreated;
  CashIndentField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  CashIndentField? _FileCreatedDateTime;
  CashIndentField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  CashIndentField? _FileTransmitted;
  CashIndentField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  CashIndentField? _FileTransmittedDateTime;
  CashIndentField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  /// Deletes List<CashIndent> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCashIndent!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCashIndent!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'SOSlipNumber IN (SELECT SOSlipNumber from cashIndent ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCashIndent!.updateBatch(qparams, values);
  }

  /// This method always returns [CashIndent] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashIndent?
  @override
  Future<CashIndent?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCashIndent!.toList(qparams);
    final data = await objFuture;
    CashIndent? obj;
    if (data.isNotEmpty) {
      obj = CashIndent.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CashIndent]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CashIndent?
  @override
  Future<CashIndent> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CashIndent();
  }

  /// This method returns int. [CashIndent]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? cashindentCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cashindentsFuture = await _mnCashIndent!.toList(qparams);
    final int count = cashindentsFuture[0]['CNT'] as int;
    if (cashindentCount != null) {
      cashindentCount(count);
    }
    return count;
  }

  /// This method returns List<CashIndent> [CashIndent]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CashIndent>
  @override
  Future<List<CashIndent>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CashIndent> cashindentsData = await CashIndent.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return cashindentsData;
  }

  /// This method returns Json String [CashIndent]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CashIndent]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CashIndent]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCashIndent!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CashIndent]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `SOSlipNumber` FROM cashIndent WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> SOSlipNumberData = <String>[];
    qparams.selectColumns = ['SOSlipNumber'];
    final SOSlipNumberFuture = await _mnCashIndent!.toList(qparams);

    final int count = SOSlipNumberFuture.length;
    for (int i = 0; i < count; i++) {
      SOSlipNumberData.add(SOSlipNumberFuture[i]['SOSlipNumber'] as String);
    }
    return SOSlipNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CashIndent]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCashIndent!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CashIndent.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCashIndent!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CashIndentFilterBuilder

// region CashIndentFields
class CashIndentFields {
  static TableField? _fSOSlipNumber;
  static TableField get SOSlipNumber {
    return _fSOSlipNumber = _fSOSlipNumber ??
        SqlSyntax.setField(_fSOSlipNumber, 'soslipnumber', DbType.integer);
  }

  static TableField? _fSOGenerationDate;
  static TableField get SOGenerationDate {
    return _fSOGenerationDate = _fSOGenerationDate ??
        SqlSyntax.setField(_fSOGenerationDate, 'SOGenerationDate', DbType.text);
  }

  static TableField? _fChequeNumber;
  static TableField get ChequeNumber {
    return _fChequeNumber = _fChequeNumber ??
        SqlSyntax.setField(_fChequeNumber, 'ChequeNumber', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fSOName;
  static TableField get SOName {
    return _fSOName =
        _fSOName ?? SqlSyntax.setField(_fSOName, 'SOName', DbType.text);
  }

  static TableField? _fCashAmount;
  static TableField get CashAmount {
    return _fCashAmount = _fCashAmount ??
        SqlSyntax.setField(_fCashAmount, 'CashAmount', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fChequeAmount;
  static TableField get ChequeAmount {
    return _fChequeAmount = _fChequeAmount ??
        SqlSyntax.setField(_fChequeAmount, 'ChequeAmount', DbType.text);
  }

  static TableField? _fAmountType;
  static TableField get AmountType {
    return _fAmountType = _fAmountType ??
        SqlSyntax.setField(_fAmountType, 'AmountType', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }
}
// endregion CashIndentFields

//region CashIndentManager
class CashIndentManager extends SqfEntityProvider {
  CashIndentManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'cashIndent';
  static const List<String> _primaryKeyList = ['SOSlipNumber'];
  static const String _whereStr = 'SOSlipNumber=?';
}

//endregion CashIndentManager
// region CancelBooking
class CancelBooking extends TableBase {
  CancelBooking(
      {this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.ValueCode,
      this.Value,
      this.DistanceCode,
      this.Distance,
      this.SenderCustomerId,
      this.RecipientCountryId,
      this.IsReversed,
      this.TaxAmount,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.SerialNumber,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CancelBooking.withFields(
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.ValueCode,
      this.Value,
      this.DistanceCode,
      this.Distance,
      this.SenderCustomerId,
      this.RecipientCountryId,
      this.IsReversed,
      this.TaxAmount,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.SerialNumber,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  CancelBooking.withId(
      this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.BasePrice,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.WeightCode,
      this.Weight,
      this.Quantity,
      this.ValueCode,
      this.Value,
      this.DistanceCode,
      this.Distance,
      this.SenderCustomerId,
      this.RecipientCountryId,
      this.IsReversed,
      this.TaxAmount,
      this.PostageDue,
      this.PrepaidAmount,
      this.MaterialGroup,
      this.SerialNumber,
      this.IsFullPrepaid,
      this.VAS,
      this.VASValue,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CancelBooking.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserId'] != null) {
      UserId = o['UserId'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyId'] != null) {
      CurrencyId = o['CurrencyId'].toString();
    }
    if (o['TenderId'] != null) {
      TenderId = o['TenderId'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifferenceAmount'] != null) {
      RoundOffDifferenceAmount = o['RoundOffDifferenceAmount'].toString();
    }
    if (o['ParentInvoiceNumber'] != null) {
      ParentInvoiceNumber = o['ParentInvoiceNumber'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['BasePrice'] != null) {
      BasePrice = o['BasePrice'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['ArticleNumber'] != null) {
      ArticleNumber = o['ArticleNumber'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['WeightCode'] != null) {
      WeightCode = o['WeightCode'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['ValueCode'] != null) {
      ValueCode = o['ValueCode'].toString();
    }
    if (o['Value'] != null) {
      Value = o['Value'].toString();
    }
    if (o['DistanceCode'] != null) {
      DistanceCode = o['DistanceCode'].toString();
    }
    if (o['Distance'] != null) {
      Distance = o['Distance'].toString();
    }
    if (o['SenderCustomerId'] != null) {
      SenderCustomerId = o['SenderCustomerId'].toString();
    }
    if (o['RecipientCountryId'] != null) {
      RecipientCountryId = o['RecipientCountryId'].toString();
    }
    if (o['IsReversed'] != null) {
      IsReversed = o['IsReversed'].toString();
    }
    if (o['TaxAmount'] != null) {
      TaxAmount = o['TaxAmount'].toString();
    }
    if (o['PostageDue'] != null) {
      PostageDue = o['PostageDue'].toString();
    }
    if (o['PrepaidAmount'] != null) {
      PrepaidAmount = o['PrepaidAmount'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['SerialNumber'] != null) {
      SerialNumber = o['SerialNumber'].toString();
    }
    if (o['IsFullPrepaid'] != null) {
      IsFullPrepaid = o['IsFullPrepaid'].toString();
    }
    if (o['VAS'] != null) {
      VAS = o['VAS'].toString();
    }
    if (o['VASValue'] != null) {
      VASValue = o['VASValue'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['CancellationReason'] != null) {
      CancellationReason = o['CancellationReason'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }
  }
  // FIELDS (CancelBooking)
  int? id;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserId;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyId;
  String? TenderId;
  String? TotalCashAmount;
  String? RoundOffDifferenceAmount;
  String? ParentInvoiceNumber;
  String? CircleCode;
  String? LineItemNumber;
  String? BasePrice;
  String? LineItemTotalAmount;
  String? ArticleNumber;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? WeightCode;
  String? Weight;
  String? Quantity;
  String? ValueCode;
  String? Value;
  String? DistanceCode;
  String? Distance;
  String? SenderCustomerId;
  String? RecipientCountryId;
  String? IsReversed;
  String? TaxAmount;
  String? PostageDue;
  String? PrepaidAmount;
  String? MaterialGroup;
  String? SerialNumber;
  String? IsFullPrepaid;
  String? VAS;
  String? VASValue;
  String? FileName;
  String? FileCreated;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? CancellationReason;
  String? Authorized;

  // end FIELDS (CancelBooking)

  static const bool _softDeleteActivated = false;
  CancelBookingManager? __mnCancelBooking;

  CancelBookingManager get _mnCancelBooking {
    return __mnCancelBooking = __mnCancelBooking ?? CancelBookingManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifferenceAmount != null || !forView) {
      map['RoundOffDifferenceAmount'] = RoundOffDifferenceAmount;
    }
    if (ParentInvoiceNumber != null || !forView) {
      map['ParentInvoiceNumber'] = ParentInvoiceNumber;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (DistanceCode != null || !forView) {
      map['DistanceCode'] = DistanceCode;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (RecipientCountryId != null || !forView) {
      map['RecipientCountryId'] = RecipientCountryId;
    }
    if (IsReversed != null || !forView) {
      map['IsReversed'] = IsReversed;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (SerialNumber != null || !forView) {
      map['SerialNumber'] = SerialNumber;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifferenceAmount != null || !forView) {
      map['RoundOffDifferenceAmount'] = RoundOffDifferenceAmount;
    }
    if (ParentInvoiceNumber != null || !forView) {
      map['ParentInvoiceNumber'] = ParentInvoiceNumber;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (BasePrice != null || !forView) {
      map['BasePrice'] = BasePrice;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (WeightCode != null || !forView) {
      map['WeightCode'] = WeightCode;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (DistanceCode != null || !forView) {
      map['DistanceCode'] = DistanceCode;
    }
    if (Distance != null || !forView) {
      map['Distance'] = Distance;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (RecipientCountryId != null || !forView) {
      map['RecipientCountryId'] = RecipientCountryId;
    }
    if (IsReversed != null || !forView) {
      map['IsReversed'] = IsReversed;
    }
    if (TaxAmount != null || !forView) {
      map['TaxAmount'] = TaxAmount;
    }
    if (PostageDue != null || !forView) {
      map['PostageDue'] = PostageDue;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (SerialNumber != null || !forView) {
      map['SerialNumber'] = SerialNumber;
    }
    if (IsFullPrepaid != null || !forView) {
      map['IsFullPrepaid'] = IsFullPrepaid;
    }
    if (VAS != null || !forView) {
      map['VAS'] = VAS;
    }
    if (VASValue != null || !forView) {
      map['VASValue'] = VASValue;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [CancelBooking]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CancelBooking]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifferenceAmount,
      ParentInvoiceNumber,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      ValueCode,
      Value,
      DistanceCode,
      Distance,
      SenderCustomerId,
      RecipientCountryId,
      IsReversed,
      TaxAmount,
      PostageDue,
      PrepaidAmount,
      MaterialGroup,
      SerialNumber,
      IsFullPrepaid,
      VAS,
      VASValue,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifferenceAmount,
      ParentInvoiceNumber,
      CircleCode,
      LineItemNumber,
      BasePrice,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      WeightCode,
      Weight,
      Quantity,
      ValueCode,
      Value,
      DistanceCode,
      Distance,
      SenderCustomerId,
      RecipientCountryId,
      IsReversed,
      TaxAmount,
      PostageDue,
      PrepaidAmount,
      MaterialGroup,
      SerialNumber,
      IsFullPrepaid,
      VAS,
      VASValue,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  static Future<List<CancelBooking>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CancelBooking.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CancelBooking>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CancelBooking>[];
    try {
      objList = list
          .map((cancelbooking) =>
              CancelBooking.fromMap(cancelbooking as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CancelBooking.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CancelBooking>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CancelBooking> objList = <CancelBooking>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CancelBooking.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CancelBooking by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CancelBooking] if exist, otherwise returns null
  Future<CancelBooking?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    CancelBooking? obj;
    final data = await _mnCancelBooking.getById([id]);
    if (data.length != 0) {
      obj = CancelBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CancelBooking) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCancelBooking.insert(this, ignoreBatch);
    } else {
      await _mnCancelBooking.update(this);
    }

    return id;
  }

  /// Saves the (CancelBooking) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCancelBooking.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCancelBooking.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs CancelBooking. Returns a new Primary Key value of CancelBooking

  /// <returns>Returns a new Primary Key value of CancelBooking
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<CancelBooking> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CancelBooking> cancelbookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in cancelbookings) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < cancelbookings.length; i++) {
        if (cancelbookings[i].id == null) {
          cancelbookings[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCancelBooking.rawInsert(
          'INSERT OR REPLACE INTO CancelBooking (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, ValueCode, Value, DistanceCode, Distance, SenderCustomerId, RecipientCountryId, IsReversed, TaxAmount, PostageDue, PrepaidAmount, MaterialGroup, SerialNumber, IsFullPrepaid, VAS, VASValue, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifferenceAmount,
            ParentInvoiceNumber,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            ValueCode,
            Value,
            DistanceCode,
            Distance,
            SenderCustomerId,
            RecipientCountryId,
            IsReversed,
            TaxAmount,
            PostageDue,
            PrepaidAmount,
            MaterialGroup,
            SerialNumber,
            IsFullPrepaid,
            VAS,
            VASValue,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CancelBooking id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CancelBooking id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CancelBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCancelBooking.rawInsert(
          'INSERT OR IGNORE INTO CancelBooking (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, ValueCode, Value, DistanceCode, Distance, SenderCustomerId, RecipientCountryId, IsReversed, TaxAmount, PostageDue, PrepaidAmount, MaterialGroup, SerialNumber, IsFullPrepaid, VAS, VASValue, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifferenceAmount,
            ParentInvoiceNumber,
            CircleCode,
            LineItemNumber,
            BasePrice,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            WeightCode,
            Weight,
            Quantity,
            ValueCode,
            Value,
            DistanceCode,
            Distance,
            SenderCustomerId,
            RecipientCountryId,
            IsReversed,
            TaxAmount,
            PostageDue,
            PrepaidAmount,
            MaterialGroup,
            SerialNumber,
            IsFullPrepaid,
            VAS,
            VASValue,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CancelBooking id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CancelBooking id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CancelBooking Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CancelBooking>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<CancelBooking> cancelbookings,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCancelBooking.rawInsertAll(
        'INSERT OR REPLACE INTO CancelBooking (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, BasePrice, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, WeightCode, Weight, Quantity, ValueCode, Value, DistanceCode, Distance, SenderCustomerId, RecipientCountryId, IsReversed, TaxAmount, PostageDue, PrepaidAmount, MaterialGroup, SerialNumber, IsFullPrepaid, VAS, VASValue, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        cancelbookings,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CancelBooking

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CancelBooking invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCancelBooking
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCancelBooking.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CancelBooking] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CancelBookingFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CancelBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CancelBookingFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CancelBookingFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cancelbooking

// region CancelBookingField
class CancelBookingField extends FilterBase {
  CancelBookingField(CancelBookingFilterBuilder cancelbookingFB)
      : super(cancelbookingFB);

  @override
  CancelBookingFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder isNull() {
    return super.isNull() as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CancelBookingFilterBuilder;
  }

  @override
  CancelBookingField get not {
    return super.not as CancelBookingField;
  }
}
// endregion CancelBookingField

// region CancelBookingFilterBuilder
class CancelBookingFilterBuilder extends ConjunctionBase {
  CancelBookingFilterBuilder(CancelBooking obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCancelBooking = obj._mnCancelBooking;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CancelBookingManager? _mnCancelBooking;

  /// put the sql keyword 'AND'
  @override
  CancelBookingFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CancelBookingFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CancelBookingFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CancelBookingFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CancelBookingFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CancelBookingFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CancelBookingFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CancelBookingFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CancelBookingFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CancelBookingFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CancelBookingFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CancelBookingField _setField(
      CancelBookingField? field, String colName, DbType dbtype) {
    return CancelBookingField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CancelBookingField? _id;
  CancelBookingField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  CancelBookingField? _FacilityId;
  CancelBookingField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  CancelBookingField? _BookingFacilityZip;
  CancelBookingField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  CancelBookingField? _DistributionChannel;
  CancelBookingField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  CancelBookingField? _UserId;
  CancelBookingField get UserId {
    return _UserId = _setField(_UserId, 'UserId', DbType.text);
  }

  CancelBookingField? _CounterNumber;
  CancelBookingField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  CancelBookingField? _InvoiceNumber;
  CancelBookingField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  CancelBookingField? _TotalAmount;
  CancelBookingField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  CancelBookingField? _BookingDate;
  CancelBookingField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  CancelBookingField? _BookingTime;
  CancelBookingField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  CancelBookingField? _CurrencyId;
  CancelBookingField get CurrencyId {
    return _CurrencyId = _setField(_CurrencyId, 'CurrencyId', DbType.text);
  }

  CancelBookingField? _TenderId;
  CancelBookingField get TenderId {
    return _TenderId = _setField(_TenderId, 'TenderId', DbType.text);
  }

  CancelBookingField? _TotalCashAmount;
  CancelBookingField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  CancelBookingField? _RoundOffDifferenceAmount;
  CancelBookingField get RoundOffDifferenceAmount {
    return _RoundOffDifferenceAmount = _setField(
        _RoundOffDifferenceAmount, 'RoundOffDifferenceAmount', DbType.text);
  }

  CancelBookingField? _ParentInvoiceNumber;
  CancelBookingField get ParentInvoiceNumber {
    return _ParentInvoiceNumber =
        _setField(_ParentInvoiceNumber, 'ParentInvoiceNumber', DbType.text);
  }

  CancelBookingField? _CircleCode;
  CancelBookingField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  CancelBookingField? _LineItemNumber;
  CancelBookingField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  CancelBookingField? _BasePrice;
  CancelBookingField get BasePrice {
    return _BasePrice = _setField(_BasePrice, 'BasePrice', DbType.text);
  }

  CancelBookingField? _LineItemTotalAmount;
  CancelBookingField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  CancelBookingField? _ArticleNumber;
  CancelBookingField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.text);
  }

  CancelBookingField? _Division;
  CancelBookingField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  CancelBookingField? _OrderType;
  CancelBookingField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  CancelBookingField? _ProductType;
  CancelBookingField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  CancelBookingField? _ProductCode;
  CancelBookingField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  CancelBookingField? _WeightCode;
  CancelBookingField get WeightCode {
    return _WeightCode = _setField(_WeightCode, 'WeightCode', DbType.text);
  }

  CancelBookingField? _Weight;
  CancelBookingField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  CancelBookingField? _Quantity;
  CancelBookingField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  CancelBookingField? _ValueCode;
  CancelBookingField get ValueCode {
    return _ValueCode = _setField(_ValueCode, 'ValueCode', DbType.text);
  }

  CancelBookingField? _Value;
  CancelBookingField get Value {
    return _Value = _setField(_Value, 'Value', DbType.text);
  }

  CancelBookingField? _DistanceCode;
  CancelBookingField get DistanceCode {
    return _DistanceCode =
        _setField(_DistanceCode, 'DistanceCode', DbType.text);
  }

  CancelBookingField? _Distance;
  CancelBookingField get Distance {
    return _Distance = _setField(_Distance, 'Distance', DbType.text);
  }

  CancelBookingField? _SenderCustomerId;
  CancelBookingField get SenderCustomerId {
    return _SenderCustomerId =
        _setField(_SenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  CancelBookingField? _RecipientCountryId;
  CancelBookingField get RecipientCountryId {
    return _RecipientCountryId =
        _setField(_RecipientCountryId, 'RecipientCountryId', DbType.text);
  }

  CancelBookingField? _IsReversed;
  CancelBookingField get IsReversed {
    return _IsReversed = _setField(_IsReversed, 'IsReversed', DbType.text);
  }

  CancelBookingField? _TaxAmount;
  CancelBookingField get TaxAmount {
    return _TaxAmount = _setField(_TaxAmount, 'TaxAmount', DbType.text);
  }

  CancelBookingField? _PostageDue;
  CancelBookingField get PostageDue {
    return _PostageDue = _setField(_PostageDue, 'PostageDue', DbType.text);
  }

  CancelBookingField? _PrepaidAmount;
  CancelBookingField get PrepaidAmount {
    return _PrepaidAmount =
        _setField(_PrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  CancelBookingField? _MaterialGroup;
  CancelBookingField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  CancelBookingField? _SerialNumber;
  CancelBookingField get SerialNumber {
    return _SerialNumber =
        _setField(_SerialNumber, 'SerialNumber', DbType.text);
  }

  CancelBookingField? _IsFullPrepaid;
  CancelBookingField get IsFullPrepaid {
    return _IsFullPrepaid =
        _setField(_IsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  CancelBookingField? _VAS;
  CancelBookingField get VAS {
    return _VAS = _setField(_VAS, 'VAS', DbType.text);
  }

  CancelBookingField? _VASValue;
  CancelBookingField get VASValue {
    return _VASValue = _setField(_VASValue, 'VASValue', DbType.text);
  }

  CancelBookingField? _FileName;
  CancelBookingField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  CancelBookingField? _FileCreated;
  CancelBookingField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  CancelBookingField? _FileCreatedDateTime;
  CancelBookingField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  CancelBookingField? _FileTransmitted;
  CancelBookingField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  CancelBookingField? _FileTransmittedDateTime;
  CancelBookingField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  CancelBookingField? _CancellationReason;
  CancelBookingField get CancellationReason {
    return _CancellationReason =
        _setField(_CancellationReason, 'CancellationReason', DbType.text);
  }

  CancelBookingField? _Authorized;
  CancelBookingField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<CancelBooking> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCancelBooking!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCancelBooking!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from CancelBooking ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCancelBooking!.updateBatch(qparams, values);
  }

  /// This method always returns [CancelBooking] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CancelBooking?
  @override
  Future<CancelBooking?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCancelBooking!.toList(qparams);
    final data = await objFuture;
    CancelBooking? obj;
    if (data.isNotEmpty) {
      obj = CancelBooking.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CancelBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CancelBooking?
  @override
  Future<CancelBooking> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CancelBooking();
  }

  /// This method returns int. [CancelBooking]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cancelbookingCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cancelbookingsFuture = await _mnCancelBooking!.toList(qparams);
    final int count = cancelbookingsFuture[0]['CNT'] as int;
    if (cancelbookingCount != null) {
      cancelbookingCount(count);
    }
    return count;
  }

  /// This method returns List<CancelBooking> [CancelBooking]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CancelBooking>
  @override
  Future<List<CancelBooking>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CancelBooking> cancelbookingsData =
        await CancelBooking.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cancelbookingsData;
  }

  /// This method returns Json String [CancelBooking]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CancelBooking]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CancelBooking]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCancelBooking!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CancelBooking]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM CancelBooking WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCancelBooking!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CancelBooking]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCancelBooking!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CancelBooking.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCancelBooking!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CancelBookingFilterBuilder

// region CancelBookingFields
class CancelBookingFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserId;
  static TableField get UserId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'UserId', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyId;
  static TableField get CurrencyId {
    return _fCurrencyId = _fCurrencyId ??
        SqlSyntax.setField(_fCurrencyId, 'CurrencyId', DbType.text);
  }

  static TableField? _fTenderId;
  static TableField get TenderId {
    return _fTenderId =
        _fTenderId ?? SqlSyntax.setField(_fTenderId, 'TenderId', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifferenceAmount;
  static TableField get RoundOffDifferenceAmount {
    return _fRoundOffDifferenceAmount = _fRoundOffDifferenceAmount ??
        SqlSyntax.setField(_fRoundOffDifferenceAmount,
            'RoundOffDifferenceAmount', DbType.text);
  }

  static TableField? _fParentInvoiceNumber;
  static TableField get ParentInvoiceNumber {
    return _fParentInvoiceNumber = _fParentInvoiceNumber ??
        SqlSyntax.setField(
            _fParentInvoiceNumber, 'ParentInvoiceNumber', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fBasePrice;
  static TableField get BasePrice {
    return _fBasePrice = _fBasePrice ??
        SqlSyntax.setField(_fBasePrice, 'BasePrice', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'ArticleNumber', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fWeightCode;
  static TableField get WeightCode {
    return _fWeightCode = _fWeightCode ??
        SqlSyntax.setField(_fWeightCode, 'WeightCode', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fValueCode;
  static TableField get ValueCode {
    return _fValueCode = _fValueCode ??
        SqlSyntax.setField(_fValueCode, 'ValueCode', DbType.text);
  }

  static TableField? _fValue;
  static TableField get Value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'Value', DbType.text);
  }

  static TableField? _fDistanceCode;
  static TableField get DistanceCode {
    return _fDistanceCode = _fDistanceCode ??
        SqlSyntax.setField(_fDistanceCode, 'DistanceCode', DbType.text);
  }

  static TableField? _fDistance;
  static TableField get Distance {
    return _fDistance =
        _fDistance ?? SqlSyntax.setField(_fDistance, 'Distance', DbType.text);
  }

  static TableField? _fSenderCustomerId;
  static TableField get SenderCustomerId {
    return _fSenderCustomerId = _fSenderCustomerId ??
        SqlSyntax.setField(_fSenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  static TableField? _fRecipientCountryId;
  static TableField get RecipientCountryId {
    return _fRecipientCountryId = _fRecipientCountryId ??
        SqlSyntax.setField(
            _fRecipientCountryId, 'RecipientCountryId', DbType.text);
  }

  static TableField? _fIsReversed;
  static TableField get IsReversed {
    return _fIsReversed = _fIsReversed ??
        SqlSyntax.setField(_fIsReversed, 'IsReversed', DbType.text);
  }

  static TableField? _fTaxAmount;
  static TableField get TaxAmount {
    return _fTaxAmount = _fTaxAmount ??
        SqlSyntax.setField(_fTaxAmount, 'TaxAmount', DbType.text);
  }

  static TableField? _fPostageDue;
  static TableField get PostageDue {
    return _fPostageDue = _fPostageDue ??
        SqlSyntax.setField(_fPostageDue, 'PostageDue', DbType.text);
  }

  static TableField? _fPrepaidAmount;
  static TableField get PrepaidAmount {
    return _fPrepaidAmount = _fPrepaidAmount ??
        SqlSyntax.setField(_fPrepaidAmount, 'PrepaidAmount', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fSerialNumber;
  static TableField get SerialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'SerialNumber', DbType.text);
  }

  static TableField? _fIsFullPrepaid;
  static TableField get IsFullPrepaid {
    return _fIsFullPrepaid = _fIsFullPrepaid ??
        SqlSyntax.setField(_fIsFullPrepaid, 'IsFullPrepaid', DbType.text);
  }

  static TableField? _fVAS;
  static TableField get VAS {
    return _fVAS = _fVAS ?? SqlSyntax.setField(_fVAS, 'VAS', DbType.text);
  }

  static TableField? _fVASValue;
  static TableField get VASValue {
    return _fVASValue =
        _fVASValue ?? SqlSyntax.setField(_fVASValue, 'VASValue', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fCancellationReason;
  static TableField get CancellationReason {
    return _fCancellationReason = _fCancellationReason ??
        SqlSyntax.setField(
            _fCancellationReason, 'CancellationReason', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion CancelBookingFields

//region CancelBookingManager
class CancelBookingManager extends SqfEntityProvider {
  CancelBookingManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CancelBooking';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CancelBookingManager
// region CancelBiller
class CancelBiller extends TableBase {
  CancelBiller(
      {this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerId,
      this.IsReversed,
      this.MaterialGroup,
      this.SerialNumber,
      this.AddlBillInfo,
      this.AddlBillAmountInfo,
      this.BillerID,
      this.BillerName,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CancelBiller.withFields(
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerId,
      this.IsReversed,
      this.MaterialGroup,
      this.SerialNumber,
      this.AddlBillInfo,
      this.AddlBillAmountInfo,
      this.BillerID,
      this.BillerName,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  CancelBiller.withId(
      this.id,
      this.FacilityId,
      this.BookingFacilityZip,
      this.DistributionChannel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifferenceAmount,
      this.ParentInvoiceNumber,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.SenderCustomerId,
      this.IsReversed,
      this.MaterialGroup,
      this.SerialNumber,
      this.AddlBillInfo,
      this.AddlBillAmountInfo,
      this.BillerID,
      this.BillerName,
      this.FileName,
      this.FileCreated,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime,
      this.CancellationReason,
      this.Authorized) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CancelBiller.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['BookingFacilityZip'] != null) {
      BookingFacilityZip = o['BookingFacilityZip'].toString();
    }
    if (o['DistributionChannel'] != null) {
      DistributionChannel = o['DistributionChannel'].toString();
    }
    if (o['UserId'] != null) {
      UserId = o['UserId'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyId'] != null) {
      CurrencyId = o['CurrencyId'].toString();
    }
    if (o['TenderId'] != null) {
      TenderId = o['TenderId'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifferenceAmount'] != null) {
      RoundOffDifferenceAmount = o['RoundOffDifferenceAmount'].toString();
    }
    if (o['ParentInvoiceNumber'] != null) {
      ParentInvoiceNumber = o['ParentInvoiceNumber'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['ArticleNumber'] != null) {
      ArticleNumber = o['ArticleNumber'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['ValueCode'] != null) {
      ValueCode = o['ValueCode'].toString();
    }
    if (o['Value'] != null) {
      Value = o['Value'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['SenderCustomerId'] != null) {
      SenderCustomerId = o['SenderCustomerId'].toString();
    }
    if (o['IsReversed'] != null) {
      IsReversed = o['IsReversed'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['SerialNumber'] != null) {
      SerialNumber = o['SerialNumber'].toString();
    }
    if (o['AddlBillInfo'] != null) {
      AddlBillInfo = o['AddlBillInfo'].toString();
    }
    if (o['AddlBillAmountInfo'] != null) {
      AddlBillAmountInfo = o['AddlBillAmountInfo'].toString();
    }
    if (o['BillerID'] != null) {
      BillerID = o['BillerID'].toString();
    }
    if (o['BillerName'] != null) {
      BillerName = o['BillerName'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
    if (o['CancellationReason'] != null) {
      CancellationReason = o['CancellationReason'].toString();
    }
    if (o['Authorized'] != null) {
      Authorized = o['Authorized'].toString();
    }
  }
  // FIELDS (CancelBiller)
  int? id;
  String? FacilityId;
  String? BookingFacilityZip;
  String? DistributionChannel;
  String? UserId;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyId;
  String? TenderId;
  String? TotalCashAmount;
  String? RoundOffDifferenceAmount;
  String? ParentInvoiceNumber;
  String? CircleCode;
  String? LineItemNumber;
  String? LineItemTotalAmount;
  String? ArticleNumber;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? ValueCode;
  String? Value;
  String? Quantity;
  String? SenderCustomerId;
  String? IsReversed;
  String? MaterialGroup;
  String? SerialNumber;
  String? AddlBillInfo;
  String? AddlBillAmountInfo;
  String? BillerID;
  String? BillerName;
  String? FileName;
  String? FileCreated;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;
  String? CancellationReason;
  String? Authorized;

  // end FIELDS (CancelBiller)

  static const bool _softDeleteActivated = false;
  CancelBillerManager? __mnCancelBiller;

  CancelBillerManager get _mnCancelBiller {
    return __mnCancelBiller = __mnCancelBiller ?? CancelBillerManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifferenceAmount != null || !forView) {
      map['RoundOffDifferenceAmount'] = RoundOffDifferenceAmount;
    }
    if (ParentInvoiceNumber != null || !forView) {
      map['ParentInvoiceNumber'] = ParentInvoiceNumber;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (IsReversed != null || !forView) {
      map['IsReversed'] = IsReversed;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (SerialNumber != null || !forView) {
      map['SerialNumber'] = SerialNumber;
    }
    if (AddlBillInfo != null || !forView) {
      map['AddlBillInfo'] = AddlBillInfo;
    }
    if (AddlBillAmountInfo != null || !forView) {
      map['AddlBillAmountInfo'] = AddlBillAmountInfo;
    }
    if (BillerID != null || !forView) {
      map['BillerID'] = BillerID;
    }
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (BookingFacilityZip != null || !forView) {
      map['BookingFacilityZip'] = BookingFacilityZip;
    }
    if (DistributionChannel != null || !forView) {
      map['DistributionChannel'] = DistributionChannel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifferenceAmount != null || !forView) {
      map['RoundOffDifferenceAmount'] = RoundOffDifferenceAmount;
    }
    if (ParentInvoiceNumber != null || !forView) {
      map['ParentInvoiceNumber'] = ParentInvoiceNumber;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (SenderCustomerId != null || !forView) {
      map['SenderCustomerId'] = SenderCustomerId;
    }
    if (IsReversed != null || !forView) {
      map['IsReversed'] = IsReversed;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (SerialNumber != null || !forView) {
      map['SerialNumber'] = SerialNumber;
    }
    if (AddlBillInfo != null || !forView) {
      map['AddlBillInfo'] = AddlBillInfo;
    }
    if (AddlBillAmountInfo != null || !forView) {
      map['AddlBillAmountInfo'] = AddlBillAmountInfo;
    }
    if (BillerID != null || !forView) {
      map['BillerID'] = BillerID;
    }
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }
    if (CancellationReason != null || !forView) {
      map['CancellationReason'] = CancellationReason;
    }
    if (Authorized != null || !forView) {
      map['Authorized'] = Authorized;
    }

    return map;
  }

  /// This method returns Json String [CancelBiller]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CancelBiller]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifferenceAmount,
      ParentInvoiceNumber,
      CircleCode,
      LineItemNumber,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      SenderCustomerId,
      IsReversed,
      MaterialGroup,
      SerialNumber,
      AddlBillInfo,
      AddlBillAmountInfo,
      BillerID,
      BillerName,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      FacilityId,
      BookingFacilityZip,
      DistributionChannel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifferenceAmount,
      ParentInvoiceNumber,
      CircleCode,
      LineItemNumber,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      SenderCustomerId,
      IsReversed,
      MaterialGroup,
      SerialNumber,
      AddlBillInfo,
      AddlBillAmountInfo,
      BillerID,
      BillerName,
      FileName,
      FileCreated,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime,
      CancellationReason,
      Authorized
    ];
  }

  static Future<List<CancelBiller>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CancelBiller.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CancelBiller>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CancelBiller>[];
    try {
      objList = list
          .map((cancelbiller) =>
              CancelBiller.fromMap(cancelbiller as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CancelBiller.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CancelBiller>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CancelBiller> objList = <CancelBiller>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CancelBiller.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CancelBiller by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CancelBiller] if exist, otherwise returns null
  Future<CancelBiller?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    CancelBiller? obj;
    final data = await _mnCancelBiller.getById([id]);
    if (data.length != 0) {
      obj = CancelBiller.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CancelBiller) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCancelBiller.insert(this, ignoreBatch);
    } else {
      await _mnCancelBiller.update(this);
    }

    return id;
  }

  /// Saves the (CancelBiller) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnCancelBiller.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnCancelBiller.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs CancelBiller. Returns a new Primary Key value of CancelBiller

  /// <returns>Returns a new Primary Key value of CancelBiller
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<CancelBiller> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CancelBiller> cancelbillers,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in cancelbillers) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < cancelbillers.length; i++) {
        if (cancelbillers[i].id == null) {
          cancelbillers[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCancelBiller.rawInsert(
          'INSERT OR REPLACE INTO CancelBiller (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerId, IsReversed, MaterialGroup, SerialNumber, AddlBillInfo, AddlBillAmountInfo, BillerID, BillerName, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifferenceAmount,
            ParentInvoiceNumber,
            CircleCode,
            LineItemNumber,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            SenderCustomerId,
            IsReversed,
            MaterialGroup,
            SerialNumber,
            AddlBillInfo,
            AddlBillAmountInfo,
            BillerID,
            BillerName,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CancelBiller id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'CancelBiller id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CancelBiller Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCancelBiller.rawInsert(
          'INSERT OR IGNORE INTO CancelBiller (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerId, IsReversed, MaterialGroup, SerialNumber, AddlBillInfo, AddlBillAmountInfo, BillerID, BillerName, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            BookingFacilityZip,
            DistributionChannel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifferenceAmount,
            ParentInvoiceNumber,
            CircleCode,
            LineItemNumber,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            SenderCustomerId,
            IsReversed,
            MaterialGroup,
            SerialNumber,
            AddlBillInfo,
            AddlBillAmountInfo,
            BillerID,
            BillerName,
            FileName,
            FileCreated,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime,
            CancellationReason,
            Authorized
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CancelBiller id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'CancelBiller id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CancelBiller Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CancelBiller>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<CancelBiller> cancelbillers,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnCancelBiller.rawInsertAll(
        'INSERT OR REPLACE INTO CancelBiller (id, FacilityId, BookingFacilityZip, DistributionChannel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifferenceAmount, ParentInvoiceNumber, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, SenderCustomerId, IsReversed, MaterialGroup, SerialNumber, AddlBillInfo, AddlBillAmountInfo, BillerID, BillerName, FileName, FileCreated, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime, CancellationReason, Authorized)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        cancelbillers,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CancelBiller

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CancelBiller invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCancelBiller
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnCancelBiller.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CancelBiller] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CancelBillerFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CancelBillerFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CancelBillerFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CancelBillerFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cancelbiller

// region CancelBillerField
class CancelBillerField extends FilterBase {
  CancelBillerField(CancelBillerFilterBuilder cancelbillerFB)
      : super(cancelbillerFB);

  @override
  CancelBillerFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder isNull() {
    return super.isNull() as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CancelBillerFilterBuilder;
  }

  @override
  CancelBillerField get not {
    return super.not as CancelBillerField;
  }
}
// endregion CancelBillerField

// region CancelBillerFilterBuilder
class CancelBillerFilterBuilder extends ConjunctionBase {
  CancelBillerFilterBuilder(CancelBiller obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCancelBiller = obj._mnCancelBiller;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CancelBillerManager? _mnCancelBiller;

  /// put the sql keyword 'AND'
  @override
  CancelBillerFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CancelBillerFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CancelBillerFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CancelBillerFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CancelBillerFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CancelBillerFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CancelBillerFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CancelBillerFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CancelBillerFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CancelBillerFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CancelBillerFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CancelBillerField _setField(
      CancelBillerField? field, String colName, DbType dbtype) {
    return CancelBillerField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CancelBillerField? _id;
  CancelBillerField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  CancelBillerField? _FacilityId;
  CancelBillerField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  CancelBillerField? _BookingFacilityZip;
  CancelBillerField get BookingFacilityZip {
    return _BookingFacilityZip =
        _setField(_BookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  CancelBillerField? _DistributionChannel;
  CancelBillerField get DistributionChannel {
    return _DistributionChannel =
        _setField(_DistributionChannel, 'DistributionChannel', DbType.text);
  }

  CancelBillerField? _UserId;
  CancelBillerField get UserId {
    return _UserId = _setField(_UserId, 'UserId', DbType.text);
  }

  CancelBillerField? _CounterNumber;
  CancelBillerField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  CancelBillerField? _InvoiceNumber;
  CancelBillerField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  CancelBillerField? _TotalAmount;
  CancelBillerField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  CancelBillerField? _BookingDate;
  CancelBillerField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  CancelBillerField? _BookingTime;
  CancelBillerField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  CancelBillerField? _CurrencyId;
  CancelBillerField get CurrencyId {
    return _CurrencyId = _setField(_CurrencyId, 'CurrencyId', DbType.text);
  }

  CancelBillerField? _TenderId;
  CancelBillerField get TenderId {
    return _TenderId = _setField(_TenderId, 'TenderId', DbType.text);
  }

  CancelBillerField? _TotalCashAmount;
  CancelBillerField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  CancelBillerField? _RoundOffDifferenceAmount;
  CancelBillerField get RoundOffDifferenceAmount {
    return _RoundOffDifferenceAmount = _setField(
        _RoundOffDifferenceAmount, 'RoundOffDifferenceAmount', DbType.text);
  }

  CancelBillerField? _ParentInvoiceNumber;
  CancelBillerField get ParentInvoiceNumber {
    return _ParentInvoiceNumber =
        _setField(_ParentInvoiceNumber, 'ParentInvoiceNumber', DbType.text);
  }

  CancelBillerField? _CircleCode;
  CancelBillerField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  CancelBillerField? _LineItemNumber;
  CancelBillerField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  CancelBillerField? _LineItemTotalAmount;
  CancelBillerField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  CancelBillerField? _ArticleNumber;
  CancelBillerField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.text);
  }

  CancelBillerField? _Division;
  CancelBillerField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  CancelBillerField? _OrderType;
  CancelBillerField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  CancelBillerField? _ProductType;
  CancelBillerField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  CancelBillerField? _ProductCode;
  CancelBillerField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  CancelBillerField? _ValueCode;
  CancelBillerField get ValueCode {
    return _ValueCode = _setField(_ValueCode, 'ValueCode', DbType.text);
  }

  CancelBillerField? _Value;
  CancelBillerField get Value {
    return _Value = _setField(_Value, 'Value', DbType.text);
  }

  CancelBillerField? _Quantity;
  CancelBillerField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  CancelBillerField? _SenderCustomerId;
  CancelBillerField get SenderCustomerId {
    return _SenderCustomerId =
        _setField(_SenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  CancelBillerField? _IsReversed;
  CancelBillerField get IsReversed {
    return _IsReversed = _setField(_IsReversed, 'IsReversed', DbType.text);
  }

  CancelBillerField? _MaterialGroup;
  CancelBillerField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  CancelBillerField? _SerialNumber;
  CancelBillerField get SerialNumber {
    return _SerialNumber =
        _setField(_SerialNumber, 'SerialNumber', DbType.text);
  }

  CancelBillerField? _AddlBillInfo;
  CancelBillerField get AddlBillInfo {
    return _AddlBillInfo =
        _setField(_AddlBillInfo, 'AddlBillInfo', DbType.text);
  }

  CancelBillerField? _AddlBillAmountInfo;
  CancelBillerField get AddlBillAmountInfo {
    return _AddlBillAmountInfo =
        _setField(_AddlBillAmountInfo, 'AddlBillAmountInfo', DbType.text);
  }

  CancelBillerField? _BillerID;
  CancelBillerField get BillerID {
    return _BillerID = _setField(_BillerID, 'BillerID', DbType.text);
  }

  CancelBillerField? _BillerName;
  CancelBillerField get BillerName {
    return _BillerName = _setField(_BillerName, 'BillerName', DbType.text);
  }

  CancelBillerField? _FileName;
  CancelBillerField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  CancelBillerField? _FileCreated;
  CancelBillerField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  CancelBillerField? _FileCreatedDateTime;
  CancelBillerField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  CancelBillerField? _FileTransmitted;
  CancelBillerField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  CancelBillerField? _FileTransmittedDateTime;
  CancelBillerField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  CancelBillerField? _CancellationReason;
  CancelBillerField get CancellationReason {
    return _CancellationReason =
        _setField(_CancellationReason, 'CancellationReason', DbType.text);
  }

  CancelBillerField? _Authorized;
  CancelBillerField get Authorized {
    return _Authorized = _setField(_Authorized, 'Authorized', DbType.text);
  }

  /// Deletes List<CancelBiller> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCancelBiller!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCancelBiller!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from CancelBiller ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCancelBiller!.updateBatch(qparams, values);
  }

  /// This method always returns [CancelBiller] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CancelBiller?
  @override
  Future<CancelBiller?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCancelBiller!.toList(qparams);
    final data = await objFuture;
    CancelBiller? obj;
    if (data.isNotEmpty) {
      obj = CancelBiller.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CancelBiller]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CancelBiller?
  @override
  Future<CancelBiller> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CancelBiller();
  }

  /// This method returns int. [CancelBiller]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? cancelbillerCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cancelbillersFuture = await _mnCancelBiller!.toList(qparams);
    final int count = cancelbillersFuture[0]['CNT'] as int;
    if (cancelbillerCount != null) {
      cancelbillerCount(count);
    }
    return count;
  }

  /// This method returns List<CancelBiller> [CancelBiller]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CancelBiller>
  @override
  Future<List<CancelBiller>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CancelBiller> cancelbillersData = await CancelBiller.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return cancelbillersData;
  }

  /// This method returns Json String [CancelBiller]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CancelBiller]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CancelBiller]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCancelBiller!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CancelBiller]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM CancelBiller WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnCancelBiller!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CancelBiller]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCancelBiller!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CancelBiller.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCancelBiller!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CancelBillerFilterBuilder

// region CancelBillerFields
class CancelBillerFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fBookingFacilityZip;
  static TableField get BookingFacilityZip {
    return _fBookingFacilityZip = _fBookingFacilityZip ??
        SqlSyntax.setField(
            _fBookingFacilityZip, 'BookingFacilityZip', DbType.text);
  }

  static TableField? _fDistributionChannel;
  static TableField get DistributionChannel {
    return _fDistributionChannel = _fDistributionChannel ??
        SqlSyntax.setField(
            _fDistributionChannel, 'DistributionChannel', DbType.text);
  }

  static TableField? _fUserId;
  static TableField get UserId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'UserId', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyId;
  static TableField get CurrencyId {
    return _fCurrencyId = _fCurrencyId ??
        SqlSyntax.setField(_fCurrencyId, 'CurrencyId', DbType.text);
  }

  static TableField? _fTenderId;
  static TableField get TenderId {
    return _fTenderId =
        _fTenderId ?? SqlSyntax.setField(_fTenderId, 'TenderId', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifferenceAmount;
  static TableField get RoundOffDifferenceAmount {
    return _fRoundOffDifferenceAmount = _fRoundOffDifferenceAmount ??
        SqlSyntax.setField(_fRoundOffDifferenceAmount,
            'RoundOffDifferenceAmount', DbType.text);
  }

  static TableField? _fParentInvoiceNumber;
  static TableField get ParentInvoiceNumber {
    return _fParentInvoiceNumber = _fParentInvoiceNumber ??
        SqlSyntax.setField(
            _fParentInvoiceNumber, 'ParentInvoiceNumber', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'ArticleNumber', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fValueCode;
  static TableField get ValueCode {
    return _fValueCode = _fValueCode ??
        SqlSyntax.setField(_fValueCode, 'ValueCode', DbType.text);
  }

  static TableField? _fValue;
  static TableField get Value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'Value', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fSenderCustomerId;
  static TableField get SenderCustomerId {
    return _fSenderCustomerId = _fSenderCustomerId ??
        SqlSyntax.setField(_fSenderCustomerId, 'SenderCustomerId', DbType.text);
  }

  static TableField? _fIsReversed;
  static TableField get IsReversed {
    return _fIsReversed = _fIsReversed ??
        SqlSyntax.setField(_fIsReversed, 'IsReversed', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fSerialNumber;
  static TableField get SerialNumber {
    return _fSerialNumber = _fSerialNumber ??
        SqlSyntax.setField(_fSerialNumber, 'SerialNumber', DbType.text);
  }

  static TableField? _fAddlBillInfo;
  static TableField get AddlBillInfo {
    return _fAddlBillInfo = _fAddlBillInfo ??
        SqlSyntax.setField(_fAddlBillInfo, 'AddlBillInfo', DbType.text);
  }

  static TableField? _fAddlBillAmountInfo;
  static TableField get AddlBillAmountInfo {
    return _fAddlBillAmountInfo = _fAddlBillAmountInfo ??
        SqlSyntax.setField(
            _fAddlBillAmountInfo, 'AddlBillAmountInfo', DbType.text);
  }

  static TableField? _fBillerID;
  static TableField get BillerID {
    return _fBillerID =
        _fBillerID ?? SqlSyntax.setField(_fBillerID, 'BillerID', DbType.text);
  }

  static TableField? _fBillerName;
  static TableField get BillerName {
    return _fBillerName = _fBillerName ??
        SqlSyntax.setField(_fBillerName, 'BillerName', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  static TableField? _fCancellationReason;
  static TableField get CancellationReason {
    return _fCancellationReason = _fCancellationReason ??
        SqlSyntax.setField(
            _fCancellationReason, 'CancellationReason', DbType.text);
  }

  static TableField? _fAuthorized;
  static TableField get Authorized {
    return _fAuthorized = _fAuthorized ??
        SqlSyntax.setField(_fAuthorized, 'Authorized', DbType.text);
  }
}
// endregion CancelBillerFields

//region CancelBillerManager
class CancelBillerManager extends SqfEntityProvider {
  CancelBillerManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CancelBiller';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion CancelBillerManager
// region SwitchOnAcknowledge
class SwitchOnAcknowledge extends TableBase {
  SwitchOnAcknowledge(
      {this.id,
      this.ParentOfficeNumber,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SwitchOnAcknowledge.withFields(
      this.ParentOfficeNumber,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance) {
    _setDefaultValues();
  }
  SwitchOnAcknowledge.withId(
      this.id,
      this.ParentOfficeNumber,
      this.OfficeId,
      this.BOSequenceId,
      this.OfficeName,
      this.LegacyCode,
      this.SanctionedLimit,
      this.CashBalance) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SwitchOnAcknowledge.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['ParentOfficeNumber'] != null) {
      ParentOfficeNumber = o['ParentOfficeNumber'].toString();
    }
    if (o['OfficeId'] != null) {
      OfficeId = o['OfficeId'].toString();
    }
    if (o['BOSequenceId'] != null) {
      BOSequenceId = o['BOSequenceId'].toString();
    }
    if (o['OfficeName'] != null) {
      OfficeName = o['OfficeName'].toString();
    }
    if (o['LegacyCode'] != null) {
      LegacyCode = o['LegacyCode'].toString();
    }
    if (o['SanctionedLimit'] != null) {
      SanctionedLimit = o['SanctionedLimit'].toString();
    }
    if (o['CashBalance'] != null) {
      CashBalance = o['CashBalance'].toString();
    }
  }
  // FIELDS (SwitchOnAcknowledge)
  int? id;
  String? ParentOfficeNumber;
  String? OfficeId;
  String? BOSequenceId;
  String? OfficeName;
  String? LegacyCode;
  String? SanctionedLimit;
  String? CashBalance;

  // end FIELDS (SwitchOnAcknowledge)

  static const bool _softDeleteActivated = false;
  SwitchOnAcknowledgeManager? __mnSwitchOnAcknowledge;

  SwitchOnAcknowledgeManager get _mnSwitchOnAcknowledge {
    return __mnSwitchOnAcknowledge =
        __mnSwitchOnAcknowledge ?? SwitchOnAcknowledgeManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeNumber != null || !forView) {
      map['ParentOfficeNumber'] = ParentOfficeNumber;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (SanctionedLimit != null || !forView) {
      map['SanctionedLimit'] = SanctionedLimit;
    }
    if (CashBalance != null || !forView) {
      map['CashBalance'] = CashBalance;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (ParentOfficeNumber != null || !forView) {
      map['ParentOfficeNumber'] = ParentOfficeNumber;
    }
    if (OfficeId != null || !forView) {
      map['OfficeId'] = OfficeId;
    }
    if (BOSequenceId != null || !forView) {
      map['BOSequenceId'] = BOSequenceId;
    }
    if (OfficeName != null || !forView) {
      map['OfficeName'] = OfficeName;
    }
    if (LegacyCode != null || !forView) {
      map['LegacyCode'] = LegacyCode;
    }
    if (SanctionedLimit != null || !forView) {
      map['SanctionedLimit'] = SanctionedLimit;
    }
    if (CashBalance != null || !forView) {
      map['CashBalance'] = CashBalance;
    }

    return map;
  }

  /// This method returns Json String [SwitchOnAcknowledge]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SwitchOnAcknowledge]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ParentOfficeNumber,
      OfficeId,
      BOSequenceId,
      OfficeName,
      LegacyCode,
      SanctionedLimit,
      CashBalance
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      ParentOfficeNumber,
      OfficeId,
      BOSequenceId,
      OfficeName,
      LegacyCode,
      SanctionedLimit,
      CashBalance
    ];
  }

  static Future<List<SwitchOnAcknowledge>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnAcknowledge.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SwitchOnAcknowledge>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SwitchOnAcknowledge>[];
    try {
      objList = list
          .map((switchonacknowledge) => SwitchOnAcknowledge.fromMap(
              switchonacknowledge as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnAcknowledge.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SwitchOnAcknowledge>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SwitchOnAcknowledge> objList = <SwitchOnAcknowledge>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SwitchOnAcknowledge.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SwitchOnAcknowledge by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SwitchOnAcknowledge] if exist, otherwise returns null
  Future<SwitchOnAcknowledge?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SwitchOnAcknowledge? obj;
    final data = await _mnSwitchOnAcknowledge.getById([id]);
    if (data.length != 0) {
      obj = SwitchOnAcknowledge.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SwitchOnAcknowledge) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnAcknowledge.insert(this, ignoreBatch);
    } else {
      await _mnSwitchOnAcknowledge.update(this);
    }

    return id;
  }

  /// Saves the (SwitchOnAcknowledge) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnAcknowledge.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSwitchOnAcknowledge.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SwitchOnAcknowledge. Returns a new Primary Key value of SwitchOnAcknowledge

  /// <returns>Returns a new Primary Key value of SwitchOnAcknowledge
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SwitchOnAcknowledge> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SwitchOnAcknowledge> switchonacknowledges,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in switchonacknowledges) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < switchonacknowledges.length; i++) {
        if (switchonacknowledges[i].id == null) {
          switchonacknowledges[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnAcknowledge.rawInsert(
          'INSERT OR REPLACE INTO switchOnAcknowledge (id, ParentOfficeNumber, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeNumber,
            OfficeId,
            BOSequenceId,
            OfficeName,
            LegacyCode,
            SanctionedLimit,
            CashBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SwitchOnAcknowledge id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnAcknowledge id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SwitchOnAcknowledge Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnAcknowledge.rawInsert(
          'INSERT OR IGNORE INTO switchOnAcknowledge (id, ParentOfficeNumber, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            ParentOfficeNumber,
            OfficeId,
            BOSequenceId,
            OfficeName,
            LegacyCode,
            SanctionedLimit,
            CashBalance
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'SwitchOnAcknowledge id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnAcknowledge id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SwitchOnAcknowledge Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SwitchOnAcknowledge>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SwitchOnAcknowledge> switchonacknowledges,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnSwitchOnAcknowledge.rawInsertAll(
        'INSERT OR REPLACE INTO switchOnAcknowledge (id, ParentOfficeNumber, OfficeId, BOSequenceId, OfficeName, LegacyCode, SanctionedLimit, CashBalance)  VALUES (?,?,?,?,?,?,?,?)',
        switchonacknowledges,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SwitchOnAcknowledge

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SwitchOnAcknowledge invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSwitchOnAcknowledge
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSwitchOnAcknowledge.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SwitchOnAcknowledge] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SwitchOnAcknowledgeFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnAcknowledgeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnAcknowledgeFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion switchonacknowledge

// region SwitchOnAcknowledgeField
class SwitchOnAcknowledgeField extends FilterBase {
  SwitchOnAcknowledgeField(
      SwitchOnAcknowledgeFilterBuilder switchonacknowledgeFB)
      : super(switchonacknowledgeFB);

  @override
  SwitchOnAcknowledgeFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder isNull() {
    return super.isNull() as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SwitchOnAcknowledgeFilterBuilder;
  }

  @override
  SwitchOnAcknowledgeField get not {
    return super.not as SwitchOnAcknowledgeField;
  }
}
// endregion SwitchOnAcknowledgeField

// region SwitchOnAcknowledgeFilterBuilder
class SwitchOnAcknowledgeFilterBuilder extends ConjunctionBase {
  SwitchOnAcknowledgeFilterBuilder(SwitchOnAcknowledge obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSwitchOnAcknowledge = obj._mnSwitchOnAcknowledge;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SwitchOnAcknowledgeManager? _mnSwitchOnAcknowledge;

  /// put the sql keyword 'AND'
  @override
  SwitchOnAcknowledgeFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SwitchOnAcknowledgeFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SwitchOnAcknowledgeFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SwitchOnAcknowledgeFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SwitchOnAcknowledgeFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SwitchOnAcknowledgeFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SwitchOnAcknowledgeFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnAcknowledgeFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnAcknowledgeFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnAcknowledgeFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnAcknowledgeFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SwitchOnAcknowledgeField _setField(
      SwitchOnAcknowledgeField? field, String colName, DbType dbtype) {
    return SwitchOnAcknowledgeField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SwitchOnAcknowledgeField? _id;
  SwitchOnAcknowledgeField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SwitchOnAcknowledgeField? _ParentOfficeNumber;
  SwitchOnAcknowledgeField get ParentOfficeNumber {
    return _ParentOfficeNumber =
        _setField(_ParentOfficeNumber, 'ParentOfficeNumber', DbType.text);
  }

  SwitchOnAcknowledgeField? _OfficeId;
  SwitchOnAcknowledgeField get OfficeId {
    return _OfficeId = _setField(_OfficeId, 'OfficeId', DbType.text);
  }

  SwitchOnAcknowledgeField? _BOSequenceId;
  SwitchOnAcknowledgeField get BOSequenceId {
    return _BOSequenceId =
        _setField(_BOSequenceId, 'BOSequenceId', DbType.text);
  }

  SwitchOnAcknowledgeField? _OfficeName;
  SwitchOnAcknowledgeField get OfficeName {
    return _OfficeName = _setField(_OfficeName, 'OfficeName', DbType.text);
  }

  SwitchOnAcknowledgeField? _LegacyCode;
  SwitchOnAcknowledgeField get LegacyCode {
    return _LegacyCode = _setField(_LegacyCode, 'LegacyCode', DbType.text);
  }

  SwitchOnAcknowledgeField? _SanctionedLimit;
  SwitchOnAcknowledgeField get SanctionedLimit {
    return _SanctionedLimit =
        _setField(_SanctionedLimit, 'SanctionedLimit', DbType.text);
  }

  SwitchOnAcknowledgeField? _CashBalance;
  SwitchOnAcknowledgeField get CashBalance {
    return _CashBalance = _setField(_CashBalance, 'CashBalance', DbType.text);
  }

  /// Deletes List<SwitchOnAcknowledge> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSwitchOnAcknowledge!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSwitchOnAcknowledge!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from switchOnAcknowledge ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSwitchOnAcknowledge!.updateBatch(qparams, values);
  }

  /// This method always returns [SwitchOnAcknowledge] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnAcknowledge?
  @override
  Future<SwitchOnAcknowledge?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSwitchOnAcknowledge!.toList(qparams);
    final data = await objFuture;
    SwitchOnAcknowledge? obj;
    if (data.isNotEmpty) {
      obj = SwitchOnAcknowledge.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SwitchOnAcknowledge]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnAcknowledge?
  @override
  Future<SwitchOnAcknowledge> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SwitchOnAcknowledge();
  }

  /// This method returns int. [SwitchOnAcknowledge]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? switchonacknowledgeCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final switchonacknowledgesFuture =
        await _mnSwitchOnAcknowledge!.toList(qparams);
    final int count = switchonacknowledgesFuture[0]['CNT'] as int;
    if (switchonacknowledgeCount != null) {
      switchonacknowledgeCount(count);
    }
    return count;
  }

  /// This method returns List<SwitchOnAcknowledge> [SwitchOnAcknowledge]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SwitchOnAcknowledge>
  @override
  Future<List<SwitchOnAcknowledge>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SwitchOnAcknowledge> switchonacknowledgesData =
        await SwitchOnAcknowledge.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return switchonacknowledgesData;
  }

  /// This method returns Json String [SwitchOnAcknowledge]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SwitchOnAcknowledge]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SwitchOnAcknowledge]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSwitchOnAcknowledge!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SwitchOnAcknowledge]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM switchOnAcknowledge WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSwitchOnAcknowledge!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SwitchOnAcknowledge]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSwitchOnAcknowledge!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SwitchOnAcknowledge.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSwitchOnAcknowledge!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SwitchOnAcknowledgeFilterBuilder

// region SwitchOnAcknowledgeFields
class SwitchOnAcknowledgeFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fParentOfficeNumber;
  static TableField get ParentOfficeNumber {
    return _fParentOfficeNumber = _fParentOfficeNumber ??
        SqlSyntax.setField(
            _fParentOfficeNumber, 'ParentOfficeNumber', DbType.text);
  }

  static TableField? _fOfficeId;
  static TableField get OfficeId {
    return _fOfficeId =
        _fOfficeId ?? SqlSyntax.setField(_fOfficeId, 'OfficeId', DbType.text);
  }

  static TableField? _fBOSequenceId;
  static TableField get BOSequenceId {
    return _fBOSequenceId = _fBOSequenceId ??
        SqlSyntax.setField(_fBOSequenceId, 'BOSequenceId', DbType.text);
  }

  static TableField? _fOfficeName;
  static TableField get OfficeName {
    return _fOfficeName = _fOfficeName ??
        SqlSyntax.setField(_fOfficeName, 'OfficeName', DbType.text);
  }

  static TableField? _fLegacyCode;
  static TableField get LegacyCode {
    return _fLegacyCode = _fLegacyCode ??
        SqlSyntax.setField(_fLegacyCode, 'LegacyCode', DbType.text);
  }

  static TableField? _fSanctionedLimit;
  static TableField get SanctionedLimit {
    return _fSanctionedLimit = _fSanctionedLimit ??
        SqlSyntax.setField(_fSanctionedLimit, 'SanctionedLimit', DbType.text);
  }

  static TableField? _fCashBalance;
  static TableField get CashBalance {
    return _fCashBalance = _fCashBalance ??
        SqlSyntax.setField(_fCashBalance, 'CashBalance', DbType.text);
  }
}
// endregion SwitchOnAcknowledgeFields

//region SwitchOnAcknowledgeManager
class SwitchOnAcknowledgeManager extends SqfEntityProvider {
  SwitchOnAcknowledgeManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'switchOnAcknowledge';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SwitchOnAcknowledgeManager
// region SwitchOnAcknowledgement
class SwitchOnAcknowledgement extends TableBase {
  SwitchOnAcknowledgement(
      {this.id,
      this.LegacyUpdation,
      this.SanctionedDeletion,
      this.SanctionedInsertion,
      this.UpdateWallet,
      this.InsertionClosingBalance,
      this.InsertionOpeningBalance,
      this.InsertionOpeningStock}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SwitchOnAcknowledgement.withFields(
      this.LegacyUpdation,
      this.SanctionedDeletion,
      this.SanctionedInsertion,
      this.UpdateWallet,
      this.InsertionClosingBalance,
      this.InsertionOpeningBalance,
      this.InsertionOpeningStock) {
    _setDefaultValues();
  }
  SwitchOnAcknowledgement.withId(
      this.id,
      this.LegacyUpdation,
      this.SanctionedDeletion,
      this.SanctionedInsertion,
      this.UpdateWallet,
      this.InsertionClosingBalance,
      this.InsertionOpeningBalance,
      this.InsertionOpeningStock) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SwitchOnAcknowledgement.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['LegacyUpdation'] != null) {
      LegacyUpdation = o['LegacyUpdation'].toString();
    }
    if (o['SanctionedDeletion'] != null) {
      SanctionedDeletion = o['SanctionedDeletion'].toString();
    }
    if (o['SanctionedInsertion'] != null) {
      SanctionedInsertion = o['SanctionedInsertion'].toString();
    }
    if (o['UpdateWallet'] != null) {
      UpdateWallet = o['UpdateWallet'].toString();
    }
    if (o['InsertionClosingBalance'] != null) {
      InsertionClosingBalance = o['InsertionClosingBalance'].toString();
    }
    if (o['InsertionOpeningBalance'] != null) {
      InsertionOpeningBalance = o['InsertionOpeningBalance'].toString();
    }
    if (o['InsertionOpeningStock'] != null) {
      InsertionOpeningStock = o['InsertionOpeningStock'].toString();
    }
  }
  // FIELDS (SwitchOnAcknowledgement)
  int? id;
  String? LegacyUpdation;
  String? SanctionedDeletion;
  String? SanctionedInsertion;
  String? UpdateWallet;
  String? InsertionClosingBalance;
  String? InsertionOpeningBalance;
  String? InsertionOpeningStock;

  // end FIELDS (SwitchOnAcknowledgement)

  static const bool _softDeleteActivated = false;
  SwitchOnAcknowledgementManager? __mnSwitchOnAcknowledgement;

  SwitchOnAcknowledgementManager get _mnSwitchOnAcknowledgement {
    return __mnSwitchOnAcknowledgement =
        __mnSwitchOnAcknowledgement ?? SwitchOnAcknowledgementManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (LegacyUpdation != null || !forView) {
      map['LegacyUpdation'] = LegacyUpdation;
    }
    if (SanctionedDeletion != null || !forView) {
      map['SanctionedDeletion'] = SanctionedDeletion;
    }
    if (SanctionedInsertion != null || !forView) {
      map['SanctionedInsertion'] = SanctionedInsertion;
    }
    if (UpdateWallet != null || !forView) {
      map['UpdateWallet'] = UpdateWallet;
    }
    if (InsertionClosingBalance != null || !forView) {
      map['InsertionClosingBalance'] = InsertionClosingBalance;
    }
    if (InsertionOpeningBalance != null || !forView) {
      map['InsertionOpeningBalance'] = InsertionOpeningBalance;
    }
    if (InsertionOpeningStock != null || !forView) {
      map['InsertionOpeningStock'] = InsertionOpeningStock;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (LegacyUpdation != null || !forView) {
      map['LegacyUpdation'] = LegacyUpdation;
    }
    if (SanctionedDeletion != null || !forView) {
      map['SanctionedDeletion'] = SanctionedDeletion;
    }
    if (SanctionedInsertion != null || !forView) {
      map['SanctionedInsertion'] = SanctionedInsertion;
    }
    if (UpdateWallet != null || !forView) {
      map['UpdateWallet'] = UpdateWallet;
    }
    if (InsertionClosingBalance != null || !forView) {
      map['InsertionClosingBalance'] = InsertionClosingBalance;
    }
    if (InsertionOpeningBalance != null || !forView) {
      map['InsertionOpeningBalance'] = InsertionOpeningBalance;
    }
    if (InsertionOpeningStock != null || !forView) {
      map['InsertionOpeningStock'] = InsertionOpeningStock;
    }

    return map;
  }

  /// This method returns Json String [SwitchOnAcknowledgement]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SwitchOnAcknowledgement]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      LegacyUpdation,
      SanctionedDeletion,
      SanctionedInsertion,
      UpdateWallet,
      InsertionClosingBalance,
      InsertionOpeningBalance,
      InsertionOpeningStock
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      LegacyUpdation,
      SanctionedDeletion,
      SanctionedInsertion,
      UpdateWallet,
      InsertionClosingBalance,
      InsertionOpeningBalance,
      InsertionOpeningStock
    ];
  }

  static Future<List<SwitchOnAcknowledgement>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnAcknowledgement.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SwitchOnAcknowledgement>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SwitchOnAcknowledgement>[];
    try {
      objList = list
          .map((switchonacknowledgement) => SwitchOnAcknowledgement.fromMap(
              switchonacknowledgement as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SwitchOnAcknowledgement.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SwitchOnAcknowledgement>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SwitchOnAcknowledgement> objList = <SwitchOnAcknowledgement>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SwitchOnAcknowledgement.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SwitchOnAcknowledgement by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SwitchOnAcknowledgement] if exist, otherwise returns null
  Future<SwitchOnAcknowledgement?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SwitchOnAcknowledgement? obj;
    final data = await _mnSwitchOnAcknowledgement.getById([id]);
    if (data.length != 0) {
      obj = SwitchOnAcknowledgement.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SwitchOnAcknowledgement) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnAcknowledgement.insert(this, ignoreBatch);
    } else {
      await _mnSwitchOnAcknowledgement.update(this);
    }

    return id;
  }

  /// Saves the (SwitchOnAcknowledgement) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSwitchOnAcknowledgement.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSwitchOnAcknowledgement.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SwitchOnAcknowledgement. Returns a new Primary Key value of SwitchOnAcknowledgement

  /// <returns>Returns a new Primary Key value of SwitchOnAcknowledgement
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SwitchOnAcknowledgement> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SwitchOnAcknowledgement> switchonacknowledgements,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in switchonacknowledgements) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < switchonacknowledgements.length; i++) {
        if (switchonacknowledgements[i].id == null) {
          switchonacknowledgements[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnAcknowledgement.rawInsert(
          'INSERT OR REPLACE INTO switchOnAcknowledgement (id, LegacyUpdation, SanctionedDeletion, SanctionedInsertion, UpdateWallet, InsertionClosingBalance, InsertionOpeningBalance, InsertionOpeningStock)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            LegacyUpdation,
            SanctionedDeletion,
            SanctionedInsertion,
            UpdateWallet,
            InsertionClosingBalance,
            InsertionOpeningBalance,
            InsertionOpeningStock
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SwitchOnAcknowledgement id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnAcknowledgement id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SwitchOnAcknowledgement Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSwitchOnAcknowledgement.rawInsert(
          'INSERT OR IGNORE INTO switchOnAcknowledgement (id, LegacyUpdation, SanctionedDeletion, SanctionedInsertion, UpdateWallet, InsertionClosingBalance, InsertionOpeningBalance, InsertionOpeningStock)  VALUES (?,?,?,?,?,?,?,?)',
          [
            id,
            LegacyUpdation,
            SanctionedDeletion,
            SanctionedInsertion,
            UpdateWallet,
            InsertionClosingBalance,
            InsertionOpeningBalance,
            InsertionOpeningStock
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SwitchOnAcknowledgement id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SwitchOnAcknowledgement id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SwitchOnAcknowledgement Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SwitchOnAcknowledgement>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SwitchOnAcknowledgement> switchonacknowledgements,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnSwitchOnAcknowledgement.rawInsertAll(
        'INSERT OR REPLACE INTO switchOnAcknowledgement (id, LegacyUpdation, SanctionedDeletion, SanctionedInsertion, UpdateWallet, InsertionClosingBalance, InsertionOpeningBalance, InsertionOpeningStock)  VALUES (?,?,?,?,?,?,?,?)',
        switchonacknowledgements,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SwitchOnAcknowledgement

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SwitchOnAcknowledgement invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSwitchOnAcknowledgement
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSwitchOnAcknowledgement.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SwitchOnAcknowledgement] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SwitchOnAcknowledgementFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnAcknowledgementFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SwitchOnAcknowledgementFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion switchonacknowledgement

// region SwitchOnAcknowledgementField
class SwitchOnAcknowledgementField extends FilterBase {
  SwitchOnAcknowledgementField(
      SwitchOnAcknowledgementFilterBuilder switchonacknowledgementFB)
      : super(switchonacknowledgementFB);

  @override
  SwitchOnAcknowledgementFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder isNull() {
    return super.isNull() as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SwitchOnAcknowledgementFilterBuilder;
  }

  @override
  SwitchOnAcknowledgementField get not {
    return super.not as SwitchOnAcknowledgementField;
  }
}
// endregion SwitchOnAcknowledgementField

// region SwitchOnAcknowledgementFilterBuilder
class SwitchOnAcknowledgementFilterBuilder extends ConjunctionBase {
  SwitchOnAcknowledgementFilterBuilder(
      SwitchOnAcknowledgement obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSwitchOnAcknowledgement = obj._mnSwitchOnAcknowledgement;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SwitchOnAcknowledgementManager? _mnSwitchOnAcknowledgement;

  /// put the sql keyword 'AND'
  @override
  SwitchOnAcknowledgementFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SwitchOnAcknowledgementFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SwitchOnAcknowledgementFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SwitchOnAcknowledgementFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SwitchOnAcknowledgementFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SwitchOnAcknowledgementFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SwitchOnAcknowledgementFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnAcknowledgementFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnAcknowledgementFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SwitchOnAcknowledgementFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SwitchOnAcknowledgementFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SwitchOnAcknowledgementField _setField(
      SwitchOnAcknowledgementField? field, String colName, DbType dbtype) {
    return SwitchOnAcknowledgementField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SwitchOnAcknowledgementField? _id;
  SwitchOnAcknowledgementField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SwitchOnAcknowledgementField? _LegacyUpdation;
  SwitchOnAcknowledgementField get LegacyUpdation {
    return _LegacyUpdation =
        _setField(_LegacyUpdation, 'LegacyUpdation', DbType.text);
  }

  SwitchOnAcknowledgementField? _SanctionedDeletion;
  SwitchOnAcknowledgementField get SanctionedDeletion {
    return _SanctionedDeletion =
        _setField(_SanctionedDeletion, 'SanctionedDeletion', DbType.text);
  }

  SwitchOnAcknowledgementField? _SanctionedInsertion;
  SwitchOnAcknowledgementField get SanctionedInsertion {
    return _SanctionedInsertion =
        _setField(_SanctionedInsertion, 'SanctionedInsertion', DbType.text);
  }

  SwitchOnAcknowledgementField? _UpdateWallet;
  SwitchOnAcknowledgementField get UpdateWallet {
    return _UpdateWallet =
        _setField(_UpdateWallet, 'UpdateWallet', DbType.text);
  }

  SwitchOnAcknowledgementField? _InsertionClosingBalance;
  SwitchOnAcknowledgementField get InsertionClosingBalance {
    return _InsertionClosingBalance = _setField(
        _InsertionClosingBalance, 'InsertionClosingBalance', DbType.text);
  }

  SwitchOnAcknowledgementField? _InsertionOpeningBalance;
  SwitchOnAcknowledgementField get InsertionOpeningBalance {
    return _InsertionOpeningBalance = _setField(
        _InsertionOpeningBalance, 'InsertionOpeningBalance', DbType.text);
  }

  SwitchOnAcknowledgementField? _InsertionOpeningStock;
  SwitchOnAcknowledgementField get InsertionOpeningStock {
    return _InsertionOpeningStock =
        _setField(_InsertionOpeningStock, 'InsertionOpeningStock', DbType.text);
  }

  /// Deletes List<SwitchOnAcknowledgement> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSwitchOnAcknowledgement!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSwitchOnAcknowledgement!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from switchOnAcknowledgement ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSwitchOnAcknowledgement!.updateBatch(qparams, values);
  }

  /// This method always returns [SwitchOnAcknowledgement] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnAcknowledgement?
  @override
  Future<SwitchOnAcknowledgement?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSwitchOnAcknowledgement!.toList(qparams);
    final data = await objFuture;
    SwitchOnAcknowledgement? obj;
    if (data.isNotEmpty) {
      obj = SwitchOnAcknowledgement.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SwitchOnAcknowledgement]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SwitchOnAcknowledgement?
  @override
  Future<SwitchOnAcknowledgement> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SwitchOnAcknowledgement();
  }

  /// This method returns int. [SwitchOnAcknowledgement]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? switchonacknowledgementCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final switchonacknowledgementsFuture =
        await _mnSwitchOnAcknowledgement!.toList(qparams);
    final int count = switchonacknowledgementsFuture[0]['CNT'] as int;
    if (switchonacknowledgementCount != null) {
      switchonacknowledgementCount(count);
    }
    return count;
  }

  /// This method returns List<SwitchOnAcknowledgement> [SwitchOnAcknowledgement]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SwitchOnAcknowledgement>
  @override
  Future<List<SwitchOnAcknowledgement>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SwitchOnAcknowledgement> switchonacknowledgementsData =
        await SwitchOnAcknowledgement.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return switchonacknowledgementsData;
  }

  /// This method returns Json String [SwitchOnAcknowledgement]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SwitchOnAcknowledgement]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SwitchOnAcknowledgement]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSwitchOnAcknowledgement!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SwitchOnAcknowledgement]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM switchOnAcknowledgement WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSwitchOnAcknowledgement!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SwitchOnAcknowledgement]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSwitchOnAcknowledgement!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SwitchOnAcknowledgement.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSwitchOnAcknowledgement!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SwitchOnAcknowledgementFilterBuilder

// region SwitchOnAcknowledgementFields
class SwitchOnAcknowledgementFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fLegacyUpdation;
  static TableField get LegacyUpdation {
    return _fLegacyUpdation = _fLegacyUpdation ??
        SqlSyntax.setField(_fLegacyUpdation, 'LegacyUpdation', DbType.text);
  }

  static TableField? _fSanctionedDeletion;
  static TableField get SanctionedDeletion {
    return _fSanctionedDeletion = _fSanctionedDeletion ??
        SqlSyntax.setField(
            _fSanctionedDeletion, 'SanctionedDeletion', DbType.text);
  }

  static TableField? _fSanctionedInsertion;
  static TableField get SanctionedInsertion {
    return _fSanctionedInsertion = _fSanctionedInsertion ??
        SqlSyntax.setField(
            _fSanctionedInsertion, 'SanctionedInsertion', DbType.text);
  }

  static TableField? _fUpdateWallet;
  static TableField get UpdateWallet {
    return _fUpdateWallet = _fUpdateWallet ??
        SqlSyntax.setField(_fUpdateWallet, 'UpdateWallet', DbType.text);
  }

  static TableField? _fInsertionClosingBalance;
  static TableField get InsertionClosingBalance {
    return _fInsertionClosingBalance = _fInsertionClosingBalance ??
        SqlSyntax.setField(
            _fInsertionClosingBalance, 'InsertionClosingBalance', DbType.text);
  }

  static TableField? _fInsertionOpeningBalance;
  static TableField get InsertionOpeningBalance {
    return _fInsertionOpeningBalance = _fInsertionOpeningBalance ??
        SqlSyntax.setField(
            _fInsertionOpeningBalance, 'InsertionOpeningBalance', DbType.text);
  }

  static TableField? _fInsertionOpeningStock;
  static TableField get InsertionOpeningStock {
    return _fInsertionOpeningStock = _fInsertionOpeningStock ??
        SqlSyntax.setField(
            _fInsertionOpeningStock, 'InsertionOpeningStock', DbType.text);
  }
}
// endregion SwitchOnAcknowledgementFields

//region SwitchOnAcknowledgementManager
class SwitchOnAcknowledgementManager extends SqfEntityProvider {
  SwitchOnAcknowledgementManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'switchOnAcknowledgement';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SwitchOnAcknowledgementManager
// region BillerData
class BillerData extends TableBase {
  BillerData({this.BillerId, this.BillerName}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BillerData.withFields(this.BillerId, this.BillerName) {
    _setDefaultValues();
  }
  BillerData.withId(this.BillerId, this.BillerName) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BillerData.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BillerId = o['BillerId'].toString();
    if (o['BillerName'] != null) {
      BillerName = o['BillerName'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BillerData)
  String? BillerId;
  String? BillerName;
  bool? isSaved;
  // end FIELDS (BillerData)

  static const bool _softDeleteActivated = false;
  BillerDataManager? __mnBillerData;

  BillerDataManager get _mnBillerData {
    return __mnBillerData = __mnBillerData ?? BillerDataManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BillerId'] = BillerId;
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BillerId'] = BillerId;
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }

    return map;
  }

  /// This method returns Json String [BillerData]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BillerData]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [BillerId, BillerName];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [BillerId, BillerName];
  }

  static Future<List<BillerData>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillerData.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BillerData>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BillerData>[];
    try {
      objList = list
          .map((billerdata) =>
              BillerData.fromMap(billerdata as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillerData.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BillerData>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BillerData> objList = <BillerData>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BillerData.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BillerData by ID if exist, otherwise returns null
  /// Primary Keys: String? BillerId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BillerData] if exist, otherwise returns null
  Future<BillerData?> getById(String? BillerId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BillerId == null) {
      return null;
    }
    BillerData? obj;
    final data = await _mnBillerData.getById([BillerId]);
    if (data.length != 0) {
      obj = BillerData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BillerData) object. If the Primary Key (BillerId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BillerId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBillerData.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO billerData (BillerId, BillerName)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BillerData> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BillerData> billerdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in billerdatas) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillerData.rawInsert(
          'INSERT OR REPLACE INTO billerData (BillerId, BillerName)  VALUES (?,?)',
          [BillerId, BillerName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BillerData BillerId=$BillerId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BillerData BillerId=$BillerId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillerData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillerData.rawInsert(
          'INSERT OR IGNORE INTO billerData (BillerId, BillerName)  VALUES (?,?)',
          [BillerId, BillerName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BillerData BillerId=$BillerId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BillerData BillerId=$BillerId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillerData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BillerData

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BillerData invoked (BillerId=$BillerId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBillerData.delete(
          QueryParams(whereString: 'BillerId=?', whereArguments: [BillerId]));
    } else {
      return _mnBillerData.updateBatch(
          QueryParams(whereString: 'BillerId=?', whereArguments: [BillerId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BillerData] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BillerDataFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillerDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BillerDataFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillerDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BillerId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion billerdata

// region BillerDataField
class BillerDataField extends FilterBase {
  BillerDataField(BillerDataFilterBuilder billerdataFB) : super(billerdataFB);

  @override
  BillerDataFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder isNull() {
    return super.isNull() as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BillerDataFilterBuilder;
  }

  @override
  BillerDataField get not {
    return super.not as BillerDataField;
  }
}
// endregion BillerDataField

// region BillerDataFilterBuilder
class BillerDataFilterBuilder extends ConjunctionBase {
  BillerDataFilterBuilder(BillerData obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBillerData = obj._mnBillerData;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BillerDataManager? _mnBillerData;

  /// put the sql keyword 'AND'
  @override
  BillerDataFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BillerDataFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BillerDataFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BillerDataFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BillerDataFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BillerDataFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BillerDataFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillerDataFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillerDataFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillerDataFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillerDataFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BillerDataField _setField(
      BillerDataField? field, String colName, DbType dbtype) {
    return BillerDataField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BillerDataField? _BillerId;
  BillerDataField get BillerId {
    return _BillerId = _setField(_BillerId, 'BillerId', DbType.integer);
  }

  BillerDataField? _BillerName;
  BillerDataField get BillerName {
    return _BillerName = _setField(_BillerName, 'BillerName', DbType.text);
  }

  /// Deletes List<BillerData> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBillerData!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBillerData!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BillerId IN (SELECT BillerId from billerData ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBillerData!.updateBatch(qparams, values);
  }

  /// This method always returns [BillerData] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillerData?
  @override
  Future<BillerData?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBillerData!.toList(qparams);
    final data = await objFuture;
    BillerData? obj;
    if (data.isNotEmpty) {
      obj = BillerData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BillerData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillerData?
  @override
  Future<BillerData> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BillerData();
  }

  /// This method returns int. [BillerData]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? billerdataCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final billerdatasFuture = await _mnBillerData!.toList(qparams);
    final int count = billerdatasFuture[0]['CNT'] as int;
    if (billerdataCount != null) {
      billerdataCount(count);
    }
    return count;
  }

  /// This method returns List<BillerData> [BillerData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BillerData>
  @override
  Future<List<BillerData>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BillerData> billerdatasData = await BillerData.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return billerdatasData;
  }

  /// This method returns Json String [BillerData]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BillerData]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BillerData]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBillerData!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BillerData]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BillerId` FROM billerData WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BillerIdData = <String>[];
    qparams.selectColumns = ['BillerId'];
    final BillerIdFuture = await _mnBillerData!.toList(qparams);

    final int count = BillerIdFuture.length;
    for (int i = 0; i < count; i++) {
      BillerIdData.add(BillerIdFuture[i]['BillerId'] as String);
    }
    return BillerIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BillerData]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBillerData!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BillerData.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBillerData!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BillerDataFilterBuilder

// region BillerDataFields
class BillerDataFields {
  static TableField? _fBillerId;
  static TableField get BillerId {
    return _fBillerId = _fBillerId ??
        SqlSyntax.setField(_fBillerId, 'billerid', DbType.integer);
  }

  static TableField? _fBillerName;
  static TableField get BillerName {
    return _fBillerName = _fBillerName ??
        SqlSyntax.setField(_fBillerName, 'BillerName', DbType.text);
  }
}
// endregion BillerDataFields

//region BillerDataManager
class BillerDataManager extends SqfEntityProvider {
  BillerDataManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'billerData';
  static const List<String> _primaryKeyList = ['BillerId'];
  static const String _whereStr = 'BillerId=?';
}

//endregion BillerDataManager
// region SpecialRemittanceFile
class SpecialRemittanceFile extends TableBase {
  SpecialRemittanceFile(
      {this.id,
      this.SlipNumber,
      this.Date,
      this.ChequeNumber,
      this.BOProfitName,
      this.SOProfitName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.ChequeCash,
      this.IS_COMMUNICATED,
      this.FILE_NAME}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  SpecialRemittanceFile.withFields(
      this.SlipNumber,
      this.Date,
      this.ChequeNumber,
      this.BOProfitName,
      this.SOProfitName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.ChequeCash,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  SpecialRemittanceFile.withId(
      this.id,
      this.SlipNumber,
      this.Date,
      this.ChequeNumber,
      this.BOProfitName,
      this.SOProfitName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.ChequeCash,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  // fromMap v2.0
  SpecialRemittanceFile.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['SlipNumber'] != null) {
      SlipNumber = o['SlipNumber'].toString();
    }
    if (o['Date'] != null) {
      Date = o['Date'].toString();
    }
    if (o['ChequeNumber'] != null) {
      ChequeNumber = o['ChequeNumber'].toString();
    }
    if (o['BOProfitName'] != null) {
      BOProfitName = o['BOProfitName'].toString();
    }
    if (o['SOProfitName'] != null) {
      SOProfitName = o['SOProfitName'].toString();
    }
    if (o['CashAmount'] != null) {
      CashAmount = o['CashAmount'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['ChequeAmount'] != null) {
      ChequeAmount = o['ChequeAmount'].toString();
    }
    if (o['ChequeCash'] != null) {
      ChequeCash = o['ChequeCash'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
  }
  // FIELDS (SpecialRemittanceFile)
  int? id;
  String? SlipNumber;
  String? Date;
  String? ChequeNumber;
  String? BOProfitName;
  String? SOProfitName;
  String? CashAmount;
  String? Weight;
  String? ChequeAmount;
  String? ChequeCash;
  String? IS_COMMUNICATED;
  String? FILE_NAME;

  // end FIELDS (SpecialRemittanceFile)

  static const bool _softDeleteActivated = false;
  SpecialRemittanceFileManager? __mnSpecialRemittanceFile;

  SpecialRemittanceFileManager get _mnSpecialRemittanceFile {
    return __mnSpecialRemittanceFile =
        __mnSpecialRemittanceFile ?? SpecialRemittanceFileManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SlipNumber != null || !forView) {
      map['SlipNumber'] = SlipNumber;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (BOProfitName != null || !forView) {
      map['BOProfitName'] = BOProfitName;
    }
    if (SOProfitName != null || !forView) {
      map['SOProfitName'] = SOProfitName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (ChequeCash != null || !forView) {
      map['ChequeCash'] = ChequeCash;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SlipNumber != null || !forView) {
      map['SlipNumber'] = SlipNumber;
    }
    if (Date != null || !forView) {
      map['Date'] = Date;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (BOProfitName != null || !forView) {
      map['BOProfitName'] = BOProfitName;
    }
    if (SOProfitName != null || !forView) {
      map['SOProfitName'] = SOProfitName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (ChequeCash != null || !forView) {
      map['ChequeCash'] = ChequeCash;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  /// This method returns Json String [SpecialRemittanceFile]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [SpecialRemittanceFile]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      SlipNumber,
      Date,
      ChequeNumber,
      BOProfitName,
      SOProfitName,
      CashAmount,
      Weight,
      ChequeAmount,
      ChequeCash,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      SlipNumber,
      Date,
      ChequeNumber,
      BOProfitName,
      SOProfitName,
      CashAmount,
      Weight,
      ChequeAmount,
      ChequeCash,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  static Future<List<SpecialRemittanceFile>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpecialRemittanceFile.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<SpecialRemittanceFile>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <SpecialRemittanceFile>[];
    try {
      objList = list
          .map((specialremittancefile) => SpecialRemittanceFile.fromMap(
              specialremittancefile as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR SpecialRemittanceFile.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<SpecialRemittanceFile>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<SpecialRemittanceFile> objList = <SpecialRemittanceFile>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = SpecialRemittanceFile.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns SpecialRemittanceFile by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [SpecialRemittanceFile] if exist, otherwise returns null
  Future<SpecialRemittanceFile?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    SpecialRemittanceFile? obj;
    final data = await _mnSpecialRemittanceFile.getById([id]);
    if (data.length != 0) {
      obj = SpecialRemittanceFile.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (SpecialRemittanceFile) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSpecialRemittanceFile.insert(this, ignoreBatch);
    } else {
      await _mnSpecialRemittanceFile.update(this);
    }

    return id;
  }

  /// Saves the (SpecialRemittanceFile) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnSpecialRemittanceFile.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnSpecialRemittanceFile.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs SpecialRemittanceFile. Returns a new Primary Key value of SpecialRemittanceFile

  /// <returns>Returns a new Primary Key value of SpecialRemittanceFile
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<SpecialRemittanceFile> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<SpecialRemittanceFile> specialremittancefiles,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in specialremittancefiles) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < specialremittancefiles.length; i++) {
        if (specialremittancefiles[i].id == null) {
          specialremittancefiles[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpecialRemittanceFile.rawInsert(
          'INSERT OR REPLACE INTO specialRemittanceFile (id, SlipNumber, Date, ChequeNumber, BOProfitName, SOProfitName, CashAmount, Weight, ChequeAmount, ChequeCash, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SlipNumber,
            Date,
            ChequeNumber,
            BOProfitName,
            SOProfitName,
            CashAmount,
            Weight,
            ChequeAmount,
            ChequeCash,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpecialRemittanceFile id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SpecialRemittanceFile id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SpecialRemittanceFile Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnSpecialRemittanceFile.rawInsert(
          'INSERT OR IGNORE INTO specialRemittanceFile (id, SlipNumber, Date, ChequeNumber, BOProfitName, SOProfitName, CashAmount, Weight, ChequeAmount, ChequeCash, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SlipNumber,
            Date,
            ChequeNumber,
            BOProfitName,
            SOProfitName,
            CashAmount,
            Weight,
            ChequeAmount,
            ChequeCash,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'SpecialRemittanceFile id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'SpecialRemittanceFile id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'SpecialRemittanceFile Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<SpecialRemittanceFile>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<SpecialRemittanceFile> specialremittancefiles,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnSpecialRemittanceFile.rawInsertAll(
        'INSERT OR REPLACE INTO specialRemittanceFile (id, SlipNumber, Date, ChequeNumber, BOProfitName, SOProfitName, CashAmount, Weight, ChequeAmount, ChequeCash, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',
        specialremittancefiles,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes SpecialRemittanceFile

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete SpecialRemittanceFile invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnSpecialRemittanceFile
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnSpecialRemittanceFile.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [SpecialRemittanceFile] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  SpecialRemittanceFileFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpecialRemittanceFileFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  SpecialRemittanceFileFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return SpecialRemittanceFileFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion specialremittancefile

// region SpecialRemittanceFileField
class SpecialRemittanceFileField extends FilterBase {
  SpecialRemittanceFileField(
      SpecialRemittanceFileFilterBuilder specialremittancefileFB)
      : super(specialremittancefileFB);

  @override
  SpecialRemittanceFileFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder isNull() {
    return super.isNull() as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as SpecialRemittanceFileFilterBuilder;
  }

  @override
  SpecialRemittanceFileField get not {
    return super.not as SpecialRemittanceFileField;
  }
}
// endregion SpecialRemittanceFileField

// region SpecialRemittanceFileFilterBuilder
class SpecialRemittanceFileFilterBuilder extends ConjunctionBase {
  SpecialRemittanceFileFilterBuilder(
      SpecialRemittanceFile obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnSpecialRemittanceFile = obj._mnSpecialRemittanceFile;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  SpecialRemittanceFileManager? _mnSpecialRemittanceFile;

  /// put the sql keyword 'AND'
  @override
  SpecialRemittanceFileFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  SpecialRemittanceFileFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  SpecialRemittanceFileFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  SpecialRemittanceFileFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  SpecialRemittanceFileFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  SpecialRemittanceFileFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  SpecialRemittanceFileFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpecialRemittanceFileFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpecialRemittanceFileFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  SpecialRemittanceFileFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  SpecialRemittanceFileFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  SpecialRemittanceFileField _setField(
      SpecialRemittanceFileField? field, String colName, DbType dbtype) {
    return SpecialRemittanceFileField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  SpecialRemittanceFileField? _id;
  SpecialRemittanceFileField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  SpecialRemittanceFileField? _SlipNumber;
  SpecialRemittanceFileField get SlipNumber {
    return _SlipNumber = _setField(_SlipNumber, 'SlipNumber', DbType.text);
  }

  SpecialRemittanceFileField? _Date;
  SpecialRemittanceFileField get Date {
    return _Date = _setField(_Date, 'Date', DbType.text);
  }

  SpecialRemittanceFileField? _ChequeNumber;
  SpecialRemittanceFileField get ChequeNumber {
    return _ChequeNumber =
        _setField(_ChequeNumber, 'ChequeNumber', DbType.text);
  }

  SpecialRemittanceFileField? _BOProfitName;
  SpecialRemittanceFileField get BOProfitName {
    return _BOProfitName =
        _setField(_BOProfitName, 'BOProfitName', DbType.text);
  }

  SpecialRemittanceFileField? _SOProfitName;
  SpecialRemittanceFileField get SOProfitName {
    return _SOProfitName =
        _setField(_SOProfitName, 'SOProfitName', DbType.text);
  }

  SpecialRemittanceFileField? _CashAmount;
  SpecialRemittanceFileField get CashAmount {
    return _CashAmount = _setField(_CashAmount, 'CashAmount', DbType.text);
  }

  SpecialRemittanceFileField? _Weight;
  SpecialRemittanceFileField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  SpecialRemittanceFileField? _ChequeAmount;
  SpecialRemittanceFileField get ChequeAmount {
    return _ChequeAmount =
        _setField(_ChequeAmount, 'ChequeAmount', DbType.text);
  }

  SpecialRemittanceFileField? _ChequeCash;
  SpecialRemittanceFileField get ChequeCash {
    return _ChequeCash = _setField(_ChequeCash, 'ChequeCash', DbType.text);
  }

  SpecialRemittanceFileField? _IS_COMMUNICATED;
  SpecialRemittanceFileField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  SpecialRemittanceFileField? _FILE_NAME;
  SpecialRemittanceFileField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  /// Deletes List<SpecialRemittanceFile> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnSpecialRemittanceFile!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnSpecialRemittanceFile!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from specialRemittanceFile ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnSpecialRemittanceFile!.updateBatch(qparams, values);
  }

  /// This method always returns [SpecialRemittanceFile] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpecialRemittanceFile?
  @override
  Future<SpecialRemittanceFile?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnSpecialRemittanceFile!.toList(qparams);
    final data = await objFuture;
    SpecialRemittanceFile? obj;
    if (data.isNotEmpty) {
      obj = SpecialRemittanceFile.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [SpecialRemittanceFile]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> SpecialRemittanceFile?
  @override
  Future<SpecialRemittanceFile> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        SpecialRemittanceFile();
  }

  /// This method returns int. [SpecialRemittanceFile]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? specialremittancefileCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final specialremittancefilesFuture =
        await _mnSpecialRemittanceFile!.toList(qparams);
    final int count = specialremittancefilesFuture[0]['CNT'] as int;
    if (specialremittancefileCount != null) {
      specialremittancefileCount(count);
    }
    return count;
  }

  /// This method returns List<SpecialRemittanceFile> [SpecialRemittanceFile]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<SpecialRemittanceFile>
  @override
  Future<List<SpecialRemittanceFile>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<SpecialRemittanceFile> specialremittancefilesData =
        await SpecialRemittanceFile.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return specialremittancefilesData;
  }

  /// This method returns Json String [SpecialRemittanceFile]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [SpecialRemittanceFile]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [SpecialRemittanceFile]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnSpecialRemittanceFile!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [SpecialRemittanceFile]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM specialRemittanceFile WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnSpecialRemittanceFile!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [SpecialRemittanceFile]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnSpecialRemittanceFile!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await SpecialRemittanceFile.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnSpecialRemittanceFile!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion SpecialRemittanceFileFilterBuilder

// region SpecialRemittanceFileFields
class SpecialRemittanceFileFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSlipNumber;
  static TableField get SlipNumber {
    return _fSlipNumber = _fSlipNumber ??
        SqlSyntax.setField(_fSlipNumber, 'SlipNumber', DbType.text);
  }

  static TableField? _fDate;
  static TableField get Date {
    return _fDate = _fDate ?? SqlSyntax.setField(_fDate, 'Date', DbType.text);
  }

  static TableField? _fChequeNumber;
  static TableField get ChequeNumber {
    return _fChequeNumber = _fChequeNumber ??
        SqlSyntax.setField(_fChequeNumber, 'ChequeNumber', DbType.text);
  }

  static TableField? _fBOProfitName;
  static TableField get BOProfitName {
    return _fBOProfitName = _fBOProfitName ??
        SqlSyntax.setField(_fBOProfitName, 'BOProfitName', DbType.text);
  }

  static TableField? _fSOProfitName;
  static TableField get SOProfitName {
    return _fSOProfitName = _fSOProfitName ??
        SqlSyntax.setField(_fSOProfitName, 'SOProfitName', DbType.text);
  }

  static TableField? _fCashAmount;
  static TableField get CashAmount {
    return _fCashAmount = _fCashAmount ??
        SqlSyntax.setField(_fCashAmount, 'CashAmount', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fChequeAmount;
  static TableField get ChequeAmount {
    return _fChequeAmount = _fChequeAmount ??
        SqlSyntax.setField(_fChequeAmount, 'ChequeAmount', DbType.text);
  }

  static TableField? _fChequeCash;
  static TableField get ChequeCash {
    return _fChequeCash = _fChequeCash ??
        SqlSyntax.setField(_fChequeCash, 'ChequeCash', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }
}
// endregion SpecialRemittanceFileFields

//region SpecialRemittanceFileManager
class SpecialRemittanceFileManager extends SqfEntityProvider {
  SpecialRemittanceFileManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'specialRemittanceFile';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion SpecialRemittanceFileManager
// region BillFile
class BillFile extends TableBase {
  BillFile(
      {this.id,
      this.FacilityId,
      this.Zip,
      this.Channel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.CustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.ElapsedTime,
      this.AdditionalBillInfo,
      this.AdditionalBillAmountInfo,
      this.BillerId,
      this.BillerName,
      this.IS_COMMUNICATED,
      this.FILE_NAME}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BillFile.withFields(
      this.FacilityId,
      this.Zip,
      this.Channel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.CustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.ElapsedTime,
      this.AdditionalBillInfo,
      this.AdditionalBillAmountInfo,
      this.BillerId,
      this.BillerName,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  BillFile.withId(
      this.id,
      this.FacilityId,
      this.Zip,
      this.Channel,
      this.UserId,
      this.CounterNumber,
      this.InvoiceNumber,
      this.TotalAmount,
      this.BookingDate,
      this.BookingTime,
      this.CurrencyId,
      this.TenderId,
      this.TotalCashAmount,
      this.RoundOffDifference,
      this.CircleCode,
      this.LineItemNumber,
      this.LineItemTotalAmount,
      this.ArticleNumber,
      this.Division,
      this.OrderType,
      this.ProductType,
      this.ProductCode,
      this.ValueCode,
      this.Value,
      this.Quantity,
      this.CustomerId,
      this.MaterialGroup,
      this.DestinationFacilityId,
      this.ElapsedTime,
      this.AdditionalBillInfo,
      this.AdditionalBillAmountInfo,
      this.BillerId,
      this.BillerName,
      this.IS_COMMUNICATED,
      this.FILE_NAME) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BillFile.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['FacilityId'] != null) {
      FacilityId = o['FacilityId'].toString();
    }
    if (o['Zip'] != null) {
      Zip = o['Zip'].toString();
    }
    if (o['Channel'] != null) {
      Channel = o['Channel'].toString();
    }
    if (o['UserId'] != null) {
      UserId = o['UserId'].toString();
    }
    if (o['CounterNumber'] != null) {
      CounterNumber = o['CounterNumber'].toString();
    }
    if (o['InvoiceNumber'] != null) {
      InvoiceNumber = o['InvoiceNumber'].toString();
    }
    if (o['TotalAmount'] != null) {
      TotalAmount = o['TotalAmount'].toString();
    }
    if (o['BookingDate'] != null) {
      BookingDate = o['BookingDate'].toString();
    }
    if (o['BookingTime'] != null) {
      BookingTime = o['BookingTime'].toString();
    }
    if (o['CurrencyId'] != null) {
      CurrencyId = o['CurrencyId'].toString();
    }
    if (o['TenderId'] != null) {
      TenderId = o['TenderId'].toString();
    }
    if (o['TotalCashAmount'] != null) {
      TotalCashAmount = o['TotalCashAmount'].toString();
    }
    if (o['RoundOffDifference'] != null) {
      RoundOffDifference = o['RoundOffDifference'].toString();
    }
    if (o['CircleCode'] != null) {
      CircleCode = o['CircleCode'].toString();
    }
    if (o['LineItemNumber'] != null) {
      LineItemNumber = o['LineItemNumber'].toString();
    }
    if (o['LineItemTotalAmount'] != null) {
      LineItemTotalAmount = o['LineItemTotalAmount'].toString();
    }
    if (o['ArticleNumber'] != null) {
      ArticleNumber = o['ArticleNumber'].toString();
    }
    if (o['Division'] != null) {
      Division = o['Division'].toString();
    }
    if (o['OrderType'] != null) {
      OrderType = o['OrderType'].toString();
    }
    if (o['ProductType'] != null) {
      ProductType = o['ProductType'].toString();
    }
    if (o['ProductCode'] != null) {
      ProductCode = o['ProductCode'].toString();
    }
    if (o['ValueCode'] != null) {
      ValueCode = o['ValueCode'].toString();
    }
    if (o['Value'] != null) {
      Value = o['Value'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['CustomerId'] != null) {
      CustomerId = o['CustomerId'].toString();
    }
    if (o['MaterialGroup'] != null) {
      MaterialGroup = o['MaterialGroup'].toString();
    }
    if (o['DestinationFacilityId'] != null) {
      DestinationFacilityId = o['DestinationFacilityId'].toString();
    }
    if (o['ElapsedTime'] != null) {
      ElapsedTime = o['ElapsedTime'].toString();
    }
    if (o['AdditionalBillInfo'] != null) {
      AdditionalBillInfo = o['AdditionalBillInfo'].toString();
    }
    if (o['AdditionalBillAmountInfo'] != null) {
      AdditionalBillAmountInfo = o['AdditionalBillAmountInfo'].toString();
    }
    if (o['BillerId'] != null) {
      BillerId = o['BillerId'].toString();
    }
    if (o['BillerName'] != null) {
      BillerName = o['BillerName'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
  }
  // FIELDS (BillFile)
  int? id;
  String? FacilityId;
  String? Zip;
  String? Channel;
  String? UserId;
  String? CounterNumber;
  String? InvoiceNumber;
  String? TotalAmount;
  String? BookingDate;
  String? BookingTime;
  String? CurrencyId;
  String? TenderId;
  String? TotalCashAmount;
  String? RoundOffDifference;
  String? CircleCode;
  String? LineItemNumber;
  String? LineItemTotalAmount;
  String? ArticleNumber;
  String? Division;
  String? OrderType;
  String? ProductType;
  String? ProductCode;
  String? ValueCode;
  String? Value;
  String? Quantity;
  String? CustomerId;
  String? MaterialGroup;
  String? DestinationFacilityId;
  String? ElapsedTime;
  String? AdditionalBillInfo;
  String? AdditionalBillAmountInfo;
  String? BillerId;
  String? BillerName;
  String? IS_COMMUNICATED;
  String? FILE_NAME;

  // end FIELDS (BillFile)

  static const bool _softDeleteActivated = false;
  BillFileManager? __mnBillFile;

  BillFileManager get _mnBillFile {
    return __mnBillFile = __mnBillFile ?? BillFileManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (Zip != null || !forView) {
      map['Zip'] = Zip;
    }
    if (Channel != null || !forView) {
      map['Channel'] = Channel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (CustomerId != null || !forView) {
      map['CustomerId'] = CustomerId;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacilityId != null || !forView) {
      map['DestinationFacilityId'] = DestinationFacilityId;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (AdditionalBillInfo != null || !forView) {
      map['AdditionalBillInfo'] = AdditionalBillInfo;
    }
    if (AdditionalBillAmountInfo != null || !forView) {
      map['AdditionalBillAmountInfo'] = AdditionalBillAmountInfo;
    }
    if (BillerId != null || !forView) {
      map['BillerId'] = BillerId;
    }
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (FacilityId != null || !forView) {
      map['FacilityId'] = FacilityId;
    }
    if (Zip != null || !forView) {
      map['Zip'] = Zip;
    }
    if (Channel != null || !forView) {
      map['Channel'] = Channel;
    }
    if (UserId != null || !forView) {
      map['UserId'] = UserId;
    }
    if (CounterNumber != null || !forView) {
      map['CounterNumber'] = CounterNumber;
    }
    if (InvoiceNumber != null || !forView) {
      map['InvoiceNumber'] = InvoiceNumber;
    }
    if (TotalAmount != null || !forView) {
      map['TotalAmount'] = TotalAmount;
    }
    if (BookingDate != null || !forView) {
      map['BookingDate'] = BookingDate;
    }
    if (BookingTime != null || !forView) {
      map['BookingTime'] = BookingTime;
    }
    if (CurrencyId != null || !forView) {
      map['CurrencyId'] = CurrencyId;
    }
    if (TenderId != null || !forView) {
      map['TenderId'] = TenderId;
    }
    if (TotalCashAmount != null || !forView) {
      map['TotalCashAmount'] = TotalCashAmount;
    }
    if (RoundOffDifference != null || !forView) {
      map['RoundOffDifference'] = RoundOffDifference;
    }
    if (CircleCode != null || !forView) {
      map['CircleCode'] = CircleCode;
    }
    if (LineItemNumber != null || !forView) {
      map['LineItemNumber'] = LineItemNumber;
    }
    if (LineItemTotalAmount != null || !forView) {
      map['LineItemTotalAmount'] = LineItemTotalAmount;
    }
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (Division != null || !forView) {
      map['Division'] = Division;
    }
    if (OrderType != null || !forView) {
      map['OrderType'] = OrderType;
    }
    if (ProductType != null || !forView) {
      map['ProductType'] = ProductType;
    }
    if (ProductCode != null || !forView) {
      map['ProductCode'] = ProductCode;
    }
    if (ValueCode != null || !forView) {
      map['ValueCode'] = ValueCode;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (CustomerId != null || !forView) {
      map['CustomerId'] = CustomerId;
    }
    if (MaterialGroup != null || !forView) {
      map['MaterialGroup'] = MaterialGroup;
    }
    if (DestinationFacilityId != null || !forView) {
      map['DestinationFacilityId'] = DestinationFacilityId;
    }
    if (ElapsedTime != null || !forView) {
      map['ElapsedTime'] = ElapsedTime;
    }
    if (AdditionalBillInfo != null || !forView) {
      map['AdditionalBillInfo'] = AdditionalBillInfo;
    }
    if (AdditionalBillAmountInfo != null || !forView) {
      map['AdditionalBillAmountInfo'] = AdditionalBillAmountInfo;
    }
    if (BillerId != null || !forView) {
      map['BillerId'] = BillerId;
    }
    if (BillerName != null || !forView) {
      map['BillerName'] = BillerName;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  /// This method returns Json String [BillFile]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BillFile]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      FacilityId,
      Zip,
      Channel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      CustomerId,
      MaterialGroup,
      DestinationFacilityId,
      ElapsedTime,
      AdditionalBillInfo,
      AdditionalBillAmountInfo,
      BillerId,
      BillerName,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      FacilityId,
      Zip,
      Channel,
      UserId,
      CounterNumber,
      InvoiceNumber,
      TotalAmount,
      BookingDate,
      BookingTime,
      CurrencyId,
      TenderId,
      TotalCashAmount,
      RoundOffDifference,
      CircleCode,
      LineItemNumber,
      LineItemTotalAmount,
      ArticleNumber,
      Division,
      OrderType,
      ProductType,
      ProductCode,
      ValueCode,
      Value,
      Quantity,
      CustomerId,
      MaterialGroup,
      DestinationFacilityId,
      ElapsedTime,
      AdditionalBillInfo,
      AdditionalBillAmountInfo,
      BillerId,
      BillerName,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  static Future<List<BillFile>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillFile.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BillFile>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BillFile>[];
    try {
      objList = list
          .map((billfile) => BillFile.fromMap(billfile as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillFile.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BillFile>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BillFile> objList = <BillFile>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BillFile.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BillFile by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BillFile] if exist, otherwise returns null
  Future<BillFile?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    BillFile? obj;
    final data = await _mnBillFile.getById([id]);
    if (data.length != 0) {
      obj = BillFile.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BillFile) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBillFile.insert(this, ignoreBatch);
    } else {
      await _mnBillFile.update(this);
    }

    return id;
  }

  /// Saves the (BillFile) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnBillFile.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnBillFile.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs BillFile. Returns a new Primary Key value of BillFile

  /// <returns>Returns a new Primary Key value of BillFile
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<BillFile> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BillFile> billfiles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in billfiles) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < billfiles.length; i++) {
        if (billfiles[i].id == null) {
          billfiles[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillFile.rawInsert(
          'INSERT OR REPLACE INTO billFile (id, FacilityId, Zip, Channel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, CustomerId, MaterialGroup, DestinationFacilityId, ElapsedTime, AdditionalBillInfo, AdditionalBillAmountInfo, BillerId, BillerName, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            Zip,
            Channel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            CustomerId,
            MaterialGroup,
            DestinationFacilityId,
            ElapsedTime,
            AdditionalBillInfo,
            AdditionalBillAmountInfo,
            BillerId,
            BillerName,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BillFile id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'BillFile id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillFile Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillFile.rawInsert(
          'INSERT OR IGNORE INTO billFile (id, FacilityId, Zip, Channel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, CustomerId, MaterialGroup, DestinationFacilityId, ElapsedTime, AdditionalBillInfo, AdditionalBillAmountInfo, BillerId, BillerName, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            FacilityId,
            Zip,
            Channel,
            UserId,
            CounterNumber,
            InvoiceNumber,
            TotalAmount,
            BookingDate,
            BookingTime,
            CurrencyId,
            TenderId,
            TotalCashAmount,
            RoundOffDifference,
            CircleCode,
            LineItemNumber,
            LineItemTotalAmount,
            ArticleNumber,
            Division,
            OrderType,
            ProductType,
            ProductCode,
            ValueCode,
            Value,
            Quantity,
            CustomerId,
            MaterialGroup,
            DestinationFacilityId,
            ElapsedTime,
            AdditionalBillInfo,
            AdditionalBillAmountInfo,
            BillerId,
            BillerName,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BillFile id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false, errorMessage: 'BillFile id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillFile Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BillFile>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BillFile> billfiles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBillFile.rawInsertAll(
        'INSERT OR REPLACE INTO billFile (id, FacilityId, Zip, Channel, UserId, CounterNumber, InvoiceNumber, TotalAmount, BookingDate, BookingTime, CurrencyId, TenderId, TotalCashAmount, RoundOffDifference, CircleCode, LineItemNumber, LineItemTotalAmount, ArticleNumber, Division, OrderType, ProductType, ProductCode, ValueCode, Value, Quantity, CustomerId, MaterialGroup, DestinationFacilityId, ElapsedTime, AdditionalBillInfo, AdditionalBillAmountInfo, BillerId, BillerName, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        billfiles,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BillFile

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BillFile invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBillFile
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnBillFile.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BillFile] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BillFileFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillFileFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BillFileFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillFileFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion billfile

// region BillFileField
class BillFileField extends FilterBase {
  BillFileField(BillFileFilterBuilder billfileFB) : super(billfileFB);

  @override
  BillFileFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder isNull() {
    return super.isNull() as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BillFileFilterBuilder;
  }

  @override
  BillFileField get not {
    return super.not as BillFileField;
  }
}
// endregion BillFileField

// region BillFileFilterBuilder
class BillFileFilterBuilder extends ConjunctionBase {
  BillFileFilterBuilder(BillFile obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBillFile = obj._mnBillFile;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BillFileManager? _mnBillFile;

  /// put the sql keyword 'AND'
  @override
  BillFileFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BillFileFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BillFileFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BillFileFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BillFileFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BillFileFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BillFileFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillFileFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillFileFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillFileFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillFileFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BillFileField _setField(BillFileField? field, String colName, DbType dbtype) {
    return BillFileField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BillFileField? _id;
  BillFileField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  BillFileField? _FacilityId;
  BillFileField get FacilityId {
    return _FacilityId = _setField(_FacilityId, 'FacilityId', DbType.text);
  }

  BillFileField? _Zip;
  BillFileField get Zip {
    return _Zip = _setField(_Zip, 'Zip', DbType.text);
  }

  BillFileField? _Channel;
  BillFileField get Channel {
    return _Channel = _setField(_Channel, 'Channel', DbType.text);
  }

  BillFileField? _UserId;
  BillFileField get UserId {
    return _UserId = _setField(_UserId, 'UserId', DbType.text);
  }

  BillFileField? _CounterNumber;
  BillFileField get CounterNumber {
    return _CounterNumber =
        _setField(_CounterNumber, 'CounterNumber', DbType.text);
  }

  BillFileField? _InvoiceNumber;
  BillFileField get InvoiceNumber {
    return _InvoiceNumber =
        _setField(_InvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  BillFileField? _TotalAmount;
  BillFileField get TotalAmount {
    return _TotalAmount = _setField(_TotalAmount, 'TotalAmount', DbType.text);
  }

  BillFileField? _BookingDate;
  BillFileField get BookingDate {
    return _BookingDate = _setField(_BookingDate, 'BookingDate', DbType.text);
  }

  BillFileField? _BookingTime;
  BillFileField get BookingTime {
    return _BookingTime = _setField(_BookingTime, 'BookingTime', DbType.text);
  }

  BillFileField? _CurrencyId;
  BillFileField get CurrencyId {
    return _CurrencyId = _setField(_CurrencyId, 'CurrencyId', DbType.text);
  }

  BillFileField? _TenderId;
  BillFileField get TenderId {
    return _TenderId = _setField(_TenderId, 'TenderId', DbType.text);
  }

  BillFileField? _TotalCashAmount;
  BillFileField get TotalCashAmount {
    return _TotalCashAmount =
        _setField(_TotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  BillFileField? _RoundOffDifference;
  BillFileField get RoundOffDifference {
    return _RoundOffDifference =
        _setField(_RoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  BillFileField? _CircleCode;
  BillFileField get CircleCode {
    return _CircleCode = _setField(_CircleCode, 'CircleCode', DbType.text);
  }

  BillFileField? _LineItemNumber;
  BillFileField get LineItemNumber {
    return _LineItemNumber =
        _setField(_LineItemNumber, 'LineItemNumber', DbType.text);
  }

  BillFileField? _LineItemTotalAmount;
  BillFileField get LineItemTotalAmount {
    return _LineItemTotalAmount =
        _setField(_LineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  BillFileField? _ArticleNumber;
  BillFileField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.text);
  }

  BillFileField? _Division;
  BillFileField get Division {
    return _Division = _setField(_Division, 'Division', DbType.text);
  }

  BillFileField? _OrderType;
  BillFileField get OrderType {
    return _OrderType = _setField(_OrderType, 'OrderType', DbType.text);
  }

  BillFileField? _ProductType;
  BillFileField get ProductType {
    return _ProductType = _setField(_ProductType, 'ProductType', DbType.text);
  }

  BillFileField? _ProductCode;
  BillFileField get ProductCode {
    return _ProductCode = _setField(_ProductCode, 'ProductCode', DbType.text);
  }

  BillFileField? _ValueCode;
  BillFileField get ValueCode {
    return _ValueCode = _setField(_ValueCode, 'ValueCode', DbType.text);
  }

  BillFileField? _Value;
  BillFileField get Value {
    return _Value = _setField(_Value, 'Value', DbType.text);
  }

  BillFileField? _Quantity;
  BillFileField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  BillFileField? _CustomerId;
  BillFileField get CustomerId {
    return _CustomerId = _setField(_CustomerId, 'CustomerId', DbType.text);
  }

  BillFileField? _MaterialGroup;
  BillFileField get MaterialGroup {
    return _MaterialGroup =
        _setField(_MaterialGroup, 'MaterialGroup', DbType.text);
  }

  BillFileField? _DestinationFacilityId;
  BillFileField get DestinationFacilityId {
    return _DestinationFacilityId =
        _setField(_DestinationFacilityId, 'DestinationFacilityId', DbType.text);
  }

  BillFileField? _ElapsedTime;
  BillFileField get ElapsedTime {
    return _ElapsedTime = _setField(_ElapsedTime, 'ElapsedTime', DbType.text);
  }

  BillFileField? _AdditionalBillInfo;
  BillFileField get AdditionalBillInfo {
    return _AdditionalBillInfo =
        _setField(_AdditionalBillInfo, 'AdditionalBillInfo', DbType.text);
  }

  BillFileField? _AdditionalBillAmountInfo;
  BillFileField get AdditionalBillAmountInfo {
    return _AdditionalBillAmountInfo = _setField(
        _AdditionalBillAmountInfo, 'AdditionalBillAmountInfo', DbType.text);
  }

  BillFileField? _BillerId;
  BillFileField get BillerId {
    return _BillerId = _setField(_BillerId, 'BillerId', DbType.text);
  }

  BillFileField? _BillerName;
  BillFileField get BillerName {
    return _BillerName = _setField(_BillerName, 'BillerName', DbType.text);
  }

  BillFileField? _IS_COMMUNICATED;
  BillFileField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  BillFileField? _FILE_NAME;
  BillFileField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  /// Deletes List<BillFile> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBillFile!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBillFile!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from billFile ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBillFile!.updateBatch(qparams, values);
  }

  /// This method always returns [BillFile] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillFile?
  @override
  Future<BillFile?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBillFile!.toList(qparams);
    final data = await objFuture;
    BillFile? obj;
    if (data.isNotEmpty) {
      obj = BillFile.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BillFile]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillFile?
  @override
  Future<BillFile> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BillFile();
  }

  /// This method returns int. [BillFile]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? billfileCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final billfilesFuture = await _mnBillFile!.toList(qparams);
    final int count = billfilesFuture[0]['CNT'] as int;
    if (billfileCount != null) {
      billfileCount(count);
    }
    return count;
  }

  /// This method returns List<BillFile> [BillFile]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BillFile>
  @override
  Future<List<BillFile>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BillFile> billfilesData = await BillFile.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return billfilesData;
  }

  /// This method returns Json String [BillFile]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BillFile]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BillFile]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBillFile!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BillFile]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] = 'SELECT `id` FROM billFile WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnBillFile!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BillFile]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBillFile!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BillFile.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBillFile!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BillFileFilterBuilder

// region BillFileFields
class BillFileFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fFacilityId;
  static TableField get FacilityId {
    return _fFacilityId = _fFacilityId ??
        SqlSyntax.setField(_fFacilityId, 'FacilityId', DbType.text);
  }

  static TableField? _fZip;
  static TableField get Zip {
    return _fZip = _fZip ?? SqlSyntax.setField(_fZip, 'Zip', DbType.text);
  }

  static TableField? _fChannel;
  static TableField get Channel {
    return _fChannel =
        _fChannel ?? SqlSyntax.setField(_fChannel, 'Channel', DbType.text);
  }

  static TableField? _fUserId;
  static TableField get UserId {
    return _fUserId =
        _fUserId ?? SqlSyntax.setField(_fUserId, 'UserId', DbType.text);
  }

  static TableField? _fCounterNumber;
  static TableField get CounterNumber {
    return _fCounterNumber = _fCounterNumber ??
        SqlSyntax.setField(_fCounterNumber, 'CounterNumber', DbType.text);
  }

  static TableField? _fInvoiceNumber;
  static TableField get InvoiceNumber {
    return _fInvoiceNumber = _fInvoiceNumber ??
        SqlSyntax.setField(_fInvoiceNumber, 'InvoiceNumber', DbType.text);
  }

  static TableField? _fTotalAmount;
  static TableField get TotalAmount {
    return _fTotalAmount = _fTotalAmount ??
        SqlSyntax.setField(_fTotalAmount, 'TotalAmount', DbType.text);
  }

  static TableField? _fBookingDate;
  static TableField get BookingDate {
    return _fBookingDate = _fBookingDate ??
        SqlSyntax.setField(_fBookingDate, 'BookingDate', DbType.text);
  }

  static TableField? _fBookingTime;
  static TableField get BookingTime {
    return _fBookingTime = _fBookingTime ??
        SqlSyntax.setField(_fBookingTime, 'BookingTime', DbType.text);
  }

  static TableField? _fCurrencyId;
  static TableField get CurrencyId {
    return _fCurrencyId = _fCurrencyId ??
        SqlSyntax.setField(_fCurrencyId, 'CurrencyId', DbType.text);
  }

  static TableField? _fTenderId;
  static TableField get TenderId {
    return _fTenderId =
        _fTenderId ?? SqlSyntax.setField(_fTenderId, 'TenderId', DbType.text);
  }

  static TableField? _fTotalCashAmount;
  static TableField get TotalCashAmount {
    return _fTotalCashAmount = _fTotalCashAmount ??
        SqlSyntax.setField(_fTotalCashAmount, 'TotalCashAmount', DbType.text);
  }

  static TableField? _fRoundOffDifference;
  static TableField get RoundOffDifference {
    return _fRoundOffDifference = _fRoundOffDifference ??
        SqlSyntax.setField(
            _fRoundOffDifference, 'RoundOffDifference', DbType.text);
  }

  static TableField? _fCircleCode;
  static TableField get CircleCode {
    return _fCircleCode = _fCircleCode ??
        SqlSyntax.setField(_fCircleCode, 'CircleCode', DbType.text);
  }

  static TableField? _fLineItemNumber;
  static TableField get LineItemNumber {
    return _fLineItemNumber = _fLineItemNumber ??
        SqlSyntax.setField(_fLineItemNumber, 'LineItemNumber', DbType.text);
  }

  static TableField? _fLineItemTotalAmount;
  static TableField get LineItemTotalAmount {
    return _fLineItemTotalAmount = _fLineItemTotalAmount ??
        SqlSyntax.setField(
            _fLineItemTotalAmount, 'LineItemTotalAmount', DbType.text);
  }

  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'ArticleNumber', DbType.text);
  }

  static TableField? _fDivision;
  static TableField get Division {
    return _fDivision =
        _fDivision ?? SqlSyntax.setField(_fDivision, 'Division', DbType.text);
  }

  static TableField? _fOrderType;
  static TableField get OrderType {
    return _fOrderType = _fOrderType ??
        SqlSyntax.setField(_fOrderType, 'OrderType', DbType.text);
  }

  static TableField? _fProductType;
  static TableField get ProductType {
    return _fProductType = _fProductType ??
        SqlSyntax.setField(_fProductType, 'ProductType', DbType.text);
  }

  static TableField? _fProductCode;
  static TableField get ProductCode {
    return _fProductCode = _fProductCode ??
        SqlSyntax.setField(_fProductCode, 'ProductCode', DbType.text);
  }

  static TableField? _fValueCode;
  static TableField get ValueCode {
    return _fValueCode = _fValueCode ??
        SqlSyntax.setField(_fValueCode, 'ValueCode', DbType.text);
  }

  static TableField? _fValue;
  static TableField get Value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'Value', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fCustomerId;
  static TableField get CustomerId {
    return _fCustomerId = _fCustomerId ??
        SqlSyntax.setField(_fCustomerId, 'CustomerId', DbType.text);
  }

  static TableField? _fMaterialGroup;
  static TableField get MaterialGroup {
    return _fMaterialGroup = _fMaterialGroup ??
        SqlSyntax.setField(_fMaterialGroup, 'MaterialGroup', DbType.text);
  }

  static TableField? _fDestinationFacilityId;
  static TableField get DestinationFacilityId {
    return _fDestinationFacilityId = _fDestinationFacilityId ??
        SqlSyntax.setField(
            _fDestinationFacilityId, 'DestinationFacilityId', DbType.text);
  }

  static TableField? _fElapsedTime;
  static TableField get ElapsedTime {
    return _fElapsedTime = _fElapsedTime ??
        SqlSyntax.setField(_fElapsedTime, 'ElapsedTime', DbType.text);
  }

  static TableField? _fAdditionalBillInfo;
  static TableField get AdditionalBillInfo {
    return _fAdditionalBillInfo = _fAdditionalBillInfo ??
        SqlSyntax.setField(
            _fAdditionalBillInfo, 'AdditionalBillInfo', DbType.text);
  }

  static TableField? _fAdditionalBillAmountInfo;
  static TableField get AdditionalBillAmountInfo {
    return _fAdditionalBillAmountInfo = _fAdditionalBillAmountInfo ??
        SqlSyntax.setField(_fAdditionalBillAmountInfo,
            'AdditionalBillAmountInfo', DbType.text);
  }

  static TableField? _fBillerId;
  static TableField get BillerId {
    return _fBillerId =
        _fBillerId ?? SqlSyntax.setField(_fBillerId, 'BillerId', DbType.text);
  }

  static TableField? _fBillerName;
  static TableField get BillerName {
    return _fBillerName = _fBillerName ??
        SqlSyntax.setField(_fBillerName, 'BillerName', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }
}
// endregion BillFileFields

//region BillFileManager
class BillFileManager extends SqfEntityProvider {
  BillFileManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'billFile';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion BillFileManager
// region DayModel
class DayModel extends TableBase {
  DayModel(
      {this.DayBeginDate,
      this.DayBeginTime,
      this.CashOpeningBalance,
      this.CashClosingBalance,
      this.DayCloseDate,
      this.DayCloseTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DayModel.withFields(
      this.DayBeginDate,
      this.DayBeginTime,
      this.CashOpeningBalance,
      this.CashClosingBalance,
      this.DayCloseDate,
      this.DayCloseTime) {
    _setDefaultValues();
  }
  DayModel.withId(this.DayBeginDate, this.DayBeginTime, this.CashOpeningBalance,
      this.CashClosingBalance, this.DayCloseDate, this.DayCloseTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DayModel.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    DayBeginDate = o['DayBeginDate'].toString();
    if (o['DayBeginTime'] != null) {
      DayBeginTime = o['DayBeginTime'].toString();
    }
    if (o['CashOpeningBalance'] != null) {
      CashOpeningBalance = o['CashOpeningBalance'].toString();
    }
    if (o['CashClosingBalance'] != null) {
      CashClosingBalance = o['CashClosingBalance'].toString();
    }
    if (o['DayCloseDate'] != null) {
      DayCloseDate = o['DayCloseDate'].toString();
    }
    if (o['DayCloseTime'] != null) {
      DayCloseTime = o['DayCloseTime'].toString();
    }

    isSaved = true;
  }
  // FIELDS (DayModel)
  String? DayBeginDate;
  String? DayBeginTime;
  String? CashOpeningBalance;
  String? CashClosingBalance;
  String? DayCloseDate;
  String? DayCloseTime;
  bool? isSaved;
  // end FIELDS (DayModel)

  static const bool _softDeleteActivated = false;
  DayModelManager? __mnDayModel;

  DayModelManager get _mnDayModel {
    return __mnDayModel = __mnDayModel ?? DayModelManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['DayBeginDate'] = DayBeginDate;
    if (DayBeginTime != null || !forView) {
      map['DayBeginTime'] = DayBeginTime;
    }
    if (CashOpeningBalance != null || !forView) {
      map['CashOpeningBalance'] = CashOpeningBalance;
    }
    if (CashClosingBalance != null || !forView) {
      map['CashClosingBalance'] = CashClosingBalance;
    }
    if (DayCloseDate != null || !forView) {
      map['DayCloseDate'] = DayCloseDate;
    }
    if (DayCloseTime != null || !forView) {
      map['DayCloseTime'] = DayCloseTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['DayBeginDate'] = DayBeginDate;
    if (DayBeginTime != null || !forView) {
      map['DayBeginTime'] = DayBeginTime;
    }
    if (CashOpeningBalance != null || !forView) {
      map['CashOpeningBalance'] = CashOpeningBalance;
    }
    if (CashClosingBalance != null || !forView) {
      map['CashClosingBalance'] = CashClosingBalance;
    }
    if (DayCloseDate != null || !forView) {
      map['DayCloseDate'] = DayCloseDate;
    }
    if (DayCloseTime != null || !forView) {
      map['DayCloseTime'] = DayCloseTime;
    }

    return map;
  }

  /// This method returns Json String [DayModel]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DayModel]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      DayBeginDate,
      DayBeginTime,
      CashOpeningBalance,
      CashClosingBalance,
      DayCloseDate,
      DayCloseTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      DayBeginDate,
      DayBeginTime,
      CashOpeningBalance,
      CashClosingBalance,
      DayCloseDate,
      DayCloseTime
    ];
  }

  static Future<List<DayModel>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DayModel.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DayModel>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DayModel>[];
    try {
      objList = list
          .map((daymodel) => DayModel.fromMap(daymodel as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DayModel.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DayModel>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DayModel> objList = <DayModel>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DayModel.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DayModel by ID if exist, otherwise returns null
  /// Primary Keys: String? DayBeginDate
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DayModel] if exist, otherwise returns null
  Future<DayModel?> getById(String? DayBeginDate,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (DayBeginDate == null) {
      return null;
    }
    DayModel? obj;
    final data = await _mnDayModel.getById([DayBeginDate]);
    if (data.length != 0) {
      obj = DayModel.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DayModel) object. If the Primary Key (DayBeginDate) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same DayBeginDate
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnDayModel.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO DayModel (DayBeginDate, DayBeginTime, CashOpeningBalance, CashClosingBalance, DayCloseDate, DayCloseTime)  VALUES (?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<DayModel> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DayModel> daymodels,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in daymodels) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDayModel.rawInsert(
          'INSERT OR REPLACE INTO DayModel (DayBeginDate, DayBeginTime, CashOpeningBalance, CashClosingBalance, DayCloseDate, DayCloseTime)  VALUES (?,?,?,?,?,?)',
          [
            DayBeginDate,
            DayBeginTime,
            CashOpeningBalance,
            CashClosingBalance,
            DayCloseDate,
            DayCloseTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DayModel DayBeginDate=$DayBeginDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DayModel DayBeginDate=$DayBeginDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DayModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDayModel.rawInsert(
          'INSERT OR IGNORE INTO DayModel (DayBeginDate, DayBeginTime, CashOpeningBalance, CashClosingBalance, DayCloseDate, DayCloseTime)  VALUES (?,?,?,?,?,?)',
          [
            DayBeginDate,
            DayBeginTime,
            CashOpeningBalance,
            CashClosingBalance,
            DayCloseDate,
            DayCloseTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DayModel DayBeginDate=$DayBeginDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'DayModel DayBeginDate=$DayBeginDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DayModel Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes DayModel

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete DayModel invoked (DayBeginDate=$DayBeginDate)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDayModel.delete(QueryParams(
          whereString: 'DayBeginDate=?', whereArguments: [DayBeginDate]));
    } else {
      return _mnDayModel.updateBatch(
          QueryParams(
              whereString: 'DayBeginDate=?', whereArguments: [DayBeginDate]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DayModel] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DayModelFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DayModelFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DayModelFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DayModelFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      DayBeginDate = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion daymodel

// region DayModelField
class DayModelField extends FilterBase {
  DayModelField(DayModelFilterBuilder daymodelFB) : super(daymodelFB);

  @override
  DayModelFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder isNull() {
    return super.isNull() as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DayModelFilterBuilder;
  }

  @override
  DayModelField get not {
    return super.not as DayModelField;
  }
}
// endregion DayModelField

// region DayModelFilterBuilder
class DayModelFilterBuilder extends ConjunctionBase {
  DayModelFilterBuilder(DayModel obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDayModel = obj._mnDayModel;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DayModelManager? _mnDayModel;

  /// put the sql keyword 'AND'
  @override
  DayModelFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DayModelFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DayModelFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DayModelFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DayModelFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DayModelFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DayModelFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DayModelFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DayModelFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DayModelFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DayModelFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DayModelField _setField(DayModelField? field, String colName, DbType dbtype) {
    return DayModelField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DayModelField? _DayBeginDate;
  DayModelField get DayBeginDate {
    return _DayBeginDate =
        _setField(_DayBeginDate, 'DayBeginDate', DbType.integer);
  }

  DayModelField? _DayBeginTime;
  DayModelField get DayBeginTime {
    return _DayBeginTime =
        _setField(_DayBeginTime, 'DayBeginTime', DbType.text);
  }

  DayModelField? _CashOpeningBalance;
  DayModelField get CashOpeningBalance {
    return _CashOpeningBalance =
        _setField(_CashOpeningBalance, 'CashOpeningBalance', DbType.text);
  }

  DayModelField? _CashClosingBalance;
  DayModelField get CashClosingBalance {
    return _CashClosingBalance =
        _setField(_CashClosingBalance, 'CashClosingBalance', DbType.text);
  }

  DayModelField? _DayCloseDate;
  DayModelField get DayCloseDate {
    return _DayCloseDate =
        _setField(_DayCloseDate, 'DayCloseDate', DbType.text);
  }

  DayModelField? _DayCloseTime;
  DayModelField get DayCloseTime {
    return _DayCloseTime =
        _setField(_DayCloseTime, 'DayCloseTime', DbType.text);
  }

  /// Deletes List<DayModel> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDayModel!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDayModel!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'DayBeginDate IN (SELECT DayBeginDate from DayModel ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDayModel!.updateBatch(qparams, values);
  }

  /// This method always returns [DayModel] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DayModel?
  @override
  Future<DayModel?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDayModel!.toList(qparams);
    final data = await objFuture;
    DayModel? obj;
    if (data.isNotEmpty) {
      obj = DayModel.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DayModel]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DayModel?
  @override
  Future<DayModel> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DayModel();
  }

  /// This method returns int. [DayModel]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? daymodelCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final daymodelsFuture = await _mnDayModel!.toList(qparams);
    final int count = daymodelsFuture[0]['CNT'] as int;
    if (daymodelCount != null) {
      daymodelCount(count);
    }
    return count;
  }

  /// This method returns List<DayModel> [DayModel]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DayModel>
  @override
  Future<List<DayModel>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DayModel> daymodelsData = await DayModel.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return daymodelsData;
  }

  /// This method returns Json String [DayModel]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DayModel]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DayModel]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDayModel!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DayModel]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `DayBeginDate` FROM DayModel WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> DayBeginDateData = <String>[];
    qparams.selectColumns = ['DayBeginDate'];
    final DayBeginDateFuture = await _mnDayModel!.toList(qparams);

    final int count = DayBeginDateFuture.length;
    for (int i = 0; i < count; i++) {
      DayBeginDateData.add(DayBeginDateFuture[i]['DayBeginDate'] as String);
    }
    return DayBeginDateData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DayModel]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDayModel!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DayModel.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDayModel!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DayModelFilterBuilder

// region DayModelFields
class DayModelFields {
  static TableField? _fDayBeginDate;
  static TableField get DayBeginDate {
    return _fDayBeginDate = _fDayBeginDate ??
        SqlSyntax.setField(_fDayBeginDate, 'daybegindate', DbType.integer);
  }

  static TableField? _fDayBeginTime;
  static TableField get DayBeginTime {
    return _fDayBeginTime = _fDayBeginTime ??
        SqlSyntax.setField(_fDayBeginTime, 'DayBeginTime', DbType.text);
  }

  static TableField? _fCashOpeningBalance;
  static TableField get CashOpeningBalance {
    return _fCashOpeningBalance = _fCashOpeningBalance ??
        SqlSyntax.setField(
            _fCashOpeningBalance, 'CashOpeningBalance', DbType.text);
  }

  static TableField? _fCashClosingBalance;
  static TableField get CashClosingBalance {
    return _fCashClosingBalance = _fCashClosingBalance ??
        SqlSyntax.setField(
            _fCashClosingBalance, 'CashClosingBalance', DbType.text);
  }

  static TableField? _fDayCloseDate;
  static TableField get DayCloseDate {
    return _fDayCloseDate = _fDayCloseDate ??
        SqlSyntax.setField(_fDayCloseDate, 'DayCloseDate', DbType.text);
  }

  static TableField? _fDayCloseTime;
  static TableField get DayCloseTime {
    return _fDayCloseTime = _fDayCloseTime ??
        SqlSyntax.setField(_fDayCloseTime, 'DayCloseTime', DbType.text);
  }
}
// endregion DayModelFields

//region DayModelManager
class DayModelManager extends SqfEntityProvider {
  DayModelManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'DayModel';
  static const List<String> _primaryKeyList = ['DayBeginDate'];
  static const String _whereStr = 'DayBeginDate=?';
}

//endregion DayModelManager
// region BodaBrief
class BodaBrief extends TableBase {
  BodaBrief(
      {this.BodaGeneratedDate,
      this.BodaGeneratedTime,
      this.OpeningBalance,
      this.ClosingBalance,
      this.BodaNumber,
      this.MailsAmount,
      this.TotalReceiptsAmount,
      this.CashToAOAmount,
      this.InsuranceAmount,
      this.BankingAmount,
      this.InventoryAmount,
      this.LiabilitiesAmount,
      this.CashIndentAmount}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BodaBrief.withFields(
      this.BodaGeneratedDate,
      this.BodaGeneratedTime,
      this.OpeningBalance,
      this.ClosingBalance,
      this.BodaNumber,
      this.MailsAmount,
      this.TotalReceiptsAmount,
      this.CashToAOAmount,
      this.InsuranceAmount,
      this.BankingAmount,
      this.InventoryAmount,
      this.LiabilitiesAmount,
      this.CashIndentAmount) {
    _setDefaultValues();
  }
  BodaBrief.withId(
      this.BodaGeneratedDate,
      this.BodaGeneratedTime,
      this.OpeningBalance,
      this.ClosingBalance,
      this.BodaNumber,
      this.MailsAmount,
      this.TotalReceiptsAmount,
      this.CashToAOAmount,
      this.InsuranceAmount,
      this.BankingAmount,
      this.InventoryAmount,
      this.LiabilitiesAmount,
      this.CashIndentAmount) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BodaBrief.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BodaGeneratedDate = o['BodaGeneratedDate'].toString();
    if (o['BodaGeneratedTime'] != null) {
      BodaGeneratedTime = o['BodaGeneratedTime'].toString();
    }
    if (o['OpeningBalance'] != null) {
      OpeningBalance = o['OpeningBalance'].toString();
    }
    if (o['ClosingBalance'] != null) {
      ClosingBalance = o['ClosingBalance'].toString();
    }
    if (o['BodaNumber'] != null) {
      BodaNumber = o['BodaNumber'].toString();
    }
    if (o['MailsAmount'] != null) {
      MailsAmount = o['MailsAmount'].toString();
    }
    if (o['TotalReceiptsAmount'] != null) {
      TotalReceiptsAmount = o['TotalReceiptsAmount'].toString();
    }
    if (o['CashToAOAmount'] != null) {
      CashToAOAmount = o['CashToAOAmount'].toString();
    }
    if (o['InsuranceAmount'] != null) {
      InsuranceAmount = o['InsuranceAmount'].toString();
    }
    if (o['BankingAmount'] != null) {
      BankingAmount = o['BankingAmount'].toString();
    }
    if (o['InventoryAmount'] != null) {
      InventoryAmount = o['InventoryAmount'].toString();
    }
    if (o['LiabilitiesAmount'] != null) {
      LiabilitiesAmount = o['LiabilitiesAmount'].toString();
    }
    if (o['CashIndentAmount'] != null) {
      CashIndentAmount = o['CashIndentAmount'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BodaBrief)
  String? BodaGeneratedDate;
  String? BodaGeneratedTime;
  String? OpeningBalance;
  String? ClosingBalance;
  String? BodaNumber;
  String? MailsAmount;
  String? TotalReceiptsAmount;
  String? CashToAOAmount;
  String? InsuranceAmount;
  String? BankingAmount;
  String? InventoryAmount;
  String? LiabilitiesAmount;
  String? CashIndentAmount;
  bool? isSaved;
  // end FIELDS (BodaBrief)

  static const bool _softDeleteActivated = false;
  BodaBriefManager? __mnBodaBrief;

  BodaBriefManager get _mnBodaBrief {
    return __mnBodaBrief = __mnBodaBrief ?? BodaBriefManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BodaGeneratedDate'] = BodaGeneratedDate;
    if (BodaGeneratedTime != null || !forView) {
      map['BodaGeneratedTime'] = BodaGeneratedTime;
    }
    if (OpeningBalance != null || !forView) {
      map['OpeningBalance'] = OpeningBalance;
    }
    if (ClosingBalance != null || !forView) {
      map['ClosingBalance'] = ClosingBalance;
    }
    if (BodaNumber != null || !forView) {
      map['BodaNumber'] = BodaNumber;
    }
    if (MailsAmount != null || !forView) {
      map['MailsAmount'] = MailsAmount;
    }
    if (TotalReceiptsAmount != null || !forView) {
      map['TotalReceiptsAmount'] = TotalReceiptsAmount;
    }
    if (CashToAOAmount != null || !forView) {
      map['CashToAOAmount'] = CashToAOAmount;
    }
    if (InsuranceAmount != null || !forView) {
      map['InsuranceAmount'] = InsuranceAmount;
    }
    if (BankingAmount != null || !forView) {
      map['BankingAmount'] = BankingAmount;
    }
    if (InventoryAmount != null || !forView) {
      map['InventoryAmount'] = InventoryAmount;
    }
    if (LiabilitiesAmount != null || !forView) {
      map['LiabilitiesAmount'] = LiabilitiesAmount;
    }
    if (CashIndentAmount != null || !forView) {
      map['CashIndentAmount'] = CashIndentAmount;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BodaGeneratedDate'] = BodaGeneratedDate;
    if (BodaGeneratedTime != null || !forView) {
      map['BodaGeneratedTime'] = BodaGeneratedTime;
    }
    if (OpeningBalance != null || !forView) {
      map['OpeningBalance'] = OpeningBalance;
    }
    if (ClosingBalance != null || !forView) {
      map['ClosingBalance'] = ClosingBalance;
    }
    if (BodaNumber != null || !forView) {
      map['BodaNumber'] = BodaNumber;
    }
    if (MailsAmount != null || !forView) {
      map['MailsAmount'] = MailsAmount;
    }
    if (TotalReceiptsAmount != null || !forView) {
      map['TotalReceiptsAmount'] = TotalReceiptsAmount;
    }
    if (CashToAOAmount != null || !forView) {
      map['CashToAOAmount'] = CashToAOAmount;
    }
    if (InsuranceAmount != null || !forView) {
      map['InsuranceAmount'] = InsuranceAmount;
    }
    if (BankingAmount != null || !forView) {
      map['BankingAmount'] = BankingAmount;
    }
    if (InventoryAmount != null || !forView) {
      map['InventoryAmount'] = InventoryAmount;
    }
    if (LiabilitiesAmount != null || !forView) {
      map['LiabilitiesAmount'] = LiabilitiesAmount;
    }
    if (CashIndentAmount != null || !forView) {
      map['CashIndentAmount'] = CashIndentAmount;
    }

    return map;
  }

  /// This method returns Json String [BodaBrief]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BodaBrief]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BodaGeneratedDate,
      BodaGeneratedTime,
      OpeningBalance,
      ClosingBalance,
      BodaNumber,
      MailsAmount,
      TotalReceiptsAmount,
      CashToAOAmount,
      InsuranceAmount,
      BankingAmount,
      InventoryAmount,
      LiabilitiesAmount,
      CashIndentAmount
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BodaGeneratedDate,
      BodaGeneratedTime,
      OpeningBalance,
      ClosingBalance,
      BodaNumber,
      MailsAmount,
      TotalReceiptsAmount,
      CashToAOAmount,
      InsuranceAmount,
      BankingAmount,
      InventoryAmount,
      LiabilitiesAmount,
      CashIndentAmount
    ];
  }

  static Future<List<BodaBrief>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaBrief.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BodaBrief>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BodaBrief>[];
    try {
      objList = list
          .map((bodabrief) =>
              BodaBrief.fromMap(bodabrief as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaBrief.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BodaBrief>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BodaBrief> objList = <BodaBrief>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BodaBrief.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BodaBrief by ID if exist, otherwise returns null
  /// Primary Keys: String? BodaGeneratedDate
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BodaBrief] if exist, otherwise returns null
  Future<BodaBrief?> getById(String? BodaGeneratedDate,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BodaGeneratedDate == null) {
      return null;
    }
    BodaBrief? obj;
    final data = await _mnBodaBrief.getById([BodaGeneratedDate]);
    if (data.length != 0) {
      obj = BodaBrief.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BodaBrief) object. If the Primary Key (BodaGeneratedDate) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BodaGeneratedDate
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBodaBrief.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bodaBrief (BodaGeneratedDate, BodaGeneratedTime, OpeningBalance, ClosingBalance, BodaNumber, MailsAmount, TotalReceiptsAmount, CashToAOAmount, InsuranceAmount, BankingAmount, InventoryAmount, LiabilitiesAmount, CashIndentAmount)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BodaBrief> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BodaBrief> bodabriefs,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in bodabriefs) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaBrief.rawInsert(
          'INSERT OR REPLACE INTO bodaBrief (BodaGeneratedDate, BodaGeneratedTime, OpeningBalance, ClosingBalance, BodaNumber, MailsAmount, TotalReceiptsAmount, CashToAOAmount, InsuranceAmount, BankingAmount, InventoryAmount, LiabilitiesAmount, CashIndentAmount)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            BodaGeneratedDate,
            BodaGeneratedTime,
            OpeningBalance,
            ClosingBalance,
            BodaNumber,
            MailsAmount,
            TotalReceiptsAmount,
            CashToAOAmount,
            InsuranceAmount,
            BankingAmount,
            InventoryAmount,
            LiabilitiesAmount,
            CashIndentAmount
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaBrief BodaGeneratedDate=$BodaGeneratedDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaBrief BodaGeneratedDate=$BodaGeneratedDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaBrief Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaBrief.rawInsert(
          'INSERT OR IGNORE INTO bodaBrief (BodaGeneratedDate, BodaGeneratedTime, OpeningBalance, ClosingBalance, BodaNumber, MailsAmount, TotalReceiptsAmount, CashToAOAmount, InsuranceAmount, BankingAmount, InventoryAmount, LiabilitiesAmount, CashIndentAmount)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            BodaGeneratedDate,
            BodaGeneratedTime,
            OpeningBalance,
            ClosingBalance,
            BodaNumber,
            MailsAmount,
            TotalReceiptsAmount,
            CashToAOAmount,
            InsuranceAmount,
            BankingAmount,
            InventoryAmount,
            LiabilitiesAmount,
            CashIndentAmount
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaBrief BodaGeneratedDate=$BodaGeneratedDate updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaBrief BodaGeneratedDate=$BodaGeneratedDate did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaBrief Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BodaBrief

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BodaBrief invoked (BodaGeneratedDate=$BodaGeneratedDate)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBodaBrief.delete(QueryParams(
          whereString: 'BodaGeneratedDate=?',
          whereArguments: [BodaGeneratedDate]));
    } else {
      return _mnBodaBrief.updateBatch(
          QueryParams(
              whereString: 'BodaGeneratedDate=?',
              whereArguments: [BodaGeneratedDate]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BodaBrief] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BodaBriefFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaBriefFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BodaBriefFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaBriefFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BodaGeneratedDate = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bodabrief

// region BodaBriefField
class BodaBriefField extends FilterBase {
  BodaBriefField(BodaBriefFilterBuilder bodabriefFB) : super(bodabriefFB);

  @override
  BodaBriefFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder isNull() {
    return super.isNull() as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BodaBriefFilterBuilder;
  }

  @override
  BodaBriefField get not {
    return super.not as BodaBriefField;
  }
}
// endregion BodaBriefField

// region BodaBriefFilterBuilder
class BodaBriefFilterBuilder extends ConjunctionBase {
  BodaBriefFilterBuilder(BodaBrief obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBodaBrief = obj._mnBodaBrief;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BodaBriefManager? _mnBodaBrief;

  /// put the sql keyword 'AND'
  @override
  BodaBriefFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BodaBriefFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BodaBriefFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BodaBriefFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BodaBriefFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BodaBriefFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BodaBriefFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaBriefFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaBriefFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaBriefFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaBriefFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BodaBriefField _setField(
      BodaBriefField? field, String colName, DbType dbtype) {
    return BodaBriefField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BodaBriefField? _BodaGeneratedDate;
  BodaBriefField get BodaGeneratedDate {
    return _BodaGeneratedDate =
        _setField(_BodaGeneratedDate, 'BodaGeneratedDate', DbType.integer);
  }

  BodaBriefField? _BodaGeneratedTime;
  BodaBriefField get BodaGeneratedTime {
    return _BodaGeneratedTime =
        _setField(_BodaGeneratedTime, 'BodaGeneratedTime', DbType.text);
  }

  BodaBriefField? _OpeningBalance;
  BodaBriefField get OpeningBalance {
    return _OpeningBalance =
        _setField(_OpeningBalance, 'OpeningBalance', DbType.text);
  }

  BodaBriefField? _ClosingBalance;
  BodaBriefField get ClosingBalance {
    return _ClosingBalance =
        _setField(_ClosingBalance, 'ClosingBalance', DbType.text);
  }

  BodaBriefField? _BodaNumber;
  BodaBriefField get BodaNumber {
    return _BodaNumber = _setField(_BodaNumber, 'BodaNumber', DbType.text);
  }

  BodaBriefField? _MailsAmount;
  BodaBriefField get MailsAmount {
    return _MailsAmount = _setField(_MailsAmount, 'MailsAmount', DbType.text);
  }

  BodaBriefField? _TotalReceiptsAmount;
  BodaBriefField get TotalReceiptsAmount {
    return _TotalReceiptsAmount =
        _setField(_TotalReceiptsAmount, 'TotalReceiptsAmount', DbType.text);
  }

  BodaBriefField? _CashToAOAmount;
  BodaBriefField get CashToAOAmount {
    return _CashToAOAmount =
        _setField(_CashToAOAmount, 'CashToAOAmount', DbType.text);
  }

  BodaBriefField? _InsuranceAmount;
  BodaBriefField get InsuranceAmount {
    return _InsuranceAmount =
        _setField(_InsuranceAmount, 'InsuranceAmount', DbType.text);
  }

  BodaBriefField? _BankingAmount;
  BodaBriefField get BankingAmount {
    return _BankingAmount =
        _setField(_BankingAmount, 'BankingAmount', DbType.text);
  }

  BodaBriefField? _InventoryAmount;
  BodaBriefField get InventoryAmount {
    return _InventoryAmount =
        _setField(_InventoryAmount, 'InventoryAmount', DbType.text);
  }

  BodaBriefField? _LiabilitiesAmount;
  BodaBriefField get LiabilitiesAmount {
    return _LiabilitiesAmount =
        _setField(_LiabilitiesAmount, 'LiabilitiesAmount', DbType.text);
  }

  BodaBriefField? _CashIndentAmount;
  BodaBriefField get CashIndentAmount {
    return _CashIndentAmount =
        _setField(_CashIndentAmount, 'CashIndentAmount', DbType.text);
  }

  /// Deletes List<BodaBrief> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBodaBrief!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBodaBrief!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BodaGeneratedDate IN (SELECT BodaGeneratedDate from bodaBrief ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBodaBrief!.updateBatch(qparams, values);
  }

  /// This method always returns [BodaBrief] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaBrief?
  @override
  Future<BodaBrief?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBodaBrief!.toList(qparams);
    final data = await objFuture;
    BodaBrief? obj;
    if (data.isNotEmpty) {
      obj = BodaBrief.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BodaBrief]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaBrief?
  @override
  Future<BodaBrief> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BodaBrief();
  }

  /// This method returns int. [BodaBrief]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bodabriefCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bodabriefsFuture = await _mnBodaBrief!.toList(qparams);
    final int count = bodabriefsFuture[0]['CNT'] as int;
    if (bodabriefCount != null) {
      bodabriefCount(count);
    }
    return count;
  }

  /// This method returns List<BodaBrief> [BodaBrief]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BodaBrief>
  @override
  Future<List<BodaBrief>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BodaBrief> bodabriefsData = await BodaBrief.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return bodabriefsData;
  }

  /// This method returns Json String [BodaBrief]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BodaBrief]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BodaBrief]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBodaBrief!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BodaBrief]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BodaGeneratedDate` FROM bodaBrief WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BodaGeneratedDateData = <String>[];
    qparams.selectColumns = ['BodaGeneratedDate'];
    final BodaGeneratedDateFuture = await _mnBodaBrief!.toList(qparams);

    final int count = BodaGeneratedDateFuture.length;
    for (int i = 0; i < count; i++) {
      BodaGeneratedDateData.add(
          BodaGeneratedDateFuture[i]['BodaGeneratedDate'] as String);
    }
    return BodaGeneratedDateData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BodaBrief]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBodaBrief!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BodaBrief.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBodaBrief!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BodaBriefFilterBuilder

// region BodaBriefFields
class BodaBriefFields {
  static TableField? _fBodaGeneratedDate;
  static TableField get BodaGeneratedDate {
    return _fBodaGeneratedDate = _fBodaGeneratedDate ??
        SqlSyntax.setField(
            _fBodaGeneratedDate, 'bodagenerateddate', DbType.integer);
  }

  static TableField? _fBodaGeneratedTime;
  static TableField get BodaGeneratedTime {
    return _fBodaGeneratedTime = _fBodaGeneratedTime ??
        SqlSyntax.setField(
            _fBodaGeneratedTime, 'BodaGeneratedTime', DbType.text);
  }

  static TableField? _fOpeningBalance;
  static TableField get OpeningBalance {
    return _fOpeningBalance = _fOpeningBalance ??
        SqlSyntax.setField(_fOpeningBalance, 'OpeningBalance', DbType.text);
  }

  static TableField? _fClosingBalance;
  static TableField get ClosingBalance {
    return _fClosingBalance = _fClosingBalance ??
        SqlSyntax.setField(_fClosingBalance, 'ClosingBalance', DbType.text);
  }

  static TableField? _fBodaNumber;
  static TableField get BodaNumber {
    return _fBodaNumber = _fBodaNumber ??
        SqlSyntax.setField(_fBodaNumber, 'BodaNumber', DbType.text);
  }

  static TableField? _fMailsAmount;
  static TableField get MailsAmount {
    return _fMailsAmount = _fMailsAmount ??
        SqlSyntax.setField(_fMailsAmount, 'MailsAmount', DbType.text);
  }

  static TableField? _fTotalReceiptsAmount;
  static TableField get TotalReceiptsAmount {
    return _fTotalReceiptsAmount = _fTotalReceiptsAmount ??
        SqlSyntax.setField(
            _fTotalReceiptsAmount, 'TotalReceiptsAmount', DbType.text);
  }

  static TableField? _fCashToAOAmount;
  static TableField get CashToAOAmount {
    return _fCashToAOAmount = _fCashToAOAmount ??
        SqlSyntax.setField(_fCashToAOAmount, 'CashToAOAmount', DbType.text);
  }

  static TableField? _fInsuranceAmount;
  static TableField get InsuranceAmount {
    return _fInsuranceAmount = _fInsuranceAmount ??
        SqlSyntax.setField(_fInsuranceAmount, 'InsuranceAmount', DbType.text);
  }

  static TableField? _fBankingAmount;
  static TableField get BankingAmount {
    return _fBankingAmount = _fBankingAmount ??
        SqlSyntax.setField(_fBankingAmount, 'BankingAmount', DbType.text);
  }

  static TableField? _fInventoryAmount;
  static TableField get InventoryAmount {
    return _fInventoryAmount = _fInventoryAmount ??
        SqlSyntax.setField(_fInventoryAmount, 'InventoryAmount', DbType.text);
  }

  static TableField? _fLiabilitiesAmount;
  static TableField get LiabilitiesAmount {
    return _fLiabilitiesAmount = _fLiabilitiesAmount ??
        SqlSyntax.setField(
            _fLiabilitiesAmount, 'LiabilitiesAmount', DbType.text);
  }

  static TableField? _fCashIndentAmount;
  static TableField get CashIndentAmount {
    return _fCashIndentAmount = _fCashIndentAmount ??
        SqlSyntax.setField(_fCashIndentAmount, 'CashIndentAmount', DbType.text);
  }
}
// endregion BodaBriefFields

//region BodaBriefManager
class BodaBriefManager extends SqfEntityProvider {
  BodaBriefManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bodaBrief';
  static const List<String> _primaryKeyList = ['BodaGeneratedDate'];
  static const String _whereStr = 'BodaGeneratedDate=?';
}

//endregion BodaBriefManager
// region BodaArticle
class BodaArticle extends TableBase {
  BodaArticle(
      {this.ArticleNumber,
      this.ArticleType,
      this.ArticleAmount,
      this.BodaDate,
      this.BodaTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BodaArticle.withFields(this.ArticleNumber, this.ArticleType,
      this.ArticleAmount, this.BodaDate, this.BodaTime) {
    _setDefaultValues();
  }
  BodaArticle.withId(this.ArticleNumber, this.ArticleType, this.ArticleAmount,
      this.BodaDate, this.BodaTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BodaArticle.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['ArticleType'] != null) {
      ArticleType = o['ArticleType'].toString();
    }
    if (o['ArticleAmount'] != null) {
      ArticleAmount = o['ArticleAmount'].toString();
    }
    if (o['BodaDate'] != null) {
      BodaDate = o['BodaDate'].toString();
    }
    if (o['BodaTime'] != null) {
      BodaTime = o['BodaTime'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BodaArticle)
  String? ArticleNumber;
  String? ArticleType;
  String? ArticleAmount;
  String? BodaDate;
  String? BodaTime;
  bool? isSaved;
  // end FIELDS (BodaArticle)

  static const bool _softDeleteActivated = false;
  BodaArticleManager? __mnBodaArticle;

  BodaArticleManager get _mnBodaArticle {
    return __mnBodaArticle = __mnBodaArticle ?? BodaArticleManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (ArticleAmount != null || !forView) {
      map['ArticleAmount'] = ArticleAmount;
    }
    if (BodaDate != null || !forView) {
      map['BodaDate'] = BodaDate;
    }
    if (BodaTime != null || !forView) {
      map['BodaTime'] = BodaTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (ArticleAmount != null || !forView) {
      map['ArticleAmount'] = ArticleAmount;
    }
    if (BodaDate != null || !forView) {
      map['BodaDate'] = BodaDate;
    }
    if (BodaTime != null || !forView) {
      map['BodaTime'] = BodaTime;
    }

    return map;
  }

  /// This method returns Json String [BodaArticle]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BodaArticle]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime];
  }

  static Future<List<BodaArticle>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaArticle.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BodaArticle>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BodaArticle>[];
    try {
      objList = list
          .map((bodaarticle) =>
              BodaArticle.fromMap(bodaarticle as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaArticle.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BodaArticle>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BodaArticle> objList = <BodaArticle>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BodaArticle.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BodaArticle by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BodaArticle] if exist, otherwise returns null
  Future<BodaArticle?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    BodaArticle? obj;
    final data = await _mnBodaArticle.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = BodaArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BodaArticle) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBodaArticle.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bodaArticles (ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BodaArticle> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BodaArticle> bodaarticles,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in bodaarticles) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaArticle.rawInsert(
          'INSERT OR REPLACE INTO bodaArticles (ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime)  VALUES (?,?,?,?,?)',
          [ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaArticle ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaArticle ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaArticle.rawInsert(
          'INSERT OR IGNORE INTO bodaArticles (ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime)  VALUES (?,?,?,?,?)',
          [ArticleNumber, ArticleType, ArticleAmount, BodaDate, BodaTime],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaArticle ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaArticle ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaArticle Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BodaArticle

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BodaArticle invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBodaArticle.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnBodaArticle.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BodaArticle] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BodaArticleFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BodaArticleFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaArticleFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bodaarticle

// region BodaArticleField
class BodaArticleField extends FilterBase {
  BodaArticleField(BodaArticleFilterBuilder bodaarticleFB)
      : super(bodaarticleFB);

  @override
  BodaArticleFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder isNull() {
    return super.isNull() as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BodaArticleFilterBuilder;
  }

  @override
  BodaArticleField get not {
    return super.not as BodaArticleField;
  }
}
// endregion BodaArticleField

// region BodaArticleFilterBuilder
class BodaArticleFilterBuilder extends ConjunctionBase {
  BodaArticleFilterBuilder(BodaArticle obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBodaArticle = obj._mnBodaArticle;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BodaArticleManager? _mnBodaArticle;

  /// put the sql keyword 'AND'
  @override
  BodaArticleFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BodaArticleFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BodaArticleFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BodaArticleFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BodaArticleFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BodaArticleFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BodaArticleFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaArticleFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaArticleFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaArticleFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaArticleFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BodaArticleField _setField(
      BodaArticleField? field, String colName, DbType dbtype) {
    return BodaArticleField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BodaArticleField? _ArticleNumber;
  BodaArticleField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  BodaArticleField? _ArticleType;
  BodaArticleField get ArticleType {
    return _ArticleType = _setField(_ArticleType, 'ArticleType', DbType.text);
  }

  BodaArticleField? _ArticleAmount;
  BodaArticleField get ArticleAmount {
    return _ArticleAmount =
        _setField(_ArticleAmount, 'ArticleAmount', DbType.text);
  }

  BodaArticleField? _BodaDate;
  BodaArticleField get BodaDate {
    return _BodaDate = _setField(_BodaDate, 'BodaDate', DbType.text);
  }

  BodaArticleField? _BodaTime;
  BodaArticleField get BodaTime {
    return _BodaTime = _setField(_BodaTime, 'BodaTime', DbType.text);
  }

  /// Deletes List<BodaArticle> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBodaArticle!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBodaArticle!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from bodaArticles ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBodaArticle!.updateBatch(qparams, values);
  }

  /// This method always returns [BodaArticle] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaArticle?
  @override
  Future<BodaArticle?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBodaArticle!.toList(qparams);
    final data = await objFuture;
    BodaArticle? obj;
    if (data.isNotEmpty) {
      obj = BodaArticle.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BodaArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaArticle?
  @override
  Future<BodaArticle> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BodaArticle();
  }

  /// This method returns int. [BodaArticle]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bodaarticleCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bodaarticlesFuture = await _mnBodaArticle!.toList(qparams);
    final int count = bodaarticlesFuture[0]['CNT'] as int;
    if (bodaarticleCount != null) {
      bodaarticleCount(count);
    }
    return count;
  }

  /// This method returns List<BodaArticle> [BodaArticle]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BodaArticle>
  @override
  Future<List<BodaArticle>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BodaArticle> bodaarticlesData = await BodaArticle.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return bodaarticlesData;
  }

  /// This method returns Json String [BodaArticle]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BodaArticle]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BodaArticle]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBodaArticle!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BodaArticle]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM bodaArticles WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnBodaArticle!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BodaArticle]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBodaArticle!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BodaArticle.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBodaArticle!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BodaArticleFilterBuilder

// region BodaArticleFields
class BodaArticleFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fArticleType;
  static TableField get ArticleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'ArticleType', DbType.text);
  }

  static TableField? _fArticleAmount;
  static TableField get ArticleAmount {
    return _fArticleAmount = _fArticleAmount ??
        SqlSyntax.setField(_fArticleAmount, 'ArticleAmount', DbType.text);
  }

  static TableField? _fBodaDate;
  static TableField get BodaDate {
    return _fBodaDate =
        _fBodaDate ?? SqlSyntax.setField(_fBodaDate, 'BodaDate', DbType.text);
  }

  static TableField? _fBodaTime;
  static TableField get BodaTime {
    return _fBodaTime =
        _fBodaTime ?? SqlSyntax.setField(_fBodaTime, 'BodaTime', DbType.text);
  }
}
// endregion BodaArticleFields

//region BodaArticleManager
class BodaArticleManager extends SqfEntityProvider {
  BodaArticleManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bodaArticles';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion BodaArticleManager
// region BodaInventory
class BodaInventory extends TableBase {
  BodaInventory(
      {this.inventoryid,
      this.InventoryName,
      this.InventoryQuantity,
      this.InventoryPrice,
      this.InventoryDate}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BodaInventory.withFields(this.inventoryid, this.InventoryName,
      this.InventoryQuantity, this.InventoryPrice, this.InventoryDate) {
    _setDefaultValues();
  }
  BodaInventory.withId(this.inventoryid, this.InventoryName,
      this.InventoryQuantity, this.InventoryPrice, this.InventoryDate) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BodaInventory.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    inventoryid = o['inventoryid'].toString();
    if (o['InventoryName'] != null) {
      InventoryName = o['InventoryName'].toString();
    }
    if (o['InventoryQuantity'] != null) {
      InventoryQuantity = o['InventoryQuantity'].toString();
    }
    if (o['InventoryPrice'] != null) {
      InventoryPrice = o['InventoryPrice'].toString();
    }
    if (o['InventoryDate'] != null) {
      InventoryDate = o['InventoryDate'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BodaInventory)
  String? inventoryid;
  String? InventoryName;
  String? InventoryQuantity;
  String? InventoryPrice;
  String? InventoryDate;
  bool? isSaved;
  // end FIELDS (BodaInventory)

  static const bool _softDeleteActivated = false;
  BodaInventoryManager? __mnBodaInventory;

  BodaInventoryManager get _mnBodaInventory {
    return __mnBodaInventory = __mnBodaInventory ?? BodaInventoryManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['inventoryid'] = inventoryid;
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryDate != null || !forView) {
      map['InventoryDate'] = InventoryDate;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['inventoryid'] = inventoryid;
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryDate != null || !forView) {
      map['InventoryDate'] = InventoryDate;
    }

    return map;
  }

  /// This method returns Json String [BodaInventory]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BodaInventory]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      inventoryid,
      InventoryName,
      InventoryQuantity,
      InventoryPrice,
      InventoryDate
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      inventoryid,
      InventoryName,
      InventoryQuantity,
      InventoryPrice,
      InventoryDate
    ];
  }

  static Future<List<BodaInventory>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaInventory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BodaInventory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BodaInventory>[];
    try {
      objList = list
          .map((bodainventory) =>
              BodaInventory.fromMap(bodainventory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaInventory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BodaInventory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BodaInventory> objList = <BodaInventory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BodaInventory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BodaInventory by ID if exist, otherwise returns null
  /// Primary Keys: String? inventoryid
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BodaInventory] if exist, otherwise returns null
  Future<BodaInventory?> getById(String? inventoryid,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (inventoryid == null) {
      return null;
    }
    BodaInventory? obj;
    final data = await _mnBodaInventory.getById([inventoryid]);
    if (data.length != 0) {
      obj = BodaInventory.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BodaInventory) object. If the Primary Key (inventoryid) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same inventoryid
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBodaInventory.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bodaInventory (inventoryid, InventoryName, InventoryQuantity, InventoryPrice, InventoryDate)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BodaInventory> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BodaInventory> bodainventories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in bodainventories) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaInventory.rawInsert(
          'INSERT OR REPLACE INTO bodaInventory (inventoryid, InventoryName, InventoryQuantity, InventoryPrice, InventoryDate)  VALUES (?,?,?,?,?)',
          [
            inventoryid,
            InventoryName,
            InventoryQuantity,
            InventoryPrice,
            InventoryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaInventory inventoryid=$inventoryid updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaInventory inventoryid=$inventoryid did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaInventory Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaInventory.rawInsert(
          'INSERT OR IGNORE INTO bodaInventory (inventoryid, InventoryName, InventoryQuantity, InventoryPrice, InventoryDate)  VALUES (?,?,?,?,?)',
          [
            inventoryid,
            InventoryName,
            InventoryQuantity,
            InventoryPrice,
            InventoryDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaInventory inventoryid=$inventoryid updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaInventory inventoryid=$inventoryid did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaInventory Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BodaInventory

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BodaInventory invoked (inventoryid=$inventoryid)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBodaInventory.delete(QueryParams(
          whereString: 'inventoryid=?', whereArguments: [inventoryid]));
    } else {
      return _mnBodaInventory.updateBatch(
          QueryParams(
              whereString: 'inventoryid=?', whereArguments: [inventoryid]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BodaInventory] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BodaInventoryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaInventoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BodaInventoryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaInventoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      inventoryid = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bodainventory

// region BodaInventoryField
class BodaInventoryField extends FilterBase {
  BodaInventoryField(BodaInventoryFilterBuilder bodainventoryFB)
      : super(bodainventoryFB);

  @override
  BodaInventoryFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder isNull() {
    return super.isNull() as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BodaInventoryFilterBuilder;
  }

  @override
  BodaInventoryField get not {
    return super.not as BodaInventoryField;
  }
}
// endregion BodaInventoryField

// region BodaInventoryFilterBuilder
class BodaInventoryFilterBuilder extends ConjunctionBase {
  BodaInventoryFilterBuilder(BodaInventory obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBodaInventory = obj._mnBodaInventory;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BodaInventoryManager? _mnBodaInventory;

  /// put the sql keyword 'AND'
  @override
  BodaInventoryFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BodaInventoryFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BodaInventoryFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BodaInventoryFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BodaInventoryFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BodaInventoryFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BodaInventoryFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaInventoryFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaInventoryFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaInventoryFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaInventoryFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BodaInventoryField _setField(
      BodaInventoryField? field, String colName, DbType dbtype) {
    return BodaInventoryField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BodaInventoryField? _inventoryid;
  BodaInventoryField get inventoryid {
    return _inventoryid =
        _setField(_inventoryid, 'inventoryid', DbType.integer);
  }

  BodaInventoryField? _InventoryName;
  BodaInventoryField get InventoryName {
    return _InventoryName =
        _setField(_InventoryName, 'InventoryName', DbType.text);
  }

  BodaInventoryField? _InventoryQuantity;
  BodaInventoryField get InventoryQuantity {
    return _InventoryQuantity =
        _setField(_InventoryQuantity, 'InventoryQuantity', DbType.text);
  }

  BodaInventoryField? _InventoryPrice;
  BodaInventoryField get InventoryPrice {
    return _InventoryPrice =
        _setField(_InventoryPrice, 'InventoryPrice', DbType.text);
  }

  BodaInventoryField? _InventoryDate;
  BodaInventoryField get InventoryDate {
    return _InventoryDate =
        _setField(_InventoryDate, 'InventoryDate', DbType.text);
  }

  /// Deletes List<BodaInventory> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBodaInventory!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBodaInventory!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'inventoryid IN (SELECT inventoryid from bodaInventory ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBodaInventory!.updateBatch(qparams, values);
  }

  /// This method always returns [BodaInventory] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaInventory?
  @override
  Future<BodaInventory?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBodaInventory!.toList(qparams);
    final data = await objFuture;
    BodaInventory? obj;
    if (data.isNotEmpty) {
      obj = BodaInventory.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BodaInventory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaInventory?
  @override
  Future<BodaInventory> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BodaInventory();
  }

  /// This method returns int. [BodaInventory]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bodainventoryCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bodainventoriesFuture = await _mnBodaInventory!.toList(qparams);
    final int count = bodainventoriesFuture[0]['CNT'] as int;
    if (bodainventoryCount != null) {
      bodainventoryCount(count);
    }
    return count;
  }

  /// This method returns List<BodaInventory> [BodaInventory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BodaInventory>
  @override
  Future<List<BodaInventory>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BodaInventory> bodainventoriesData =
        await BodaInventory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bodainventoriesData;
  }

  /// This method returns Json String [BodaInventory]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BodaInventory]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BodaInventory]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBodaInventory!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BodaInventory]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `inventoryid` FROM bodaInventory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> inventoryidData = <String>[];
    qparams.selectColumns = ['inventoryid'];
    final inventoryidFuture = await _mnBodaInventory!.toList(qparams);

    final int count = inventoryidFuture.length;
    for (int i = 0; i < count; i++) {
      inventoryidData.add(inventoryidFuture[i]['inventoryid'] as String);
    }
    return inventoryidData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BodaInventory]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBodaInventory!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BodaInventory.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBodaInventory!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BodaInventoryFilterBuilder

// region BodaInventoryFields
class BodaInventoryFields {
  static TableField? _fInventoryid;
  static TableField get inventoryid {
    return _fInventoryid = _fInventoryid ??
        SqlSyntax.setField(_fInventoryid, 'inventoryid', DbType.integer);
  }

  static TableField? _fInventoryName;
  static TableField get InventoryName {
    return _fInventoryName = _fInventoryName ??
        SqlSyntax.setField(_fInventoryName, 'InventoryName', DbType.text);
  }

  static TableField? _fInventoryQuantity;
  static TableField get InventoryQuantity {
    return _fInventoryQuantity = _fInventoryQuantity ??
        SqlSyntax.setField(
            _fInventoryQuantity, 'InventoryQuantity', DbType.text);
  }

  static TableField? _fInventoryPrice;
  static TableField get InventoryPrice {
    return _fInventoryPrice = _fInventoryPrice ??
        SqlSyntax.setField(_fInventoryPrice, 'InventoryPrice', DbType.text);
  }

  static TableField? _fInventoryDate;
  static TableField get InventoryDate {
    return _fInventoryDate = _fInventoryDate ??
        SqlSyntax.setField(_fInventoryDate, 'InventoryDate', DbType.text);
  }
}
// endregion BodaInventoryFields

//region BodaInventoryManager
class BodaInventoryManager extends SqfEntityProvider {
  BodaInventoryManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bodaInventory';
  static const List<String> _primaryKeyList = ['inventoryid'];
  static const String _whereStr = 'inventoryid=?';
}

//endregion BodaInventoryManager
// region BodaInsurance
class BodaInsurance extends TableBase {
  BodaInsurance(
      {this.InsuranceId,
      this.PolicyNumber,
      this.PolicyType,
      this.PolicyAmount,
      this.PolicyDate}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BodaInsurance.withFields(this.InsuranceId, this.PolicyNumber, this.PolicyType,
      this.PolicyAmount, this.PolicyDate) {
    _setDefaultValues();
  }
  BodaInsurance.withId(this.InsuranceId, this.PolicyNumber, this.PolicyType,
      this.PolicyAmount, this.PolicyDate) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BodaInsurance.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InsuranceId = o['InsuranceId'].toString();
    if (o['PolicyNumber'] != null) {
      PolicyNumber = o['PolicyNumber'].toString();
    }
    if (o['PolicyType'] != null) {
      PolicyType = o['PolicyType'].toString();
    }
    if (o['PolicyAmount'] != null) {
      PolicyAmount = o['PolicyAmount'].toString();
    }
    if (o['PolicyDate'] != null) {
      PolicyDate = o['PolicyDate'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BodaInsurance)
  String? InsuranceId;
  String? PolicyNumber;
  String? PolicyType;
  String? PolicyAmount;
  String? PolicyDate;
  bool? isSaved;
  // end FIELDS (BodaInsurance)

  static const bool _softDeleteActivated = false;
  BodaInsuranceManager? __mnBodaInsurance;

  BodaInsuranceManager get _mnBodaInsurance {
    return __mnBodaInsurance = __mnBodaInsurance ?? BodaInsuranceManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InsuranceId'] = InsuranceId;
    if (PolicyNumber != null || !forView) {
      map['PolicyNumber'] = PolicyNumber;
    }
    if (PolicyType != null || !forView) {
      map['PolicyType'] = PolicyType;
    }
    if (PolicyAmount != null || !forView) {
      map['PolicyAmount'] = PolicyAmount;
    }
    if (PolicyDate != null || !forView) {
      map['PolicyDate'] = PolicyDate;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InsuranceId'] = InsuranceId;
    if (PolicyNumber != null || !forView) {
      map['PolicyNumber'] = PolicyNumber;
    }
    if (PolicyType != null || !forView) {
      map['PolicyType'] = PolicyType;
    }
    if (PolicyAmount != null || !forView) {
      map['PolicyAmount'] = PolicyAmount;
    }
    if (PolicyDate != null || !forView) {
      map['PolicyDate'] = PolicyDate;
    }

    return map;
  }

  /// This method returns Json String [BodaInsurance]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BodaInsurance]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate];
  }

  static Future<List<BodaInsurance>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaInsurance.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BodaInsurance>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BodaInsurance>[];
    try {
      objList = list
          .map((bodainsurance) =>
              BodaInsurance.fromMap(bodainsurance as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BodaInsurance.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BodaInsurance>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BodaInsurance> objList = <BodaInsurance>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BodaInsurance.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BodaInsurance by ID if exist, otherwise returns null
  /// Primary Keys: String? InsuranceId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BodaInsurance] if exist, otherwise returns null
  Future<BodaInsurance?> getById(String? InsuranceId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InsuranceId == null) {
      return null;
    }
    BodaInsurance? obj;
    final data = await _mnBodaInsurance.getById([InsuranceId]);
    if (data.length != 0) {
      obj = BodaInsurance.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BodaInsurance) object. If the Primary Key (InsuranceId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same InsuranceId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBodaInsurance.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bodaInsurance (InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BodaInsurance> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BodaInsurance> bodainsurances,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in bodainsurances) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaInsurance.rawInsert(
          'INSERT OR REPLACE INTO bodaInsurance (InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate)  VALUES (?,?,?,?,?)',
          [InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaInsurance InsuranceId=$InsuranceId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaInsurance InsuranceId=$InsuranceId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaInsurance Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBodaInsurance.rawInsert(
          'INSERT OR IGNORE INTO bodaInsurance (InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate)  VALUES (?,?,?,?,?)',
          [InsuranceId, PolicyNumber, PolicyType, PolicyAmount, PolicyDate],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BodaInsurance InsuranceId=$InsuranceId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BodaInsurance InsuranceId=$InsuranceId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BodaInsurance Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BodaInsurance

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BodaInsurance invoked (InsuranceId=$InsuranceId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBodaInsurance.delete(QueryParams(
          whereString: 'InsuranceId=?', whereArguments: [InsuranceId]));
    } else {
      return _mnBodaInsurance.updateBatch(
          QueryParams(
              whereString: 'InsuranceId=?', whereArguments: [InsuranceId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BodaInsurance] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BodaInsuranceFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaInsuranceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BodaInsuranceFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BodaInsuranceFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InsuranceId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bodainsurance

// region BodaInsuranceField
class BodaInsuranceField extends FilterBase {
  BodaInsuranceField(BodaInsuranceFilterBuilder bodainsuranceFB)
      : super(bodainsuranceFB);

  @override
  BodaInsuranceFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder isNull() {
    return super.isNull() as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BodaInsuranceFilterBuilder;
  }

  @override
  BodaInsuranceField get not {
    return super.not as BodaInsuranceField;
  }
}
// endregion BodaInsuranceField

// region BodaInsuranceFilterBuilder
class BodaInsuranceFilterBuilder extends ConjunctionBase {
  BodaInsuranceFilterBuilder(BodaInsurance obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBodaInsurance = obj._mnBodaInsurance;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BodaInsuranceManager? _mnBodaInsurance;

  /// put the sql keyword 'AND'
  @override
  BodaInsuranceFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BodaInsuranceFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BodaInsuranceFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BodaInsuranceFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BodaInsuranceFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BodaInsuranceFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BodaInsuranceFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaInsuranceFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaInsuranceFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BodaInsuranceFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BodaInsuranceFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BodaInsuranceField _setField(
      BodaInsuranceField? field, String colName, DbType dbtype) {
    return BodaInsuranceField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BodaInsuranceField? _InsuranceId;
  BodaInsuranceField get InsuranceId {
    return _InsuranceId =
        _setField(_InsuranceId, 'InsuranceId', DbType.integer);
  }

  BodaInsuranceField? _PolicyNumber;
  BodaInsuranceField get PolicyNumber {
    return _PolicyNumber =
        _setField(_PolicyNumber, 'PolicyNumber', DbType.text);
  }

  BodaInsuranceField? _PolicyType;
  BodaInsuranceField get PolicyType {
    return _PolicyType = _setField(_PolicyType, 'PolicyType', DbType.text);
  }

  BodaInsuranceField? _PolicyAmount;
  BodaInsuranceField get PolicyAmount {
    return _PolicyAmount =
        _setField(_PolicyAmount, 'PolicyAmount', DbType.text);
  }

  BodaInsuranceField? _PolicyDate;
  BodaInsuranceField get PolicyDate {
    return _PolicyDate = _setField(_PolicyDate, 'PolicyDate', DbType.text);
  }

  /// Deletes List<BodaInsurance> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBodaInsurance!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBodaInsurance!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InsuranceId IN (SELECT InsuranceId from bodaInsurance ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBodaInsurance!.updateBatch(qparams, values);
  }

  /// This method always returns [BodaInsurance] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaInsurance?
  @override
  Future<BodaInsurance?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBodaInsurance!.toList(qparams);
    final data = await objFuture;
    BodaInsurance? obj;
    if (data.isNotEmpty) {
      obj = BodaInsurance.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BodaInsurance]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BodaInsurance?
  @override
  Future<BodaInsurance> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BodaInsurance();
  }

  /// This method returns int. [BodaInsurance]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bodainsuranceCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bodainsurancesFuture = await _mnBodaInsurance!.toList(qparams);
    final int count = bodainsurancesFuture[0]['CNT'] as int;
    if (bodainsuranceCount != null) {
      bodainsuranceCount(count);
    }
    return count;
  }

  /// This method returns List<BodaInsurance> [BodaInsurance]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BodaInsurance>
  @override
  Future<List<BodaInsurance>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BodaInsurance> bodainsurancesData =
        await BodaInsurance.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bodainsurancesData;
  }

  /// This method returns Json String [BodaInsurance]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BodaInsurance]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BodaInsurance]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBodaInsurance!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BodaInsurance]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InsuranceId` FROM bodaInsurance WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> InsuranceIdData = <String>[];
    qparams.selectColumns = ['InsuranceId'];
    final InsuranceIdFuture = await _mnBodaInsurance!.toList(qparams);

    final int count = InsuranceIdFuture.length;
    for (int i = 0; i < count; i++) {
      InsuranceIdData.add(InsuranceIdFuture[i]['InsuranceId'] as String);
    }
    return InsuranceIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BodaInsurance]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBodaInsurance!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BodaInsurance.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBodaInsurance!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BodaInsuranceFilterBuilder

// region BodaInsuranceFields
class BodaInsuranceFields {
  static TableField? _fInsuranceId;
  static TableField get InsuranceId {
    return _fInsuranceId = _fInsuranceId ??
        SqlSyntax.setField(_fInsuranceId, 'insuranceid', DbType.integer);
  }

  static TableField? _fPolicyNumber;
  static TableField get PolicyNumber {
    return _fPolicyNumber = _fPolicyNumber ??
        SqlSyntax.setField(_fPolicyNumber, 'PolicyNumber', DbType.text);
  }

  static TableField? _fPolicyType;
  static TableField get PolicyType {
    return _fPolicyType = _fPolicyType ??
        SqlSyntax.setField(_fPolicyType, 'PolicyType', DbType.text);
  }

  static TableField? _fPolicyAmount;
  static TableField get PolicyAmount {
    return _fPolicyAmount = _fPolicyAmount ??
        SqlSyntax.setField(_fPolicyAmount, 'PolicyAmount', DbType.text);
  }

  static TableField? _fPolicyDate;
  static TableField get PolicyDate {
    return _fPolicyDate = _fPolicyDate ??
        SqlSyntax.setField(_fPolicyDate, 'PolicyDate', DbType.text);
  }
}
// endregion BodaInsuranceFields

//region BodaInsuranceManager
class BodaInsuranceManager extends SqfEntityProvider {
  BodaInsuranceManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bodaInsurance';
  static const List<String> _primaryKeyList = ['InsuranceId'];
  static const String _whereStr = 'InsuranceId=?';
}

//endregion BodaInsuranceManager
// region BillData
class BillData extends TableBase {
  BillData(
      {this.BillId,
      this.BillName,
      this.BillCode,
      this.BillAccountNumber,
      this.BillDate,
      this.BillPayableAmount,
      this.BillCollectedAmount}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BillData.withFields(
      this.BillId,
      this.BillName,
      this.BillCode,
      this.BillAccountNumber,
      this.BillDate,
      this.BillPayableAmount,
      this.BillCollectedAmount) {
    _setDefaultValues();
  }
  BillData.withId(
      this.BillId,
      this.BillName,
      this.BillCode,
      this.BillAccountNumber,
      this.BillDate,
      this.BillPayableAmount,
      this.BillCollectedAmount) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BillData.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BillId = o['BillId'].toString();
    if (o['BillName'] != null) {
      BillName = o['BillName'].toString();
    }
    if (o['BillCode'] != null) {
      BillCode = o['BillCode'].toString();
    }
    if (o['BillAccountNumber'] != null) {
      BillAccountNumber = o['BillAccountNumber'].toString();
    }
    if (o['BillDate'] != null) {
      BillDate = o['BillDate'].toString();
    }
    if (o['BillPayableAmount'] != null) {
      BillPayableAmount = o['BillPayableAmount'].toString();
    }
    if (o['BillCollectedAmount'] != null) {
      BillCollectedAmount = o['BillCollectedAmount'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BillData)
  String? BillId;
  String? BillName;
  String? BillCode;
  String? BillAccountNumber;
  String? BillDate;
  String? BillPayableAmount;
  String? BillCollectedAmount;
  bool? isSaved;
  // end FIELDS (BillData)

  static const bool _softDeleteActivated = false;
  BillDataManager? __mnBillData;

  BillDataManager get _mnBillData {
    return __mnBillData = __mnBillData ?? BillDataManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BillId'] = BillId;
    if (BillName != null || !forView) {
      map['BillName'] = BillName;
    }
    if (BillCode != null || !forView) {
      map['BillCode'] = BillCode;
    }
    if (BillAccountNumber != null || !forView) {
      map['BillAccountNumber'] = BillAccountNumber;
    }
    if (BillDate != null || !forView) {
      map['BillDate'] = BillDate;
    }
    if (BillPayableAmount != null || !forView) {
      map['BillPayableAmount'] = BillPayableAmount;
    }
    if (BillCollectedAmount != null || !forView) {
      map['BillCollectedAmount'] = BillCollectedAmount;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BillId'] = BillId;
    if (BillName != null || !forView) {
      map['BillName'] = BillName;
    }
    if (BillCode != null || !forView) {
      map['BillCode'] = BillCode;
    }
    if (BillAccountNumber != null || !forView) {
      map['BillAccountNumber'] = BillAccountNumber;
    }
    if (BillDate != null || !forView) {
      map['BillDate'] = BillDate;
    }
    if (BillPayableAmount != null || !forView) {
      map['BillPayableAmount'] = BillPayableAmount;
    }
    if (BillCollectedAmount != null || !forView) {
      map['BillCollectedAmount'] = BillCollectedAmount;
    }

    return map;
  }

  /// This method returns Json String [BillData]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BillData]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BillId,
      BillName,
      BillCode,
      BillAccountNumber,
      BillDate,
      BillPayableAmount,
      BillCollectedAmount
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BillId,
      BillName,
      BillCode,
      BillAccountNumber,
      BillDate,
      BillPayableAmount,
      BillCollectedAmount
    ];
  }

  static Future<List<BillData>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillData.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BillData>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BillData>[];
    try {
      objList = list
          .map((billdata) => BillData.fromMap(billdata as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BillData.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BillData>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BillData> objList = <BillData>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BillData.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BillData by ID if exist, otherwise returns null
  /// Primary Keys: String? BillId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BillData] if exist, otherwise returns null
  Future<BillData?> getById(String? BillId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BillId == null) {
      return null;
    }
    BillData? obj;
    final data = await _mnBillData.getById([BillId]);
    if (data.length != 0) {
      obj = BillData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BillData) object. If the Primary Key (BillId) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BillId
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBillData.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO billData (BillId, BillName, BillCode, BillAccountNumber, BillDate, BillPayableAmount, BillCollectedAmount)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BillData> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BillData> billdatas,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BookingModel().batchStart();
    for (final obj in billdatas) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BookingModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillData.rawInsert(
          'INSERT OR REPLACE INTO billData (BillId, BillName, BillCode, BillAccountNumber, BillDate, BillPayableAmount, BillCollectedAmount)  VALUES (?,?,?,?,?,?,?)',
          [
            BillId,
            BillName,
            BillCode,
            BillAccountNumber,
            BillDate,
            BillPayableAmount,
            BillCollectedAmount
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BillData BillId=$BillId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BillData BillId=$BillId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBillData.rawInsert(
          'INSERT OR IGNORE INTO billData (BillId, BillName, BillCode, BillAccountNumber, BillDate, BillPayableAmount, BillCollectedAmount)  VALUES (?,?,?,?,?,?,?)',
          [
            BillId,
            BillName,
            BillCode,
            BillAccountNumber,
            BillDate,
            BillPayableAmount,
            BillCollectedAmount
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BillData BillId=$BillId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BillData BillId=$BillId did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BillData Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BillData

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BillData invoked (BillId=$BillId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBillData.delete(
          QueryParams(whereString: 'BillId=?', whereArguments: [BillId]));
    } else {
      return _mnBillData.updateBatch(
          QueryParams(whereString: 'BillId=?', whereArguments: [BillId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BillData] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BillDataFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BillDataFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BillDataFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BillId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion billdata

// region BillDataField
class BillDataField extends FilterBase {
  BillDataField(BillDataFilterBuilder billdataFB) : super(billdataFB);

  @override
  BillDataFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder isNull() {
    return super.isNull() as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BillDataFilterBuilder;
  }

  @override
  BillDataField get not {
    return super.not as BillDataField;
  }
}
// endregion BillDataField

// region BillDataFilterBuilder
class BillDataFilterBuilder extends ConjunctionBase {
  BillDataFilterBuilder(BillData obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBillData = obj._mnBillData;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BillDataManager? _mnBillData;

  /// put the sql keyword 'AND'
  @override
  BillDataFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BillDataFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BillDataFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BillDataFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BillDataFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BillDataFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BillDataFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillDataFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillDataFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BillDataFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BillDataFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BillDataField _setField(BillDataField? field, String colName, DbType dbtype) {
    return BillDataField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BillDataField? _BillId;
  BillDataField get BillId {
    return _BillId = _setField(_BillId, 'BillId', DbType.integer);
  }

  BillDataField? _BillName;
  BillDataField get BillName {
    return _BillName = _setField(_BillName, 'BillName', DbType.text);
  }

  BillDataField? _BillCode;
  BillDataField get BillCode {
    return _BillCode = _setField(_BillCode, 'BillCode', DbType.text);
  }

  BillDataField? _BillAccountNumber;
  BillDataField get BillAccountNumber {
    return _BillAccountNumber =
        _setField(_BillAccountNumber, 'BillAccountNumber', DbType.text);
  }

  BillDataField? _BillDate;
  BillDataField get BillDate {
    return _BillDate = _setField(_BillDate, 'BillDate', DbType.text);
  }

  BillDataField? _BillPayableAmount;
  BillDataField get BillPayableAmount {
    return _BillPayableAmount =
        _setField(_BillPayableAmount, 'BillPayableAmount', DbType.text);
  }

  BillDataField? _BillCollectedAmount;
  BillDataField get BillCollectedAmount {
    return _BillCollectedAmount =
        _setField(_BillCollectedAmount, 'BillCollectedAmount', DbType.text);
  }

  /// Deletes List<BillData> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBillData!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBillData!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BillId IN (SELECT BillId from billData ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBillData!.updateBatch(qparams, values);
  }

  /// This method always returns [BillData] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillData?
  @override
  Future<BillData?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBillData!.toList(qparams);
    final data = await objFuture;
    BillData? obj;
    if (data.isNotEmpty) {
      obj = BillData.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BillData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BillData?
  @override
  Future<BillData> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BillData();
  }

  /// This method returns int. [BillData]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? billdataCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final billdatasFuture = await _mnBillData!.toList(qparams);
    final int count = billdatasFuture[0]['CNT'] as int;
    if (billdataCount != null) {
      billdataCount(count);
    }
    return count;
  }

  /// This method returns List<BillData> [BillData]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BillData>
  @override
  Future<List<BillData>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BillData> billdatasData = await BillData.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return billdatasData;
  }

  /// This method returns Json String [BillData]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BillData]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BillData]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBillData!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BillData]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BillId` FROM billData WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BillIdData = <String>[];
    qparams.selectColumns = ['BillId'];
    final BillIdFuture = await _mnBillData!.toList(qparams);

    final int count = BillIdFuture.length;
    for (int i = 0; i < count; i++) {
      BillIdData.add(BillIdFuture[i]['BillId'] as String);
    }
    return BillIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BillData]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBillData!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BillData.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBillData!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BillDataFilterBuilder

// region BillDataFields
class BillDataFields {
  static TableField? _fBillId;
  static TableField get BillId {
    return _fBillId =
        _fBillId ?? SqlSyntax.setField(_fBillId, 'billid', DbType.integer);
  }

  static TableField? _fBillName;
  static TableField get BillName {
    return _fBillName =
        _fBillName ?? SqlSyntax.setField(_fBillName, 'BillName', DbType.text);
  }

  static TableField? _fBillCode;
  static TableField get BillCode {
    return _fBillCode =
        _fBillCode ?? SqlSyntax.setField(_fBillCode, 'BillCode', DbType.text);
  }

  static TableField? _fBillAccountNumber;
  static TableField get BillAccountNumber {
    return _fBillAccountNumber = _fBillAccountNumber ??
        SqlSyntax.setField(
            _fBillAccountNumber, 'BillAccountNumber', DbType.text);
  }

  static TableField? _fBillDate;
  static TableField get BillDate {
    return _fBillDate =
        _fBillDate ?? SqlSyntax.setField(_fBillDate, 'BillDate', DbType.text);
  }

  static TableField? _fBillPayableAmount;
  static TableField get BillPayableAmount {
    return _fBillPayableAmount = _fBillPayableAmount ??
        SqlSyntax.setField(
            _fBillPayableAmount, 'BillPayableAmount', DbType.text);
  }

  static TableField? _fBillCollectedAmount;
  static TableField get BillCollectedAmount {
    return _fBillCollectedAmount = _fBillCollectedAmount ??
        SqlSyntax.setField(
            _fBillCollectedAmount, 'BillCollectedAmount', DbType.text);
  }
}
// endregion BillDataFields

//region BillDataManager
class BillDataManager extends SqfEntityProvider {
  BillDataManager()
      : super(BookingModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'billData';
  static const List<String> _primaryKeyList = ['BillId'];
  static const String _whereStr = 'BillId=?';
}

//endregion BillDataManager
class BookingModelSequenceManager extends SqfEntityProvider {
  BookingModelSequenceManager() : super(BookingModel());
}
// END OF ENTITIES
