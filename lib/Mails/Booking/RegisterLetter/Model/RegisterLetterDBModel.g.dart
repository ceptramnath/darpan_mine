// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'RegisterLetterDBModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:RegisterLetterTable.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// RegisterLetterTable TABLE
class TableRegisterLetterTable extends SqfEntityTableBase {
  TableRegisterLetterTable() {
    // declare properties of EntityTable
    tableName = 'registerLetterTable';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('WeightAmount', DbType.text),
      SqfEntityFieldBase('PrepaidAmount', DbType.integer),
      SqfEntityFieldBase('AcknowledgementService', DbType.integer),
      SqfEntityFieldBase('InsuranceService', DbType.text),
      SqfEntityFieldBase('ValuePayableService', DbType.text),
      SqfEntityFieldBase('RegistrationFee', DbType.real),
      SqfEntityFieldBase('AmountToBeCollected', DbType.text),
      SqfEntityFieldBase('SenderName', DbType.text),
      SqfEntityFieldBase('SenderAddress', DbType.text),
      SqfEntityFieldBase('SenderPincode', DbType.integer),
      SqfEntityFieldBase('SenderCity', DbType.text),
      SqfEntityFieldBase('SenderState', DbType.text),
      SqfEntityFieldBase('SenderMobileNumber', DbType.text),
      SqfEntityFieldBase('SenderEmail', DbType.text),
      SqfEntityFieldBase('AddresseeName', DbType.text),
      SqfEntityFieldBase('AddresseeAddress', DbType.text),
      SqfEntityFieldBase('AddresseePincode', DbType.integer),
      SqfEntityFieldBase('AddresseeCity', DbType.text),
      SqfEntityFieldBase('AddresseeState', DbType.text),
      SqfEntityFieldBase('AddresseeMobileNumber', DbType.text),
      SqfEntityFieldBase('AddresseeEmail', DbType.text),
      SqfEntityFieldBase('RemarkDate', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableRegisterLetterTable();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class RegisterLetterFormModel extends SqfEntityModelProvider {
  RegisterLetterFormModel() {
    databaseName = formLetterModel.databaseName;
    password = formLetterModel.password;
    dbVersion = formLetterModel.dbVersion;
    preSaveAction = formLetterModel.preSaveAction;
    logFunction = formLetterModel.logFunction;
    databaseTables = [
      TableRegisterLetterTable.getInstance,
    ];

    bundledDatabasePath = formLetterModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = formLetterModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region RegisterLetterTable
class RegisterLetterTable extends TableBase {
  RegisterLetterTable(
      {this.ArticleNumber,
      this.Weight,
      this.WeightAmount,
      this.PrepaidAmount,
      this.AcknowledgementService,
      this.InsuranceService,
      this.ValuePayableService,
      this.RegistrationFee,
      this.AmountToBeCollected,
      this.SenderName,
      this.SenderAddress,
      this.SenderPincode,
      this.SenderCity,
      this.SenderState,
      this.SenderMobileNumber,
      this.SenderEmail,
      this.AddresseeName,
      this.AddresseeAddress,
      this.AddresseePincode,
      this.AddresseeCity,
      this.AddresseeState,
      this.AddresseeMobileNumber,
      this.AddresseeEmail,
      this.RemarkDate}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  RegisterLetterTable.withFields(
      this.ArticleNumber,
      this.Weight,
      this.WeightAmount,
      this.PrepaidAmount,
      this.AcknowledgementService,
      this.InsuranceService,
      this.ValuePayableService,
      this.RegistrationFee,
      this.AmountToBeCollected,
      this.SenderName,
      this.SenderAddress,
      this.SenderPincode,
      this.SenderCity,
      this.SenderState,
      this.SenderMobileNumber,
      this.SenderEmail,
      this.AddresseeName,
      this.AddresseeAddress,
      this.AddresseePincode,
      this.AddresseeCity,
      this.AddresseeState,
      this.AddresseeMobileNumber,
      this.AddresseeEmail,
      this.RemarkDate) {
    _setDefaultValues();
  }
  RegisterLetterTable.withId(
      this.ArticleNumber,
      this.Weight,
      this.WeightAmount,
      this.PrepaidAmount,
      this.AcknowledgementService,
      this.InsuranceService,
      this.ValuePayableService,
      this.RegistrationFee,
      this.AmountToBeCollected,
      this.SenderName,
      this.SenderAddress,
      this.SenderPincode,
      this.SenderCity,
      this.SenderState,
      this.SenderMobileNumber,
      this.SenderEmail,
      this.AddresseeName,
      this.AddresseeAddress,
      this.AddresseePincode,
      this.AddresseeCity,
      this.AddresseeState,
      this.AddresseeMobileNumber,
      this.AddresseeEmail,
      this.RemarkDate) {
    _setDefaultValues();
  }
  // fromMap v2.0
  RegisterLetterTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['WeightAmount'] != null) {
      WeightAmount = o['WeightAmount'].toString();
    }
    if (o['PrepaidAmount'] != null) {
      PrepaidAmount = int.tryParse(o['PrepaidAmount'].toString());
    }
    if (o['AcknowledgementService'] != null) {
      AcknowledgementService =
          int.tryParse(o['AcknowledgementService'].toString());
    }
    if (o['InsuranceService'] != null) {
      InsuranceService = o['InsuranceService'].toString();
    }
    if (o['ValuePayableService'] != null) {
      ValuePayableService = o['ValuePayableService'].toString();
    }
    if (o['RegistrationFee'] != null) {
      RegistrationFee = double.tryParse(o['RegistrationFee'].toString());
    }
    if (o['AmountToBeCollected'] != null) {
      AmountToBeCollected = o['AmountToBeCollected'].toString();
    }
    if (o['SenderName'] != null) {
      SenderName = o['SenderName'].toString();
    }
    if (o['SenderAddress'] != null) {
      SenderAddress = o['SenderAddress'].toString();
    }
    if (o['SenderPincode'] != null) {
      SenderPincode = int.tryParse(o['SenderPincode'].toString());
    }
    if (o['SenderCity'] != null) {
      SenderCity = o['SenderCity'].toString();
    }
    if (o['SenderState'] != null) {
      SenderState = o['SenderState'].toString();
    }
    if (o['SenderMobileNumber'] != null) {
      SenderMobileNumber = o['SenderMobileNumber'].toString();
    }
    if (o['SenderEmail'] != null) {
      SenderEmail = o['SenderEmail'].toString();
    }
    if (o['AddresseeName'] != null) {
      AddresseeName = o['AddresseeName'].toString();
    }
    if (o['AddresseeAddress'] != null) {
      AddresseeAddress = o['AddresseeAddress'].toString();
    }
    if (o['AddresseePincode'] != null) {
      AddresseePincode = int.tryParse(o['AddresseePincode'].toString());
    }
    if (o['AddresseeCity'] != null) {
      AddresseeCity = o['AddresseeCity'].toString();
    }
    if (o['AddresseeState'] != null) {
      AddresseeState = o['AddresseeState'].toString();
    }
    if (o['AddresseeMobileNumber'] != null) {
      AddresseeMobileNumber = o['AddresseeMobileNumber'].toString();
    }
    if (o['AddresseeEmail'] != null) {
      AddresseeEmail = o['AddresseeEmail'].toString();
    }
    if (o['RemarkDate'] != null) {
      RemarkDate = o['RemarkDate'].toString();
    }

    isSaved = true;
  }
  // FIELDS (RegisterLetterTable)
  String? ArticleNumber;
  String? Weight;
  String? WeightAmount;
  int? PrepaidAmount;
  int? AcknowledgementService;
  String? InsuranceService;
  String? ValuePayableService;
  double? RegistrationFee;
  String? AmountToBeCollected;
  String? SenderName;
  String? SenderAddress;
  int? SenderPincode;
  String? SenderCity;
  String? SenderState;
  String? SenderMobileNumber;
  String? SenderEmail;
  String? AddresseeName;
  String? AddresseeAddress;
  int? AddresseePincode;
  String? AddresseeCity;
  String? AddresseeState;
  String? AddresseeMobileNumber;
  String? AddresseeEmail;
  String? RemarkDate;
  bool? isSaved;
  // end FIELDS (RegisterLetterTable)

  static const bool _softDeleteActivated = false;
  RegisterLetterTableManager? __mnRegisterLetterTable;

  RegisterLetterTableManager get _mnRegisterLetterTable {
    return __mnRegisterLetterTable =
        __mnRegisterLetterTable ?? RegisterLetterTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightAmount != null || !forView) {
      map['WeightAmount'] = WeightAmount;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (AcknowledgementService != null || !forView) {
      map['AcknowledgementService'] = AcknowledgementService;
    }
    if (InsuranceService != null || !forView) {
      map['InsuranceService'] = InsuranceService;
    }
    if (ValuePayableService != null || !forView) {
      map['ValuePayableService'] = ValuePayableService;
    }
    if (RegistrationFee != null || !forView) {
      map['RegistrationFee'] = RegistrationFee;
    }
    if (AmountToBeCollected != null || !forView) {
      map['AmountToBeCollected'] = AmountToBeCollected;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderPincode != null || !forView) {
      map['SenderPincode'] = SenderPincode;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderMobileNumber != null || !forView) {
      map['SenderMobileNumber'] = SenderMobileNumber;
    }
    if (SenderEmail != null || !forView) {
      map['SenderEmail'] = SenderEmail;
    }
    if (AddresseeName != null || !forView) {
      map['AddresseeName'] = AddresseeName;
    }
    if (AddresseeAddress != null || !forView) {
      map['AddresseeAddress'] = AddresseeAddress;
    }
    if (AddresseePincode != null || !forView) {
      map['AddresseePincode'] = AddresseePincode;
    }
    if (AddresseeCity != null || !forView) {
      map['AddresseeCity'] = AddresseeCity;
    }
    if (AddresseeState != null || !forView) {
      map['AddresseeState'] = AddresseeState;
    }
    if (AddresseeMobileNumber != null || !forView) {
      map['AddresseeMobileNumber'] = AddresseeMobileNumber;
    }
    if (AddresseeEmail != null || !forView) {
      map['AddresseeEmail'] = AddresseeEmail;
    }
    if (RemarkDate != null || !forView) {
      map['RemarkDate'] = RemarkDate;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (WeightAmount != null || !forView) {
      map['WeightAmount'] = WeightAmount;
    }
    if (PrepaidAmount != null || !forView) {
      map['PrepaidAmount'] = PrepaidAmount;
    }
    if (AcknowledgementService != null || !forView) {
      map['AcknowledgementService'] = AcknowledgementService;
    }
    if (InsuranceService != null || !forView) {
      map['InsuranceService'] = InsuranceService;
    }
    if (ValuePayableService != null || !forView) {
      map['ValuePayableService'] = ValuePayableService;
    }
    if (RegistrationFee != null || !forView) {
      map['RegistrationFee'] = RegistrationFee;
    }
    if (AmountToBeCollected != null || !forView) {
      map['AmountToBeCollected'] = AmountToBeCollected;
    }
    if (SenderName != null || !forView) {
      map['SenderName'] = SenderName;
    }
    if (SenderAddress != null || !forView) {
      map['SenderAddress'] = SenderAddress;
    }
    if (SenderPincode != null || !forView) {
      map['SenderPincode'] = SenderPincode;
    }
    if (SenderCity != null || !forView) {
      map['SenderCity'] = SenderCity;
    }
    if (SenderState != null || !forView) {
      map['SenderState'] = SenderState;
    }
    if (SenderMobileNumber != null || !forView) {
      map['SenderMobileNumber'] = SenderMobileNumber;
    }
    if (SenderEmail != null || !forView) {
      map['SenderEmail'] = SenderEmail;
    }
    if (AddresseeName != null || !forView) {
      map['AddresseeName'] = AddresseeName;
    }
    if (AddresseeAddress != null || !forView) {
      map['AddresseeAddress'] = AddresseeAddress;
    }
    if (AddresseePincode != null || !forView) {
      map['AddresseePincode'] = AddresseePincode;
    }
    if (AddresseeCity != null || !forView) {
      map['AddresseeCity'] = AddresseeCity;
    }
    if (AddresseeState != null || !forView) {
      map['AddresseeState'] = AddresseeState;
    }
    if (AddresseeMobileNumber != null || !forView) {
      map['AddresseeMobileNumber'] = AddresseeMobileNumber;
    }
    if (AddresseeEmail != null || !forView) {
      map['AddresseeEmail'] = AddresseeEmail;
    }
    if (RemarkDate != null || !forView) {
      map['RemarkDate'] = RemarkDate;
    }

    return map;
  }

  /// This method returns Json String [RegisterLetterTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [RegisterLetterTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      Weight,
      WeightAmount,
      PrepaidAmount,
      AcknowledgementService,
      InsuranceService,
      ValuePayableService,
      RegistrationFee,
      AmountToBeCollected,
      SenderName,
      SenderAddress,
      SenderPincode,
      SenderCity,
      SenderState,
      SenderMobileNumber,
      SenderEmail,
      AddresseeName,
      AddresseeAddress,
      AddresseePincode,
      AddresseeCity,
      AddresseeState,
      AddresseeMobileNumber,
      AddresseeEmail,
      RemarkDate
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      ArticleNumber,
      Weight,
      WeightAmount,
      PrepaidAmount,
      AcknowledgementService,
      InsuranceService,
      ValuePayableService,
      RegistrationFee,
      AmountToBeCollected,
      SenderName,
      SenderAddress,
      SenderPincode,
      SenderCity,
      SenderState,
      SenderMobileNumber,
      SenderEmail,
      AddresseeName,
      AddresseeAddress,
      AddresseePincode,
      AddresseeCity,
      AddresseeState,
      AddresseeMobileNumber,
      AddresseeEmail,
      RemarkDate
    ];
  }

  static Future<List<RegisterLetterTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegisterLetterTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<RegisterLetterTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <RegisterLetterTable>[];
    try {
      objList = list
          .map((registerlettertable) => RegisterLetterTable.fromMap(
              registerlettertable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR RegisterLetterTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<RegisterLetterTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<RegisterLetterTable> objList = <RegisterLetterTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = RegisterLetterTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns RegisterLetterTable by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [RegisterLetterTable] if exist, otherwise returns null
  Future<RegisterLetterTable?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    RegisterLetterTable? obj;
    final data = await _mnRegisterLetterTable.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = RegisterLetterTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (RegisterLetterTable) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnRegisterLetterTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO registerLetterTable (ArticleNumber, Weight, WeightAmount, PrepaidAmount, AcknowledgementService, InsuranceService, ValuePayableService, RegistrationFee, AmountToBeCollected, SenderName, SenderAddress, SenderPincode, SenderCity, SenderState, SenderMobileNumber, SenderEmail, AddresseeName, AddresseeAddress, AddresseePincode, AddresseeCity, AddresseeState, AddresseeMobileNumber, AddresseeEmail, RemarkDate)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<RegisterLetterTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<RegisterLetterTable> registerlettertables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await RegisterLetterFormModel().batchStart();
    for (final obj in registerlettertables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await RegisterLetterFormModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRegisterLetterTable.rawInsert(
          'INSERT OR REPLACE INTO registerLetterTable (ArticleNumber, Weight, WeightAmount, PrepaidAmount, AcknowledgementService, InsuranceService, ValuePayableService, RegistrationFee, AmountToBeCollected, SenderName, SenderAddress, SenderPincode, SenderCity, SenderState, SenderMobileNumber, SenderEmail, AddresseeName, AddresseeAddress, AddresseePincode, AddresseeCity, AddresseeState, AddresseeMobileNumber, AddresseeEmail, RemarkDate)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            Weight,
            WeightAmount,
            PrepaidAmount,
            AcknowledgementService,
            InsuranceService,
            ValuePayableService,
            RegistrationFee,
            AmountToBeCollected,
            SenderName,
            SenderAddress,
            SenderPincode,
            SenderCity,
            SenderState,
            SenderMobileNumber,
            SenderEmail,
            AddresseeName,
            AddresseeAddress,
            AddresseePincode,
            AddresseeCity,
            AddresseeState,
            AddresseeMobileNumber,
            AddresseeEmail,
            RemarkDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'RegisterLetterTable ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'RegisterLetterTable ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'RegisterLetterTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnRegisterLetterTable.rawInsert(
          'INSERT OR IGNORE INTO registerLetterTable (ArticleNumber, Weight, WeightAmount, PrepaidAmount, AcknowledgementService, InsuranceService, ValuePayableService, RegistrationFee, AmountToBeCollected, SenderName, SenderAddress, SenderPincode, SenderCity, SenderState, SenderMobileNumber, SenderEmail, AddresseeName, AddresseeAddress, AddresseePincode, AddresseeCity, AddresseeState, AddresseeMobileNumber, AddresseeEmail, RemarkDate)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            Weight,
            WeightAmount,
            PrepaidAmount,
            AcknowledgementService,
            InsuranceService,
            ValuePayableService,
            RegistrationFee,
            AmountToBeCollected,
            SenderName,
            SenderAddress,
            SenderPincode,
            SenderCity,
            SenderState,
            SenderMobileNumber,
            SenderEmail,
            AddresseeName,
            AddresseeAddress,
            AddresseePincode,
            AddresseeCity,
            AddresseeState,
            AddresseeMobileNumber,
            AddresseeEmail,
            RemarkDate
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'RegisterLetterTable ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'RegisterLetterTable ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'RegisterLetterTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes RegisterLetterTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete RegisterLetterTable invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnRegisterLetterTable.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnRegisterLetterTable.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [RegisterLetterTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  RegisterLetterTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegisterLetterTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  RegisterLetterTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return RegisterLetterTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion registerlettertable

// region RegisterLetterTableField
class RegisterLetterTableField extends FilterBase {
  RegisterLetterTableField(
      RegisterLetterTableFilterBuilder registerlettertableFB)
      : super(registerlettertableFB);

  @override
  RegisterLetterTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder isNull() {
    return super.isNull() as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as RegisterLetterTableFilterBuilder;
  }

  @override
  RegisterLetterTableField get not {
    return super.not as RegisterLetterTableField;
  }
}
// endregion RegisterLetterTableField

// region RegisterLetterTableFilterBuilder
class RegisterLetterTableFilterBuilder extends ConjunctionBase {
  RegisterLetterTableFilterBuilder(RegisterLetterTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnRegisterLetterTable = obj._mnRegisterLetterTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  RegisterLetterTableManager? _mnRegisterLetterTable;

  /// put the sql keyword 'AND'
  @override
  RegisterLetterTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  RegisterLetterTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  RegisterLetterTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  RegisterLetterTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  RegisterLetterTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  RegisterLetterTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  RegisterLetterTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegisterLetterTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegisterLetterTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  RegisterLetterTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  RegisterLetterTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  RegisterLetterTableField _setField(
      RegisterLetterTableField? field, String colName, DbType dbtype) {
    return RegisterLetterTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  RegisterLetterTableField? _ArticleNumber;
  RegisterLetterTableField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  RegisterLetterTableField? _Weight;
  RegisterLetterTableField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  RegisterLetterTableField? _WeightAmount;
  RegisterLetterTableField get WeightAmount {
    return _WeightAmount =
        _setField(_WeightAmount, 'WeightAmount', DbType.text);
  }

  RegisterLetterTableField? _PrepaidAmount;
  RegisterLetterTableField get PrepaidAmount {
    return _PrepaidAmount =
        _setField(_PrepaidAmount, 'PrepaidAmount', DbType.integer);
  }

  RegisterLetterTableField? _AcknowledgementService;
  RegisterLetterTableField get AcknowledgementService {
    return _AcknowledgementService = _setField(
        _AcknowledgementService, 'AcknowledgementService', DbType.integer);
  }

  RegisterLetterTableField? _InsuranceService;
  RegisterLetterTableField get InsuranceService {
    return _InsuranceService =
        _setField(_InsuranceService, 'InsuranceService', DbType.text);
  }

  RegisterLetterTableField? _ValuePayableService;
  RegisterLetterTableField get ValuePayableService {
    return _ValuePayableService =
        _setField(_ValuePayableService, 'ValuePayableService', DbType.text);
  }

  RegisterLetterTableField? _RegistrationFee;
  RegisterLetterTableField get RegistrationFee {
    return _RegistrationFee =
        _setField(_RegistrationFee, 'RegistrationFee', DbType.real);
  }

  RegisterLetterTableField? _AmountToBeCollected;
  RegisterLetterTableField get AmountToBeCollected {
    return _AmountToBeCollected =
        _setField(_AmountToBeCollected, 'AmountToBeCollected', DbType.text);
  }

  RegisterLetterTableField? _SenderName;
  RegisterLetterTableField get SenderName {
    return _SenderName = _setField(_SenderName, 'SenderName', DbType.text);
  }

  RegisterLetterTableField? _SenderAddress;
  RegisterLetterTableField get SenderAddress {
    return _SenderAddress =
        _setField(_SenderAddress, 'SenderAddress', DbType.text);
  }

  RegisterLetterTableField? _SenderPincode;
  RegisterLetterTableField get SenderPincode {
    return _SenderPincode =
        _setField(_SenderPincode, 'SenderPincode', DbType.integer);
  }

  RegisterLetterTableField? _SenderCity;
  RegisterLetterTableField get SenderCity {
    return _SenderCity = _setField(_SenderCity, 'SenderCity', DbType.text);
  }

  RegisterLetterTableField? _SenderState;
  RegisterLetterTableField get SenderState {
    return _SenderState = _setField(_SenderState, 'SenderState', DbType.text);
  }

  RegisterLetterTableField? _SenderMobileNumber;
  RegisterLetterTableField get SenderMobileNumber {
    return _SenderMobileNumber =
        _setField(_SenderMobileNumber, 'SenderMobileNumber', DbType.text);
  }

  RegisterLetterTableField? _SenderEmail;
  RegisterLetterTableField get SenderEmail {
    return _SenderEmail = _setField(_SenderEmail, 'SenderEmail', DbType.text);
  }

  RegisterLetterTableField? _AddresseeName;
  RegisterLetterTableField get AddresseeName {
    return _AddresseeName =
        _setField(_AddresseeName, 'AddresseeName', DbType.text);
  }

  RegisterLetterTableField? _AddresseeAddress;
  RegisterLetterTableField get AddresseeAddress {
    return _AddresseeAddress =
        _setField(_AddresseeAddress, 'AddresseeAddress', DbType.text);
  }

  RegisterLetterTableField? _AddresseePincode;
  RegisterLetterTableField get AddresseePincode {
    return _AddresseePincode =
        _setField(_AddresseePincode, 'AddresseePincode', DbType.integer);
  }

  RegisterLetterTableField? _AddresseeCity;
  RegisterLetterTableField get AddresseeCity {
    return _AddresseeCity =
        _setField(_AddresseeCity, 'AddresseeCity', DbType.text);
  }

  RegisterLetterTableField? _AddresseeState;
  RegisterLetterTableField get AddresseeState {
    return _AddresseeState =
        _setField(_AddresseeState, 'AddresseeState', DbType.text);
  }

  RegisterLetterTableField? _AddresseeMobileNumber;
  RegisterLetterTableField get AddresseeMobileNumber {
    return _AddresseeMobileNumber =
        _setField(_AddresseeMobileNumber, 'AddresseeMobileNumber', DbType.text);
  }

  RegisterLetterTableField? _AddresseeEmail;
  RegisterLetterTableField get AddresseeEmail {
    return _AddresseeEmail =
        _setField(_AddresseeEmail, 'AddresseeEmail', DbType.text);
  }

  RegisterLetterTableField? _RemarkDate;
  RegisterLetterTableField get RemarkDate {
    return _RemarkDate = _setField(_RemarkDate, 'RemarkDate', DbType.text);
  }

  /// Deletes List<RegisterLetterTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnRegisterLetterTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnRegisterLetterTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from registerLetterTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnRegisterLetterTable!.updateBatch(qparams, values);
  }

  /// This method always returns [RegisterLetterTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegisterLetterTable?
  @override
  Future<RegisterLetterTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnRegisterLetterTable!.toList(qparams);
    final data = await objFuture;
    RegisterLetterTable? obj;
    if (data.isNotEmpty) {
      obj = RegisterLetterTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [RegisterLetterTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> RegisterLetterTable?
  @override
  Future<RegisterLetterTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        RegisterLetterTable();
  }

  /// This method returns int. [RegisterLetterTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? registerlettertableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final registerlettertablesFuture =
        await _mnRegisterLetterTable!.toList(qparams);
    final int count = registerlettertablesFuture[0]['CNT'] as int;
    if (registerlettertableCount != null) {
      registerlettertableCount(count);
    }
    return count;
  }

  /// This method returns List<RegisterLetterTable> [RegisterLetterTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<RegisterLetterTable>
  @override
  Future<List<RegisterLetterTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<RegisterLetterTable> registerlettertablesData =
        await RegisterLetterTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return registerlettertablesData;
  }

  /// This method returns Json String [RegisterLetterTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [RegisterLetterTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [RegisterLetterTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnRegisterLetterTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [RegisterLetterTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM registerLetterTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture = await _mnRegisterLetterTable!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [RegisterLetterTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnRegisterLetterTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await RegisterLetterTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnRegisterLetterTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion RegisterLetterTableFilterBuilder

// region RegisterLetterTableFields
class RegisterLetterTableFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fWeightAmount;
  static TableField get WeightAmount {
    return _fWeightAmount = _fWeightAmount ??
        SqlSyntax.setField(_fWeightAmount, 'WeightAmount', DbType.text);
  }

  static TableField? _fPrepaidAmount;
  static TableField get PrepaidAmount {
    return _fPrepaidAmount = _fPrepaidAmount ??
        SqlSyntax.setField(_fPrepaidAmount, 'PrepaidAmount', DbType.integer);
  }

  static TableField? _fAcknowledgementService;
  static TableField get AcknowledgementService {
    return _fAcknowledgementService = _fAcknowledgementService ??
        SqlSyntax.setField(
            _fAcknowledgementService, 'AcknowledgementService', DbType.integer);
  }

  static TableField? _fInsuranceService;
  static TableField get InsuranceService {
    return _fInsuranceService = _fInsuranceService ??
        SqlSyntax.setField(_fInsuranceService, 'InsuranceService', DbType.text);
  }

  static TableField? _fValuePayableService;
  static TableField get ValuePayableService {
    return _fValuePayableService = _fValuePayableService ??
        SqlSyntax.setField(
            _fValuePayableService, 'ValuePayableService', DbType.text);
  }

  static TableField? _fRegistrationFee;
  static TableField get RegistrationFee {
    return _fRegistrationFee = _fRegistrationFee ??
        SqlSyntax.setField(_fRegistrationFee, 'RegistrationFee', DbType.real);
  }

  static TableField? _fAmountToBeCollected;
  static TableField get AmountToBeCollected {
    return _fAmountToBeCollected = _fAmountToBeCollected ??
        SqlSyntax.setField(
            _fAmountToBeCollected, 'AmountToBeCollected', DbType.text);
  }

  static TableField? _fSenderName;
  static TableField get SenderName {
    return _fSenderName = _fSenderName ??
        SqlSyntax.setField(_fSenderName, 'SenderName', DbType.text);
  }

  static TableField? _fSenderAddress;
  static TableField get SenderAddress {
    return _fSenderAddress = _fSenderAddress ??
        SqlSyntax.setField(_fSenderAddress, 'SenderAddress', DbType.text);
  }

  static TableField? _fSenderPincode;
  static TableField get SenderPincode {
    return _fSenderPincode = _fSenderPincode ??
        SqlSyntax.setField(_fSenderPincode, 'SenderPincode', DbType.integer);
  }

  static TableField? _fSenderCity;
  static TableField get SenderCity {
    return _fSenderCity = _fSenderCity ??
        SqlSyntax.setField(_fSenderCity, 'SenderCity', DbType.text);
  }

  static TableField? _fSenderState;
  static TableField get SenderState {
    return _fSenderState = _fSenderState ??
        SqlSyntax.setField(_fSenderState, 'SenderState', DbType.text);
  }

  static TableField? _fSenderMobileNumber;
  static TableField get SenderMobileNumber {
    return _fSenderMobileNumber = _fSenderMobileNumber ??
        SqlSyntax.setField(
            _fSenderMobileNumber, 'SenderMobileNumber', DbType.text);
  }

  static TableField? _fSenderEmail;
  static TableField get SenderEmail {
    return _fSenderEmail = _fSenderEmail ??
        SqlSyntax.setField(_fSenderEmail, 'SenderEmail', DbType.text);
  }

  static TableField? _fAddresseeName;
  static TableField get AddresseeName {
    return _fAddresseeName = _fAddresseeName ??
        SqlSyntax.setField(_fAddresseeName, 'AddresseeName', DbType.text);
  }

  static TableField? _fAddresseeAddress;
  static TableField get AddresseeAddress {
    return _fAddresseeAddress = _fAddresseeAddress ??
        SqlSyntax.setField(_fAddresseeAddress, 'AddresseeAddress', DbType.text);
  }

  static TableField? _fAddresseePincode;
  static TableField get AddresseePincode {
    return _fAddresseePincode = _fAddresseePincode ??
        SqlSyntax.setField(
            _fAddresseePincode, 'AddresseePincode', DbType.integer);
  }

  static TableField? _fAddresseeCity;
  static TableField get AddresseeCity {
    return _fAddresseeCity = _fAddresseeCity ??
        SqlSyntax.setField(_fAddresseeCity, 'AddresseeCity', DbType.text);
  }

  static TableField? _fAddresseeState;
  static TableField get AddresseeState {
    return _fAddresseeState = _fAddresseeState ??
        SqlSyntax.setField(_fAddresseeState, 'AddresseeState', DbType.text);
  }

  static TableField? _fAddresseeMobileNumber;
  static TableField get AddresseeMobileNumber {
    return _fAddresseeMobileNumber = _fAddresseeMobileNumber ??
        SqlSyntax.setField(
            _fAddresseeMobileNumber, 'AddresseeMobileNumber', DbType.text);
  }

  static TableField? _fAddresseeEmail;
  static TableField get AddresseeEmail {
    return _fAddresseeEmail = _fAddresseeEmail ??
        SqlSyntax.setField(_fAddresseeEmail, 'AddresseeEmail', DbType.text);
  }

  static TableField? _fRemarkDate;
  static TableField get RemarkDate {
    return _fRemarkDate = _fRemarkDate ??
        SqlSyntax.setField(_fRemarkDate, 'RemarkDate', DbType.text);
  }
}
// endregion RegisterLetterTableFields

//region RegisterLetterTableManager
class RegisterLetterTableManager extends SqfEntityProvider {
  RegisterLetterTableManager()
      : super(RegisterLetterFormModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'registerLetterTable';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion RegisterLetterTableManager
class RegisterLetterFormModelSequenceManager extends SqfEntityProvider {
  RegisterLetterFormModelSequenceManager() : super(RegisterLetterFormModel());
}
// END OF ENTITIES
