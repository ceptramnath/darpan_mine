// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'BagModel.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:BagReceivedTable.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// BagReceivedTable TABLE
class TableBagReceivedTable extends SqfEntityTableBase {
  TableBagReceivedTable() {
    // declare properties of EntityTable
    tableName = 'bagReceivedTable';
    primaryKeyName = 'BagNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ReceivedDate', DbType.text),
      SqfEntityFieldBase('ReceivedTime', DbType.text),
      SqfEntityFieldBase('OpenedDate', DbType.text),
      SqfEntityFieldBase('OpenedTime', DbType.text),
      SqfEntityFieldBase('ArticlesCount', DbType.text),
      SqfEntityFieldBase('StampsCount', DbType.text),
      SqfEntityFieldBase('CashCount', DbType.text),
      SqfEntityFieldBase('DocumentsCount', DbType.text),
      SqfEntityFieldBase('ArticlesStatus', DbType.text),
      SqfEntityFieldBase('CashStatus', DbType.text),
      SqfEntityFieldBase('StampsStatus', DbType.text),
      SqfEntityFieldBase('DocumentsStatus', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagReceivedTable();
  }
}

// BagArticlesTable TABLE
class TableBagArticlesTable extends SqfEntityTableBase {
  TableBagArticlesTable() {
    // declare properties of EntityTable
    tableName = 'bagArticlesTable';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ArticleNumber', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('BagNumber', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('ArticleType', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('IS_COMMUNICATED', DbType.text),
      SqfEntityFieldBase('FILE_NAME', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagArticlesTable();
  }
}

// BagStampsTable TABLE
class TableBagStampsTable extends SqfEntityTableBase {
  TableBagStampsTable() {
    // declare properties of EntityTable
    tableName = 'bagStampsTable';
    primaryKeyName = 'StampID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('StampPrice', DbType.text),
      SqfEntityFieldBase('StampName', DbType.text),
      SqfEntityFieldBase('StampQuantity', DbType.text),
      SqfEntityFieldBase('StampAmountTotal', DbType.text),
      SqfEntityFieldBase('StampDate', DbType.text),
      SqfEntityFieldBase('StampTime', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagStampsTable();
  }
}

// BagCashTable TABLE
class TableBagCashTable extends SqfEntityTableBase {
  TableBagCashTable() {
    // declare properties of EntityTable
    tableName = 'bagCashTable';
    primaryKeyName = 'CashID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('BagDate', DbType.text),
      SqfEntityFieldBase('CashReceived', DbType.text),
      SqfEntityFieldBase('CashAmount', DbType.text),
      SqfEntityFieldBase('CashType', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagCashTable();
  }
}

// BagDocumentsTable TABLE
class TableBagDocumentsTable extends SqfEntityTableBase {
  TableBagDocumentsTable() {
    // declare properties of EntityTable
    tableName = 'bagDocumentsTable';
    primaryKeyName = 'DocumentID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('DocumentName', DbType.text),
      SqfEntityFieldBase('ReceivedDate', DbType.text),
      SqfEntityFieldBase('ReceivedTime', DbType.text),
      SqfEntityFieldBase('IsAdded', DbType.text),
      SqfEntityFieldBase('DocumentStatus', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagDocumentsTable();
  }
}

// BagInventory TABLE
class TableBagInventory extends SqfEntityTableBase {
  TableBagInventory() {
    // declare properties of EntityTable
    tableName = 'bagInventory';
    primaryKeyName = 'InventoryID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('InventoryName', DbType.text),
      SqfEntityFieldBase('InventoryPrice', DbType.text),
      SqfEntityFieldBase('InventoryQuantity', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagInventory();
  }
}

// BagExcessArticlesTable TABLE
class TableBagExcessArticlesTable extends SqfEntityTableBase {
  TableBagExcessArticlesTable() {
    // declare properties of EntityTable
    tableName = 'bagExcessArticlesTable';
    primaryKeyName = 'ArticleNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('ArticleType', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagExcessArticlesTable();
  }
}

// BagExcessStampsTable TABLE
class TableBagExcessStampsTable extends SqfEntityTableBase {
  TableBagExcessStampsTable() {
    // declare properties of EntityTable
    tableName = 'bagExcessStampsTable';
    primaryKeyName = 'StampID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('StampPrice', DbType.text),
      SqfEntityFieldBase('StampName', DbType.text),
      SqfEntityFieldBase('Name', DbType.text),
      SqfEntityFieldBase('StampQuantity', DbType.text),
      SqfEntityFieldBase('StampAmountTotal', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagExcessStampsTable();
  }
}

// ProductsTable TABLE
class TableProductsTable extends SqfEntityTableBase {
  TableProductsTable() {
    // declare properties of EntityTable
    tableName = 'productsTable';
    primaryKeyName = 'ProductID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Name', DbType.text),
      SqfEntityFieldBase('Price', DbType.text),
      SqfEntityFieldBase('Quantity', DbType.text),
      SqfEntityFieldBase('Value', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableProductsTable();
  }
}

// DocumentsTable TABLE
class TableDocumentsTable extends SqfEntityTableBase {
  TableDocumentsTable() {
    // declare properties of EntityTable
    tableName = 'documentsTable';
    primaryKeyName = 'DocumentID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('DocumentName', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDocumentsTable();
  }
}

// BagCloseTable TABLE
class TableBagCloseTable extends SqfEntityTableBase {
  TableBagCloseTable() {
    // declare properties of EntityTable
    tableName = 'bagCloseTable';
    primaryKeyName = 'BagNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ClosedDate', DbType.text),
      SqfEntityFieldBase('ClosedTime', DbType.text),
      SqfEntityFieldBase('TotalArticlesCount', DbType.text),
      SqfEntityFieldBase('CashCount', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
      SqfEntityFieldBase('DispatchDate', DbType.text),
      SqfEntityFieldBase('DispatchTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagCloseTable();
  }
}

// CloseArticlesTable TABLE
class TableCloseArticlesTable extends SqfEntityTableBase {
  TableCloseArticlesTable() {
    // declare properties of EntityTable
    tableName = 'closeArticlesTable';
    primaryKeyName = 'Sl';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('ArticleNumber', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('BagNumber', DbType.text, isPrimaryKeyField: true),
      SqfEntityFieldBase('ArticleType', DbType.text),
      SqfEntityFieldBase('IsExcess', DbType.text),
      SqfEntityFieldBase('IsScanned', DbType.text),
      SqfEntityFieldBase('IsBooked', DbType.text),
      SqfEntityFieldBase('Status', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCloseArticlesTable();
  }
}

// ExcessBagCashTable TABLE
class TableExcessBagCashTable extends SqfEntityTableBase {
  TableExcessBagCashTable() {
    // declare properties of EntityTable
    tableName = 'ExcessBagCashTable';
    primaryKeyName = 'id';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SOSlipNumber', DbType.text),
      SqfEntityFieldBase('ChequeNumber', DbType.text),
      SqfEntityFieldBase('GenerationDate', DbType.text),
      SqfEntityFieldBase('BOName', DbType.text),
      SqfEntityFieldBase('SOName', DbType.text),
      SqfEntityFieldBase('CashAmount', DbType.text),
      SqfEntityFieldBase('Weight', DbType.text),
      SqfEntityFieldBase('ChequeAmount', DbType.text),
      SqfEntityFieldBase('TypeOfPayment', DbType.text),
      SqfEntityFieldBase('Miscellaneous', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableExcessBagCashTable();
  }
}

// DocumentTable TABLE
class TableDocumentTable extends SqfEntityTableBase {
  TableDocumentTable() {
    // declare properties of EntityTable
    tableName = 'DocumentTable';
    primaryKeyName = 'DocumentId';
    primaryKeyType = PrimaryKeyType.integer_auto_incremental;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BOAccountNumber', DbType.text),
      SqfEntityFieldBase('CreatedOn', DbType.text),
      SqfEntityFieldBase('FromOffice', DbType.text),
      SqfEntityFieldBase('DocumentDetails', DbType.text),
      SqfEntityFieldBase('BagNumber', DbType.text),
      SqfEntityFieldBase('FileCreated', DbType.text),
      SqfEntityFieldBase('FileName', DbType.text),
      SqfEntityFieldBase('FileCreatedDateTime', DbType.text),
      SqfEntityFieldBase('FileTransmitted', DbType.text),
      SqfEntityFieldBase('FileTransmittedDateTime', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableDocumentTable();
  }
}

// BagTable TABLE
class TableBagTable extends SqfEntityTableBase {
  TableBagTable() {
    // declare properties of EntityTable
    tableName = 'bagTable';
    primaryKeyName = 'BagNumber';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('BagDate', DbType.text),
      SqfEntityFieldBase('BagTime', DbType.text),
      SqfEntityFieldBase('BagType', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableBagTable();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class BagModel extends SqfEntityModelProvider {
  BagModel() {
    databaseName = formLetterModel.databaseName;
    password = formLetterModel.password;
    dbVersion = formLetterModel.dbVersion;
    preSaveAction = formLetterModel.preSaveAction;
    logFunction = formLetterModel.logFunction;
    databaseTables = [
      TableBagReceivedTable.getInstance,
      TableBagArticlesTable.getInstance,
      TableBagStampsTable.getInstance,
      TableBagCashTable.getInstance,
      TableBagDocumentsTable.getInstance,
      TableBagInventory.getInstance,
      TableBagExcessArticlesTable.getInstance,
      TableBagExcessStampsTable.getInstance,
      TableProductsTable.getInstance,
      TableDocumentsTable.getInstance,
      TableBagCloseTable.getInstance,
      TableCloseArticlesTable.getInstance,
      TableExcessBagCashTable.getInstance,
      TableDocumentTable.getInstance,
      TableBagTable.getInstance,
    ];

    bundledDatabasePath = formLetterModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = formLetterModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region BagReceivedTable
class BagReceivedTable extends TableBase {
  BagReceivedTable(
      {this.BagNumber,
      this.ReceivedDate,
      this.ReceivedTime,
      this.OpenedDate,
      this.OpenedTime,
      this.ArticlesCount,
      this.StampsCount,
      this.CashCount,
      this.DocumentsCount,
      this.ArticlesStatus,
      this.CashStatus,
      this.StampsStatus,
      this.DocumentsStatus,
      this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagReceivedTable.withFields(
      this.BagNumber,
      this.ReceivedDate,
      this.ReceivedTime,
      this.OpenedDate,
      this.OpenedTime,
      this.ArticlesCount,
      this.StampsCount,
      this.CashCount,
      this.DocumentsCount,
      this.ArticlesStatus,
      this.CashStatus,
      this.StampsStatus,
      this.DocumentsStatus,
      this.Status) {
    _setDefaultValues();
  }
  BagReceivedTable.withId(
      this.BagNumber,
      this.ReceivedDate,
      this.ReceivedTime,
      this.OpenedDate,
      this.OpenedTime,
      this.ArticlesCount,
      this.StampsCount,
      this.CashCount,
      this.DocumentsCount,
      this.ArticlesStatus,
      this.CashStatus,
      this.StampsStatus,
      this.DocumentsStatus,
      this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagReceivedTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BagNumber = o['BagNumber'].toString();
    if (o['ReceivedDate'] != null) {
      ReceivedDate = o['ReceivedDate'].toString();
    }
    if (o['ReceivedTime'] != null) {
      ReceivedTime = o['ReceivedTime'].toString();
    }
    if (o['OpenedDate'] != null) {
      OpenedDate = o['OpenedDate'].toString();
    }
    if (o['OpenedTime'] != null) {
      OpenedTime = o['OpenedTime'].toString();
    }
    if (o['ArticlesCount'] != null) {
      ArticlesCount = o['ArticlesCount'].toString();
    }
    if (o['StampsCount'] != null) {
      StampsCount = o['StampsCount'].toString();
    }
    if (o['CashCount'] != null) {
      CashCount = o['CashCount'].toString();
    }
    if (o['DocumentsCount'] != null) {
      DocumentsCount = o['DocumentsCount'].toString();
    }
    if (o['ArticlesStatus'] != null) {
      ArticlesStatus = o['ArticlesStatus'].toString();
    }
    if (o['CashStatus'] != null) {
      CashStatus = o['CashStatus'].toString();
    }
    if (o['StampsStatus'] != null) {
      StampsStatus = o['StampsStatus'].toString();
    }
    if (o['DocumentsStatus'] != null) {
      DocumentsStatus = o['DocumentsStatus'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagReceivedTable)
  String? BagNumber;
  String? ReceivedDate;
  String? ReceivedTime;
  String? OpenedDate;
  String? OpenedTime;
  String? ArticlesCount;
  String? StampsCount;
  String? CashCount;
  String? DocumentsCount;
  String? ArticlesStatus;
  String? CashStatus;
  String? StampsStatus;
  String? DocumentsStatus;
  String? Status;
  bool? isSaved;
  // end FIELDS (BagReceivedTable)

  static const bool _softDeleteActivated = false;
  BagReceivedTableManager? __mnBagReceivedTable;

  BagReceivedTableManager get _mnBagReceivedTable {
    return __mnBagReceivedTable =
        __mnBagReceivedTable ?? BagReceivedTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (ReceivedDate != null || !forView) {
      map['ReceivedDate'] = ReceivedDate;
    }
    if (ReceivedTime != null || !forView) {
      map['ReceivedTime'] = ReceivedTime;
    }
    if (OpenedDate != null || !forView) {
      map['OpenedDate'] = OpenedDate;
    }
    if (OpenedTime != null || !forView) {
      map['OpenedTime'] = OpenedTime;
    }
    if (ArticlesCount != null || !forView) {
      map['ArticlesCount'] = ArticlesCount;
    }
    if (StampsCount != null || !forView) {
      map['StampsCount'] = StampsCount;
    }
    if (CashCount != null || !forView) {
      map['CashCount'] = CashCount;
    }
    if (DocumentsCount != null || !forView) {
      map['DocumentsCount'] = DocumentsCount;
    }
    if (ArticlesStatus != null || !forView) {
      map['ArticlesStatus'] = ArticlesStatus;
    }
    if (CashStatus != null || !forView) {
      map['CashStatus'] = CashStatus;
    }
    if (StampsStatus != null || !forView) {
      map['StampsStatus'] = StampsStatus;
    }
    if (DocumentsStatus != null || !forView) {
      map['DocumentsStatus'] = DocumentsStatus;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (ReceivedDate != null || !forView) {
      map['ReceivedDate'] = ReceivedDate;
    }
    if (ReceivedTime != null || !forView) {
      map['ReceivedTime'] = ReceivedTime;
    }
    if (OpenedDate != null || !forView) {
      map['OpenedDate'] = OpenedDate;
    }
    if (OpenedTime != null || !forView) {
      map['OpenedTime'] = OpenedTime;
    }
    if (ArticlesCount != null || !forView) {
      map['ArticlesCount'] = ArticlesCount;
    }
    if (StampsCount != null || !forView) {
      map['StampsCount'] = StampsCount;
    }
    if (CashCount != null || !forView) {
      map['CashCount'] = CashCount;
    }
    if (DocumentsCount != null || !forView) {
      map['DocumentsCount'] = DocumentsCount;
    }
    if (ArticlesStatus != null || !forView) {
      map['ArticlesStatus'] = ArticlesStatus;
    }
    if (CashStatus != null || !forView) {
      map['CashStatus'] = CashStatus;
    }
    if (StampsStatus != null || !forView) {
      map['StampsStatus'] = StampsStatus;
    }
    if (DocumentsStatus != null || !forView) {
      map['DocumentsStatus'] = DocumentsStatus;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [BagReceivedTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagReceivedTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BagNumber,
      ReceivedDate,
      ReceivedTime,
      OpenedDate,
      OpenedTime,
      ArticlesCount,
      StampsCount,
      CashCount,
      DocumentsCount,
      ArticlesStatus,
      CashStatus,
      StampsStatus,
      DocumentsStatus,
      Status
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BagNumber,
      ReceivedDate,
      ReceivedTime,
      OpenedDate,
      OpenedTime,
      ArticlesCount,
      StampsCount,
      CashCount,
      DocumentsCount,
      ArticlesStatus,
      CashStatus,
      StampsStatus,
      DocumentsStatus,
      Status
    ];
  }

  static Future<List<BagReceivedTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagReceivedTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagReceivedTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagReceivedTable>[];
    try {
      objList = list
          .map((bagreceivedtable) => BagReceivedTable.fromMap(
              bagreceivedtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagReceivedTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagReceivedTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagReceivedTable> objList = <BagReceivedTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagReceivedTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagReceivedTable by ID if exist, otherwise returns null
  /// Primary Keys: String? BagNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagReceivedTable] if exist, otherwise returns null
  Future<BagReceivedTable?> getById(String? BagNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BagNumber == null) {
      return null;
    }
    BagReceivedTable? obj;
    final data = await _mnBagReceivedTable.getById([BagNumber]);
    if (data.length != 0) {
      obj = BagReceivedTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagReceivedTable) object. If the Primary Key (BagNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BagNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagReceivedTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagReceivedTable (BagNumber, ReceivedDate, ReceivedTime, OpenedDate, OpenedTime, ArticlesCount, StampsCount, CashCount, DocumentsCount, ArticlesStatus, CashStatus, StampsStatus, DocumentsStatus, Status)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagReceivedTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagReceivedTable> bagreceivedtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagreceivedtables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagReceivedTable.rawInsert(
          'INSERT OR REPLACE INTO bagReceivedTable (BagNumber, ReceivedDate, ReceivedTime, OpenedDate, OpenedTime, ArticlesCount, StampsCount, CashCount, DocumentsCount, ArticlesStatus, CashStatus, StampsStatus, DocumentsStatus, Status)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            BagNumber,
            ReceivedDate,
            ReceivedTime,
            OpenedDate,
            OpenedTime,
            ArticlesCount,
            StampsCount,
            CashCount,
            DocumentsCount,
            ArticlesStatus,
            CashStatus,
            StampsStatus,
            DocumentsStatus,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagReceivedTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagReceivedTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagReceivedTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagReceivedTable.rawInsert(
          'INSERT OR IGNORE INTO bagReceivedTable (BagNumber, ReceivedDate, ReceivedTime, OpenedDate, OpenedTime, ArticlesCount, StampsCount, CashCount, DocumentsCount, ArticlesStatus, CashStatus, StampsStatus, DocumentsStatus, Status)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            BagNumber,
            ReceivedDate,
            ReceivedTime,
            OpenedDate,
            OpenedTime,
            ArticlesCount,
            StampsCount,
            CashCount,
            DocumentsCount,
            ArticlesStatus,
            CashStatus,
            StampsStatus,
            DocumentsStatus,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagReceivedTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagReceivedTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagReceivedTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagReceivedTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagReceivedTable invoked (BagNumber=$BagNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagReceivedTable.delete(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]));
    } else {
      return _mnBagReceivedTable.updateBatch(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagReceivedTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagReceivedTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagReceivedTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagReceivedTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagReceivedTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BagNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagreceivedtable

// region BagReceivedTableField
class BagReceivedTableField extends FilterBase {
  BagReceivedTableField(BagReceivedTableFilterBuilder bagreceivedtableFB)
      : super(bagreceivedtableFB);

  @override
  BagReceivedTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder isNull() {
    return super.isNull() as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagReceivedTableFilterBuilder;
  }

  @override
  BagReceivedTableField get not {
    return super.not as BagReceivedTableField;
  }
}
// endregion BagReceivedTableField

// region BagReceivedTableFilterBuilder
class BagReceivedTableFilterBuilder extends ConjunctionBase {
  BagReceivedTableFilterBuilder(BagReceivedTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagReceivedTable = obj._mnBagReceivedTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagReceivedTableManager? _mnBagReceivedTable;

  /// put the sql keyword 'AND'
  @override
  BagReceivedTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagReceivedTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagReceivedTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagReceivedTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagReceivedTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagReceivedTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagReceivedTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagReceivedTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagReceivedTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagReceivedTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagReceivedTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagReceivedTableField _setField(
      BagReceivedTableField? field, String colName, DbType dbtype) {
    return BagReceivedTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagReceivedTableField? _BagNumber;
  BagReceivedTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.integer);
  }

  BagReceivedTableField? _ReceivedDate;
  BagReceivedTableField get ReceivedDate {
    return _ReceivedDate =
        _setField(_ReceivedDate, 'ReceivedDate', DbType.text);
  }

  BagReceivedTableField? _ReceivedTime;
  BagReceivedTableField get ReceivedTime {
    return _ReceivedTime =
        _setField(_ReceivedTime, 'ReceivedTime', DbType.text);
  }

  BagReceivedTableField? _OpenedDate;
  BagReceivedTableField get OpenedDate {
    return _OpenedDate = _setField(_OpenedDate, 'OpenedDate', DbType.text);
  }

  BagReceivedTableField? _OpenedTime;
  BagReceivedTableField get OpenedTime {
    return _OpenedTime = _setField(_OpenedTime, 'OpenedTime', DbType.text);
  }

  BagReceivedTableField? _ArticlesCount;
  BagReceivedTableField get ArticlesCount {
    return _ArticlesCount =
        _setField(_ArticlesCount, 'ArticlesCount', DbType.text);
  }

  BagReceivedTableField? _StampsCount;
  BagReceivedTableField get StampsCount {
    return _StampsCount = _setField(_StampsCount, 'StampsCount', DbType.text);
  }

  BagReceivedTableField? _CashCount;
  BagReceivedTableField get CashCount {
    return _CashCount = _setField(_CashCount, 'CashCount', DbType.text);
  }

  BagReceivedTableField? _DocumentsCount;
  BagReceivedTableField get DocumentsCount {
    return _DocumentsCount =
        _setField(_DocumentsCount, 'DocumentsCount', DbType.text);
  }

  BagReceivedTableField? _ArticlesStatus;
  BagReceivedTableField get ArticlesStatus {
    return _ArticlesStatus =
        _setField(_ArticlesStatus, 'ArticlesStatus', DbType.text);
  }

  BagReceivedTableField? _CashStatus;
  BagReceivedTableField get CashStatus {
    return _CashStatus = _setField(_CashStatus, 'CashStatus', DbType.text);
  }

  BagReceivedTableField? _StampsStatus;
  BagReceivedTableField get StampsStatus {
    return _StampsStatus =
        _setField(_StampsStatus, 'StampsStatus', DbType.text);
  }

  BagReceivedTableField? _DocumentsStatus;
  BagReceivedTableField get DocumentsStatus {
    return _DocumentsStatus =
        _setField(_DocumentsStatus, 'DocumentsStatus', DbType.text);
  }

  BagReceivedTableField? _Status;
  BagReceivedTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<BagReceivedTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagReceivedTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagReceivedTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BagNumber IN (SELECT BagNumber from bagReceivedTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagReceivedTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagReceivedTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagReceivedTable?
  @override
  Future<BagReceivedTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagReceivedTable!.toList(qparams);
    final data = await objFuture;
    BagReceivedTable? obj;
    if (data.isNotEmpty) {
      obj = BagReceivedTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagReceivedTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagReceivedTable?
  @override
  Future<BagReceivedTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagReceivedTable();
  }

  /// This method returns int. [BagReceivedTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagreceivedtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagreceivedtablesFuture = await _mnBagReceivedTable!.toList(qparams);
    final int count = bagreceivedtablesFuture[0]['CNT'] as int;
    if (bagreceivedtableCount != null) {
      bagreceivedtableCount(count);
    }
    return count;
  }

  /// This method returns List<BagReceivedTable> [BagReceivedTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagReceivedTable>
  @override
  Future<List<BagReceivedTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagReceivedTable> bagreceivedtablesData =
        await BagReceivedTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagreceivedtablesData;
  }

  /// This method returns Json String [BagReceivedTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagReceivedTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagReceivedTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagReceivedTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagReceivedTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BagNumber` FROM bagReceivedTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BagNumberData = <String>[];
    qparams.selectColumns = ['BagNumber'];
    final BagNumberFuture = await _mnBagReceivedTable!.toList(qparams);

    final int count = BagNumberFuture.length;
    for (int i = 0; i < count; i++) {
      BagNumberData.add(BagNumberFuture[i]['BagNumber'] as String);
    }
    return BagNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagReceivedTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagReceivedTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagReceivedTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagReceivedTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagReceivedTableFilterBuilder

// region BagReceivedTableFields
class BagReceivedTableFields {
  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'bagnumber', DbType.integer);
  }

  static TableField? _fReceivedDate;
  static TableField get ReceivedDate {
    return _fReceivedDate = _fReceivedDate ??
        SqlSyntax.setField(_fReceivedDate, 'ReceivedDate', DbType.text);
  }

  static TableField? _fReceivedTime;
  static TableField get ReceivedTime {
    return _fReceivedTime = _fReceivedTime ??
        SqlSyntax.setField(_fReceivedTime, 'ReceivedTime', DbType.text);
  }

  static TableField? _fOpenedDate;
  static TableField get OpenedDate {
    return _fOpenedDate = _fOpenedDate ??
        SqlSyntax.setField(_fOpenedDate, 'OpenedDate', DbType.text);
  }

  static TableField? _fOpenedTime;
  static TableField get OpenedTime {
    return _fOpenedTime = _fOpenedTime ??
        SqlSyntax.setField(_fOpenedTime, 'OpenedTime', DbType.text);
  }

  static TableField? _fArticlesCount;
  static TableField get ArticlesCount {
    return _fArticlesCount = _fArticlesCount ??
        SqlSyntax.setField(_fArticlesCount, 'ArticlesCount', DbType.text);
  }

  static TableField? _fStampsCount;
  static TableField get StampsCount {
    return _fStampsCount = _fStampsCount ??
        SqlSyntax.setField(_fStampsCount, 'StampsCount', DbType.text);
  }

  static TableField? _fCashCount;
  static TableField get CashCount {
    return _fCashCount = _fCashCount ??
        SqlSyntax.setField(_fCashCount, 'CashCount', DbType.text);
  }

  static TableField? _fDocumentsCount;
  static TableField get DocumentsCount {
    return _fDocumentsCount = _fDocumentsCount ??
        SqlSyntax.setField(_fDocumentsCount, 'DocumentsCount', DbType.text);
  }

  static TableField? _fArticlesStatus;
  static TableField get ArticlesStatus {
    return _fArticlesStatus = _fArticlesStatus ??
        SqlSyntax.setField(_fArticlesStatus, 'ArticlesStatus', DbType.text);
  }

  static TableField? _fCashStatus;
  static TableField get CashStatus {
    return _fCashStatus = _fCashStatus ??
        SqlSyntax.setField(_fCashStatus, 'CashStatus', DbType.text);
  }

  static TableField? _fStampsStatus;
  static TableField get StampsStatus {
    return _fStampsStatus = _fStampsStatus ??
        SqlSyntax.setField(_fStampsStatus, 'StampsStatus', DbType.text);
  }

  static TableField? _fDocumentsStatus;
  static TableField get DocumentsStatus {
    return _fDocumentsStatus = _fDocumentsStatus ??
        SqlSyntax.setField(_fDocumentsStatus, 'DocumentsStatus', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion BagReceivedTableFields

//region BagReceivedTableManager
class BagReceivedTableManager extends SqfEntityProvider {
  BagReceivedTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagReceivedTable';
  static const List<String> _primaryKeyList = ['BagNumber'];
  static const String _whereStr = 'BagNumber=?';
}

//endregion BagReceivedTableManager
// region BagArticlesTable
class BagArticlesTable extends TableBase {
  BagArticlesTable(
      {this.Sl,
      this.ArticleNumber,
      this.BagNumber,
      this.ArticleType,
      this.Status,
      this.IS_COMMUNICATED,
      this.FILE_NAME}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagArticlesTable.withFields(this.ArticleNumber, this.BagNumber,
      this.ArticleType, this.Status, this.IS_COMMUNICATED, this.FILE_NAME) {
    _setDefaultValues();
  }
  BagArticlesTable.withId(this.Sl, this.ArticleNumber, this.BagNumber,
      this.ArticleType, this.Status, this.IS_COMMUNICATED, this.FILE_NAME) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagArticlesTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['ArticleNumber'] != null) {
      ArticleNumber = o['ArticleNumber'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['ArticleType'] != null) {
      ArticleType = o['ArticleType'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['IS_COMMUNICATED'] != null) {
      IS_COMMUNICATED = o['IS_COMMUNICATED'].toString();
    }
    if (o['FILE_NAME'] != null) {
      FILE_NAME = o['FILE_NAME'].toString();
    }
  }
  // FIELDS (BagArticlesTable)
  int? Sl;
  String? ArticleNumber;
  String? BagNumber;
  String? ArticleType;
  String? Status;
  String? IS_COMMUNICATED;
  String? FILE_NAME;

  // end FIELDS (BagArticlesTable)

  static const bool _softDeleteActivated = false;
  BagArticlesTableManager? __mnBagArticlesTable;

  BagArticlesTableManager get _mnBagArticlesTable {
    return __mnBagArticlesTable =
        __mnBagArticlesTable ?? BagArticlesTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (IS_COMMUNICATED != null || !forView) {
      map['IS_COMMUNICATED'] = IS_COMMUNICATED;
    }
    if (FILE_NAME != null || !forView) {
      map['FILE_NAME'] = FILE_NAME;
    }

    return map;
  }

  /// This method returns Json String [BagArticlesTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      BagNumber,
      ArticleType,
      Status,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      ArticleNumber,
      BagNumber,
      ArticleType,
      Status,
      IS_COMMUNICATED,
      FILE_NAME
    ];
  }

  static Future<List<BagArticlesTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagArticlesTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagArticlesTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagArticlesTable>[];
    try {
      objList = list
          .map((bagarticlestable) => BagArticlesTable.fromMap(
              bagarticlestable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagArticlesTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagArticlesTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagArticlesTable> objList = <BagArticlesTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagArticlesTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagArticlesTable by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? ArticleNumber, String? BagNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagArticlesTable] if exist, otherwise returns null
  Future<BagArticlesTable?> getById(
      int? Sl, String? ArticleNumber, String? BagNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    BagArticlesTable? obj;
    final data =
        await _mnBagArticlesTable.getById([Sl, ArticleNumber, BagNumber]);
    if (data.length != 0) {
      obj = BagArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagArticlesTable) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagArticlesTable.rawInsert(
          'INSERT OR REPLACE INTO bagArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, Status, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs BagArticlesTable
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagArticlesTable.rawInsert(
          'INSERT INTO bagArticlesTable ( ArticleNumber, BagNumber, ArticleType, Status, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?)',
          [
            ArticleNumber,
            BagNumber,
            ArticleType,
            Status,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<BagArticlesTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagArticlesTable> bagarticlestables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagarticlestables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < bagarticlestables.length; i++) {
        if (bagarticlestables[i].Sl == null) {
          bagarticlestables[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagArticlesTable.rawInsert(
          'INSERT OR REPLACE INTO bagArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, Status, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            ArticleNumber,
            BagNumber,
            ArticleType,
            Status,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BagArticlesTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagArticlesTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagArticlesTable.rawInsert(
          'INSERT OR IGNORE INTO bagArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, Status, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?)',
          [
            Sl,
            ArticleNumber,
            BagNumber,
            ArticleType,
            Status,
            IS_COMMUNICATED,
            FILE_NAME
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BagArticlesTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagArticlesTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<BagArticlesTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<BagArticlesTable> bagarticlestables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnBagArticlesTable.rawInsertAll(
        'INSERT OR REPLACE INTO bagArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, Status, IS_COMMUNICATED, FILE_NAME)  VALUES (?,?,?,?,?,?,?)',
        bagarticlestables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes BagArticlesTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BagArticlesTable invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagArticlesTable.delete(QueryParams(
          whereString: 'Sl=? AND ArticleNumber=? AND BagNumber=?',
          whereArguments: [Sl, ArticleNumber, BagNumber]));
    } else {
      return _mnBagArticlesTable.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND ArticleNumber=? AND BagNumber=?',
              whereArguments: [Sl, ArticleNumber, BagNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagArticlesTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagArticlesTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagArticlesTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      ArticleNumber = null;
      BagNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagarticlestable

// region BagArticlesTableField
class BagArticlesTableField extends FilterBase {
  BagArticlesTableField(BagArticlesTableFilterBuilder bagarticlestableFB)
      : super(bagarticlestableFB);

  @override
  BagArticlesTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder isNull() {
    return super.isNull() as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagArticlesTableFilterBuilder;
  }

  @override
  BagArticlesTableField get not {
    return super.not as BagArticlesTableField;
  }
}
// endregion BagArticlesTableField

// region BagArticlesTableFilterBuilder
class BagArticlesTableFilterBuilder extends ConjunctionBase {
  BagArticlesTableFilterBuilder(BagArticlesTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagArticlesTable = obj._mnBagArticlesTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagArticlesTableManager? _mnBagArticlesTable;

  /// put the sql keyword 'AND'
  @override
  BagArticlesTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagArticlesTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagArticlesTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagArticlesTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagArticlesTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagArticlesTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagArticlesTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagArticlesTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagArticlesTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagArticlesTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagArticlesTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagArticlesTableField _setField(
      BagArticlesTableField? field, String colName, DbType dbtype) {
    return BagArticlesTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagArticlesTableField? _Sl;
  BagArticlesTableField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  BagArticlesTableField? _ArticleNumber;
  BagArticlesTableField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.text);
  }

  BagArticlesTableField? _BagNumber;
  BagArticlesTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagArticlesTableField? _ArticleType;
  BagArticlesTableField get ArticleType {
    return _ArticleType = _setField(_ArticleType, 'ArticleType', DbType.text);
  }

  BagArticlesTableField? _Status;
  BagArticlesTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  BagArticlesTableField? _IS_COMMUNICATED;
  BagArticlesTableField get IS_COMMUNICATED {
    return _IS_COMMUNICATED =
        _setField(_IS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  BagArticlesTableField? _FILE_NAME;
  BagArticlesTableField get FILE_NAME {
    return _FILE_NAME = _setField(_FILE_NAME, 'FILE_NAME', DbType.text);
  }

  /// Deletes List<BagArticlesTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagArticlesTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagArticlesTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from bagArticlesTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagArticlesTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagArticlesTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagArticlesTable?
  @override
  Future<BagArticlesTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagArticlesTable!.toList(qparams);
    final data = await objFuture;
    BagArticlesTable? obj;
    if (data.isNotEmpty) {
      obj = BagArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagArticlesTable?
  @override
  Future<BagArticlesTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagArticlesTable();
  }

  /// This method returns int. [BagArticlesTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagarticlestableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagarticlestablesFuture = await _mnBagArticlesTable!.toList(qparams);
    final int count = bagarticlestablesFuture[0]['CNT'] as int;
    if (bagarticlestableCount != null) {
      bagarticlestableCount(count);
    }
    return count;
  }

  /// This method returns List<BagArticlesTable> [BagArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagArticlesTable>
  @override
  Future<List<BagArticlesTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagArticlesTable> bagarticlestablesData =
        await BagArticlesTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagarticlestablesData;
  }

  /// This method returns Json String [BagArticlesTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagArticlesTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagArticlesTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagArticlesTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`ArticleNumber`BagNumber` FROM bagArticlesTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,ArticleNumber,BagNumber> [BagArticlesTable]
  /// <returns>List<Sl,ArticleNumber,BagNumber>
  @override
  Future<List<BagArticlesTable>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'ArticleNumber', 'BagNumber'];
    final bagarticlestableFuture = await _mnBagArticlesTable!.toList(qparams);
    return await BagArticlesTable.fromMapList(bagarticlestableFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagArticlesTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagArticlesTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagArticlesTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagArticlesTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagArticlesTableFilterBuilder

// region BagArticlesTableFields
class BagArticlesTableFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'ArticleNumber', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fArticleType;
  static TableField get ArticleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'ArticleType', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fIS_COMMUNICATED;
  static TableField get IS_COMMUNICATED {
    return _fIS_COMMUNICATED = _fIS_COMMUNICATED ??
        SqlSyntax.setField(_fIS_COMMUNICATED, 'IS_COMMUNICATED', DbType.text);
  }

  static TableField? _fFILE_NAME;
  static TableField get FILE_NAME {
    return _fFILE_NAME = _fFILE_NAME ??
        SqlSyntax.setField(_fFILE_NAME, 'FILE_NAME', DbType.text);
  }
}
// endregion BagArticlesTableFields

//region BagArticlesTableManager
class BagArticlesTableManager extends SqfEntityProvider {
  BagArticlesTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagArticlesTable';
  static const List<String> _primaryKeyList = [
    'Sl',
    'ArticleNumber',
    'BagNumber'
  ];
  static const String _whereStr = 'Sl=? AND ArticleNumber=? AND BagNumber=?';
}

//endregion BagArticlesTableManager
// region BagStampsTable
class BagStampsTable extends TableBase {
  BagStampsTable(
      {this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.StampQuantity,
      this.StampAmountTotal,
      this.StampDate,
      this.StampTime,
      this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagStampsTable.withFields(
      this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.StampQuantity,
      this.StampAmountTotal,
      this.StampDate,
      this.StampTime,
      this.Status) {
    _setDefaultValues();
  }
  BagStampsTable.withId(
      this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.StampQuantity,
      this.StampAmountTotal,
      this.StampDate,
      this.StampTime,
      this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagStampsTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    StampID = o['StampID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['StampPrice'] != null) {
      StampPrice = o['StampPrice'].toString();
    }
    if (o['StampName'] != null) {
      StampName = o['StampName'].toString();
    }
    if (o['StampQuantity'] != null) {
      StampQuantity = o['StampQuantity'].toString();
    }
    if (o['StampAmountTotal'] != null) {
      StampAmountTotal = o['StampAmountTotal'].toString();
    }
    if (o['StampDate'] != null) {
      StampDate = o['StampDate'].toString();
    }
    if (o['StampTime'] != null) {
      StampTime = o['StampTime'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagStampsTable)
  String? StampID;
  String? BagNumber;
  String? StampPrice;
  String? StampName;
  String? StampQuantity;
  String? StampAmountTotal;
  String? StampDate;
  String? StampTime;
  String? Status;
  bool? isSaved;
  // end FIELDS (BagStampsTable)

  static const bool _softDeleteActivated = false;
  BagStampsTableManager? __mnBagStampsTable;

  BagStampsTableManager get _mnBagStampsTable {
    return __mnBagStampsTable = __mnBagStampsTable ?? BagStampsTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['StampID'] = StampID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (StampPrice != null || !forView) {
      map['StampPrice'] = StampPrice;
    }
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (StampQuantity != null || !forView) {
      map['StampQuantity'] = StampQuantity;
    }
    if (StampAmountTotal != null || !forView) {
      map['StampAmountTotal'] = StampAmountTotal;
    }
    if (StampDate != null || !forView) {
      map['StampDate'] = StampDate;
    }
    if (StampTime != null || !forView) {
      map['StampTime'] = StampTime;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['StampID'] = StampID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (StampPrice != null || !forView) {
      map['StampPrice'] = StampPrice;
    }
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (StampQuantity != null || !forView) {
      map['StampQuantity'] = StampQuantity;
    }
    if (StampAmountTotal != null || !forView) {
      map['StampAmountTotal'] = StampAmountTotal;
    }
    if (StampDate != null || !forView) {
      map['StampDate'] = StampDate;
    }
    if (StampTime != null || !forView) {
      map['StampTime'] = StampTime;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [BagStampsTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagStampsTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      StampID,
      BagNumber,
      StampPrice,
      StampName,
      StampQuantity,
      StampAmountTotal,
      StampDate,
      StampTime,
      Status
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      StampID,
      BagNumber,
      StampPrice,
      StampName,
      StampQuantity,
      StampAmountTotal,
      StampDate,
      StampTime,
      Status
    ];
  }

  static Future<List<BagStampsTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagStampsTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagStampsTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagStampsTable>[];
    try {
      objList = list
          .map((bagstampstable) =>
              BagStampsTable.fromMap(bagstampstable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagStampsTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagStampsTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagStampsTable> objList = <BagStampsTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagStampsTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagStampsTable by ID if exist, otherwise returns null
  /// Primary Keys: String? StampID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagStampsTable] if exist, otherwise returns null
  Future<BagStampsTable?> getById(String? StampID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (StampID == null) {
      return null;
    }
    BagStampsTable? obj;
    final data = await _mnBagStampsTable.getById([StampID]);
    if (data.length != 0) {
      obj = BagStampsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagStampsTable) object. If the Primary Key (StampID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same StampID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagStampsTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagStampsTable (StampID, BagNumber, StampPrice, StampName, StampQuantity, StampAmountTotal, StampDate, StampTime, Status)  VALUES (?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagStampsTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagStampsTable> bagstampstables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagstampstables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagStampsTable.rawInsert(
          'INSERT OR REPLACE INTO bagStampsTable (StampID, BagNumber, StampPrice, StampName, StampQuantity, StampAmountTotal, StampDate, StampTime, Status)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            StampID,
            BagNumber,
            StampPrice,
            StampName,
            StampQuantity,
            StampAmountTotal,
            StampDate,
            StampTime,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagStampsTable StampID=$StampID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagStampsTable StampID=$StampID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagStampsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagStampsTable.rawInsert(
          'INSERT OR IGNORE INTO bagStampsTable (StampID, BagNumber, StampPrice, StampName, StampQuantity, StampAmountTotal, StampDate, StampTime, Status)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            StampID,
            BagNumber,
            StampPrice,
            StampName,
            StampQuantity,
            StampAmountTotal,
            StampDate,
            StampTime,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagStampsTable StampID=$StampID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagStampsTable StampID=$StampID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagStampsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagStampsTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BagStampsTable invoked (StampID=$StampID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagStampsTable.delete(
          QueryParams(whereString: 'StampID=?', whereArguments: [StampID]));
    } else {
      return _mnBagStampsTable.updateBatch(
          QueryParams(whereString: 'StampID=?', whereArguments: [StampID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagStampsTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagStampsTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagStampsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagStampsTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagStampsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      StampID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagstampstable

// region BagStampsTableField
class BagStampsTableField extends FilterBase {
  BagStampsTableField(BagStampsTableFilterBuilder bagstampstableFB)
      : super(bagstampstableFB);

  @override
  BagStampsTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder isNull() {
    return super.isNull() as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagStampsTableFilterBuilder;
  }

  @override
  BagStampsTableField get not {
    return super.not as BagStampsTableField;
  }
}
// endregion BagStampsTableField

// region BagStampsTableFilterBuilder
class BagStampsTableFilterBuilder extends ConjunctionBase {
  BagStampsTableFilterBuilder(BagStampsTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagStampsTable = obj._mnBagStampsTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagStampsTableManager? _mnBagStampsTable;

  /// put the sql keyword 'AND'
  @override
  BagStampsTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagStampsTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagStampsTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagStampsTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagStampsTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagStampsTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagStampsTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagStampsTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagStampsTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagStampsTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagStampsTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagStampsTableField _setField(
      BagStampsTableField? field, String colName, DbType dbtype) {
    return BagStampsTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagStampsTableField? _StampID;
  BagStampsTableField get StampID {
    return _StampID = _setField(_StampID, 'StampID', DbType.integer);
  }

  BagStampsTableField? _BagNumber;
  BagStampsTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagStampsTableField? _StampPrice;
  BagStampsTableField get StampPrice {
    return _StampPrice = _setField(_StampPrice, 'StampPrice', DbType.text);
  }

  BagStampsTableField? _StampName;
  BagStampsTableField get StampName {
    return _StampName = _setField(_StampName, 'StampName', DbType.text);
  }

  BagStampsTableField? _StampQuantity;
  BagStampsTableField get StampQuantity {
    return _StampQuantity =
        _setField(_StampQuantity, 'StampQuantity', DbType.text);
  }

  BagStampsTableField? _StampAmountTotal;
  BagStampsTableField get StampAmountTotal {
    return _StampAmountTotal =
        _setField(_StampAmountTotal, 'StampAmountTotal', DbType.text);
  }

  BagStampsTableField? _StampDate;
  BagStampsTableField get StampDate {
    return _StampDate = _setField(_StampDate, 'StampDate', DbType.text);
  }

  BagStampsTableField? _StampTime;
  BagStampsTableField get StampTime {
    return _StampTime = _setField(_StampTime, 'StampTime', DbType.text);
  }

  BagStampsTableField? _Status;
  BagStampsTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<BagStampsTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagStampsTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagStampsTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'StampID IN (SELECT StampID from bagStampsTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagStampsTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagStampsTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagStampsTable?
  @override
  Future<BagStampsTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagStampsTable!.toList(qparams);
    final data = await objFuture;
    BagStampsTable? obj;
    if (data.isNotEmpty) {
      obj = BagStampsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagStampsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagStampsTable?
  @override
  Future<BagStampsTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagStampsTable();
  }

  /// This method returns int. [BagStampsTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagstampstableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagstampstablesFuture = await _mnBagStampsTable!.toList(qparams);
    final int count = bagstampstablesFuture[0]['CNT'] as int;
    if (bagstampstableCount != null) {
      bagstampstableCount(count);
    }
    return count;
  }

  /// This method returns List<BagStampsTable> [BagStampsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagStampsTable>
  @override
  Future<List<BagStampsTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagStampsTable> bagstampstablesData =
        await BagStampsTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagstampstablesData;
  }

  /// This method returns Json String [BagStampsTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagStampsTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagStampsTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagStampsTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagStampsTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `StampID` FROM bagStampsTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> StampIDData = <String>[];
    qparams.selectColumns = ['StampID'];
    final StampIDFuture = await _mnBagStampsTable!.toList(qparams);

    final int count = StampIDFuture.length;
    for (int i = 0; i < count; i++) {
      StampIDData.add(StampIDFuture[i]['StampID'] as String);
    }
    return StampIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagStampsTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagStampsTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagStampsTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagStampsTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagStampsTableFilterBuilder

// region BagStampsTableFields
class BagStampsTableFields {
  static TableField? _fStampID;
  static TableField get StampID {
    return _fStampID =
        _fStampID ?? SqlSyntax.setField(_fStampID, 'stampid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fStampPrice;
  static TableField get StampPrice {
    return _fStampPrice = _fStampPrice ??
        SqlSyntax.setField(_fStampPrice, 'StampPrice', DbType.text);
  }

  static TableField? _fStampName;
  static TableField get StampName {
    return _fStampName = _fStampName ??
        SqlSyntax.setField(_fStampName, 'StampName', DbType.text);
  }

  static TableField? _fStampQuantity;
  static TableField get StampQuantity {
    return _fStampQuantity = _fStampQuantity ??
        SqlSyntax.setField(_fStampQuantity, 'StampQuantity', DbType.text);
  }

  static TableField? _fStampAmountTotal;
  static TableField get StampAmountTotal {
    return _fStampAmountTotal = _fStampAmountTotal ??
        SqlSyntax.setField(_fStampAmountTotal, 'StampAmountTotal', DbType.text);
  }

  static TableField? _fStampDate;
  static TableField get StampDate {
    return _fStampDate = _fStampDate ??
        SqlSyntax.setField(_fStampDate, 'StampDate', DbType.text);
  }

  static TableField? _fStampTime;
  static TableField get StampTime {
    return _fStampTime = _fStampTime ??
        SqlSyntax.setField(_fStampTime, 'StampTime', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion BagStampsTableFields

//region BagStampsTableManager
class BagStampsTableManager extends SqfEntityProvider {
  BagStampsTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagStampsTable';
  static const List<String> _primaryKeyList = ['StampID'];
  static const String _whereStr = 'StampID=?';
}

//endregion BagStampsTableManager
// region BagCashTable
class BagCashTable extends TableBase {
  BagCashTable(
      {this.CashID,
      this.BagNumber,
      this.BagDate,
      this.CashReceived,
      this.CashAmount,
      this.CashType,
      this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagCashTable.withFields(this.CashID, this.BagNumber, this.BagDate,
      this.CashReceived, this.CashAmount, this.CashType, this.Status) {
    _setDefaultValues();
  }
  BagCashTable.withId(this.CashID, this.BagNumber, this.BagDate,
      this.CashReceived, this.CashAmount, this.CashType, this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagCashTable.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CashID = o['CashID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['BagDate'] != null) {
      BagDate = o['BagDate'].toString();
    }
    if (o['CashReceived'] != null) {
      CashReceived = o['CashReceived'].toString();
    }
    if (o['CashAmount'] != null) {
      CashAmount = o['CashAmount'].toString();
    }
    if (o['CashType'] != null) {
      CashType = o['CashType'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagCashTable)
  String? CashID;
  String? BagNumber;
  String? BagDate;
  String? CashReceived;
  String? CashAmount;
  String? CashType;
  String? Status;
  bool? isSaved;
  // end FIELDS (BagCashTable)

  static const bool _softDeleteActivated = false;
  BagCashTableManager? __mnBagCashTable;

  BagCashTableManager get _mnBagCashTable {
    return __mnBagCashTable = __mnBagCashTable ?? BagCashTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['CashID'] = CashID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (BagDate != null || !forView) {
      map['BagDate'] = BagDate;
    }
    if (CashReceived != null || !forView) {
      map['CashReceived'] = CashReceived;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (CashType != null || !forView) {
      map['CashType'] = CashType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['CashID'] = CashID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (BagDate != null || !forView) {
      map['BagDate'] = BagDate;
    }
    if (CashReceived != null || !forView) {
      map['CashReceived'] = CashReceived;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (CashType != null || !forView) {
      map['CashType'] = CashType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [BagCashTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      CashID,
      BagNumber,
      BagDate,
      CashReceived,
      CashAmount,
      CashType,
      Status
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      CashID,
      BagNumber,
      BagDate,
      CashReceived,
      CashAmount,
      CashType,
      Status
    ];
  }

  static Future<List<BagCashTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagCashTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagCashTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagCashTable>[];
    try {
      objList = list
          .map((bagcashtable) =>
              BagCashTable.fromMap(bagcashtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagCashTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagCashTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagCashTable> objList = <BagCashTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagCashTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagCashTable by ID if exist, otherwise returns null
  /// Primary Keys: String? CashID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagCashTable] if exist, otherwise returns null
  Future<BagCashTable?> getById(String? CashID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (CashID == null) {
      return null;
    }
    BagCashTable? obj;
    final data = await _mnBagCashTable.getById([CashID]);
    if (data.length != 0) {
      obj = BagCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagCashTable) object. If the Primary Key (CashID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same CashID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagCashTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagCashTable (CashID, BagNumber, BagDate, CashReceived, CashAmount, CashType, Status)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagCashTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagCashTable> bagcashtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagcashtables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagCashTable.rawInsert(
          'INSERT OR REPLACE INTO bagCashTable (CashID, BagNumber, BagDate, CashReceived, CashAmount, CashType, Status)  VALUES (?,?,?,?,?,?,?)',
          [
            CashID,
            BagNumber,
            BagDate,
            CashReceived,
            CashAmount,
            CashType,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BagCashTable CashID=$CashID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagCashTable CashID=$CashID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagCashTable.rawInsert(
          'INSERT OR IGNORE INTO bagCashTable (CashID, BagNumber, BagDate, CashReceived, CashAmount, CashType, Status)  VALUES (?,?,?,?,?,?,?)',
          [
            CashID,
            BagNumber,
            BagDate,
            CashReceived,
            CashAmount,
            CashType,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'BagCashTable CashID=$CashID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagCashTable CashID=$CashID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagCashTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BagCashTable invoked (CashID=$CashID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagCashTable.delete(
          QueryParams(whereString: 'CashID=?', whereArguments: [CashID]));
    } else {
      return _mnBagCashTable.updateBatch(
          QueryParams(whereString: 'CashID=?', whereArguments: [CashID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagCashTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagCashTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagCashTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      CashID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagcashtable

// region BagCashTableField
class BagCashTableField extends FilterBase {
  BagCashTableField(BagCashTableFilterBuilder bagcashtableFB)
      : super(bagcashtableFB);

  @override
  BagCashTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder isNull() {
    return super.isNull() as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagCashTableFilterBuilder;
  }

  @override
  BagCashTableField get not {
    return super.not as BagCashTableField;
  }
}
// endregion BagCashTableField

// region BagCashTableFilterBuilder
class BagCashTableFilterBuilder extends ConjunctionBase {
  BagCashTableFilterBuilder(BagCashTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagCashTable = obj._mnBagCashTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagCashTableManager? _mnBagCashTable;

  /// put the sql keyword 'AND'
  @override
  BagCashTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagCashTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagCashTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagCashTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagCashTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagCashTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagCashTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagCashTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagCashTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagCashTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagCashTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagCashTableField _setField(
      BagCashTableField? field, String colName, DbType dbtype) {
    return BagCashTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagCashTableField? _CashID;
  BagCashTableField get CashID {
    return _CashID = _setField(_CashID, 'CashID', DbType.integer);
  }

  BagCashTableField? _BagNumber;
  BagCashTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagCashTableField? _BagDate;
  BagCashTableField get BagDate {
    return _BagDate = _setField(_BagDate, 'BagDate', DbType.text);
  }

  BagCashTableField? _CashReceived;
  BagCashTableField get CashReceived {
    return _CashReceived =
        _setField(_CashReceived, 'CashReceived', DbType.text);
  }

  BagCashTableField? _CashAmount;
  BagCashTableField get CashAmount {
    return _CashAmount = _setField(_CashAmount, 'CashAmount', DbType.text);
  }

  BagCashTableField? _CashType;
  BagCashTableField get CashType {
    return _CashType = _setField(_CashType, 'CashType', DbType.text);
  }

  BagCashTableField? _Status;
  BagCashTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<BagCashTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagCashTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagCashTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'CashID IN (SELECT CashID from bagCashTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagCashTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagCashTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagCashTable?
  @override
  Future<BagCashTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagCashTable!.toList(qparams);
    final data = await objFuture;
    BagCashTable? obj;
    if (data.isNotEmpty) {
      obj = BagCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagCashTable?
  @override
  Future<BagCashTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagCashTable();
  }

  /// This method returns int. [BagCashTable]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bagcashtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagcashtablesFuture = await _mnBagCashTable!.toList(qparams);
    final int count = bagcashtablesFuture[0]['CNT'] as int;
    if (bagcashtableCount != null) {
      bagcashtableCount(count);
    }
    return count;
  }

  /// This method returns List<BagCashTable> [BagCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagCashTable>
  @override
  Future<List<BagCashTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagCashTable> bagcashtablesData = await BagCashTable.fromMapList(
        data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return bagcashtablesData;
  }

  /// This method returns Json String [BagCashTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagCashTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagCashTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagCashTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CashID` FROM bagCashTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> CashIDData = <String>[];
    qparams.selectColumns = ['CashID'];
    final CashIDFuture = await _mnBagCashTable!.toList(qparams);

    final int count = CashIDFuture.length;
    for (int i = 0; i < count; i++) {
      CashIDData.add(CashIDFuture[i]['CashID'] as String);
    }
    return CashIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagCashTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagCashTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagCashTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagCashTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagCashTableFilterBuilder

// region BagCashTableFields
class BagCashTableFields {
  static TableField? _fCashID;
  static TableField get CashID {
    return _fCashID =
        _fCashID ?? SqlSyntax.setField(_fCashID, 'cashid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fBagDate;
  static TableField get BagDate {
    return _fBagDate =
        _fBagDate ?? SqlSyntax.setField(_fBagDate, 'BagDate', DbType.text);
  }

  static TableField? _fCashReceived;
  static TableField get CashReceived {
    return _fCashReceived = _fCashReceived ??
        SqlSyntax.setField(_fCashReceived, 'CashReceived', DbType.text);
  }

  static TableField? _fCashAmount;
  static TableField get CashAmount {
    return _fCashAmount = _fCashAmount ??
        SqlSyntax.setField(_fCashAmount, 'CashAmount', DbType.text);
  }

  static TableField? _fCashType;
  static TableField get CashType {
    return _fCashType =
        _fCashType ?? SqlSyntax.setField(_fCashType, 'CashType', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion BagCashTableFields

//region BagCashTableManager
class BagCashTableManager extends SqfEntityProvider {
  BagCashTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagCashTable';
  static const List<String> _primaryKeyList = ['CashID'];
  static const String _whereStr = 'CashID=?';
}

//endregion BagCashTableManager
// region BagDocumentsTable
class BagDocumentsTable extends TableBase {
  BagDocumentsTable(
      {this.DocumentID,
      this.BagNumber,
      this.DocumentName,
      this.ReceivedDate,
      this.ReceivedTime,
      this.IsAdded,
      this.DocumentStatus}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagDocumentsTable.withFields(
      this.DocumentID,
      this.BagNumber,
      this.DocumentName,
      this.ReceivedDate,
      this.ReceivedTime,
      this.IsAdded,
      this.DocumentStatus) {
    _setDefaultValues();
  }
  BagDocumentsTable.withId(this.DocumentID, this.BagNumber, this.DocumentName,
      this.ReceivedDate, this.ReceivedTime, this.IsAdded, this.DocumentStatus) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagDocumentsTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    DocumentID = o['DocumentID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['DocumentName'] != null) {
      DocumentName = o['DocumentName'].toString();
    }
    if (o['ReceivedDate'] != null) {
      ReceivedDate = o['ReceivedDate'].toString();
    }
    if (o['ReceivedTime'] != null) {
      ReceivedTime = o['ReceivedTime'].toString();
    }
    if (o['IsAdded'] != null) {
      IsAdded = o['IsAdded'].toString();
    }
    if (o['DocumentStatus'] != null) {
      DocumentStatus = o['DocumentStatus'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagDocumentsTable)
  String? DocumentID;
  String? BagNumber;
  String? DocumentName;
  String? ReceivedDate;
  String? ReceivedTime;
  String? IsAdded;
  String? DocumentStatus;
  bool? isSaved;
  // end FIELDS (BagDocumentsTable)

  static const bool _softDeleteActivated = false;
  BagDocumentsTableManager? __mnBagDocumentsTable;

  BagDocumentsTableManager get _mnBagDocumentsTable {
    return __mnBagDocumentsTable =
        __mnBagDocumentsTable ?? BagDocumentsTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['DocumentID'] = DocumentID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (DocumentName != null || !forView) {
      map['DocumentName'] = DocumentName;
    }
    if (ReceivedDate != null || !forView) {
      map['ReceivedDate'] = ReceivedDate;
    }
    if (ReceivedTime != null || !forView) {
      map['ReceivedTime'] = ReceivedTime;
    }
    if (IsAdded != null || !forView) {
      map['IsAdded'] = IsAdded;
    }
    if (DocumentStatus != null || !forView) {
      map['DocumentStatus'] = DocumentStatus;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['DocumentID'] = DocumentID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (DocumentName != null || !forView) {
      map['DocumentName'] = DocumentName;
    }
    if (ReceivedDate != null || !forView) {
      map['ReceivedDate'] = ReceivedDate;
    }
    if (ReceivedTime != null || !forView) {
      map['ReceivedTime'] = ReceivedTime;
    }
    if (IsAdded != null || !forView) {
      map['IsAdded'] = IsAdded;
    }
    if (DocumentStatus != null || !forView) {
      map['DocumentStatus'] = DocumentStatus;
    }

    return map;
  }

  /// This method returns Json String [BagDocumentsTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagDocumentsTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      DocumentID,
      BagNumber,
      DocumentName,
      ReceivedDate,
      ReceivedTime,
      IsAdded,
      DocumentStatus
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      DocumentID,
      BagNumber,
      DocumentName,
      ReceivedDate,
      ReceivedTime,
      IsAdded,
      DocumentStatus
    ];
  }

  static Future<List<BagDocumentsTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagDocumentsTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagDocumentsTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagDocumentsTable>[];
    try {
      objList = list
          .map((bagdocumentstable) => BagDocumentsTable.fromMap(
              bagdocumentstable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagDocumentsTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagDocumentsTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagDocumentsTable> objList = <BagDocumentsTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagDocumentsTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagDocumentsTable by ID if exist, otherwise returns null
  /// Primary Keys: String? DocumentID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagDocumentsTable] if exist, otherwise returns null
  Future<BagDocumentsTable?> getById(String? DocumentID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (DocumentID == null) {
      return null;
    }
    BagDocumentsTable? obj;
    final data = await _mnBagDocumentsTable.getById([DocumentID]);
    if (data.length != 0) {
      obj = BagDocumentsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagDocumentsTable) object. If the Primary Key (DocumentID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same DocumentID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagDocumentsTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagDocumentsTable (DocumentID, BagNumber, DocumentName, ReceivedDate, ReceivedTime, IsAdded, DocumentStatus)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagDocumentsTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<BagDocumentsTable> bagdocumentstables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagdocumentstables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagDocumentsTable.rawInsert(
          'INSERT OR REPLACE INTO bagDocumentsTable (DocumentID, BagNumber, DocumentName, ReceivedDate, ReceivedTime, IsAdded, DocumentStatus)  VALUES (?,?,?,?,?,?,?)',
          [
            DocumentID,
            BagNumber,
            DocumentName,
            ReceivedDate,
            ReceivedTime,
            IsAdded,
            DocumentStatus
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagDocumentsTable DocumentID=$DocumentID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagDocumentsTable DocumentID=$DocumentID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagDocumentsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagDocumentsTable.rawInsert(
          'INSERT OR IGNORE INTO bagDocumentsTable (DocumentID, BagNumber, DocumentName, ReceivedDate, ReceivedTime, IsAdded, DocumentStatus)  VALUES (?,?,?,?,?,?,?)',
          [
            DocumentID,
            BagNumber,
            DocumentName,
            ReceivedDate,
            ReceivedTime,
            IsAdded,
            DocumentStatus
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagDocumentsTable DocumentID=$DocumentID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagDocumentsTable DocumentID=$DocumentID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagDocumentsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagDocumentsTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagDocumentsTable invoked (DocumentID=$DocumentID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagDocumentsTable.delete(QueryParams(
          whereString: 'DocumentID=?', whereArguments: [DocumentID]));
    } else {
      return _mnBagDocumentsTable.updateBatch(
          QueryParams(
              whereString: 'DocumentID=?', whereArguments: [DocumentID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagDocumentsTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagDocumentsTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagDocumentsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagDocumentsTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagDocumentsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      DocumentID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagdocumentstable

// region BagDocumentsTableField
class BagDocumentsTableField extends FilterBase {
  BagDocumentsTableField(BagDocumentsTableFilterBuilder bagdocumentstableFB)
      : super(bagdocumentstableFB);

  @override
  BagDocumentsTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder isNull() {
    return super.isNull() as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagDocumentsTableFilterBuilder;
  }

  @override
  BagDocumentsTableField get not {
    return super.not as BagDocumentsTableField;
  }
}
// endregion BagDocumentsTableField

// region BagDocumentsTableFilterBuilder
class BagDocumentsTableFilterBuilder extends ConjunctionBase {
  BagDocumentsTableFilterBuilder(BagDocumentsTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagDocumentsTable = obj._mnBagDocumentsTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagDocumentsTableManager? _mnBagDocumentsTable;

  /// put the sql keyword 'AND'
  @override
  BagDocumentsTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagDocumentsTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagDocumentsTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagDocumentsTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagDocumentsTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagDocumentsTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagDocumentsTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagDocumentsTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagDocumentsTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagDocumentsTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagDocumentsTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagDocumentsTableField _setField(
      BagDocumentsTableField? field, String colName, DbType dbtype) {
    return BagDocumentsTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagDocumentsTableField? _DocumentID;
  BagDocumentsTableField get DocumentID {
    return _DocumentID = _setField(_DocumentID, 'DocumentID', DbType.integer);
  }

  BagDocumentsTableField? _BagNumber;
  BagDocumentsTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagDocumentsTableField? _DocumentName;
  BagDocumentsTableField get DocumentName {
    return _DocumentName =
        _setField(_DocumentName, 'DocumentName', DbType.text);
  }

  BagDocumentsTableField? _ReceivedDate;
  BagDocumentsTableField get ReceivedDate {
    return _ReceivedDate =
        _setField(_ReceivedDate, 'ReceivedDate', DbType.text);
  }

  BagDocumentsTableField? _ReceivedTime;
  BagDocumentsTableField get ReceivedTime {
    return _ReceivedTime =
        _setField(_ReceivedTime, 'ReceivedTime', DbType.text);
  }

  BagDocumentsTableField? _IsAdded;
  BagDocumentsTableField get IsAdded {
    return _IsAdded = _setField(_IsAdded, 'IsAdded', DbType.text);
  }

  BagDocumentsTableField? _DocumentStatus;
  BagDocumentsTableField get DocumentStatus {
    return _DocumentStatus =
        _setField(_DocumentStatus, 'DocumentStatus', DbType.text);
  }

  /// Deletes List<BagDocumentsTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagDocumentsTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagDocumentsTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'DocumentID IN (SELECT DocumentID from bagDocumentsTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagDocumentsTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagDocumentsTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagDocumentsTable?
  @override
  Future<BagDocumentsTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagDocumentsTable!.toList(qparams);
    final data = await objFuture;
    BagDocumentsTable? obj;
    if (data.isNotEmpty) {
      obj = BagDocumentsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagDocumentsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagDocumentsTable?
  @override
  Future<BagDocumentsTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagDocumentsTable();
  }

  /// This method returns int. [BagDocumentsTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagdocumentstableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagdocumentstablesFuture =
        await _mnBagDocumentsTable!.toList(qparams);
    final int count = bagdocumentstablesFuture[0]['CNT'] as int;
    if (bagdocumentstableCount != null) {
      bagdocumentstableCount(count);
    }
    return count;
  }

  /// This method returns List<BagDocumentsTable> [BagDocumentsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagDocumentsTable>
  @override
  Future<List<BagDocumentsTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagDocumentsTable> bagdocumentstablesData =
        await BagDocumentsTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagdocumentstablesData;
  }

  /// This method returns Json String [BagDocumentsTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagDocumentsTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagDocumentsTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagDocumentsTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagDocumentsTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `DocumentID` FROM bagDocumentsTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> DocumentIDData = <String>[];
    qparams.selectColumns = ['DocumentID'];
    final DocumentIDFuture = await _mnBagDocumentsTable!.toList(qparams);

    final int count = DocumentIDFuture.length;
    for (int i = 0; i < count; i++) {
      DocumentIDData.add(DocumentIDFuture[i]['DocumentID'] as String);
    }
    return DocumentIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagDocumentsTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagDocumentsTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagDocumentsTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagDocumentsTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagDocumentsTableFilterBuilder

// region BagDocumentsTableFields
class BagDocumentsTableFields {
  static TableField? _fDocumentID;
  static TableField get DocumentID {
    return _fDocumentID = _fDocumentID ??
        SqlSyntax.setField(_fDocumentID, 'documentid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fDocumentName;
  static TableField get DocumentName {
    return _fDocumentName = _fDocumentName ??
        SqlSyntax.setField(_fDocumentName, 'DocumentName', DbType.text);
  }

  static TableField? _fReceivedDate;
  static TableField get ReceivedDate {
    return _fReceivedDate = _fReceivedDate ??
        SqlSyntax.setField(_fReceivedDate, 'ReceivedDate', DbType.text);
  }

  static TableField? _fReceivedTime;
  static TableField get ReceivedTime {
    return _fReceivedTime = _fReceivedTime ??
        SqlSyntax.setField(_fReceivedTime, 'ReceivedTime', DbType.text);
  }

  static TableField? _fIsAdded;
  static TableField get IsAdded {
    return _fIsAdded =
        _fIsAdded ?? SqlSyntax.setField(_fIsAdded, 'IsAdded', DbType.text);
  }

  static TableField? _fDocumentStatus;
  static TableField get DocumentStatus {
    return _fDocumentStatus = _fDocumentStatus ??
        SqlSyntax.setField(_fDocumentStatus, 'DocumentStatus', DbType.text);
  }
}
// endregion BagDocumentsTableFields

//region BagDocumentsTableManager
class BagDocumentsTableManager extends SqfEntityProvider {
  BagDocumentsTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagDocumentsTable';
  static const List<String> _primaryKeyList = ['DocumentID'];
  static const String _whereStr = 'DocumentID=?';
}

//endregion BagDocumentsTableManager
// region BagInventory
class BagInventory extends TableBase {
  BagInventory(
      {this.InventoryID,
      this.BagNumber,
      this.InventoryName,
      this.InventoryPrice,
      this.InventoryQuantity}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagInventory.withFields(this.InventoryID, this.BagNumber, this.InventoryName,
      this.InventoryPrice, this.InventoryQuantity) {
    _setDefaultValues();
  }
  BagInventory.withId(this.InventoryID, this.BagNumber, this.InventoryName,
      this.InventoryPrice, this.InventoryQuantity) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagInventory.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    InventoryID = o['InventoryID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['InventoryName'] != null) {
      InventoryName = o['InventoryName'].toString();
    }
    if (o['InventoryPrice'] != null) {
      InventoryPrice = o['InventoryPrice'].toString();
    }
    if (o['InventoryQuantity'] != null) {
      InventoryQuantity = o['InventoryQuantity'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagInventory)
  String? InventoryID;
  String? BagNumber;
  String? InventoryName;
  String? InventoryPrice;
  String? InventoryQuantity;
  bool? isSaved;
  // end FIELDS (BagInventory)

  static const bool _softDeleteActivated = false;
  BagInventoryManager? __mnBagInventory;

  BagInventoryManager get _mnBagInventory {
    return __mnBagInventory = __mnBagInventory ?? BagInventoryManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['InventoryID'] = InventoryID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (InventoryName != null || !forView) {
      map['InventoryName'] = InventoryName;
    }
    if (InventoryPrice != null || !forView) {
      map['InventoryPrice'] = InventoryPrice;
    }
    if (InventoryQuantity != null || !forView) {
      map['InventoryQuantity'] = InventoryQuantity;
    }

    return map;
  }

  /// This method returns Json String [BagInventory]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagInventory]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      InventoryID,
      BagNumber,
      InventoryName,
      InventoryPrice,
      InventoryQuantity
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      InventoryID,
      BagNumber,
      InventoryName,
      InventoryPrice,
      InventoryQuantity
    ];
  }

  static Future<List<BagInventory>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagInventory.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagInventory>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagInventory>[];
    try {
      objList = list
          .map((baginventory) =>
              BagInventory.fromMap(baginventory as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagInventory.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagInventory>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagInventory> objList = <BagInventory>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagInventory.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagInventory by ID if exist, otherwise returns null
  /// Primary Keys: String? InventoryID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagInventory] if exist, otherwise returns null
  Future<BagInventory?> getById(String? InventoryID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (InventoryID == null) {
      return null;
    }
    BagInventory? obj;
    final data = await _mnBagInventory.getById([InventoryID]);
    if (data.length != 0) {
      obj = BagInventory.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagInventory) object. If the Primary Key (InventoryID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same InventoryID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagInventory.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagInventory (InventoryID, BagNumber, InventoryName, InventoryPrice, InventoryQuantity)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagInventory> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagInventory> baginventories,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in baginventories) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagInventory.rawInsert(
          'INSERT OR REPLACE INTO bagInventory (InventoryID, BagNumber, InventoryName, InventoryPrice, InventoryQuantity)  VALUES (?,?,?,?,?)',
          [
            InventoryID,
            BagNumber,
            InventoryName,
            InventoryPrice,
            InventoryQuantity
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagInventory InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagInventory InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagInventory Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagInventory.rawInsert(
          'INSERT OR IGNORE INTO bagInventory (InventoryID, BagNumber, InventoryName, InventoryPrice, InventoryQuantity)  VALUES (?,?,?,?,?)',
          [
            InventoryID,
            BagNumber,
            InventoryName,
            InventoryPrice,
            InventoryQuantity
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagInventory InventoryID=$InventoryID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagInventory InventoryID=$InventoryID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagInventory Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagInventory

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagInventory invoked (InventoryID=$InventoryID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagInventory.delete(QueryParams(
          whereString: 'InventoryID=?', whereArguments: [InventoryID]));
    } else {
      return _mnBagInventory.updateBatch(
          QueryParams(
              whereString: 'InventoryID=?', whereArguments: [InventoryID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagInventory] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagInventoryFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagInventoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagInventoryFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagInventoryFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      InventoryID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion baginventory

// region BagInventoryField
class BagInventoryField extends FilterBase {
  BagInventoryField(BagInventoryFilterBuilder baginventoryFB)
      : super(baginventoryFB);

  @override
  BagInventoryFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder isNull() {
    return super.isNull() as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagInventoryFilterBuilder;
  }

  @override
  BagInventoryField get not {
    return super.not as BagInventoryField;
  }
}
// endregion BagInventoryField

// region BagInventoryFilterBuilder
class BagInventoryFilterBuilder extends ConjunctionBase {
  BagInventoryFilterBuilder(BagInventory obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagInventory = obj._mnBagInventory;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagInventoryManager? _mnBagInventory;

  /// put the sql keyword 'AND'
  @override
  BagInventoryFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagInventoryFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagInventoryFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagInventoryFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagInventoryFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagInventoryFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagInventoryFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagInventoryFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagInventoryFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagInventoryFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagInventoryFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagInventoryField _setField(
      BagInventoryField? field, String colName, DbType dbtype) {
    return BagInventoryField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagInventoryField? _InventoryID;
  BagInventoryField get InventoryID {
    return _InventoryID =
        _setField(_InventoryID, 'InventoryID', DbType.integer);
  }

  BagInventoryField? _BagNumber;
  BagInventoryField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagInventoryField? _InventoryName;
  BagInventoryField get InventoryName {
    return _InventoryName =
        _setField(_InventoryName, 'InventoryName', DbType.text);
  }

  BagInventoryField? _InventoryPrice;
  BagInventoryField get InventoryPrice {
    return _InventoryPrice =
        _setField(_InventoryPrice, 'InventoryPrice', DbType.text);
  }

  BagInventoryField? _InventoryQuantity;
  BagInventoryField get InventoryQuantity {
    return _InventoryQuantity =
        _setField(_InventoryQuantity, 'InventoryQuantity', DbType.text);
  }

  /// Deletes List<BagInventory> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagInventory!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagInventory!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'InventoryID IN (SELECT InventoryID from bagInventory ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagInventory!.updateBatch(qparams, values);
  }

  /// This method always returns [BagInventory] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagInventory?
  @override
  Future<BagInventory?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagInventory!.toList(qparams);
    final data = await objFuture;
    BagInventory? obj;
    if (data.isNotEmpty) {
      obj = BagInventory.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagInventory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagInventory?
  @override
  Future<BagInventory> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagInventory();
  }

  /// This method returns int. [BagInventory]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? baginventoryCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final baginventoriesFuture = await _mnBagInventory!.toList(qparams);
    final int count = baginventoriesFuture[0]['CNT'] as int;
    if (baginventoryCount != null) {
      baginventoryCount(count);
    }
    return count;
  }

  /// This method returns List<BagInventory> [BagInventory]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagInventory>
  @override
  Future<List<BagInventory>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagInventory> baginventoriesData =
        await BagInventory.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return baginventoriesData;
  }

  /// This method returns Json String [BagInventory]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagInventory]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagInventory]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagInventory!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagInventory]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `InventoryID` FROM bagInventory WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> InventoryIDData = <String>[];
    qparams.selectColumns = ['InventoryID'];
    final InventoryIDFuture = await _mnBagInventory!.toList(qparams);

    final int count = InventoryIDFuture.length;
    for (int i = 0; i < count; i++) {
      InventoryIDData.add(InventoryIDFuture[i]['InventoryID'] as String);
    }
    return InventoryIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagInventory]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagInventory!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagInventory.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagInventory!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagInventoryFilterBuilder

// region BagInventoryFields
class BagInventoryFields {
  static TableField? _fInventoryID;
  static TableField get InventoryID {
    return _fInventoryID = _fInventoryID ??
        SqlSyntax.setField(_fInventoryID, 'inventoryid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fInventoryName;
  static TableField get InventoryName {
    return _fInventoryName = _fInventoryName ??
        SqlSyntax.setField(_fInventoryName, 'InventoryName', DbType.text);
  }

  static TableField? _fInventoryPrice;
  static TableField get InventoryPrice {
    return _fInventoryPrice = _fInventoryPrice ??
        SqlSyntax.setField(_fInventoryPrice, 'InventoryPrice', DbType.text);
  }

  static TableField? _fInventoryQuantity;
  static TableField get InventoryQuantity {
    return _fInventoryQuantity = _fInventoryQuantity ??
        SqlSyntax.setField(
            _fInventoryQuantity, 'InventoryQuantity', DbType.text);
  }
}
// endregion BagInventoryFields

//region BagInventoryManager
class BagInventoryManager extends SqfEntityProvider {
  BagInventoryManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagInventory';
  static const List<String> _primaryKeyList = ['InventoryID'];
  static const String _whereStr = 'InventoryID=?';
}

//endregion BagInventoryManager
// region BagExcessArticlesTable
class BagExcessArticlesTable extends TableBase {
  BagExcessArticlesTable(
      {this.ArticleNumber, this.BagNumber, this.ArticleType, this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagExcessArticlesTable.withFields(
      this.ArticleNumber, this.BagNumber, this.ArticleType, this.Status) {
    _setDefaultValues();
  }
  BagExcessArticlesTable.withId(
      this.ArticleNumber, this.BagNumber, this.ArticleType, this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagExcessArticlesTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ArticleNumber = o['ArticleNumber'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['ArticleType'] != null) {
      ArticleType = o['ArticleType'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagExcessArticlesTable)
  String? ArticleNumber;
  String? BagNumber;
  String? ArticleType;
  String? Status;
  bool? isSaved;
  // end FIELDS (BagExcessArticlesTable)

  static const bool _softDeleteActivated = false;
  BagExcessArticlesTableManager? __mnBagExcessArticlesTable;

  BagExcessArticlesTableManager get _mnBagExcessArticlesTable {
    return __mnBagExcessArticlesTable =
        __mnBagExcessArticlesTable ?? BagExcessArticlesTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ArticleNumber'] = ArticleNumber;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [BagExcessArticlesTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagExcessArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [ArticleNumber, BagNumber, ArticleType, Status];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [ArticleNumber, BagNumber, ArticleType, Status];
  }

  static Future<List<BagExcessArticlesTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagExcessArticlesTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagExcessArticlesTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagExcessArticlesTable>[];
    try {
      objList = list
          .map((bagexcessarticlestable) => BagExcessArticlesTable.fromMap(
              bagexcessarticlestable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagExcessArticlesTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagExcessArticlesTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagExcessArticlesTable> objList = <BagExcessArticlesTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagExcessArticlesTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagExcessArticlesTable by ID if exist, otherwise returns null
  /// Primary Keys: String? ArticleNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagExcessArticlesTable] if exist, otherwise returns null
  Future<BagExcessArticlesTable?> getById(String? ArticleNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ArticleNumber == null) {
      return null;
    }
    BagExcessArticlesTable? obj;
    final data = await _mnBagExcessArticlesTable.getById([ArticleNumber]);
    if (data.length != 0) {
      obj = BagExcessArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagExcessArticlesTable) object. If the Primary Key (ArticleNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ArticleNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagExcessArticlesTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagExcessArticlesTable (ArticleNumber, BagNumber, ArticleType, Status)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagExcessArticlesTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<BagExcessArticlesTable> bagexcessarticlestables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagexcessarticlestables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagExcessArticlesTable.rawInsert(
          'INSERT OR REPLACE INTO bagExcessArticlesTable (ArticleNumber, BagNumber, ArticleType, Status)  VALUES (?,?,?,?)',
          [ArticleNumber, BagNumber, ArticleType, Status],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagExcessArticlesTable ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagExcessArticlesTable ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagExcessArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagExcessArticlesTable.rawInsert(
          'INSERT OR IGNORE INTO bagExcessArticlesTable (ArticleNumber, BagNumber, ArticleType, Status)  VALUES (?,?,?,?)',
          [ArticleNumber, BagNumber, ArticleType, Status],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagExcessArticlesTable ArticleNumber=$ArticleNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagExcessArticlesTable ArticleNumber=$ArticleNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagExcessArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagExcessArticlesTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagExcessArticlesTable invoked (ArticleNumber=$ArticleNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagExcessArticlesTable.delete(QueryParams(
          whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]));
    } else {
      return _mnBagExcessArticlesTable.updateBatch(
          QueryParams(
              whereString: 'ArticleNumber=?', whereArguments: [ArticleNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagExcessArticlesTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagExcessArticlesTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagExcessArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagExcessArticlesTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagExcessArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ArticleNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagexcessarticlestable

// region BagExcessArticlesTableField
class BagExcessArticlesTableField extends FilterBase {
  BagExcessArticlesTableField(
      BagExcessArticlesTableFilterBuilder bagexcessarticlestableFB)
      : super(bagexcessarticlestableFB);

  @override
  BagExcessArticlesTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder isNull() {
    return super.isNull() as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue)
        as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagExcessArticlesTableFilterBuilder;
  }

  @override
  BagExcessArticlesTableField get not {
    return super.not as BagExcessArticlesTableField;
  }
}
// endregion BagExcessArticlesTableField

// region BagExcessArticlesTableFilterBuilder
class BagExcessArticlesTableFilterBuilder extends ConjunctionBase {
  BagExcessArticlesTableFilterBuilder(
      BagExcessArticlesTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagExcessArticlesTable = obj._mnBagExcessArticlesTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagExcessArticlesTableManager? _mnBagExcessArticlesTable;

  /// put the sql keyword 'AND'
  @override
  BagExcessArticlesTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagExcessArticlesTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagExcessArticlesTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagExcessArticlesTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagExcessArticlesTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagExcessArticlesTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagExcessArticlesTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagExcessArticlesTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagExcessArticlesTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagExcessArticlesTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagExcessArticlesTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagExcessArticlesTableField _setField(
      BagExcessArticlesTableField? field, String colName, DbType dbtype) {
    return BagExcessArticlesTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagExcessArticlesTableField? _ArticleNumber;
  BagExcessArticlesTableField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.integer);
  }

  BagExcessArticlesTableField? _BagNumber;
  BagExcessArticlesTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagExcessArticlesTableField? _ArticleType;
  BagExcessArticlesTableField get ArticleType {
    return _ArticleType = _setField(_ArticleType, 'ArticleType', DbType.text);
  }

  BagExcessArticlesTableField? _Status;
  BagExcessArticlesTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<BagExcessArticlesTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagExcessArticlesTable!
          .updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagExcessArticlesTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ArticleNumber IN (SELECT ArticleNumber from bagExcessArticlesTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagExcessArticlesTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagExcessArticlesTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagExcessArticlesTable?
  @override
  Future<BagExcessArticlesTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagExcessArticlesTable!.toList(qparams);
    final data = await objFuture;
    BagExcessArticlesTable? obj;
    if (data.isNotEmpty) {
      obj = BagExcessArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagExcessArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagExcessArticlesTable?
  @override
  Future<BagExcessArticlesTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagExcessArticlesTable();
  }

  /// This method returns int. [BagExcessArticlesTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagexcessarticlestableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagexcessarticlestablesFuture =
        await _mnBagExcessArticlesTable!.toList(qparams);
    final int count = bagexcessarticlestablesFuture[0]['CNT'] as int;
    if (bagexcessarticlestableCount != null) {
      bagexcessarticlestableCount(count);
    }
    return count;
  }

  /// This method returns List<BagExcessArticlesTable> [BagExcessArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagExcessArticlesTable>
  @override
  Future<List<BagExcessArticlesTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagExcessArticlesTable> bagexcessarticlestablesData =
        await BagExcessArticlesTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagexcessarticlestablesData;
  }

  /// This method returns Json String [BagExcessArticlesTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagExcessArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagExcessArticlesTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagExcessArticlesTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagExcessArticlesTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ArticleNumber` FROM bagExcessArticlesTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ArticleNumberData = <String>[];
    qparams.selectColumns = ['ArticleNumber'];
    final ArticleNumberFuture =
        await _mnBagExcessArticlesTable!.toList(qparams);

    final int count = ArticleNumberFuture.length;
    for (int i = 0; i < count; i++) {
      ArticleNumberData.add(ArticleNumberFuture[i]['ArticleNumber'] as String);
    }
    return ArticleNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagExcessArticlesTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagExcessArticlesTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagExcessArticlesTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagExcessArticlesTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagExcessArticlesTableFilterBuilder

// region BagExcessArticlesTableFields
class BagExcessArticlesTableFields {
  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'articlenumber', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fArticleType;
  static TableField get ArticleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'ArticleType', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion BagExcessArticlesTableFields

//region BagExcessArticlesTableManager
class BagExcessArticlesTableManager extends SqfEntityProvider {
  BagExcessArticlesTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagExcessArticlesTable';
  static const List<String> _primaryKeyList = ['ArticleNumber'];
  static const String _whereStr = 'ArticleNumber=?';
}

//endregion BagExcessArticlesTableManager
// region BagExcessStampsTable
class BagExcessStampsTable extends TableBase {
  BagExcessStampsTable(
      {this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.Name,
      this.StampQuantity,
      this.StampAmountTotal,
      this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagExcessStampsTable.withFields(
      this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.Name,
      this.StampQuantity,
      this.StampAmountTotal,
      this.Status) {
    _setDefaultValues();
  }
  BagExcessStampsTable.withId(
      this.StampID,
      this.BagNumber,
      this.StampPrice,
      this.StampName,
      this.Name,
      this.StampQuantity,
      this.StampAmountTotal,
      this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagExcessStampsTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    StampID = o['StampID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['StampPrice'] != null) {
      StampPrice = o['StampPrice'].toString();
    }
    if (o['StampName'] != null) {
      StampName = o['StampName'].toString();
    }
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
    if (o['StampQuantity'] != null) {
      StampQuantity = o['StampQuantity'].toString();
    }
    if (o['StampAmountTotal'] != null) {
      StampAmountTotal = o['StampAmountTotal'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagExcessStampsTable)
  String? StampID;
  String? BagNumber;
  String? StampPrice;
  String? StampName;
  String? Name;
  String? StampQuantity;
  String? StampAmountTotal;
  String? Status;
  bool? isSaved;
  // end FIELDS (BagExcessStampsTable)

  static const bool _softDeleteActivated = false;
  BagExcessStampsTableManager? __mnBagExcessStampsTable;

  BagExcessStampsTableManager get _mnBagExcessStampsTable {
    return __mnBagExcessStampsTable =
        __mnBagExcessStampsTable ?? BagExcessStampsTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['StampID'] = StampID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (StampPrice != null || !forView) {
      map['StampPrice'] = StampPrice;
    }
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (StampQuantity != null || !forView) {
      map['StampQuantity'] = StampQuantity;
    }
    if (StampAmountTotal != null || !forView) {
      map['StampAmountTotal'] = StampAmountTotal;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['StampID'] = StampID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (StampPrice != null || !forView) {
      map['StampPrice'] = StampPrice;
    }
    if (StampName != null || !forView) {
      map['StampName'] = StampName;
    }
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (StampQuantity != null || !forView) {
      map['StampQuantity'] = StampQuantity;
    }
    if (StampAmountTotal != null || !forView) {
      map['StampAmountTotal'] = StampAmountTotal;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [BagExcessStampsTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagExcessStampsTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      StampID,
      BagNumber,
      StampPrice,
      StampName,
      Name,
      StampQuantity,
      StampAmountTotal,
      Status
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      StampID,
      BagNumber,
      StampPrice,
      StampName,
      Name,
      StampQuantity,
      StampAmountTotal,
      Status
    ];
  }

  static Future<List<BagExcessStampsTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagExcessStampsTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagExcessStampsTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagExcessStampsTable>[];
    try {
      objList = list
          .map((bagexcessstampstable) => BagExcessStampsTable.fromMap(
              bagexcessstampstable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagExcessStampsTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagExcessStampsTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagExcessStampsTable> objList = <BagExcessStampsTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagExcessStampsTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagExcessStampsTable by ID if exist, otherwise returns null
  /// Primary Keys: String? StampID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagExcessStampsTable] if exist, otherwise returns null
  Future<BagExcessStampsTable?> getById(String? StampID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (StampID == null) {
      return null;
    }
    BagExcessStampsTable? obj;
    final data = await _mnBagExcessStampsTable.getById([StampID]);
    if (data.length != 0) {
      obj = BagExcessStampsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagExcessStampsTable) object. If the Primary Key (StampID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same StampID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagExcessStampsTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagExcessStampsTable (StampID, BagNumber, StampPrice, StampName, Name, StampQuantity, StampAmountTotal, Status)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagExcessStampsTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<BagExcessStampsTable> bagexcessstampstables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagexcessstampstables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagExcessStampsTable.rawInsert(
          'INSERT OR REPLACE INTO bagExcessStampsTable (StampID, BagNumber, StampPrice, StampName, Name, StampQuantity, StampAmountTotal, Status)  VALUES (?,?,?,?,?,?,?,?)',
          [
            StampID,
            BagNumber,
            StampPrice,
            StampName,
            Name,
            StampQuantity,
            StampAmountTotal,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagExcessStampsTable StampID=$StampID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagExcessStampsTable StampID=$StampID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagExcessStampsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagExcessStampsTable.rawInsert(
          'INSERT OR IGNORE INTO bagExcessStampsTable (StampID, BagNumber, StampPrice, StampName, Name, StampQuantity, StampAmountTotal, Status)  VALUES (?,?,?,?,?,?,?,?)',
          [
            StampID,
            BagNumber,
            StampPrice,
            StampName,
            Name,
            StampQuantity,
            StampAmountTotal,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagExcessStampsTable StampID=$StampID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'BagExcessStampsTable StampID=$StampID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'BagExcessStampsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagExcessStampsTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagExcessStampsTable invoked (StampID=$StampID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagExcessStampsTable.delete(
          QueryParams(whereString: 'StampID=?', whereArguments: [StampID]));
    } else {
      return _mnBagExcessStampsTable.updateBatch(
          QueryParams(whereString: 'StampID=?', whereArguments: [StampID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagExcessStampsTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagExcessStampsTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagExcessStampsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagExcessStampsTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagExcessStampsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      StampID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagexcessstampstable

// region BagExcessStampsTableField
class BagExcessStampsTableField extends FilterBase {
  BagExcessStampsTableField(
      BagExcessStampsTableFilterBuilder bagexcessstampstableFB)
      : super(bagexcessstampstableFB);

  @override
  BagExcessStampsTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder isNull() {
    return super.isNull() as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagExcessStampsTableFilterBuilder;
  }

  @override
  BagExcessStampsTableField get not {
    return super.not as BagExcessStampsTableField;
  }
}
// endregion BagExcessStampsTableField

// region BagExcessStampsTableFilterBuilder
class BagExcessStampsTableFilterBuilder extends ConjunctionBase {
  BagExcessStampsTableFilterBuilder(
      BagExcessStampsTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagExcessStampsTable = obj._mnBagExcessStampsTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagExcessStampsTableManager? _mnBagExcessStampsTable;

  /// put the sql keyword 'AND'
  @override
  BagExcessStampsTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagExcessStampsTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagExcessStampsTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagExcessStampsTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagExcessStampsTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagExcessStampsTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagExcessStampsTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagExcessStampsTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagExcessStampsTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagExcessStampsTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagExcessStampsTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagExcessStampsTableField _setField(
      BagExcessStampsTableField? field, String colName, DbType dbtype) {
    return BagExcessStampsTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagExcessStampsTableField? _StampID;
  BagExcessStampsTableField get StampID {
    return _StampID = _setField(_StampID, 'StampID', DbType.integer);
  }

  BagExcessStampsTableField? _BagNumber;
  BagExcessStampsTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  BagExcessStampsTableField? _StampPrice;
  BagExcessStampsTableField get StampPrice {
    return _StampPrice = _setField(_StampPrice, 'StampPrice', DbType.text);
  }

  BagExcessStampsTableField? _StampName;
  BagExcessStampsTableField get StampName {
    return _StampName = _setField(_StampName, 'StampName', DbType.text);
  }

  BagExcessStampsTableField? _Name;
  BagExcessStampsTableField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  BagExcessStampsTableField? _StampQuantity;
  BagExcessStampsTableField get StampQuantity {
    return _StampQuantity =
        _setField(_StampQuantity, 'StampQuantity', DbType.text);
  }

  BagExcessStampsTableField? _StampAmountTotal;
  BagExcessStampsTableField get StampAmountTotal {
    return _StampAmountTotal =
        _setField(_StampAmountTotal, 'StampAmountTotal', DbType.text);
  }

  BagExcessStampsTableField? _Status;
  BagExcessStampsTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<BagExcessStampsTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagExcessStampsTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagExcessStampsTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'StampID IN (SELECT StampID from bagExcessStampsTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagExcessStampsTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagExcessStampsTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagExcessStampsTable?
  @override
  Future<BagExcessStampsTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagExcessStampsTable!.toList(qparams);
    final data = await objFuture;
    BagExcessStampsTable? obj;
    if (data.isNotEmpty) {
      obj = BagExcessStampsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagExcessStampsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagExcessStampsTable?
  @override
  Future<BagExcessStampsTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagExcessStampsTable();
  }

  /// This method returns int. [BagExcessStampsTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagexcessstampstableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagexcessstampstablesFuture =
        await _mnBagExcessStampsTable!.toList(qparams);
    final int count = bagexcessstampstablesFuture[0]['CNT'] as int;
    if (bagexcessstampstableCount != null) {
      bagexcessstampstableCount(count);
    }
    return count;
  }

  /// This method returns List<BagExcessStampsTable> [BagExcessStampsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagExcessStampsTable>
  @override
  Future<List<BagExcessStampsTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagExcessStampsTable> bagexcessstampstablesData =
        await BagExcessStampsTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagexcessstampstablesData;
  }

  /// This method returns Json String [BagExcessStampsTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagExcessStampsTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagExcessStampsTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagExcessStampsTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagExcessStampsTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `StampID` FROM bagExcessStampsTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> StampIDData = <String>[];
    qparams.selectColumns = ['StampID'];
    final StampIDFuture = await _mnBagExcessStampsTable!.toList(qparams);

    final int count = StampIDFuture.length;
    for (int i = 0; i < count; i++) {
      StampIDData.add(StampIDFuture[i]['StampID'] as String);
    }
    return StampIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagExcessStampsTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagExcessStampsTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagExcessStampsTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagExcessStampsTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagExcessStampsTableFilterBuilder

// region BagExcessStampsTableFields
class BagExcessStampsTableFields {
  static TableField? _fStampID;
  static TableField get StampID {
    return _fStampID =
        _fStampID ?? SqlSyntax.setField(_fStampID, 'stampid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fStampPrice;
  static TableField get StampPrice {
    return _fStampPrice = _fStampPrice ??
        SqlSyntax.setField(_fStampPrice, 'StampPrice', DbType.text);
  }

  static TableField? _fStampName;
  static TableField get StampName {
    return _fStampName = _fStampName ??
        SqlSyntax.setField(_fStampName, 'StampName', DbType.text);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField? _fStampQuantity;
  static TableField get StampQuantity {
    return _fStampQuantity = _fStampQuantity ??
        SqlSyntax.setField(_fStampQuantity, 'StampQuantity', DbType.text);
  }

  static TableField? _fStampAmountTotal;
  static TableField get StampAmountTotal {
    return _fStampAmountTotal = _fStampAmountTotal ??
        SqlSyntax.setField(_fStampAmountTotal, 'StampAmountTotal', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion BagExcessStampsTableFields

//region BagExcessStampsTableManager
class BagExcessStampsTableManager extends SqfEntityProvider {
  BagExcessStampsTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagExcessStampsTable';
  static const List<String> _primaryKeyList = ['StampID'];
  static const String _whereStr = 'StampID=?';
}

//endregion BagExcessStampsTableManager
// region ProductsTable
class ProductsTable extends TableBase {
  ProductsTable(
      {this.ProductID, this.Name, this.Price, this.Quantity, this.Value}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ProductsTable.withFields(
      this.ProductID, this.Name, this.Price, this.Quantity, this.Value) {
    _setDefaultValues();
  }
  ProductsTable.withId(
      this.ProductID, this.Name, this.Price, this.Quantity, this.Value) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ProductsTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    ProductID = o['ProductID'].toString();
    if (o['Name'] != null) {
      Name = o['Name'].toString();
    }
    if (o['Price'] != null) {
      Price = o['Price'].toString();
    }
    if (o['Quantity'] != null) {
      Quantity = o['Quantity'].toString();
    }
    if (o['Value'] != null) {
      Value = o['Value'].toString();
    }

    isSaved = true;
  }
  // FIELDS (ProductsTable)
  String? ProductID;
  String? Name;
  String? Price;
  String? Quantity;
  String? Value;
  bool? isSaved;
  // end FIELDS (ProductsTable)

  static const bool _softDeleteActivated = false;
  ProductsTableManager? __mnProductsTable;

  ProductsTableManager get _mnProductsTable {
    return __mnProductsTable = __mnProductsTable ?? ProductsTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['ProductID'] = ProductID;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['ProductID'] = ProductID;
    if (Name != null || !forView) {
      map['Name'] = Name;
    }
    if (Price != null || !forView) {
      map['Price'] = Price;
    }
    if (Quantity != null || !forView) {
      map['Quantity'] = Quantity;
    }
    if (Value != null || !forView) {
      map['Value'] = Value;
    }

    return map;
  }

  /// This method returns Json String [ProductsTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ProductsTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [ProductID, Name, Price, Quantity, Value];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [ProductID, Name, Price, Quantity, Value];
  }

  static Future<List<ProductsTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductsTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ProductsTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ProductsTable>[];
    try {
      objList = list
          .map((productstable) =>
              ProductsTable.fromMap(productstable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ProductsTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ProductsTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ProductsTable> objList = <ProductsTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ProductsTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ProductsTable by ID if exist, otherwise returns null
  /// Primary Keys: String? ProductID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ProductsTable] if exist, otherwise returns null
  Future<ProductsTable?> getById(String? ProductID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (ProductID == null) {
      return null;
    }
    ProductsTable? obj;
    final data = await _mnProductsTable.getById([ProductID]);
    if (data.length != 0) {
      obj = ProductsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ProductsTable) object. If the Primary Key (ProductID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same ProductID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnProductsTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO productsTable (ProductID, Name, Price, Quantity, Value)  VALUES (?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<ProductsTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<ProductsTable> productstables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in productstables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductsTable.rawInsert(
          'INSERT OR REPLACE INTO productsTable (ProductID, Name, Price, Quantity, Value)  VALUES (?,?,?,?,?)',
          [ProductID, Name, Price, Quantity, Value],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ProductsTable ProductID=$ProductID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductsTable ProductID=$ProductID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnProductsTable.rawInsert(
          'INSERT OR IGNORE INTO productsTable (ProductID, Name, Price, Quantity, Value)  VALUES (?,?,?,?,?)',
          [ProductID, Name, Price, Quantity, Value],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'ProductsTable ProductID=$ProductID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ProductsTable ProductID=$ProductID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'ProductsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes ProductsTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete ProductsTable invoked (ProductID=$ProductID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnProductsTable.delete(
          QueryParams(whereString: 'ProductID=?', whereArguments: [ProductID]));
    } else {
      return _mnProductsTable.updateBatch(
          QueryParams(whereString: 'ProductID=?', whereArguments: [ProductID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ProductsTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ProductsTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ProductsTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ProductsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      ProductID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion productstable

// region ProductsTableField
class ProductsTableField extends FilterBase {
  ProductsTableField(ProductsTableFilterBuilder productstableFB)
      : super(productstableFB);

  @override
  ProductsTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder isNull() {
    return super.isNull() as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ProductsTableFilterBuilder;
  }

  @override
  ProductsTableField get not {
    return super.not as ProductsTableField;
  }
}
// endregion ProductsTableField

// region ProductsTableFilterBuilder
class ProductsTableFilterBuilder extends ConjunctionBase {
  ProductsTableFilterBuilder(ProductsTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnProductsTable = obj._mnProductsTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ProductsTableManager? _mnProductsTable;

  /// put the sql keyword 'AND'
  @override
  ProductsTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ProductsTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ProductsTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ProductsTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ProductsTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ProductsTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ProductsTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductsTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductsTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ProductsTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ProductsTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ProductsTableField _setField(
      ProductsTableField? field, String colName, DbType dbtype) {
    return ProductsTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ProductsTableField? _ProductID;
  ProductsTableField get ProductID {
    return _ProductID = _setField(_ProductID, 'ProductID', DbType.integer);
  }

  ProductsTableField? _Name;
  ProductsTableField get Name {
    return _Name = _setField(_Name, 'Name', DbType.text);
  }

  ProductsTableField? _Price;
  ProductsTableField get Price {
    return _Price = _setField(_Price, 'Price', DbType.text);
  }

  ProductsTableField? _Quantity;
  ProductsTableField get Quantity {
    return _Quantity = _setField(_Quantity, 'Quantity', DbType.text);
  }

  ProductsTableField? _Value;
  ProductsTableField get Value {
    return _Value = _setField(_Value, 'Value', DbType.text);
  }

  /// Deletes List<ProductsTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnProductsTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnProductsTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'ProductID IN (SELECT ProductID from productsTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnProductsTable!.updateBatch(qparams, values);
  }

  /// This method always returns [ProductsTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductsTable?
  @override
  Future<ProductsTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnProductsTable!.toList(qparams);
    final data = await objFuture;
    ProductsTable? obj;
    if (data.isNotEmpty) {
      obj = ProductsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ProductsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ProductsTable?
  @override
  Future<ProductsTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ProductsTable();
  }

  /// This method returns int. [ProductsTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? productstableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final productstablesFuture = await _mnProductsTable!.toList(qparams);
    final int count = productstablesFuture[0]['CNT'] as int;
    if (productstableCount != null) {
      productstableCount(count);
    }
    return count;
  }

  /// This method returns List<ProductsTable> [ProductsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ProductsTable>
  @override
  Future<List<ProductsTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ProductsTable> productstablesData =
        await ProductsTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return productstablesData;
  }

  /// This method returns Json String [ProductsTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ProductsTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ProductsTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnProductsTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ProductsTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `ProductID` FROM productsTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> ProductIDData = <String>[];
    qparams.selectColumns = ['ProductID'];
    final ProductIDFuture = await _mnProductsTable!.toList(qparams);

    final int count = ProductIDFuture.length;
    for (int i = 0; i < count; i++) {
      ProductIDData.add(ProductIDFuture[i]['ProductID'] as String);
    }
    return ProductIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ProductsTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnProductsTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ProductsTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnProductsTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ProductsTableFilterBuilder

// region ProductsTableFields
class ProductsTableFields {
  static TableField? _fProductID;
  static TableField get ProductID {
    return _fProductID = _fProductID ??
        SqlSyntax.setField(_fProductID, 'productid', DbType.integer);
  }

  static TableField? _fName;
  static TableField get Name {
    return _fName = _fName ?? SqlSyntax.setField(_fName, 'Name', DbType.text);
  }

  static TableField? _fPrice;
  static TableField get Price {
    return _fPrice =
        _fPrice ?? SqlSyntax.setField(_fPrice, 'Price', DbType.text);
  }

  static TableField? _fQuantity;
  static TableField get Quantity {
    return _fQuantity =
        _fQuantity ?? SqlSyntax.setField(_fQuantity, 'Quantity', DbType.text);
  }

  static TableField? _fValue;
  static TableField get Value {
    return _fValue =
        _fValue ?? SqlSyntax.setField(_fValue, 'Value', DbType.text);
  }
}
// endregion ProductsTableFields

//region ProductsTableManager
class ProductsTableManager extends SqfEntityProvider {
  ProductsTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'productsTable';
  static const List<String> _primaryKeyList = ['ProductID'];
  static const String _whereStr = 'ProductID=?';
}

//endregion ProductsTableManager
// region DocumentsTable
class DocumentsTable extends TableBase {
  DocumentsTable({this.DocumentID, this.BagNumber, this.DocumentName}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DocumentsTable.withFields(
      this.DocumentID, this.BagNumber, this.DocumentName) {
    _setDefaultValues();
  }
  DocumentsTable.withId(this.DocumentID, this.BagNumber, this.DocumentName) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DocumentsTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    DocumentID = o['DocumentID'].toString();
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['DocumentName'] != null) {
      DocumentName = o['DocumentName'].toString();
    }

    isSaved = true;
  }
  // FIELDS (DocumentsTable)
  String? DocumentID;
  String? BagNumber;
  String? DocumentName;
  bool? isSaved;
  // end FIELDS (DocumentsTable)

  static const bool _softDeleteActivated = false;
  DocumentsTableManager? __mnDocumentsTable;

  DocumentsTableManager get _mnDocumentsTable {
    return __mnDocumentsTable = __mnDocumentsTable ?? DocumentsTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['DocumentID'] = DocumentID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (DocumentName != null || !forView) {
      map['DocumentName'] = DocumentName;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['DocumentID'] = DocumentID;
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (DocumentName != null || !forView) {
      map['DocumentName'] = DocumentName;
    }

    return map;
  }

  /// This method returns Json String [DocumentsTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DocumentsTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [DocumentID, BagNumber, DocumentName];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [DocumentID, BagNumber, DocumentName];
  }

  static Future<List<DocumentsTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentsTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DocumentsTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DocumentsTable>[];
    try {
      objList = list
          .map((documentstable) =>
              DocumentsTable.fromMap(documentstable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentsTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DocumentsTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DocumentsTable> objList = <DocumentsTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DocumentsTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DocumentsTable by ID if exist, otherwise returns null
  /// Primary Keys: String? DocumentID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DocumentsTable] if exist, otherwise returns null
  Future<DocumentsTable?> getById(String? DocumentID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (DocumentID == null) {
      return null;
    }
    DocumentsTable? obj;
    final data = await _mnDocumentsTable.getById([DocumentID]);
    if (data.length != 0) {
      obj = DocumentsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DocumentsTable) object. If the Primary Key (DocumentID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same DocumentID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnDocumentsTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO documentsTable (DocumentID, BagNumber, DocumentName)  VALUES (?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<DocumentsTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DocumentsTable> documentstables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in documentstables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDocumentsTable.rawInsert(
          'INSERT OR REPLACE INTO documentsTable (DocumentID, BagNumber, DocumentName)  VALUES (?,?,?)',
          [DocumentID, BagNumber, DocumentName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DocumentsTable DocumentID=$DocumentID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'DocumentsTable DocumentID=$DocumentID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DocumentsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDocumentsTable.rawInsert(
          'INSERT OR IGNORE INTO documentsTable (DocumentID, BagNumber, DocumentName)  VALUES (?,?,?)',
          [DocumentID, BagNumber, DocumentName],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DocumentsTable DocumentID=$DocumentID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'DocumentsTable DocumentID=$DocumentID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DocumentsTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes DocumentsTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete DocumentsTable invoked (DocumentID=$DocumentID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDocumentsTable.delete(QueryParams(
          whereString: 'DocumentID=?', whereArguments: [DocumentID]));
    } else {
      return _mnDocumentsTable.updateBatch(
          QueryParams(
              whereString: 'DocumentID=?', whereArguments: [DocumentID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DocumentsTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DocumentsTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DocumentsTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentsTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      DocumentID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion documentstable

// region DocumentsTableField
class DocumentsTableField extends FilterBase {
  DocumentsTableField(DocumentsTableFilterBuilder documentstableFB)
      : super(documentstableFB);

  @override
  DocumentsTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder isNull() {
    return super.isNull() as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DocumentsTableFilterBuilder;
  }

  @override
  DocumentsTableField get not {
    return super.not as DocumentsTableField;
  }
}
// endregion DocumentsTableField

// region DocumentsTableFilterBuilder
class DocumentsTableFilterBuilder extends ConjunctionBase {
  DocumentsTableFilterBuilder(DocumentsTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDocumentsTable = obj._mnDocumentsTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DocumentsTableManager? _mnDocumentsTable;

  /// put the sql keyword 'AND'
  @override
  DocumentsTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DocumentsTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DocumentsTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DocumentsTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DocumentsTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DocumentsTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DocumentsTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DocumentsTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DocumentsTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DocumentsTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DocumentsTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DocumentsTableField _setField(
      DocumentsTableField? field, String colName, DbType dbtype) {
    return DocumentsTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DocumentsTableField? _DocumentID;
  DocumentsTableField get DocumentID {
    return _DocumentID = _setField(_DocumentID, 'DocumentID', DbType.integer);
  }

  DocumentsTableField? _BagNumber;
  DocumentsTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  DocumentsTableField? _DocumentName;
  DocumentsTableField get DocumentName {
    return _DocumentName =
        _setField(_DocumentName, 'DocumentName', DbType.text);
  }

  /// Deletes List<DocumentsTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDocumentsTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDocumentsTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'DocumentID IN (SELECT DocumentID from documentsTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDocumentsTable!.updateBatch(qparams, values);
  }

  /// This method always returns [DocumentsTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DocumentsTable?
  @override
  Future<DocumentsTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDocumentsTable!.toList(qparams);
    final data = await objFuture;
    DocumentsTable? obj;
    if (data.isNotEmpty) {
      obj = DocumentsTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DocumentsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DocumentsTable?
  @override
  Future<DocumentsTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DocumentsTable();
  }

  /// This method returns int. [DocumentsTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? documentstableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final documentstablesFuture = await _mnDocumentsTable!.toList(qparams);
    final int count = documentstablesFuture[0]['CNT'] as int;
    if (documentstableCount != null) {
      documentstableCount(count);
    }
    return count;
  }

  /// This method returns List<DocumentsTable> [DocumentsTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DocumentsTable>
  @override
  Future<List<DocumentsTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DocumentsTable> documentstablesData =
        await DocumentsTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return documentstablesData;
  }

  /// This method returns Json String [DocumentsTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DocumentsTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DocumentsTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDocumentsTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DocumentsTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `DocumentID` FROM documentsTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> DocumentIDData = <String>[];
    qparams.selectColumns = ['DocumentID'];
    final DocumentIDFuture = await _mnDocumentsTable!.toList(qparams);

    final int count = DocumentIDFuture.length;
    for (int i = 0; i < count; i++) {
      DocumentIDData.add(DocumentIDFuture[i]['DocumentID'] as String);
    }
    return DocumentIDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DocumentsTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDocumentsTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DocumentsTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDocumentsTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DocumentsTableFilterBuilder

// region DocumentsTableFields
class DocumentsTableFields {
  static TableField? _fDocumentID;
  static TableField get DocumentID {
    return _fDocumentID = _fDocumentID ??
        SqlSyntax.setField(_fDocumentID, 'documentid', DbType.integer);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fDocumentName;
  static TableField get DocumentName {
    return _fDocumentName = _fDocumentName ??
        SqlSyntax.setField(_fDocumentName, 'DocumentName', DbType.text);
  }
}
// endregion DocumentsTableFields

//region DocumentsTableManager
class DocumentsTableManager extends SqfEntityProvider {
  DocumentsTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'documentsTable';
  static const List<String> _primaryKeyList = ['DocumentID'];
  static const String _whereStr = 'DocumentID=?';
}

//endregion DocumentsTableManager
// region BagCloseTable
class BagCloseTable extends TableBase {
  BagCloseTable(
      {this.BagNumber,
      this.ClosedDate,
      this.ClosedTime,
      this.TotalArticlesCount,
      this.CashCount,
      this.Status,
      this.DispatchDate,
      this.DispatchTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagCloseTable.withFields(
      this.BagNumber,
      this.ClosedDate,
      this.ClosedTime,
      this.TotalArticlesCount,
      this.CashCount,
      this.Status,
      this.DispatchDate,
      this.DispatchTime) {
    _setDefaultValues();
  }
  BagCloseTable.withId(
      this.BagNumber,
      this.ClosedDate,
      this.ClosedTime,
      this.TotalArticlesCount,
      this.CashCount,
      this.Status,
      this.DispatchDate,
      this.DispatchTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagCloseTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BagNumber = o['BagNumber'].toString();
    if (o['ClosedDate'] != null) {
      ClosedDate = o['ClosedDate'].toString();
    }
    if (o['ClosedTime'] != null) {
      ClosedTime = o['ClosedTime'].toString();
    }
    if (o['TotalArticlesCount'] != null) {
      TotalArticlesCount = o['TotalArticlesCount'].toString();
    }
    if (o['CashCount'] != null) {
      CashCount = o['CashCount'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
    if (o['DispatchDate'] != null) {
      DispatchDate = o['DispatchDate'].toString();
    }
    if (o['DispatchTime'] != null) {
      DispatchTime = o['DispatchTime'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagCloseTable)
  String? BagNumber;
  String? ClosedDate;
  String? ClosedTime;
  String? TotalArticlesCount;
  String? CashCount;
  String? Status;
  String? DispatchDate;
  String? DispatchTime;
  bool? isSaved;
  // end FIELDS (BagCloseTable)

  static const bool _softDeleteActivated = false;
  BagCloseTableManager? __mnBagCloseTable;

  BagCloseTableManager get _mnBagCloseTable {
    return __mnBagCloseTable = __mnBagCloseTable ?? BagCloseTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (ClosedDate != null || !forView) {
      map['ClosedDate'] = ClosedDate;
    }
    if (ClosedTime != null || !forView) {
      map['ClosedTime'] = ClosedTime;
    }
    if (TotalArticlesCount != null || !forView) {
      map['TotalArticlesCount'] = TotalArticlesCount;
    }
    if (CashCount != null || !forView) {
      map['CashCount'] = CashCount;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (DispatchDate != null || !forView) {
      map['DispatchDate'] = DispatchDate;
    }
    if (DispatchTime != null || !forView) {
      map['DispatchTime'] = DispatchTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (ClosedDate != null || !forView) {
      map['ClosedDate'] = ClosedDate;
    }
    if (ClosedTime != null || !forView) {
      map['ClosedTime'] = ClosedTime;
    }
    if (TotalArticlesCount != null || !forView) {
      map['TotalArticlesCount'] = TotalArticlesCount;
    }
    if (CashCount != null || !forView) {
      map['CashCount'] = CashCount;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }
    if (DispatchDate != null || !forView) {
      map['DispatchDate'] = DispatchDate;
    }
    if (DispatchTime != null || !forView) {
      map['DispatchTime'] = DispatchTime;
    }

    return map;
  }

  /// This method returns Json String [BagCloseTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagCloseTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BagNumber,
      ClosedDate,
      ClosedTime,
      TotalArticlesCount,
      CashCount,
      Status,
      DispatchDate,
      DispatchTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BagNumber,
      ClosedDate,
      ClosedTime,
      TotalArticlesCount,
      CashCount,
      Status,
      DispatchDate,
      DispatchTime
    ];
  }

  static Future<List<BagCloseTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagCloseTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagCloseTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagCloseTable>[];
    try {
      objList = list
          .map((bagclosetable) =>
              BagCloseTable.fromMap(bagclosetable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagCloseTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagCloseTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagCloseTable> objList = <BagCloseTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagCloseTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagCloseTable by ID if exist, otherwise returns null
  /// Primary Keys: String? BagNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagCloseTable] if exist, otherwise returns null
  Future<BagCloseTable?> getById(String? BagNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BagNumber == null) {
      return null;
    }
    BagCloseTable? obj;
    final data = await _mnBagCloseTable.getById([BagNumber]);
    if (data.length != 0) {
      obj = BagCloseTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagCloseTable) object. If the Primary Key (BagNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BagNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagCloseTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagCloseTable (BagNumber, ClosedDate, ClosedTime, TotalArticlesCount, CashCount, Status, DispatchDate, DispatchTime)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagCloseTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagCloseTable> bagclosetables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagclosetables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagCloseTable.rawInsert(
          'INSERT OR REPLACE INTO bagCloseTable (BagNumber, ClosedDate, ClosedTime, TotalArticlesCount, CashCount, Status, DispatchDate, DispatchTime)  VALUES (?,?,?,?,?,?,?,?)',
          [
            BagNumber,
            ClosedDate,
            ClosedTime,
            TotalArticlesCount,
            CashCount,
            Status,
            DispatchDate,
            DispatchTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagCloseTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagCloseTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagCloseTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagCloseTable.rawInsert(
          'INSERT OR IGNORE INTO bagCloseTable (BagNumber, ClosedDate, ClosedTime, TotalArticlesCount, CashCount, Status, DispatchDate, DispatchTime)  VALUES (?,?,?,?,?,?,?,?)',
          [
            BagNumber,
            ClosedDate,
            ClosedTime,
            TotalArticlesCount,
            CashCount,
            Status,
            DispatchDate,
            DispatchTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagCloseTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagCloseTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagCloseTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagCloseTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete BagCloseTable invoked (BagNumber=$BagNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagCloseTable.delete(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]));
    } else {
      return _mnBagCloseTable.updateBatch(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagCloseTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagCloseTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagCloseTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagCloseTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagCloseTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BagNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagclosetable

// region BagCloseTableField
class BagCloseTableField extends FilterBase {
  BagCloseTableField(BagCloseTableFilterBuilder bagclosetableFB)
      : super(bagclosetableFB);

  @override
  BagCloseTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder isNull() {
    return super.isNull() as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagCloseTableFilterBuilder;
  }

  @override
  BagCloseTableField get not {
    return super.not as BagCloseTableField;
  }
}
// endregion BagCloseTableField

// region BagCloseTableFilterBuilder
class BagCloseTableFilterBuilder extends ConjunctionBase {
  BagCloseTableFilterBuilder(BagCloseTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagCloseTable = obj._mnBagCloseTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagCloseTableManager? _mnBagCloseTable;

  /// put the sql keyword 'AND'
  @override
  BagCloseTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagCloseTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagCloseTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagCloseTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagCloseTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagCloseTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagCloseTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagCloseTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagCloseTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagCloseTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagCloseTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagCloseTableField _setField(
      BagCloseTableField? field, String colName, DbType dbtype) {
    return BagCloseTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagCloseTableField? _BagNumber;
  BagCloseTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.integer);
  }

  BagCloseTableField? _ClosedDate;
  BagCloseTableField get ClosedDate {
    return _ClosedDate = _setField(_ClosedDate, 'ClosedDate', DbType.text);
  }

  BagCloseTableField? _ClosedTime;
  BagCloseTableField get ClosedTime {
    return _ClosedTime = _setField(_ClosedTime, 'ClosedTime', DbType.text);
  }

  BagCloseTableField? _TotalArticlesCount;
  BagCloseTableField get TotalArticlesCount {
    return _TotalArticlesCount =
        _setField(_TotalArticlesCount, 'TotalArticlesCount', DbType.text);
  }

  BagCloseTableField? _CashCount;
  BagCloseTableField get CashCount {
    return _CashCount = _setField(_CashCount, 'CashCount', DbType.text);
  }

  BagCloseTableField? _Status;
  BagCloseTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  BagCloseTableField? _DispatchDate;
  BagCloseTableField get DispatchDate {
    return _DispatchDate =
        _setField(_DispatchDate, 'DispatchDate', DbType.text);
  }

  BagCloseTableField? _DispatchTime;
  BagCloseTableField get DispatchTime {
    return _DispatchTime =
        _setField(_DispatchTime, 'DispatchTime', DbType.text);
  }

  /// Deletes List<BagCloseTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagCloseTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagCloseTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BagNumber IN (SELECT BagNumber from bagCloseTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagCloseTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagCloseTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagCloseTable?
  @override
  Future<BagCloseTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagCloseTable!.toList(qparams);
    final data = await objFuture;
    BagCloseTable? obj;
    if (data.isNotEmpty) {
      obj = BagCloseTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagCloseTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagCloseTable?
  @override
  Future<BagCloseTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagCloseTable();
  }

  /// This method returns int. [BagCloseTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? bagclosetableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagclosetablesFuture = await _mnBagCloseTable!.toList(qparams);
    final int count = bagclosetablesFuture[0]['CNT'] as int;
    if (bagclosetableCount != null) {
      bagclosetableCount(count);
    }
    return count;
  }

  /// This method returns List<BagCloseTable> [BagCloseTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagCloseTable>
  @override
  Future<List<BagCloseTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagCloseTable> bagclosetablesData =
        await BagCloseTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return bagclosetablesData;
  }

  /// This method returns Json String [BagCloseTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagCloseTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagCloseTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagCloseTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagCloseTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BagNumber` FROM bagCloseTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BagNumberData = <String>[];
    qparams.selectColumns = ['BagNumber'];
    final BagNumberFuture = await _mnBagCloseTable!.toList(qparams);

    final int count = BagNumberFuture.length;
    for (int i = 0; i < count; i++) {
      BagNumberData.add(BagNumberFuture[i]['BagNumber'] as String);
    }
    return BagNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagCloseTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagCloseTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagCloseTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagCloseTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagCloseTableFilterBuilder

// region BagCloseTableFields
class BagCloseTableFields {
  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'bagnumber', DbType.integer);
  }

  static TableField? _fClosedDate;
  static TableField get ClosedDate {
    return _fClosedDate = _fClosedDate ??
        SqlSyntax.setField(_fClosedDate, 'ClosedDate', DbType.text);
  }

  static TableField? _fClosedTime;
  static TableField get ClosedTime {
    return _fClosedTime = _fClosedTime ??
        SqlSyntax.setField(_fClosedTime, 'ClosedTime', DbType.text);
  }

  static TableField? _fTotalArticlesCount;
  static TableField get TotalArticlesCount {
    return _fTotalArticlesCount = _fTotalArticlesCount ??
        SqlSyntax.setField(
            _fTotalArticlesCount, 'TotalArticlesCount', DbType.text);
  }

  static TableField? _fCashCount;
  static TableField get CashCount {
    return _fCashCount = _fCashCount ??
        SqlSyntax.setField(_fCashCount, 'CashCount', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }

  static TableField? _fDispatchDate;
  static TableField get DispatchDate {
    return _fDispatchDate = _fDispatchDate ??
        SqlSyntax.setField(_fDispatchDate, 'DispatchDate', DbType.text);
  }

  static TableField? _fDispatchTime;
  static TableField get DispatchTime {
    return _fDispatchTime = _fDispatchTime ??
        SqlSyntax.setField(_fDispatchTime, 'DispatchTime', DbType.text);
  }
}
// endregion BagCloseTableFields

//region BagCloseTableManager
class BagCloseTableManager extends SqfEntityProvider {
  BagCloseTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagCloseTable';
  static const List<String> _primaryKeyList = ['BagNumber'];
  static const String _whereStr = 'BagNumber=?';
}

//endregion BagCloseTableManager
// region CloseArticlesTable
class CloseArticlesTable extends TableBase {
  CloseArticlesTable(
      {this.Sl,
      this.ArticleNumber,
      this.BagNumber,
      this.ArticleType,
      this.IsExcess,
      this.IsScanned,
      this.IsBooked,
      this.Status}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CloseArticlesTable.withFields(
      this.ArticleNumber,
      this.BagNumber,
      this.ArticleType,
      this.IsExcess,
      this.IsScanned,
      this.IsBooked,
      this.Status) {
    _setDefaultValues();
  }
  CloseArticlesTable.withId(
      this.Sl,
      this.ArticleNumber,
      this.BagNumber,
      this.ArticleType,
      this.IsExcess,
      this.IsScanned,
      this.IsBooked,
      this.Status) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CloseArticlesTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Sl = int.tryParse(o['Sl'].toString());
    if (o['ArticleNumber'] != null) {
      ArticleNumber = o['ArticleNumber'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['ArticleType'] != null) {
      ArticleType = o['ArticleType'].toString();
    }
    if (o['IsExcess'] != null) {
      IsExcess = o['IsExcess'].toString();
    }
    if (o['IsScanned'] != null) {
      IsScanned = o['IsScanned'].toString();
    }
    if (o['IsBooked'] != null) {
      IsBooked = o['IsBooked'].toString();
    }
    if (o['Status'] != null) {
      Status = o['Status'].toString();
    }
  }
  // FIELDS (CloseArticlesTable)
  int? Sl;
  String? ArticleNumber;
  String? BagNumber;
  String? ArticleType;
  String? IsExcess;
  String? IsScanned;
  String? IsBooked;
  String? Status;

  // end FIELDS (CloseArticlesTable)

  static const bool _softDeleteActivated = false;
  CloseArticlesTableManager? __mnCloseArticlesTable;

  CloseArticlesTableManager get _mnCloseArticlesTable {
    return __mnCloseArticlesTable =
        __mnCloseArticlesTable ?? CloseArticlesTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (IsExcess != null || !forView) {
      map['IsExcess'] = IsExcess;
    }
    if (IsScanned != null || !forView) {
      map['IsScanned'] = IsScanned;
    }
    if (IsBooked != null || !forView) {
      map['IsBooked'] = IsBooked;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Sl'] = Sl;
    if (ArticleNumber != null || !forView) {
      map['ArticleNumber'] = ArticleNumber;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (ArticleType != null || !forView) {
      map['ArticleType'] = ArticleType;
    }
    if (IsExcess != null || !forView) {
      map['IsExcess'] = IsExcess;
    }
    if (IsScanned != null || !forView) {
      map['IsScanned'] = IsScanned;
    }
    if (IsBooked != null || !forView) {
      map['IsBooked'] = IsBooked;
    }
    if (Status != null || !forView) {
      map['Status'] = Status;
    }

    return map;
  }

  /// This method returns Json String [CloseArticlesTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CloseArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      ArticleNumber,
      BagNumber,
      ArticleType,
      IsExcess,
      IsScanned,
      IsBooked,
      Status
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      Sl,
      ArticleNumber,
      BagNumber,
      ArticleType,
      IsExcess,
      IsScanned,
      IsBooked,
      Status
    ];
  }

  static Future<List<CloseArticlesTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CloseArticlesTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CloseArticlesTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CloseArticlesTable>[];
    try {
      objList = list
          .map((closearticlestable) => CloseArticlesTable.fromMap(
              closearticlestable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CloseArticlesTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CloseArticlesTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CloseArticlesTable> objList = <CloseArticlesTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CloseArticlesTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CloseArticlesTable by ID if exist, otherwise returns null
  /// Primary Keys: int? Sl, String? ArticleNumber, String? BagNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CloseArticlesTable] if exist, otherwise returns null
  Future<CloseArticlesTable?> getById(
      int? Sl, String? ArticleNumber, String? BagNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Sl == null) {
      return null;
    }
    CloseArticlesTable? obj;
    final data =
        await _mnCloseArticlesTable.getById([Sl, ArticleNumber, BagNumber]);
    if (data.length != 0) {
      obj = CloseArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CloseArticlesTable) object. If the Primary Key (Sl) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Sl
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCloseArticlesTable.rawInsert(
          'INSERT OR REPLACE INTO closeArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, IsExcess, IsScanned, IsBooked, Status)  VALUES (?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAs CloseArticlesTable
  /// Use this method if you do not want to update existing row when conflicts another row that have the same Sl

  /// Returns a BoolResult
  @override
  Future<BoolResult> saveAs({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCloseArticlesTable.rawInsert(
          'INSERT INTO closeArticlesTable ( ArticleNumber, BagNumber, ArticleType, IsExcess, IsScanned, IsBooked, Status)  VALUES (?,?,?,?,?,?,?)',
          [
            ArticleNumber,
            BagNumber,
            ArticleType,
            IsExcess,
            IsScanned,
            IsBooked,
            Status
          ],
          ignoreBatch);

      result.success = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    return result;
  }

  /// saveAll method saves the sent List<CloseArticlesTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<CloseArticlesTable> closearticlestables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in closearticlestables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < closearticlestables.length; i++) {
        if (closearticlestables[i].Sl == null) {
          closearticlestables[i].Sl = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCloseArticlesTable.rawInsert(
          'INSERT OR REPLACE INTO closeArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, IsExcess, IsScanned, IsBooked, Status)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            ArticleNumber,
            BagNumber,
            ArticleType,
            IsExcess,
            IsScanned,
            IsBooked,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CloseArticlesTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CloseArticlesTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'CloseArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns Sl
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCloseArticlesTable.rawInsert(
          'INSERT OR IGNORE INTO closeArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, IsExcess, IsScanned, IsBooked, Status)  VALUES (?,?,?,?,?,?,?,?)',
          [
            Sl,
            ArticleNumber,
            BagNumber,
            ArticleType,
            IsExcess,
            IsScanned,
            IsBooked,
            Status
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'CloseArticlesTable Sl=$Sl updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CloseArticlesTable Sl=$Sl did not update');
      }
      return Sl;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'CloseArticlesTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<CloseArticlesTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<CloseArticlesTable> closearticlestables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnCloseArticlesTable.rawInsertAll(
        'INSERT OR REPLACE INTO closeArticlesTable (Sl, ArticleNumber, BagNumber, ArticleType, IsExcess, IsScanned, IsBooked, Status)  VALUES (?,?,?,?,?,?,?,?)',
        closearticlestables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes CloseArticlesTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CloseArticlesTable invoked (Sl=$Sl)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCloseArticlesTable.delete(QueryParams(
          whereString: 'Sl=? AND ArticleNumber=? AND BagNumber=?',
          whereArguments: [Sl, ArticleNumber, BagNumber]));
    } else {
      return _mnCloseArticlesTable.updateBatch(
          QueryParams(
              whereString: 'Sl=? AND ArticleNumber=? AND BagNumber=?',
              whereArguments: [Sl, ArticleNumber, BagNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CloseArticlesTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CloseArticlesTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CloseArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CloseArticlesTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CloseArticlesTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Sl = null;
      ArticleNumber = null;
      BagNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion closearticlestable

// region CloseArticlesTableField
class CloseArticlesTableField extends FilterBase {
  CloseArticlesTableField(CloseArticlesTableFilterBuilder closearticlestableFB)
      : super(closearticlestableFB);

  @override
  CloseArticlesTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder isNull() {
    return super.isNull() as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CloseArticlesTableFilterBuilder;
  }

  @override
  CloseArticlesTableField get not {
    return super.not as CloseArticlesTableField;
  }
}
// endregion CloseArticlesTableField

// region CloseArticlesTableFilterBuilder
class CloseArticlesTableFilterBuilder extends ConjunctionBase {
  CloseArticlesTableFilterBuilder(CloseArticlesTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCloseArticlesTable = obj._mnCloseArticlesTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CloseArticlesTableManager? _mnCloseArticlesTable;

  /// put the sql keyword 'AND'
  @override
  CloseArticlesTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CloseArticlesTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CloseArticlesTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CloseArticlesTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CloseArticlesTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CloseArticlesTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CloseArticlesTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CloseArticlesTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CloseArticlesTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CloseArticlesTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CloseArticlesTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CloseArticlesTableField _setField(
      CloseArticlesTableField? field, String colName, DbType dbtype) {
    return CloseArticlesTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CloseArticlesTableField? _Sl;
  CloseArticlesTableField get Sl {
    return _Sl = _setField(_Sl, 'Sl', DbType.integer);
  }

  CloseArticlesTableField? _ArticleNumber;
  CloseArticlesTableField get ArticleNumber {
    return _ArticleNumber =
        _setField(_ArticleNumber, 'ArticleNumber', DbType.text);
  }

  CloseArticlesTableField? _BagNumber;
  CloseArticlesTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  CloseArticlesTableField? _ArticleType;
  CloseArticlesTableField get ArticleType {
    return _ArticleType = _setField(_ArticleType, 'ArticleType', DbType.text);
  }

  CloseArticlesTableField? _IsExcess;
  CloseArticlesTableField get IsExcess {
    return _IsExcess = _setField(_IsExcess, 'IsExcess', DbType.text);
  }

  CloseArticlesTableField? _IsScanned;
  CloseArticlesTableField get IsScanned {
    return _IsScanned = _setField(_IsScanned, 'IsScanned', DbType.text);
  }

  CloseArticlesTableField? _IsBooked;
  CloseArticlesTableField get IsBooked {
    return _IsBooked = _setField(_IsBooked, 'IsBooked', DbType.text);
  }

  CloseArticlesTableField? _Status;
  CloseArticlesTableField get Status {
    return _Status = _setField(_Status, 'Status', DbType.text);
  }

  /// Deletes List<CloseArticlesTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCloseArticlesTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCloseArticlesTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Sl IN (SELECT Sl from closeArticlesTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCloseArticlesTable!.updateBatch(qparams, values);
  }

  /// This method always returns [CloseArticlesTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CloseArticlesTable?
  @override
  Future<CloseArticlesTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCloseArticlesTable!.toList(qparams);
    final data = await objFuture;
    CloseArticlesTable? obj;
    if (data.isNotEmpty) {
      obj = CloseArticlesTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CloseArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CloseArticlesTable?
  @override
  Future<CloseArticlesTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CloseArticlesTable();
  }

  /// This method returns int. [CloseArticlesTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? closearticlestableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final closearticlestablesFuture =
        await _mnCloseArticlesTable!.toList(qparams);
    final int count = closearticlestablesFuture[0]['CNT'] as int;
    if (closearticlestableCount != null) {
      closearticlestableCount(count);
    }
    return count;
  }

  /// This method returns List<CloseArticlesTable> [CloseArticlesTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CloseArticlesTable>
  @override
  Future<List<CloseArticlesTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CloseArticlesTable> closearticlestablesData =
        await CloseArticlesTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return closearticlestablesData;
  }

  /// This method returns Json String [CloseArticlesTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CloseArticlesTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CloseArticlesTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCloseArticlesTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CloseArticlesTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Sl`ArticleNumber`BagNumber` FROM closeArticlesTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<Sl,ArticleNumber,BagNumber> [CloseArticlesTable]
  /// <returns>List<Sl,ArticleNumber,BagNumber>
  @override
  Future<List<CloseArticlesTable>> toListPrimaryKey(
      [bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    qparams.selectColumns = ['Sl', 'ArticleNumber', 'BagNumber'];
    final closearticlestableFuture =
        await _mnCloseArticlesTable!.toList(qparams);
    return await CloseArticlesTable.fromMapList(closearticlestableFuture);
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CloseArticlesTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCloseArticlesTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CloseArticlesTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCloseArticlesTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CloseArticlesTableFilterBuilder

// region CloseArticlesTableFields
class CloseArticlesTableFields {
  static TableField? _fSl;
  static TableField get Sl {
    return _fSl = _fSl ?? SqlSyntax.setField(_fSl, 'sl', DbType.integer);
  }

  static TableField? _fArticleNumber;
  static TableField get ArticleNumber {
    return _fArticleNumber = _fArticleNumber ??
        SqlSyntax.setField(_fArticleNumber, 'ArticleNumber', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fArticleType;
  static TableField get ArticleType {
    return _fArticleType = _fArticleType ??
        SqlSyntax.setField(_fArticleType, 'ArticleType', DbType.text);
  }

  static TableField? _fIsExcess;
  static TableField get IsExcess {
    return _fIsExcess =
        _fIsExcess ?? SqlSyntax.setField(_fIsExcess, 'IsExcess', DbType.text);
  }

  static TableField? _fIsScanned;
  static TableField get IsScanned {
    return _fIsScanned = _fIsScanned ??
        SqlSyntax.setField(_fIsScanned, 'IsScanned', DbType.text);
  }

  static TableField? _fIsBooked;
  static TableField get IsBooked {
    return _fIsBooked =
        _fIsBooked ?? SqlSyntax.setField(_fIsBooked, 'IsBooked', DbType.text);
  }

  static TableField? _fStatus;
  static TableField get Status {
    return _fStatus =
        _fStatus ?? SqlSyntax.setField(_fStatus, 'Status', DbType.text);
  }
}
// endregion CloseArticlesTableFields

//region CloseArticlesTableManager
class CloseArticlesTableManager extends SqfEntityProvider {
  CloseArticlesTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'closeArticlesTable';
  static const List<String> _primaryKeyList = [
    'Sl',
    'ArticleNumber',
    'BagNumber'
  ];
  static const String _whereStr = 'Sl=? AND ArticleNumber=? AND BagNumber=?';
}

//endregion CloseArticlesTableManager
// region ExcessBagCashTable
class ExcessBagCashTable extends TableBase {
  ExcessBagCashTable(
      {this.id,
      this.SOSlipNumber,
      this.ChequeNumber,
      this.GenerationDate,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.TypeOfPayment,
      this.Miscellaneous,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  ExcessBagCashTable.withFields(
      this.SOSlipNumber,
      this.ChequeNumber,
      this.GenerationDate,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.TypeOfPayment,
      this.Miscellaneous,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  ExcessBagCashTable.withId(
      this.id,
      this.SOSlipNumber,
      this.ChequeNumber,
      this.GenerationDate,
      this.BOName,
      this.SOName,
      this.CashAmount,
      this.Weight,
      this.ChequeAmount,
      this.TypeOfPayment,
      this.Miscellaneous,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  ExcessBagCashTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    id = int.tryParse(o['id'].toString());
    if (o['SOSlipNumber'] != null) {
      SOSlipNumber = o['SOSlipNumber'].toString();
    }
    if (o['ChequeNumber'] != null) {
      ChequeNumber = o['ChequeNumber'].toString();
    }
    if (o['GenerationDate'] != null) {
      GenerationDate = o['GenerationDate'].toString();
    }
    if (o['BOName'] != null) {
      BOName = o['BOName'].toString();
    }
    if (o['SOName'] != null) {
      SOName = o['SOName'].toString();
    }
    if (o['CashAmount'] != null) {
      CashAmount = o['CashAmount'].toString();
    }
    if (o['Weight'] != null) {
      Weight = o['Weight'].toString();
    }
    if (o['ChequeAmount'] != null) {
      ChequeAmount = o['ChequeAmount'].toString();
    }
    if (o['TypeOfPayment'] != null) {
      TypeOfPayment = o['TypeOfPayment'].toString();
    }
    if (o['Miscellaneous'] != null) {
      Miscellaneous = o['Miscellaneous'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
  }
  // FIELDS (ExcessBagCashTable)
  int? id;
  String? SOSlipNumber;
  String? ChequeNumber;
  String? GenerationDate;
  String? BOName;
  String? SOName;
  String? CashAmount;
  String? Weight;
  String? ChequeAmount;
  String? TypeOfPayment;
  String? Miscellaneous;
  String? BagNumber;
  String? FileCreated;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;

  // end FIELDS (ExcessBagCashTable)

  static const bool _softDeleteActivated = false;
  ExcessBagCashTableManager? __mnExcessBagCashTable;

  ExcessBagCashTableManager get _mnExcessBagCashTable {
    return __mnExcessBagCashTable =
        __mnExcessBagCashTable ?? ExcessBagCashTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SOSlipNumber != null || !forView) {
      map['SOSlipNumber'] = SOSlipNumber;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (GenerationDate != null || !forView) {
      map['GenerationDate'] = GenerationDate;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (TypeOfPayment != null || !forView) {
      map['TypeOfPayment'] = TypeOfPayment;
    }
    if (Miscellaneous != null || !forView) {
      map['Miscellaneous'] = Miscellaneous;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['id'] = id;
    if (SOSlipNumber != null || !forView) {
      map['SOSlipNumber'] = SOSlipNumber;
    }
    if (ChequeNumber != null || !forView) {
      map['ChequeNumber'] = ChequeNumber;
    }
    if (GenerationDate != null || !forView) {
      map['GenerationDate'] = GenerationDate;
    }
    if (BOName != null || !forView) {
      map['BOName'] = BOName;
    }
    if (SOName != null || !forView) {
      map['SOName'] = SOName;
    }
    if (CashAmount != null || !forView) {
      map['CashAmount'] = CashAmount;
    }
    if (Weight != null || !forView) {
      map['Weight'] = Weight;
    }
    if (ChequeAmount != null || !forView) {
      map['ChequeAmount'] = ChequeAmount;
    }
    if (TypeOfPayment != null || !forView) {
      map['TypeOfPayment'] = TypeOfPayment;
    }
    if (Miscellaneous != null || !forView) {
      map['Miscellaneous'] = Miscellaneous;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  /// This method returns Json String [ExcessBagCashTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [ExcessBagCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      SOSlipNumber,
      ChequeNumber,
      GenerationDate,
      BOName,
      SOName,
      CashAmount,
      Weight,
      ChequeAmount,
      TypeOfPayment,
      Miscellaneous,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      id,
      SOSlipNumber,
      ChequeNumber,
      GenerationDate,
      BOName,
      SOName,
      CashAmount,
      Weight,
      ChequeAmount,
      TypeOfPayment,
      Miscellaneous,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  static Future<List<ExcessBagCashTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExcessBagCashTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<ExcessBagCashTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <ExcessBagCashTable>[];
    try {
      objList = list
          .map((excessbagcashtable) => ExcessBagCashTable.fromMap(
              excessbagcashtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR ExcessBagCashTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<ExcessBagCashTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<ExcessBagCashTable> objList = <ExcessBagCashTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = ExcessBagCashTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns ExcessBagCashTable by ID if exist, otherwise returns null
  /// Primary Keys: int? id
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [ExcessBagCashTable] if exist, otherwise returns null
  Future<ExcessBagCashTable?> getById(int? id,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (id == null) {
      return null;
    }
    ExcessBagCashTable? obj;
    final data = await _mnExcessBagCashTable.getById([id]);
    if (data.length != 0) {
      obj = ExcessBagCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (ExcessBagCashTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExcessBagCashTable.insert(this, ignoreBatch);
    } else {
      await _mnExcessBagCashTable.update(this);
    }

    return id;
  }

  /// Saves the (ExcessBagCashTable) object. If the id field is null, saves as a new record and returns new id, if id is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns id
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (id == null || id == 0) {
      id = await _mnExcessBagCashTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // id= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnExcessBagCashTable.updateOrThrow(this);
    }

    return id;
  }

  /// saveAs ExcessBagCashTable. Returns a new Primary Key value of ExcessBagCashTable

  /// <returns>Returns a new Primary Key value of ExcessBagCashTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    id = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<ExcessBagCashTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<ExcessBagCashTable> excessbagcashtables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in excessbagcashtables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < excessbagcashtables.length; i++) {
        if (excessbagcashtables[i].id == null) {
          excessbagcashtables[i].id = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExcessBagCashTable.rawInsert(
          'INSERT OR REPLACE INTO ExcessBagCashTable (id, SOSlipNumber, ChequeNumber, GenerationDate, BOName, SOName, CashAmount, Weight, ChequeAmount, TypeOfPayment, Miscellaneous, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SOSlipNumber,
            ChequeNumber,
            GenerationDate,
            BOName,
            SOName,
            CashAmount,
            Weight,
            ChequeAmount,
            TypeOfPayment,
            Miscellaneous,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ExcessBagCashTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ExcessBagCashTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'ExcessBagCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns id
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnExcessBagCashTable.rawInsert(
          'INSERT OR IGNORE INTO ExcessBagCashTable (id, SOSlipNumber, ChequeNumber, GenerationDate, BOName, SOName, CashAmount, Weight, ChequeAmount, TypeOfPayment, Miscellaneous, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            id,
            SOSlipNumber,
            ChequeNumber,
            GenerationDate,
            BOName,
            SOName,
            CashAmount,
            Weight,
            ChequeAmount,
            TypeOfPayment,
            Miscellaneous,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage: 'ExcessBagCashTable id=$id updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'ExcessBagCashTable id=$id did not update');
      }
      return id;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'ExcessBagCashTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<ExcessBagCashTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(
      List<ExcessBagCashTable> excessbagcashtables,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    final results = await _mnExcessBagCashTable.rawInsertAll(
        'INSERT OR REPLACE INTO ExcessBagCashTable (id, SOSlipNumber, ChequeNumber, GenerationDate, BOName, SOName, CashAmount, Weight, ChequeAmount, TypeOfPayment, Miscellaneous, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
        excessbagcashtables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes ExcessBagCashTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete ExcessBagCashTable invoked (id=$id)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnExcessBagCashTable
          .delete(QueryParams(whereString: 'id=?', whereArguments: [id]));
    } else {
      return _mnExcessBagCashTable.updateBatch(
          QueryParams(whereString: 'id=?', whereArguments: [id]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [ExcessBagCashTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  ExcessBagCashTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExcessBagCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  ExcessBagCashTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return ExcessBagCashTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      id = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion excessbagcashtable

// region ExcessBagCashTableField
class ExcessBagCashTableField extends FilterBase {
  ExcessBagCashTableField(ExcessBagCashTableFilterBuilder excessbagcashtableFB)
      : super(excessbagcashtableFB);

  @override
  ExcessBagCashTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder isNull() {
    return super.isNull() as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as ExcessBagCashTableFilterBuilder;
  }

  @override
  ExcessBagCashTableField get not {
    return super.not as ExcessBagCashTableField;
  }
}
// endregion ExcessBagCashTableField

// region ExcessBagCashTableFilterBuilder
class ExcessBagCashTableFilterBuilder extends ConjunctionBase {
  ExcessBagCashTableFilterBuilder(ExcessBagCashTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnExcessBagCashTable = obj._mnExcessBagCashTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  ExcessBagCashTableManager? _mnExcessBagCashTable;

  /// put the sql keyword 'AND'
  @override
  ExcessBagCashTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  ExcessBagCashTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  ExcessBagCashTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  ExcessBagCashTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  ExcessBagCashTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  ExcessBagCashTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  ExcessBagCashTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExcessBagCashTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExcessBagCashTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  ExcessBagCashTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  ExcessBagCashTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  ExcessBagCashTableField _setField(
      ExcessBagCashTableField? field, String colName, DbType dbtype) {
    return ExcessBagCashTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  ExcessBagCashTableField? _id;
  ExcessBagCashTableField get id {
    return _id = _setField(_id, 'id', DbType.integer);
  }

  ExcessBagCashTableField? _SOSlipNumber;
  ExcessBagCashTableField get SOSlipNumber {
    return _SOSlipNumber =
        _setField(_SOSlipNumber, 'SOSlipNumber', DbType.text);
  }

  ExcessBagCashTableField? _ChequeNumber;
  ExcessBagCashTableField get ChequeNumber {
    return _ChequeNumber =
        _setField(_ChequeNumber, 'ChequeNumber', DbType.text);
  }

  ExcessBagCashTableField? _GenerationDate;
  ExcessBagCashTableField get GenerationDate {
    return _GenerationDate =
        _setField(_GenerationDate, 'GenerationDate', DbType.text);
  }

  ExcessBagCashTableField? _BOName;
  ExcessBagCashTableField get BOName {
    return _BOName = _setField(_BOName, 'BOName', DbType.text);
  }

  ExcessBagCashTableField? _SOName;
  ExcessBagCashTableField get SOName {
    return _SOName = _setField(_SOName, 'SOName', DbType.text);
  }

  ExcessBagCashTableField? _CashAmount;
  ExcessBagCashTableField get CashAmount {
    return _CashAmount = _setField(_CashAmount, 'CashAmount', DbType.text);
  }

  ExcessBagCashTableField? _Weight;
  ExcessBagCashTableField get Weight {
    return _Weight = _setField(_Weight, 'Weight', DbType.text);
  }

  ExcessBagCashTableField? _ChequeAmount;
  ExcessBagCashTableField get ChequeAmount {
    return _ChequeAmount =
        _setField(_ChequeAmount, 'ChequeAmount', DbType.text);
  }

  ExcessBagCashTableField? _TypeOfPayment;
  ExcessBagCashTableField get TypeOfPayment {
    return _TypeOfPayment =
        _setField(_TypeOfPayment, 'TypeOfPayment', DbType.text);
  }

  ExcessBagCashTableField? _Miscellaneous;
  ExcessBagCashTableField get Miscellaneous {
    return _Miscellaneous =
        _setField(_Miscellaneous, 'Miscellaneous', DbType.text);
  }

  ExcessBagCashTableField? _BagNumber;
  ExcessBagCashTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  ExcessBagCashTableField? _FileCreated;
  ExcessBagCashTableField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  ExcessBagCashTableField? _FileName;
  ExcessBagCashTableField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  ExcessBagCashTableField? _FileCreatedDateTime;
  ExcessBagCashTableField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  ExcessBagCashTableField? _FileTransmitted;
  ExcessBagCashTableField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  ExcessBagCashTableField? _FileTransmittedDateTime;
  ExcessBagCashTableField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  /// Deletes List<ExcessBagCashTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnExcessBagCashTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnExcessBagCashTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'id IN (SELECT id from ExcessBagCashTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnExcessBagCashTable!.updateBatch(qparams, values);
  }

  /// This method always returns [ExcessBagCashTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExcessBagCashTable?
  @override
  Future<ExcessBagCashTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnExcessBagCashTable!.toList(qparams);
    final data = await objFuture;
    ExcessBagCashTable? obj;
    if (data.isNotEmpty) {
      obj = ExcessBagCashTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [ExcessBagCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> ExcessBagCashTable?
  @override
  Future<ExcessBagCashTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        ExcessBagCashTable();
  }

  /// This method returns int. [ExcessBagCashTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? excessbagcashtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final excessbagcashtablesFuture =
        await _mnExcessBagCashTable!.toList(qparams);
    final int count = excessbagcashtablesFuture[0]['CNT'] as int;
    if (excessbagcashtableCount != null) {
      excessbagcashtableCount(count);
    }
    return count;
  }

  /// This method returns List<ExcessBagCashTable> [ExcessBagCashTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<ExcessBagCashTable>
  @override
  Future<List<ExcessBagCashTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<ExcessBagCashTable> excessbagcashtablesData =
        await ExcessBagCashTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return excessbagcashtablesData;
  }

  /// This method returns Json String [ExcessBagCashTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [ExcessBagCashTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [ExcessBagCashTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnExcessBagCashTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [ExcessBagCashTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `id` FROM ExcessBagCashTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> idData = <int>[];
    qparams.selectColumns = ['id'];
    final idFuture = await _mnExcessBagCashTable!.toList(qparams);

    final int count = idFuture.length;
    for (int i = 0; i < count; i++) {
      idData.add(idFuture[i]['id'] as int);
    }
    return idData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [ExcessBagCashTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnExcessBagCashTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await ExcessBagCashTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnExcessBagCashTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion ExcessBagCashTableFilterBuilder

// region ExcessBagCashTableFields
class ExcessBagCashTableFields {
  static TableField? _fId;
  static TableField get id {
    return _fId = _fId ?? SqlSyntax.setField(_fId, 'id', DbType.integer);
  }

  static TableField? _fSOSlipNumber;
  static TableField get SOSlipNumber {
    return _fSOSlipNumber = _fSOSlipNumber ??
        SqlSyntax.setField(_fSOSlipNumber, 'SOSlipNumber', DbType.text);
  }

  static TableField? _fChequeNumber;
  static TableField get ChequeNumber {
    return _fChequeNumber = _fChequeNumber ??
        SqlSyntax.setField(_fChequeNumber, 'ChequeNumber', DbType.text);
  }

  static TableField? _fGenerationDate;
  static TableField get GenerationDate {
    return _fGenerationDate = _fGenerationDate ??
        SqlSyntax.setField(_fGenerationDate, 'GenerationDate', DbType.text);
  }

  static TableField? _fBOName;
  static TableField get BOName {
    return _fBOName =
        _fBOName ?? SqlSyntax.setField(_fBOName, 'BOName', DbType.text);
  }

  static TableField? _fSOName;
  static TableField get SOName {
    return _fSOName =
        _fSOName ?? SqlSyntax.setField(_fSOName, 'SOName', DbType.text);
  }

  static TableField? _fCashAmount;
  static TableField get CashAmount {
    return _fCashAmount = _fCashAmount ??
        SqlSyntax.setField(_fCashAmount, 'CashAmount', DbType.text);
  }

  static TableField? _fWeight;
  static TableField get Weight {
    return _fWeight =
        _fWeight ?? SqlSyntax.setField(_fWeight, 'Weight', DbType.text);
  }

  static TableField? _fChequeAmount;
  static TableField get ChequeAmount {
    return _fChequeAmount = _fChequeAmount ??
        SqlSyntax.setField(_fChequeAmount, 'ChequeAmount', DbType.text);
  }

  static TableField? _fTypeOfPayment;
  static TableField get TypeOfPayment {
    return _fTypeOfPayment = _fTypeOfPayment ??
        SqlSyntax.setField(_fTypeOfPayment, 'TypeOfPayment', DbType.text);
  }

  static TableField? _fMiscellaneous;
  static TableField get Miscellaneous {
    return _fMiscellaneous = _fMiscellaneous ??
        SqlSyntax.setField(_fMiscellaneous, 'Miscellaneous', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }
}
// endregion ExcessBagCashTableFields

//region ExcessBagCashTableManager
class ExcessBagCashTableManager extends SqfEntityProvider {
  ExcessBagCashTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'ExcessBagCashTable';
  static const List<String> _primaryKeyList = ['id'];
  static const String _whereStr = 'id=?';
}

//endregion ExcessBagCashTableManager
// region DocumentTable
class DocumentTable extends TableBase {
  DocumentTable(
      {this.DocumentId,
      this.BOAccountNumber,
      this.CreatedOn,
      this.FromOffice,
      this.DocumentDetails,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  DocumentTable.withFields(
      this.BOAccountNumber,
      this.CreatedOn,
      this.FromOffice,
      this.DocumentDetails,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  DocumentTable.withId(
      this.DocumentId,
      this.BOAccountNumber,
      this.CreatedOn,
      this.FromOffice,
      this.DocumentDetails,
      this.BagNumber,
      this.FileCreated,
      this.FileName,
      this.FileCreatedDateTime,
      this.FileTransmitted,
      this.FileTransmittedDateTime) {
    _setDefaultValues();
  }
  // fromMap v2.0
  DocumentTable.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    DocumentId = int.tryParse(o['DocumentId'].toString());
    if (o['BOAccountNumber'] != null) {
      BOAccountNumber = o['BOAccountNumber'].toString();
    }
    if (o['CreatedOn'] != null) {
      CreatedOn = o['CreatedOn'].toString();
    }
    if (o['FromOffice'] != null) {
      FromOffice = o['FromOffice'].toString();
    }
    if (o['DocumentDetails'] != null) {
      DocumentDetails = o['DocumentDetails'].toString();
    }
    if (o['BagNumber'] != null) {
      BagNumber = o['BagNumber'].toString();
    }
    if (o['FileCreated'] != null) {
      FileCreated = o['FileCreated'].toString();
    }
    if (o['FileName'] != null) {
      FileName = o['FileName'].toString();
    }
    if (o['FileCreatedDateTime'] != null) {
      FileCreatedDateTime = o['FileCreatedDateTime'].toString();
    }
    if (o['FileTransmitted'] != null) {
      FileTransmitted = o['FileTransmitted'].toString();
    }
    if (o['FileTransmittedDateTime'] != null) {
      FileTransmittedDateTime = o['FileTransmittedDateTime'].toString();
    }
  }
  // FIELDS (DocumentTable)
  int? DocumentId;
  String? BOAccountNumber;
  String? CreatedOn;
  String? FromOffice;
  String? DocumentDetails;
  String? BagNumber;
  String? FileCreated;
  String? FileName;
  String? FileCreatedDateTime;
  String? FileTransmitted;
  String? FileTransmittedDateTime;

  // end FIELDS (DocumentTable)

  static const bool _softDeleteActivated = false;
  DocumentTableManager? __mnDocumentTable;

  DocumentTableManager get _mnDocumentTable {
    return __mnDocumentTable = __mnDocumentTable ?? DocumentTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['DocumentId'] = DocumentId;
    if (BOAccountNumber != null || !forView) {
      map['BOAccountNumber'] = BOAccountNumber;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (FromOffice != null || !forView) {
      map['FromOffice'] = FromOffice;
    }
    if (DocumentDetails != null || !forView) {
      map['DocumentDetails'] = DocumentDetails;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['DocumentId'] = DocumentId;
    if (BOAccountNumber != null || !forView) {
      map['BOAccountNumber'] = BOAccountNumber;
    }
    if (CreatedOn != null || !forView) {
      map['CreatedOn'] = CreatedOn;
    }
    if (FromOffice != null || !forView) {
      map['FromOffice'] = FromOffice;
    }
    if (DocumentDetails != null || !forView) {
      map['DocumentDetails'] = DocumentDetails;
    }
    if (BagNumber != null || !forView) {
      map['BagNumber'] = BagNumber;
    }
    if (FileCreated != null || !forView) {
      map['FileCreated'] = FileCreated;
    }
    if (FileName != null || !forView) {
      map['FileName'] = FileName;
    }
    if (FileCreatedDateTime != null || !forView) {
      map['FileCreatedDateTime'] = FileCreatedDateTime;
    }
    if (FileTransmitted != null || !forView) {
      map['FileTransmitted'] = FileTransmitted;
    }
    if (FileTransmittedDateTime != null || !forView) {
      map['FileTransmittedDateTime'] = FileTransmittedDateTime;
    }

    return map;
  }

  /// This method returns Json String [DocumentTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [DocumentTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BOAccountNumber,
      CreatedOn,
      FromOffice,
      DocumentDetails,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      DocumentId,
      BOAccountNumber,
      CreatedOn,
      FromOffice,
      DocumentDetails,
      BagNumber,
      FileCreated,
      FileName,
      FileCreatedDateTime,
      FileTransmitted,
      FileTransmittedDateTime
    ];
  }

  static Future<List<DocumentTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<DocumentTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <DocumentTable>[];
    try {
      objList = list
          .map((documenttable) =>
              DocumentTable.fromMap(documenttable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR DocumentTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<DocumentTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<DocumentTable> objList = <DocumentTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = DocumentTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns DocumentTable by ID if exist, otherwise returns null
  /// Primary Keys: int? DocumentId
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [DocumentTable] if exist, otherwise returns null
  Future<DocumentTable?> getById(int? DocumentId,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (DocumentId == null) {
      return null;
    }
    DocumentTable? obj;
    final data = await _mnDocumentTable.getById([DocumentId]);
    if (data.length != 0) {
      obj = DocumentTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (DocumentTable) object. If the DocumentId field is null, saves as a new record and returns new DocumentId, if DocumentId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns DocumentId
  @override
  Future<int?> save({bool ignoreBatch = true}) async {
    if (DocumentId == null || DocumentId == 0) {
      DocumentId = await _mnDocumentTable.insert(this, ignoreBatch);
    } else {
      await _mnDocumentTable.update(this);
    }

    return DocumentId;
  }

  /// Saves the (DocumentTable) object. If the DocumentId field is null, saves as a new record and returns new DocumentId, if DocumentId is not null then updates record
  /// ignoreBatch = true as a default. Set ignoreBatch to false if you run more than one save() operation those are between batchStart and batchCommit
  /// <returns>Returns DocumentId
  @override
  Future<int?> saveOrThrow({bool ignoreBatch = true}) async {
    if (DocumentId == null || DocumentId == 0) {
      DocumentId = await _mnDocumentTable.insertOrThrow(this, ignoreBatch);

      isInsert = true;
    } else {
      // DocumentId= await _upsert(); // removed in sqfentity_gen 1.3.0+6
      await _mnDocumentTable.updateOrThrow(this);
    }

    return DocumentId;
  }

  /// saveAs DocumentTable. Returns a new Primary Key value of DocumentTable

  /// <returns>Returns a new Primary Key value of DocumentTable
  @override
  Future<int?> saveAs({bool ignoreBatch = true}) async {
    DocumentId = null;

    return save(ignoreBatch: ignoreBatch);
  }

  /// saveAll method saves the sent List<DocumentTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<DocumentTable> documenttables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in documenttables) {
      await obj.save(ignoreBatch: false);
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
      for (int i = 0; i < documenttables.length; i++) {
        if (documenttables[i].DocumentId == null) {
          documenttables[i].DocumentId = result![i] as int;
        }
      }
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns DocumentId
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDocumentTable.rawInsert(
          'INSERT OR REPLACE INTO DocumentTable (DocumentId, BOAccountNumber, CreatedOn, FromOffice, DocumentDetails, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            DocumentId,
            BOAccountNumber,
            CreatedOn,
            FromOffice,
            DocumentDetails,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DocumentTable DocumentId=$DocumentId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'DocumentTable DocumentId=$DocumentId did not update');
      }
      return DocumentId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DocumentTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns DocumentId
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnDocumentTable.rawInsert(
          'INSERT OR IGNORE INTO DocumentTable (DocumentId, BOAccountNumber, CreatedOn, FromOffice, DocumentDetails, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            DocumentId,
            BOAccountNumber,
            CreatedOn,
            FromOffice,
            DocumentDetails,
            BagNumber,
            FileCreated,
            FileName,
            FileCreatedDateTime,
            FileTransmitted,
            FileTransmittedDateTime
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'DocumentTable DocumentId=$DocumentId updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'DocumentTable DocumentId=$DocumentId did not update');
      }
      return DocumentId;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'DocumentTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// inserts or replaces the sent List<<DocumentTable>> as a bulk in one transaction.
  /// upsertAll() method is faster then saveAll() method. upsertAll() should be used when you are sure that the primary key is greater than zero
  /// Returns a BoolCommitResult
  @override
  Future<BoolCommitResult> upsertAll(List<DocumentTable> documenttables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    final results = await _mnDocumentTable.rawInsertAll(
        'INSERT OR REPLACE INTO DocumentTable (DocumentId, BOAccountNumber, CreatedOn, FromOffice, DocumentDetails, BagNumber, FileCreated, FileName, FileCreatedDateTime, FileTransmitted, FileTransmittedDateTime)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
        documenttables,
        exclusive: exclusive,
        noResult: noResult,
        continueOnError: continueOnError);
    return results;
  }

  /// Deletes DocumentTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete DocumentTable invoked (DocumentId=$DocumentId)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnDocumentTable.delete(QueryParams(
          whereString: 'DocumentId=?', whereArguments: [DocumentId]));
    } else {
      return _mnDocumentTable.updateBatch(
          QueryParams(
              whereString: 'DocumentId=?', whereArguments: [DocumentId]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [DocumentTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  DocumentTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  DocumentTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return DocumentTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {}

  @override
  void rollbackPk() {
    if (isInsert == true) {
      DocumentId = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion documenttable

// region DocumentTableField
class DocumentTableField extends FilterBase {
  DocumentTableField(DocumentTableFilterBuilder documenttableFB)
      : super(documenttableFB);

  @override
  DocumentTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder isNull() {
    return super.isNull() as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as DocumentTableFilterBuilder;
  }

  @override
  DocumentTableField get not {
    return super.not as DocumentTableField;
  }
}
// endregion DocumentTableField

// region DocumentTableFilterBuilder
class DocumentTableFilterBuilder extends ConjunctionBase {
  DocumentTableFilterBuilder(DocumentTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnDocumentTable = obj._mnDocumentTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  DocumentTableManager? _mnDocumentTable;

  /// put the sql keyword 'AND'
  @override
  DocumentTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  DocumentTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  DocumentTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  DocumentTableFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  DocumentTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  DocumentTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  DocumentTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DocumentTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DocumentTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  DocumentTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  DocumentTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  DocumentTableField _setField(
      DocumentTableField? field, String colName, DbType dbtype) {
    return DocumentTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  DocumentTableField? _DocumentId;
  DocumentTableField get DocumentId {
    return _DocumentId = _setField(_DocumentId, 'DocumentId', DbType.integer);
  }

  DocumentTableField? _BOAccountNumber;
  DocumentTableField get BOAccountNumber {
    return _BOAccountNumber =
        _setField(_BOAccountNumber, 'BOAccountNumber', DbType.text);
  }

  DocumentTableField? _CreatedOn;
  DocumentTableField get CreatedOn {
    return _CreatedOn = _setField(_CreatedOn, 'CreatedOn', DbType.text);
  }

  DocumentTableField? _FromOffice;
  DocumentTableField get FromOffice {
    return _FromOffice = _setField(_FromOffice, 'FromOffice', DbType.text);
  }

  DocumentTableField? _DocumentDetails;
  DocumentTableField get DocumentDetails {
    return _DocumentDetails =
        _setField(_DocumentDetails, 'DocumentDetails', DbType.text);
  }

  DocumentTableField? _BagNumber;
  DocumentTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.text);
  }

  DocumentTableField? _FileCreated;
  DocumentTableField get FileCreated {
    return _FileCreated = _setField(_FileCreated, 'FileCreated', DbType.text);
  }

  DocumentTableField? _FileName;
  DocumentTableField get FileName {
    return _FileName = _setField(_FileName, 'FileName', DbType.text);
  }

  DocumentTableField? _FileCreatedDateTime;
  DocumentTableField get FileCreatedDateTime {
    return _FileCreatedDateTime =
        _setField(_FileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  DocumentTableField? _FileTransmitted;
  DocumentTableField get FileTransmitted {
    return _FileTransmitted =
        _setField(_FileTransmitted, 'FileTransmitted', DbType.text);
  }

  DocumentTableField? _FileTransmittedDateTime;
  DocumentTableField get FileTransmittedDateTime {
    return _FileTransmittedDateTime = _setField(
        _FileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }

  /// Deletes List<DocumentTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnDocumentTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnDocumentTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'DocumentId IN (SELECT DocumentId from DocumentTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnDocumentTable!.updateBatch(qparams, values);
  }

  /// This method always returns [DocumentTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DocumentTable?
  @override
  Future<DocumentTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnDocumentTable!.toList(qparams);
    final data = await objFuture;
    DocumentTable? obj;
    if (data.isNotEmpty) {
      obj = DocumentTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [DocumentTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> DocumentTable?
  @override
  Future<DocumentTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        DocumentTable();
  }

  /// This method returns int. [DocumentTable]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? documenttableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final documenttablesFuture = await _mnDocumentTable!.toList(qparams);
    final int count = documenttablesFuture[0]['CNT'] as int;
    if (documenttableCount != null) {
      documenttableCount(count);
    }
    return count;
  }

  /// This method returns List<DocumentTable> [DocumentTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<DocumentTable>
  @override
  Future<List<DocumentTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<DocumentTable> documenttablesData =
        await DocumentTable.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return documenttablesData;
  }

  /// This method returns Json String [DocumentTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [DocumentTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [DocumentTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnDocumentTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [DocumentTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `DocumentId` FROM DocumentTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<int>.
  /// <returns>List<int>
  @override
  Future<List<int>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<int> DocumentIdData = <int>[];
    qparams.selectColumns = ['DocumentId'];
    final DocumentIdFuture = await _mnDocumentTable!.toList(qparams);

    final int count = DocumentIdFuture.length;
    for (int i = 0; i < count; i++) {
      DocumentIdData.add(DocumentIdFuture[i]['DocumentId'] as int);
    }
    return DocumentIdData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [DocumentTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnDocumentTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await DocumentTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnDocumentTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion DocumentTableFilterBuilder

// region DocumentTableFields
class DocumentTableFields {
  static TableField? _fDocumentId;
  static TableField get DocumentId {
    return _fDocumentId = _fDocumentId ??
        SqlSyntax.setField(_fDocumentId, 'documentid', DbType.integer);
  }

  static TableField? _fBOAccountNumber;
  static TableField get BOAccountNumber {
    return _fBOAccountNumber = _fBOAccountNumber ??
        SqlSyntax.setField(_fBOAccountNumber, 'BOAccountNumber', DbType.text);
  }

  static TableField? _fCreatedOn;
  static TableField get CreatedOn {
    return _fCreatedOn = _fCreatedOn ??
        SqlSyntax.setField(_fCreatedOn, 'CreatedOn', DbType.text);
  }

  static TableField? _fFromOffice;
  static TableField get FromOffice {
    return _fFromOffice = _fFromOffice ??
        SqlSyntax.setField(_fFromOffice, 'FromOffice', DbType.text);
  }

  static TableField? _fDocumentDetails;
  static TableField get DocumentDetails {
    return _fDocumentDetails = _fDocumentDetails ??
        SqlSyntax.setField(_fDocumentDetails, 'DocumentDetails', DbType.text);
  }

  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'BagNumber', DbType.text);
  }

  static TableField? _fFileCreated;
  static TableField get FileCreated {
    return _fFileCreated = _fFileCreated ??
        SqlSyntax.setField(_fFileCreated, 'FileCreated', DbType.text);
  }

  static TableField? _fFileName;
  static TableField get FileName {
    return _fFileName =
        _fFileName ?? SqlSyntax.setField(_fFileName, 'FileName', DbType.text);
  }

  static TableField? _fFileCreatedDateTime;
  static TableField get FileCreatedDateTime {
    return _fFileCreatedDateTime = _fFileCreatedDateTime ??
        SqlSyntax.setField(
            _fFileCreatedDateTime, 'FileCreatedDateTime', DbType.text);
  }

  static TableField? _fFileTransmitted;
  static TableField get FileTransmitted {
    return _fFileTransmitted = _fFileTransmitted ??
        SqlSyntax.setField(_fFileTransmitted, 'FileTransmitted', DbType.text);
  }

  static TableField? _fFileTransmittedDateTime;
  static TableField get FileTransmittedDateTime {
    return _fFileTransmittedDateTime = _fFileTransmittedDateTime ??
        SqlSyntax.setField(
            _fFileTransmittedDateTime, 'FileTransmittedDateTime', DbType.text);
  }
}
// endregion DocumentTableFields

//region DocumentTableManager
class DocumentTableManager extends SqfEntityProvider {
  DocumentTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'DocumentTable';
  static const List<String> _primaryKeyList = ['DocumentId'];
  static const String _whereStr = 'DocumentId=?';
}

//endregion DocumentTableManager
// region BagTable
class BagTable extends TableBase {
  BagTable({this.BagNumber, this.BagDate, this.BagTime, this.BagType}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  BagTable.withFields(
      this.BagNumber, this.BagDate, this.BagTime, this.BagType) {
    _setDefaultValues();
  }
  BagTable.withId(this.BagNumber, this.BagDate, this.BagTime, this.BagType) {
    _setDefaultValues();
  }
  // fromMap v2.0
  BagTable.fromMap(Map<String, dynamic> o, {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BagNumber = o['BagNumber'].toString();
    if (o['BagDate'] != null) {
      BagDate = o['BagDate'].toString();
    }
    if (o['BagTime'] != null) {
      BagTime = o['BagTime'].toString();
    }
    if (o['BagType'] != null) {
      BagType = o['BagType'].toString();
    }

    isSaved = true;
  }
  // FIELDS (BagTable)
  String? BagNumber;
  String? BagDate;
  String? BagTime;
  String? BagType;
  bool? isSaved;
  // end FIELDS (BagTable)

  static const bool _softDeleteActivated = false;
  BagTableManager? __mnBagTable;

  BagTableManager get _mnBagTable {
    return __mnBagTable = __mnBagTable ?? BagTableManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (BagDate != null || !forView) {
      map['BagDate'] = BagDate;
    }
    if (BagTime != null || !forView) {
      map['BagTime'] = BagTime;
    }
    if (BagType != null || !forView) {
      map['BagType'] = BagType;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BagNumber'] = BagNumber;
    if (BagDate != null || !forView) {
      map['BagDate'] = BagDate;
    }
    if (BagTime != null || !forView) {
      map['BagTime'] = BagTime;
    }
    if (BagType != null || !forView) {
      map['BagType'] = BagType;
    }

    return map;
  }

  /// This method returns Json String [BagTable]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [BagTable]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [BagNumber, BagDate, BagTime, BagType];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [BagNumber, BagDate, BagTime, BagType];
  }

  static Future<List<BagTable>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagTable.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<BagTable>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <BagTable>[];
    try {
      objList = list
          .map((bagtable) => BagTable.fromMap(bagtable as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR BagTable.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<BagTable>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<BagTable> objList = <BagTable>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = BagTable.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns BagTable by ID if exist, otherwise returns null
  /// Primary Keys: String? BagNumber
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [BagTable] if exist, otherwise returns null
  Future<BagTable?> getById(String? BagNumber,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BagNumber == null) {
      return null;
    }
    BagTable? obj;
    final data = await _mnBagTable.getById([BagNumber]);
    if (data.length != 0) {
      obj = BagTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (BagTable) object. If the Primary Key (BagNumber) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BagNumber
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnBagTable.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO bagTable (BagNumber, BagDate, BagTime, BagType)  VALUES (?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<BagTable> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<BagTable> bagtables,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await BagModel().batchStart();
    for (final obj in bagtables) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await BagModel().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagTable.rawInsert(
          'INSERT OR REPLACE INTO bagTable (BagNumber, BagDate, BagTime, BagType)  VALUES (?,?,?,?)',
          [BagNumber, BagDate, BagTime, BagType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnBagTable.rawInsert(
          'INSERT OR IGNORE INTO bagTable (BagNumber, BagDate, BagTime, BagType)  VALUES (?,?,?,?)',
          [BagNumber, BagDate, BagTime, BagType],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'BagTable BagNumber=$BagNumber updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'BagTable BagNumber=$BagNumber did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'BagTable Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes BagTable

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete BagTable invoked (BagNumber=$BagNumber)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnBagTable.delete(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]));
    } else {
      return _mnBagTable.updateBatch(
          QueryParams(whereString: 'BagNumber=?', whereArguments: [BagNumber]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [BagTable] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  BagTableFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  BagTableFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return BagTableFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BagNumber = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion bagtable

// region BagTableField
class BagTableField extends FilterBase {
  BagTableField(BagTableFilterBuilder bagtableFB) : super(bagtableFB);

  @override
  BagTableFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder isNull() {
    return super.isNull() as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as BagTableFilterBuilder;
  }

  @override
  BagTableField get not {
    return super.not as BagTableField;
  }
}
// endregion BagTableField

// region BagTableFilterBuilder
class BagTableFilterBuilder extends ConjunctionBase {
  BagTableFilterBuilder(BagTable obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnBagTable = obj._mnBagTable;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  BagTableManager? _mnBagTable;

  /// put the sql keyword 'AND'
  @override
  BagTableFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  BagTableFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  BagTableFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  BagTableFilterBuilder where(String? whereCriteria, {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  BagTableFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  BagTableFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  BagTableFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagTableFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagTableFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  BagTableFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  BagTableFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  BagTableField _setField(BagTableField? field, String colName, DbType dbtype) {
    return BagTableField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  BagTableField? _BagNumber;
  BagTableField get BagNumber {
    return _BagNumber = _setField(_BagNumber, 'BagNumber', DbType.integer);
  }

  BagTableField? _BagDate;
  BagTableField get BagDate {
    return _BagDate = _setField(_BagDate, 'BagDate', DbType.text);
  }

  BagTableField? _BagTime;
  BagTableField get BagTime {
    return _BagTime = _setField(_BagTime, 'BagTime', DbType.text);
  }

  BagTableField? _BagType;
  BagTableField get BagType {
    return _BagType = _setField(_BagType, 'BagType', DbType.text);
  }

  /// Deletes List<BagTable> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnBagTable!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnBagTable!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BagNumber IN (SELECT BagNumber from bagTable ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnBagTable!.updateBatch(qparams, values);
  }

  /// This method always returns [BagTable] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagTable?
  @override
  Future<BagTable?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnBagTable!.toList(qparams);
    final data = await objFuture;
    BagTable? obj;
    if (data.isNotEmpty) {
      obj = BagTable.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [BagTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> BagTable?
  @override
  Future<BagTable> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        BagTable();
  }

  /// This method returns int. [BagTable]
  /// <returns>int
  @override
  Future<int> toCount([VoidCallback Function(int c)? bagtableCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final bagtablesFuture = await _mnBagTable!.toList(qparams);
    final int count = bagtablesFuture[0]['CNT'] as int;
    if (bagtableCount != null) {
      bagtableCount(count);
    }
    return count;
  }

  /// This method returns List<BagTable> [BagTable]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<BagTable>
  @override
  Future<List<BagTable>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<BagTable> bagtablesData = await BagTable.fromMapList(data,
        preload: preload,
        preloadFields: preloadFields,
        loadParents: loadParents,
        loadedFields: loadedFields,
        setDefaultValues: qparams.selectColumns == null);
    return bagtablesData;
  }

  /// This method returns Json String [BagTable]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [BagTable]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [BagTable]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnBagTable!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [BagTable]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BagNumber` FROM bagTable WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BagNumberData = <String>[];
    qparams.selectColumns = ['BagNumber'];
    final BagNumberFuture = await _mnBagTable!.toList(qparams);

    final int count = BagNumberFuture.length;
    for (int i = 0; i < count; i++) {
      BagNumberData.add(BagNumberFuture[i]['BagNumber'] as String);
    }
    return BagNumberData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [BagTable]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnBagTable!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await BagTable.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnBagTable!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion BagTableFilterBuilder

// region BagTableFields
class BagTableFields {
  static TableField? _fBagNumber;
  static TableField get BagNumber {
    return _fBagNumber = _fBagNumber ??
        SqlSyntax.setField(_fBagNumber, 'bagnumber', DbType.integer);
  }

  static TableField? _fBagDate;
  static TableField get BagDate {
    return _fBagDate =
        _fBagDate ?? SqlSyntax.setField(_fBagDate, 'BagDate', DbType.text);
  }

  static TableField? _fBagTime;
  static TableField get BagTime {
    return _fBagTime =
        _fBagTime ?? SqlSyntax.setField(_fBagTime, 'BagTime', DbType.text);
  }

  static TableField? _fBagType;
  static TableField get BagType {
    return _fBagType =
        _fBagType ?? SqlSyntax.setField(_fBagType, 'BagType', DbType.text);
  }
}
// endregion BagTableFields

//region BagTableManager
class BagTableManager extends SqfEntityProvider {
  BagTableManager()
      : super(BagModel(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'bagTable';
  static const List<String> _primaryKeyList = ['BagNumber'];
  static const String _whereStr = 'BagNumber=?';
}

//endregion BagTableManager
class BagModelSequenceManager extends SqfEntityProvider {
  BagModelSequenceManager() : super(BagModel());
}
// END OF ENTITIES
