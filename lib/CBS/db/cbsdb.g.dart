// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'cbsdb.dart';

// **************************************************************************
// SqfEntityGenerator
// **************************************************************************

// ignore_for_file: non_constant_identifier_names

//  These classes was generated by SqfEntity
//  Copyright (c) 2019, All rights reserved. Use of this source code is governed by a
//  Apache license that can be found in the LICENSE file.

//  To use these SqfEntity classes do following:
//  - import model.dart into where to use
//  - start typing ex:TBCBS_TRAN_DETAILS.select()... (add a few filters with fluent methods)...(add orderBy/orderBydesc if you want)...
//  - and then just put end of filters / or end of only select()  toSingle() / or toList()
//  - you can select one or return List<yourObject> by your filters and orders
//  - also you can batch update or batch delete by using delete/update methods instead of tosingle/tolist methods
//    Enjoy.. Huseyin Tokpunar

// BEGIN TABLES
// TBCBS_TRAN_DETAILS TABLE
class TableTBCBS_TRAN_DETAILS extends SqfEntityTableBase {
  TableTBCBS_TRAN_DETAILS() {
    // declare properties of EntityTable
    tableName = 'TBCBS_TRAN_DETAILS';
    primaryKeyName = 'TRANSACTION_ID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('CUST_ACC_NUM', DbType.text),
      SqfEntityFieldBase('REFERENCE_NO', DbType.text),
      SqfEntityFieldBase('OFFICE_ACC_NUM', DbType.text),
      SqfEntityFieldBase('ACCOUNT_TYPE', DbType.text),
      SqfEntityFieldBase('MAIN_HOLDER_NAME', DbType.text),
      SqfEntityFieldBase('MAIN_HOLDER_CIFID', DbType.text),
      SqfEntityFieldBase('JOINT_HOLDER1_NAME', DbType.text),
      SqfEntityFieldBase('JOINT_HOLDER1_CIFID', DbType.text),
      SqfEntityFieldBase('JOINT_HOLDER2_NAME', DbType.text),
      SqfEntityFieldBase('JOINT_HOLDER2_CIFID', DbType.text),
      SqfEntityFieldBase('TRANSACTION_AMT', DbType.text),
      SqfEntityFieldBase('CURRENCY', DbType.text),
      SqfEntityFieldBase('TENURE', DbType.text),
      SqfEntityFieldBase('REMARKS', DbType.text),
      SqfEntityFieldBase('TRAN_TYPE', DbType.text),
      SqfEntityFieldBase('TRAN_DATE', DbType.text),
      SqfEntityFieldBase('TRAN_TIME', DbType.text),
      SqfEntityFieldBase('FIN_SOLBOD_DATE', DbType.text),
      SqfEntityFieldBase('MODE_OF_TRAN', DbType.text),
      SqfEntityFieldBase('SCHEME_TYPE', DbType.text),
      SqfEntityFieldBase('INSTALMENT_AMT', DbType.text),
      SqfEntityFieldBase('NO_OF_INSTALMENTS', DbType.text),
      SqfEntityFieldBase('REBATE_AMT', DbType.text),
      SqfEntityFieldBase('DEFAULT_FEE', DbType.text),
      SqfEntityFieldBase('APPR_STATUS', DbType.text),
      SqfEntityFieldBase('TENURE_INW', DbType.text),
      SqfEntityFieldBase('R_CRE_TIME', DbType.text),
      SqfEntityFieldBase('R_MOD_TIME', DbType.text),
      SqfEntityFieldBase('OPERATOR_ID', DbType.text),
      SqfEntityFieldBase('MINOR_FLAG', DbType.text),
      SqfEntityFieldBase('GUARDIAN_CIFID', DbType.text),
      SqfEntityFieldBase('GUARDIAN_NAME', DbType.text),
      SqfEntityFieldBase('MINOR_DOB', DbType.text),
      SqfEntityFieldBase('GUARDIAN_RELATION', DbType.text),
      SqfEntityFieldBase('DEVICE_TRAN_ID', DbType.text),
      SqfEntityFieldBase('STATUS', DbType.text),
      SqfEntityFieldBase('DEVICE_TRAN_TYPE', DbType.text),
      SqfEntityFieldBase('REQUEST_DATE', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_1', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_2', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_3', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_4', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTBCBS_TRAN_DETAILS();
  }
}

// TBCBS_SOL_DETAILS TABLE
class TableTBCBS_SOL_DETAILS extends SqfEntityTableBase {
  TableTBCBS_SOL_DETAILS() {
    // declare properties of EntityTable
    tableName = 'TBCBS_SOL_DETAILS';
    primaryKeyName = 'BO_ID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('SOL_ID', DbType.text),
      SqfEntityFieldBase('SOL_DESC', DbType.text),
      SqfEntityFieldBase('R_CRE_TIME', DbType.text),
      SqfEntityFieldBase('R_MOD_TIME', DbType.text),
      SqfEntityFieldBase('OPERATOR_ID', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_1', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_2', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_3', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_4', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTBCBS_SOL_DETAILS();
  }
}

// TBCBS_CONFIG_DETAILS TABLE
class TableTBCBS_CONFIG_DETAILS extends SqfEntityTableBase {
  TableTBCBS_CONFIG_DETAILS() {
    // declare properties of EntityTable
    tableName = 'TBCBS_CONFIG_DETAILS';
    primaryKeyName = 'CONFIG_NAME';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('CONFIG_VALUE', DbType.text),
      SqfEntityFieldBase('R_CRE_TIME', DbType.text),
      SqfEntityFieldBase('R_MOD_TIME', DbType.text),
      SqfEntityFieldBase('OPERATOR_ID', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_1', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_2', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_3', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_4', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTBCBS_CONFIG_DETAILS();
  }
}

// TBCBS_EXCEP_DETAILS TABLE
class TableTBCBS_EXCEP_DETAILS extends SqfEntityTableBase {
  TableTBCBS_EXCEP_DETAILS() {
    // declare properties of EntityTable
    tableName = 'TBCBS_EXCEP_DETAILS';
    primaryKeyName = 'REQUEST_NUMBER';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('REQUEST_DATE', DbType.text),
      SqfEntityFieldBase('ACCOUNT_NUMBER', DbType.text),
      SqfEntityFieldBase('REQUEST_STATUS', DbType.text),
      SqfEntityFieldBase('R_CRE_TIME', DbType.text),
      SqfEntityFieldBase('R_MOD_TIME', DbType.text),
      SqfEntityFieldBase('OPERATOR_ID', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_1', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_2', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_3', DbType.text),
      SqfEntityFieldBase('FUTURE_USE_4', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableTBCBS_EXCEP_DETAILS();
  }
}

// IPPBCBS_DETAILS TABLE
class TableIPPBCBS_DETAILS extends SqfEntityTableBase {
  TableIPPBCBS_DETAILS() {
    // declare properties of EntityTable
    tableName = 'IPPBCBS_DETAILS';
    primaryKeyName = 'TRANSACTION_DATE';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('TRANSACTION_TIME', DbType.text),
      SqfEntityFieldBase('TOTAL_DEPOSITS', DbType.text),
      SqfEntityFieldBase('TOTAL_DEPOSIT_AMOUNT', DbType.text),
      SqfEntityFieldBase('TOTAL_WITHDRAWALS', DbType.text),
      SqfEntityFieldBase('TOTAL_WITHDRAWAL_AMOUNT', DbType.text),
      SqfEntityFieldBase('Remarks', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableIPPBCBS_DETAILS();
  }
}

// LEAVE_DETAILS TABLE
class TableLEAVE_DETAILS extends SqfEntityTableBase {
  TableLEAVE_DETAILS() {
    // declare properties of EntityTable
    tableName = 'LEAVE_DETAILS';
    primaryKeyName = 'REQUEST_ID';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('GDS_ID', DbType.text),
      SqfEntityFieldBase('GENDER', DbType.text),
      SqfEntityFieldBase('TYPE_OF_LEAVE', DbType.text),
      SqfEntityFieldBase('LEAVE_REASON', DbType.text),
      SqfEntityFieldBase('LEAVE_FROM_DATE', DbType.text),
      SqfEntityFieldBase('LEAVE_TO_DATE', DbType.text),
      SqfEntityFieldBase('EMP_ADDRESS1', DbType.text),
      SqfEntityFieldBase('EMP_ADDRESS2', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_ID', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_NAME', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_ADDRESS1', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_ADDRESS2', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_AGE', DbType.text),
      SqfEntityFieldBase('SUBSTITUTE_QUALIFICATION', DbType.text),
      SqfEntityFieldBase('STATUS', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableLEAVE_DETAILS();
  }
}

// CBS_ERROR_CODES TABLE
class TableCBS_ERROR_CODES extends SqfEntityTableBase {
  TableCBS_ERROR_CODES() {
    // declare properties of EntityTable
    tableName = 'CBS_ERROR_CODES';
    primaryKeyName = 'Error_code';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('Error_message', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCBS_ERROR_CODES();
  }
}

// CBS_LIMITS_CONFIG TABLE
class TableCBS_LIMITS_CONFIG extends SqfEntityTableBase {
  TableCBS_LIMITS_CONFIG() {
    // declare properties of EntityTable
    tableName = 'CBS_LIMITS_CONFIG';
    primaryKeyName = 'type';
    primaryKeyType = PrimaryKeyType.text;
    useSoftDeleting = false;
    // when useSoftDeleting is true, creates a field named 'isDeleted' on the table, and set to '1' this field when item deleted (does not hard delete)

    // declare fields
    fields = [
      SqfEntityFieldBase('tranlimits', DbType.text),
    ];
    super.init();
  }
  static SqfEntityTableBase? _instance;
  static SqfEntityTableBase get getInstance {
    return _instance = _instance ?? TableCBS_LIMITS_CONFIG();
  }
}
// END TABLES

// BEGIN DATABASE MODEL
class CBS extends SqfEntityModelProvider {
  CBS() {
    databaseName = reportModel.databaseName;
    password = reportModel.password;
    dbVersion = reportModel.dbVersion;
    preSaveAction = reportModel.preSaveAction;
    logFunction = reportModel.logFunction;
    databaseTables = [
      TableTBCBS_TRAN_DETAILS.getInstance,
      TableTBCBS_SOL_DETAILS.getInstance,
      TableTBCBS_CONFIG_DETAILS.getInstance,
      TableTBCBS_EXCEP_DETAILS.getInstance,
      TableIPPBCBS_DETAILS.getInstance,
      TableLEAVE_DETAILS.getInstance,
      TableCBS_ERROR_CODES.getInstance,
      TableCBS_LIMITS_CONFIG.getInstance,
    ];

    bundledDatabasePath = reportModel
        .bundledDatabasePath; //'assets/sample.db'; // This value is optional. When bundledDatabasePath is empty then EntityBase creats a new database when initializing the database
    databasePath = reportModel.databasePath;
  }
  Map<String, dynamic> getControllers() {
    final controllers = <String, dynamic>{};

    return controllers;
  }
}
// END DATABASE MODEL

// BEGIN ENTITIES
// region TBCBS_TRAN_DETAILS
class TBCBS_TRAN_DETAILS extends TableBase {
  TBCBS_TRAN_DETAILS(
      {this.TRANSACTION_ID,
      this.CUST_ACC_NUM,
      this.REFERENCE_NO,
      this.OFFICE_ACC_NUM,
      this.ACCOUNT_TYPE,
      this.MAIN_HOLDER_NAME,
      this.MAIN_HOLDER_CIFID,
      this.JOINT_HOLDER1_NAME,
      this.JOINT_HOLDER1_CIFID,
      this.JOINT_HOLDER2_NAME,
      this.JOINT_HOLDER2_CIFID,
      this.TRANSACTION_AMT,
      this.CURRENCY,
      this.TENURE,
      this.REMARKS,
      this.TRAN_TYPE,
      this.TRAN_DATE,
      this.TRAN_TIME,
      this.FIN_SOLBOD_DATE,
      this.MODE_OF_TRAN,
      this.SCHEME_TYPE,
      this.INSTALMENT_AMT,
      this.NO_OF_INSTALMENTS,
      this.REBATE_AMT,
      this.DEFAULT_FEE,
      this.APPR_STATUS,
      this.TENURE_INW,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.MINOR_FLAG,
      this.GUARDIAN_CIFID,
      this.GUARDIAN_NAME,
      this.MINOR_DOB,
      this.GUARDIAN_RELATION,
      this.DEVICE_TRAN_ID,
      this.STATUS,
      this.DEVICE_TRAN_TYPE,
      this.REQUEST_DATE,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TBCBS_TRAN_DETAILS.withFields(
      this.TRANSACTION_ID,
      this.CUST_ACC_NUM,
      this.REFERENCE_NO,
      this.OFFICE_ACC_NUM,
      this.ACCOUNT_TYPE,
      this.MAIN_HOLDER_NAME,
      this.MAIN_HOLDER_CIFID,
      this.JOINT_HOLDER1_NAME,
      this.JOINT_HOLDER1_CIFID,
      this.JOINT_HOLDER2_NAME,
      this.JOINT_HOLDER2_CIFID,
      this.TRANSACTION_AMT,
      this.CURRENCY,
      this.TENURE,
      this.REMARKS,
      this.TRAN_TYPE,
      this.TRAN_DATE,
      this.TRAN_TIME,
      this.FIN_SOLBOD_DATE,
      this.MODE_OF_TRAN,
      this.SCHEME_TYPE,
      this.INSTALMENT_AMT,
      this.NO_OF_INSTALMENTS,
      this.REBATE_AMT,
      this.DEFAULT_FEE,
      this.APPR_STATUS,
      this.TENURE_INW,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.MINOR_FLAG,
      this.GUARDIAN_CIFID,
      this.GUARDIAN_NAME,
      this.MINOR_DOB,
      this.GUARDIAN_RELATION,
      this.DEVICE_TRAN_ID,
      this.STATUS,
      this.DEVICE_TRAN_TYPE,
      this.REQUEST_DATE,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  TBCBS_TRAN_DETAILS.withId(
      this.TRANSACTION_ID,
      this.CUST_ACC_NUM,
      this.REFERENCE_NO,
      this.OFFICE_ACC_NUM,
      this.ACCOUNT_TYPE,
      this.MAIN_HOLDER_NAME,
      this.MAIN_HOLDER_CIFID,
      this.JOINT_HOLDER1_NAME,
      this.JOINT_HOLDER1_CIFID,
      this.JOINT_HOLDER2_NAME,
      this.JOINT_HOLDER2_CIFID,
      this.TRANSACTION_AMT,
      this.CURRENCY,
      this.TENURE,
      this.REMARKS,
      this.TRAN_TYPE,
      this.TRAN_DATE,
      this.TRAN_TIME,
      this.FIN_SOLBOD_DATE,
      this.MODE_OF_TRAN,
      this.SCHEME_TYPE,
      this.INSTALMENT_AMT,
      this.NO_OF_INSTALMENTS,
      this.REBATE_AMT,
      this.DEFAULT_FEE,
      this.APPR_STATUS,
      this.TENURE_INW,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.MINOR_FLAG,
      this.GUARDIAN_CIFID,
      this.GUARDIAN_NAME,
      this.MINOR_DOB,
      this.GUARDIAN_RELATION,
      this.DEVICE_TRAN_ID,
      this.STATUS,
      this.DEVICE_TRAN_TYPE,
      this.REQUEST_DATE,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TBCBS_TRAN_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TRANSACTION_ID = o['TRANSACTION_ID'].toString();
    if (o['CUST_ACC_NUM'] != null) {
      CUST_ACC_NUM = o['CUST_ACC_NUM'].toString();
    }
    if (o['REFERENCE_NO'] != null) {
      REFERENCE_NO = o['REFERENCE_NO'].toString();
    }
    if (o['OFFICE_ACC_NUM'] != null) {
      OFFICE_ACC_NUM = o['OFFICE_ACC_NUM'].toString();
    }
    if (o['ACCOUNT_TYPE'] != null) {
      ACCOUNT_TYPE = o['ACCOUNT_TYPE'].toString();
    }
    if (o['MAIN_HOLDER_NAME'] != null) {
      MAIN_HOLDER_NAME = o['MAIN_HOLDER_NAME'].toString();
    }
    if (o['MAIN_HOLDER_CIFID'] != null) {
      MAIN_HOLDER_CIFID = o['MAIN_HOLDER_CIFID'].toString();
    }
    if (o['JOINT_HOLDER1_NAME'] != null) {
      JOINT_HOLDER1_NAME = o['JOINT_HOLDER1_NAME'].toString();
    }
    if (o['JOINT_HOLDER1_CIFID'] != null) {
      JOINT_HOLDER1_CIFID = o['JOINT_HOLDER1_CIFID'].toString();
    }
    if (o['JOINT_HOLDER2_NAME'] != null) {
      JOINT_HOLDER2_NAME = o['JOINT_HOLDER2_NAME'].toString();
    }
    if (o['JOINT_HOLDER2_CIFID'] != null) {
      JOINT_HOLDER2_CIFID = o['JOINT_HOLDER2_CIFID'].toString();
    }
    if (o['TRANSACTION_AMT'] != null) {
      TRANSACTION_AMT = o['TRANSACTION_AMT'].toString();
    }
    if (o['CURRENCY'] != null) {
      CURRENCY = o['CURRENCY'].toString();
    }
    if (o['TENURE'] != null) {
      TENURE = o['TENURE'].toString();
    }
    if (o['REMARKS'] != null) {
      REMARKS = o['REMARKS'].toString();
    }
    if (o['TRAN_TYPE'] != null) {
      TRAN_TYPE = o['TRAN_TYPE'].toString();
    }
    if (o['TRAN_DATE'] != null) {
      TRAN_DATE = o['TRAN_DATE'].toString();
    }
    if (o['TRAN_TIME'] != null) {
      TRAN_TIME = o['TRAN_TIME'].toString();
    }
    if (o['FIN_SOLBOD_DATE'] != null) {
      FIN_SOLBOD_DATE = o['FIN_SOLBOD_DATE'].toString();
    }
    if (o['MODE_OF_TRAN'] != null) {
      MODE_OF_TRAN = o['MODE_OF_TRAN'].toString();
    }
    if (o['SCHEME_TYPE'] != null) {
      SCHEME_TYPE = o['SCHEME_TYPE'].toString();
    }
    if (o['INSTALMENT_AMT'] != null) {
      INSTALMENT_AMT = o['INSTALMENT_AMT'].toString();
    }
    if (o['NO_OF_INSTALMENTS'] != null) {
      NO_OF_INSTALMENTS = o['NO_OF_INSTALMENTS'].toString();
    }
    if (o['REBATE_AMT'] != null) {
      REBATE_AMT = o['REBATE_AMT'].toString();
    }
    if (o['DEFAULT_FEE'] != null) {
      DEFAULT_FEE = o['DEFAULT_FEE'].toString();
    }
    if (o['APPR_STATUS'] != null) {
      APPR_STATUS = o['APPR_STATUS'].toString();
    }
    if (o['TENURE_INW'] != null) {
      TENURE_INW = o['TENURE_INW'].toString();
    }
    if (o['R_CRE_TIME'] != null) {
      R_CRE_TIME = o['R_CRE_TIME'].toString();
    }
    if (o['R_MOD_TIME'] != null) {
      R_MOD_TIME = o['R_MOD_TIME'].toString();
    }
    if (o['OPERATOR_ID'] != null) {
      OPERATOR_ID = o['OPERATOR_ID'].toString();
    }
    if (o['MINOR_FLAG'] != null) {
      MINOR_FLAG = o['MINOR_FLAG'].toString();
    }
    if (o['GUARDIAN_CIFID'] != null) {
      GUARDIAN_CIFID = o['GUARDIAN_CIFID'].toString();
    }
    if (o['GUARDIAN_NAME'] != null) {
      GUARDIAN_NAME = o['GUARDIAN_NAME'].toString();
    }
    if (o['MINOR_DOB'] != null) {
      MINOR_DOB = o['MINOR_DOB'].toString();
    }
    if (o['GUARDIAN_RELATION'] != null) {
      GUARDIAN_RELATION = o['GUARDIAN_RELATION'].toString();
    }
    if (o['DEVICE_TRAN_ID'] != null) {
      DEVICE_TRAN_ID = o['DEVICE_TRAN_ID'].toString();
    }
    if (o['STATUS'] != null) {
      STATUS = o['STATUS'].toString();
    }
    if (o['DEVICE_TRAN_TYPE'] != null) {
      DEVICE_TRAN_TYPE = o['DEVICE_TRAN_TYPE'].toString();
    }
    if (o['REQUEST_DATE'] != null) {
      REQUEST_DATE = o['REQUEST_DATE'].toString();
    }
    if (o['FUTURE_USE_1'] != null) {
      FUTURE_USE_1 = o['FUTURE_USE_1'].toString();
    }
    if (o['FUTURE_USE_2'] != null) {
      FUTURE_USE_2 = o['FUTURE_USE_2'].toString();
    }
    if (o['FUTURE_USE_3'] != null) {
      FUTURE_USE_3 = o['FUTURE_USE_3'].toString();
    }
    if (o['FUTURE_USE_4'] != null) {
      FUTURE_USE_4 = o['FUTURE_USE_4'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TBCBS_TRAN_DETAILS)
  String? TRANSACTION_ID;
  String? CUST_ACC_NUM;
  String? REFERENCE_NO;
  String? OFFICE_ACC_NUM;
  String? ACCOUNT_TYPE;
  String? MAIN_HOLDER_NAME;
  String? MAIN_HOLDER_CIFID;
  String? JOINT_HOLDER1_NAME;
  String? JOINT_HOLDER1_CIFID;
  String? JOINT_HOLDER2_NAME;
  String? JOINT_HOLDER2_CIFID;
  String? TRANSACTION_AMT;
  String? CURRENCY;
  String? TENURE;
  String? REMARKS;
  String? TRAN_TYPE;
  String? TRAN_DATE;
  String? TRAN_TIME;
  String? FIN_SOLBOD_DATE;
  String? MODE_OF_TRAN;
  String? SCHEME_TYPE;
  String? INSTALMENT_AMT;
  String? NO_OF_INSTALMENTS;
  String? REBATE_AMT;
  String? DEFAULT_FEE;
  String? APPR_STATUS;
  String? TENURE_INW;
  String? R_CRE_TIME;
  String? R_MOD_TIME;
  String? OPERATOR_ID;
  String? MINOR_FLAG;
  String? GUARDIAN_CIFID;
  String? GUARDIAN_NAME;
  String? MINOR_DOB;
  String? GUARDIAN_RELATION;
  String? DEVICE_TRAN_ID;
  String? STATUS;
  String? DEVICE_TRAN_TYPE;
  String? REQUEST_DATE;
  String? FUTURE_USE_1;
  String? FUTURE_USE_2;
  String? FUTURE_USE_3;
  String? FUTURE_USE_4;
  bool? isSaved;
  // end FIELDS (TBCBS_TRAN_DETAILS)

  static const bool _softDeleteActivated = false;
  TBCBS_TRAN_DETAILSManager? __mnTBCBS_TRAN_DETAILS;

  TBCBS_TRAN_DETAILSManager get _mnTBCBS_TRAN_DETAILS {
    return __mnTBCBS_TRAN_DETAILS =
        __mnTBCBS_TRAN_DETAILS ?? TBCBS_TRAN_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['TRANSACTION_ID'] = TRANSACTION_ID;
    if (CUST_ACC_NUM != null || !forView) {
      map['CUST_ACC_NUM'] = CUST_ACC_NUM;
    }
    if (REFERENCE_NO != null || !forView) {
      map['REFERENCE_NO'] = REFERENCE_NO;
    }
    if (OFFICE_ACC_NUM != null || !forView) {
      map['OFFICE_ACC_NUM'] = OFFICE_ACC_NUM;
    }
    if (ACCOUNT_TYPE != null || !forView) {
      map['ACCOUNT_TYPE'] = ACCOUNT_TYPE;
    }
    if (MAIN_HOLDER_NAME != null || !forView) {
      map['MAIN_HOLDER_NAME'] = MAIN_HOLDER_NAME;
    }
    if (MAIN_HOLDER_CIFID != null || !forView) {
      map['MAIN_HOLDER_CIFID'] = MAIN_HOLDER_CIFID;
    }
    if (JOINT_HOLDER1_NAME != null || !forView) {
      map['JOINT_HOLDER1_NAME'] = JOINT_HOLDER1_NAME;
    }
    if (JOINT_HOLDER1_CIFID != null || !forView) {
      map['JOINT_HOLDER1_CIFID'] = JOINT_HOLDER1_CIFID;
    }
    if (JOINT_HOLDER2_NAME != null || !forView) {
      map['JOINT_HOLDER2_NAME'] = JOINT_HOLDER2_NAME;
    }
    if (JOINT_HOLDER2_CIFID != null || !forView) {
      map['JOINT_HOLDER2_CIFID'] = JOINT_HOLDER2_CIFID;
    }
    if (TRANSACTION_AMT != null || !forView) {
      map['TRANSACTION_AMT'] = TRANSACTION_AMT;
    }
    if (CURRENCY != null || !forView) {
      map['CURRENCY'] = CURRENCY;
    }
    if (TENURE != null || !forView) {
      map['TENURE'] = TENURE;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (TRAN_TYPE != null || !forView) {
      map['TRAN_TYPE'] = TRAN_TYPE;
    }
    if (TRAN_DATE != null || !forView) {
      map['TRAN_DATE'] = TRAN_DATE;
    }
    if (TRAN_TIME != null || !forView) {
      map['TRAN_TIME'] = TRAN_TIME;
    }
    if (FIN_SOLBOD_DATE != null || !forView) {
      map['FIN_SOLBOD_DATE'] = FIN_SOLBOD_DATE;
    }
    if (MODE_OF_TRAN != null || !forView) {
      map['MODE_OF_TRAN'] = MODE_OF_TRAN;
    }
    if (SCHEME_TYPE != null || !forView) {
      map['SCHEME_TYPE'] = SCHEME_TYPE;
    }
    if (INSTALMENT_AMT != null || !forView) {
      map['INSTALMENT_AMT'] = INSTALMENT_AMT;
    }
    if (NO_OF_INSTALMENTS != null || !forView) {
      map['NO_OF_INSTALMENTS'] = NO_OF_INSTALMENTS;
    }
    if (REBATE_AMT != null || !forView) {
      map['REBATE_AMT'] = REBATE_AMT;
    }
    if (DEFAULT_FEE != null || !forView) {
      map['DEFAULT_FEE'] = DEFAULT_FEE;
    }
    if (APPR_STATUS != null || !forView) {
      map['APPR_STATUS'] = APPR_STATUS;
    }
    if (TENURE_INW != null || !forView) {
      map['TENURE_INW'] = TENURE_INW;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (MINOR_FLAG != null || !forView) {
      map['MINOR_FLAG'] = MINOR_FLAG;
    }
    if (GUARDIAN_CIFID != null || !forView) {
      map['GUARDIAN_CIFID'] = GUARDIAN_CIFID;
    }
    if (GUARDIAN_NAME != null || !forView) {
      map['GUARDIAN_NAME'] = GUARDIAN_NAME;
    }
    if (MINOR_DOB != null || !forView) {
      map['MINOR_DOB'] = MINOR_DOB;
    }
    if (GUARDIAN_RELATION != null || !forView) {
      map['GUARDIAN_RELATION'] = GUARDIAN_RELATION;
    }
    if (DEVICE_TRAN_ID != null || !forView) {
      map['DEVICE_TRAN_ID'] = DEVICE_TRAN_ID;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }
    if (DEVICE_TRAN_TYPE != null || !forView) {
      map['DEVICE_TRAN_TYPE'] = DEVICE_TRAN_TYPE;
    }
    if (REQUEST_DATE != null || !forView) {
      map['REQUEST_DATE'] = REQUEST_DATE;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['TRANSACTION_ID'] = TRANSACTION_ID;
    if (CUST_ACC_NUM != null || !forView) {
      map['CUST_ACC_NUM'] = CUST_ACC_NUM;
    }
    if (REFERENCE_NO != null || !forView) {
      map['REFERENCE_NO'] = REFERENCE_NO;
    }
    if (OFFICE_ACC_NUM != null || !forView) {
      map['OFFICE_ACC_NUM'] = OFFICE_ACC_NUM;
    }
    if (ACCOUNT_TYPE != null || !forView) {
      map['ACCOUNT_TYPE'] = ACCOUNT_TYPE;
    }
    if (MAIN_HOLDER_NAME != null || !forView) {
      map['MAIN_HOLDER_NAME'] = MAIN_HOLDER_NAME;
    }
    if (MAIN_HOLDER_CIFID != null || !forView) {
      map['MAIN_HOLDER_CIFID'] = MAIN_HOLDER_CIFID;
    }
    if (JOINT_HOLDER1_NAME != null || !forView) {
      map['JOINT_HOLDER1_NAME'] = JOINT_HOLDER1_NAME;
    }
    if (JOINT_HOLDER1_CIFID != null || !forView) {
      map['JOINT_HOLDER1_CIFID'] = JOINT_HOLDER1_CIFID;
    }
    if (JOINT_HOLDER2_NAME != null || !forView) {
      map['JOINT_HOLDER2_NAME'] = JOINT_HOLDER2_NAME;
    }
    if (JOINT_HOLDER2_CIFID != null || !forView) {
      map['JOINT_HOLDER2_CIFID'] = JOINT_HOLDER2_CIFID;
    }
    if (TRANSACTION_AMT != null || !forView) {
      map['TRANSACTION_AMT'] = TRANSACTION_AMT;
    }
    if (CURRENCY != null || !forView) {
      map['CURRENCY'] = CURRENCY;
    }
    if (TENURE != null || !forView) {
      map['TENURE'] = TENURE;
    }
    if (REMARKS != null || !forView) {
      map['REMARKS'] = REMARKS;
    }
    if (TRAN_TYPE != null || !forView) {
      map['TRAN_TYPE'] = TRAN_TYPE;
    }
    if (TRAN_DATE != null || !forView) {
      map['TRAN_DATE'] = TRAN_DATE;
    }
    if (TRAN_TIME != null || !forView) {
      map['TRAN_TIME'] = TRAN_TIME;
    }
    if (FIN_SOLBOD_DATE != null || !forView) {
      map['FIN_SOLBOD_DATE'] = FIN_SOLBOD_DATE;
    }
    if (MODE_OF_TRAN != null || !forView) {
      map['MODE_OF_TRAN'] = MODE_OF_TRAN;
    }
    if (SCHEME_TYPE != null || !forView) {
      map['SCHEME_TYPE'] = SCHEME_TYPE;
    }
    if (INSTALMENT_AMT != null || !forView) {
      map['INSTALMENT_AMT'] = INSTALMENT_AMT;
    }
    if (NO_OF_INSTALMENTS != null || !forView) {
      map['NO_OF_INSTALMENTS'] = NO_OF_INSTALMENTS;
    }
    if (REBATE_AMT != null || !forView) {
      map['REBATE_AMT'] = REBATE_AMT;
    }
    if (DEFAULT_FEE != null || !forView) {
      map['DEFAULT_FEE'] = DEFAULT_FEE;
    }
    if (APPR_STATUS != null || !forView) {
      map['APPR_STATUS'] = APPR_STATUS;
    }
    if (TENURE_INW != null || !forView) {
      map['TENURE_INW'] = TENURE_INW;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (MINOR_FLAG != null || !forView) {
      map['MINOR_FLAG'] = MINOR_FLAG;
    }
    if (GUARDIAN_CIFID != null || !forView) {
      map['GUARDIAN_CIFID'] = GUARDIAN_CIFID;
    }
    if (GUARDIAN_NAME != null || !forView) {
      map['GUARDIAN_NAME'] = GUARDIAN_NAME;
    }
    if (MINOR_DOB != null || !forView) {
      map['MINOR_DOB'] = MINOR_DOB;
    }
    if (GUARDIAN_RELATION != null || !forView) {
      map['GUARDIAN_RELATION'] = GUARDIAN_RELATION;
    }
    if (DEVICE_TRAN_ID != null || !forView) {
      map['DEVICE_TRAN_ID'] = DEVICE_TRAN_ID;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }
    if (DEVICE_TRAN_TYPE != null || !forView) {
      map['DEVICE_TRAN_TYPE'] = DEVICE_TRAN_TYPE;
    }
    if (REQUEST_DATE != null || !forView) {
      map['REQUEST_DATE'] = REQUEST_DATE;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  /// This method returns Json String [TBCBS_TRAN_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TBCBS_TRAN_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      TRANSACTION_ID,
      CUST_ACC_NUM,
      REFERENCE_NO,
      OFFICE_ACC_NUM,
      ACCOUNT_TYPE,
      MAIN_HOLDER_NAME,
      MAIN_HOLDER_CIFID,
      JOINT_HOLDER1_NAME,
      JOINT_HOLDER1_CIFID,
      JOINT_HOLDER2_NAME,
      JOINT_HOLDER2_CIFID,
      TRANSACTION_AMT,
      CURRENCY,
      TENURE,
      REMARKS,
      TRAN_TYPE,
      TRAN_DATE,
      TRAN_TIME,
      FIN_SOLBOD_DATE,
      MODE_OF_TRAN,
      SCHEME_TYPE,
      INSTALMENT_AMT,
      NO_OF_INSTALMENTS,
      REBATE_AMT,
      DEFAULT_FEE,
      APPR_STATUS,
      TENURE_INW,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      MINOR_FLAG,
      GUARDIAN_CIFID,
      GUARDIAN_NAME,
      MINOR_DOB,
      GUARDIAN_RELATION,
      DEVICE_TRAN_ID,
      STATUS,
      DEVICE_TRAN_TYPE,
      REQUEST_DATE,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      TRANSACTION_ID,
      CUST_ACC_NUM,
      REFERENCE_NO,
      OFFICE_ACC_NUM,
      ACCOUNT_TYPE,
      MAIN_HOLDER_NAME,
      MAIN_HOLDER_CIFID,
      JOINT_HOLDER1_NAME,
      JOINT_HOLDER1_CIFID,
      JOINT_HOLDER2_NAME,
      JOINT_HOLDER2_CIFID,
      TRANSACTION_AMT,
      CURRENCY,
      TENURE,
      REMARKS,
      TRAN_TYPE,
      TRAN_DATE,
      TRAN_TIME,
      FIN_SOLBOD_DATE,
      MODE_OF_TRAN,
      SCHEME_TYPE,
      INSTALMENT_AMT,
      NO_OF_INSTALMENTS,
      REBATE_AMT,
      DEFAULT_FEE,
      APPR_STATUS,
      TENURE_INW,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      MINOR_FLAG,
      GUARDIAN_CIFID,
      GUARDIAN_NAME,
      MINOR_DOB,
      GUARDIAN_RELATION,
      DEVICE_TRAN_ID,
      STATUS,
      DEVICE_TRAN_TYPE,
      REQUEST_DATE,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  static Future<List<TBCBS_TRAN_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_TRAN_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TBCBS_TRAN_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TBCBS_TRAN_DETAILS>[];
    try {
      objList = list
          .map((tbcbs_tran_details) => TBCBS_TRAN_DETAILS
              .fromMap(tbcbs_tran_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_TRAN_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TBCBS_TRAN_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TBCBS_TRAN_DETAILS> objList = <TBCBS_TRAN_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TBCBS_TRAN_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TBCBS_TRAN_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? TRANSACTION_ID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TBCBS_TRAN_DETAILS] if exist, otherwise returns null
  Future<TBCBS_TRAN_DETAILS?> getById(String? TRANSACTION_ID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (TRANSACTION_ID == null) {
      return null;
    }
    TBCBS_TRAN_DETAILS? obj;
    final data = await _mnTBCBS_TRAN_DETAILS.getById([TRANSACTION_ID]);
    if (data.length != 0) {
      obj = TBCBS_TRAN_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TBCBS_TRAN_DETAILS) object. If the Primary Key (TRANSACTION_ID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same TRANSACTION_ID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTBCBS_TRAN_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO TBCBS_TRAN_DETAILS (TRANSACTION_ID, CUST_ACC_NUM, REFERENCE_NO, OFFICE_ACC_NUM, ACCOUNT_TYPE, MAIN_HOLDER_NAME, MAIN_HOLDER_CIFID, JOINT_HOLDER1_NAME, JOINT_HOLDER1_CIFID, JOINT_HOLDER2_NAME, JOINT_HOLDER2_CIFID, TRANSACTION_AMT, CURRENCY, TENURE, REMARKS, TRAN_TYPE, TRAN_DATE, TRAN_TIME, FIN_SOLBOD_DATE, MODE_OF_TRAN, SCHEME_TYPE, INSTALMENT_AMT, NO_OF_INSTALMENTS, REBATE_AMT, DEFAULT_FEE, APPR_STATUS, TENURE_INW, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, MINOR_FLAG, GUARDIAN_CIFID, GUARDIAN_NAME, MINOR_DOB, GUARDIAN_RELATION, DEVICE_TRAN_ID, STATUS, DEVICE_TRAN_TYPE, REQUEST_DATE, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TBCBS_TRAN_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TBCBS_TRAN_DETAILS> tbcbs_tran_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in tbcbs_tran_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_TRAN_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO TBCBS_TRAN_DETAILS (TRANSACTION_ID, CUST_ACC_NUM, REFERENCE_NO, OFFICE_ACC_NUM, ACCOUNT_TYPE, MAIN_HOLDER_NAME, MAIN_HOLDER_CIFID, JOINT_HOLDER1_NAME, JOINT_HOLDER1_CIFID, JOINT_HOLDER2_NAME, JOINT_HOLDER2_CIFID, TRANSACTION_AMT, CURRENCY, TENURE, REMARKS, TRAN_TYPE, TRAN_DATE, TRAN_TIME, FIN_SOLBOD_DATE, MODE_OF_TRAN, SCHEME_TYPE, INSTALMENT_AMT, NO_OF_INSTALMENTS, REBATE_AMT, DEFAULT_FEE, APPR_STATUS, TENURE_INW, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, MINOR_FLAG, GUARDIAN_CIFID, GUARDIAN_NAME, MINOR_DOB, GUARDIAN_RELATION, DEVICE_TRAN_ID, STATUS, DEVICE_TRAN_TYPE, REQUEST_DATE, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            TRANSACTION_ID,
            CUST_ACC_NUM,
            REFERENCE_NO,
            OFFICE_ACC_NUM,
            ACCOUNT_TYPE,
            MAIN_HOLDER_NAME,
            MAIN_HOLDER_CIFID,
            JOINT_HOLDER1_NAME,
            JOINT_HOLDER1_CIFID,
            JOINT_HOLDER2_NAME,
            JOINT_HOLDER2_CIFID,
            TRANSACTION_AMT,
            CURRENCY,
            TENURE,
            REMARKS,
            TRAN_TYPE,
            TRAN_DATE,
            TRAN_TIME,
            FIN_SOLBOD_DATE,
            MODE_OF_TRAN,
            SCHEME_TYPE,
            INSTALMENT_AMT,
            NO_OF_INSTALMENTS,
            REBATE_AMT,
            DEFAULT_FEE,
            APPR_STATUS,
            TENURE_INW,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            MINOR_FLAG,
            GUARDIAN_CIFID,
            GUARDIAN_NAME,
            MINOR_DOB,
            GUARDIAN_RELATION,
            DEVICE_TRAN_ID,
            STATUS,
            DEVICE_TRAN_TYPE,
            REQUEST_DATE,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TBCBS_TRAN_DETAILS TRANSACTION_ID=$TRANSACTION_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TBCBS_TRAN_DETAILS TRANSACTION_ID=$TRANSACTION_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TBCBS_TRAN_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_TRAN_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO TBCBS_TRAN_DETAILS (TRANSACTION_ID, CUST_ACC_NUM, REFERENCE_NO, OFFICE_ACC_NUM, ACCOUNT_TYPE, MAIN_HOLDER_NAME, MAIN_HOLDER_CIFID, JOINT_HOLDER1_NAME, JOINT_HOLDER1_CIFID, JOINT_HOLDER2_NAME, JOINT_HOLDER2_CIFID, TRANSACTION_AMT, CURRENCY, TENURE, REMARKS, TRAN_TYPE, TRAN_DATE, TRAN_TIME, FIN_SOLBOD_DATE, MODE_OF_TRAN, SCHEME_TYPE, INSTALMENT_AMT, NO_OF_INSTALMENTS, REBATE_AMT, DEFAULT_FEE, APPR_STATUS, TENURE_INW, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, MINOR_FLAG, GUARDIAN_CIFID, GUARDIAN_NAME, MINOR_DOB, GUARDIAN_RELATION, DEVICE_TRAN_ID, STATUS, DEVICE_TRAN_TYPE, REQUEST_DATE, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            TRANSACTION_ID,
            CUST_ACC_NUM,
            REFERENCE_NO,
            OFFICE_ACC_NUM,
            ACCOUNT_TYPE,
            MAIN_HOLDER_NAME,
            MAIN_HOLDER_CIFID,
            JOINT_HOLDER1_NAME,
            JOINT_HOLDER1_CIFID,
            JOINT_HOLDER2_NAME,
            JOINT_HOLDER2_CIFID,
            TRANSACTION_AMT,
            CURRENCY,
            TENURE,
            REMARKS,
            TRAN_TYPE,
            TRAN_DATE,
            TRAN_TIME,
            FIN_SOLBOD_DATE,
            MODE_OF_TRAN,
            SCHEME_TYPE,
            INSTALMENT_AMT,
            NO_OF_INSTALMENTS,
            REBATE_AMT,
            DEFAULT_FEE,
            APPR_STATUS,
            TENURE_INW,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            MINOR_FLAG,
            GUARDIAN_CIFID,
            GUARDIAN_NAME,
            MINOR_DOB,
            GUARDIAN_RELATION,
            DEVICE_TRAN_ID,
            STATUS,
            DEVICE_TRAN_TYPE,
            REQUEST_DATE,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'TBCBS_TRAN_DETAILS TRANSACTION_ID=$TRANSACTION_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'TBCBS_TRAN_DETAILS TRANSACTION_ID=$TRANSACTION_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
          'TBCBS_TRAN_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes TBCBS_TRAN_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete TBCBS_TRAN_DETAILS invoked (TRANSACTION_ID=$TRANSACTION_ID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTBCBS_TRAN_DETAILS.delete(QueryParams(
          whereString: 'TRANSACTION_ID=?', whereArguments: [TRANSACTION_ID]));
    } else {
      return _mnTBCBS_TRAN_DETAILS.updateBatch(
          QueryParams(
              whereString: 'TRANSACTION_ID=?',
              whereArguments: [TRANSACTION_ID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TBCBS_TRAN_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_TRAN_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_TRAN_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      TRANSACTION_ID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tbcbs_tran_details

// region TBCBS_TRAN_DETAILSField
class TBCBS_TRAN_DETAILSField extends FilterBase {
  TBCBS_TRAN_DETAILSField(TBCBS_TRAN_DETAILSFilterBuilder tbcbs_tran_detailsFB)
      : super(tbcbs_tran_detailsFB);

  @override
  TBCBS_TRAN_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder isNull() {
    return super.isNull() as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TBCBS_TRAN_DETAILSFilterBuilder;
  }

  @override
  TBCBS_TRAN_DETAILSField get not {
    return super.not as TBCBS_TRAN_DETAILSField;
  }
}
// endregion TBCBS_TRAN_DETAILSField

// region TBCBS_TRAN_DETAILSFilterBuilder
class TBCBS_TRAN_DETAILSFilterBuilder extends ConjunctionBase {
  TBCBS_TRAN_DETAILSFilterBuilder(TBCBS_TRAN_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTBCBS_TRAN_DETAILS = obj._mnTBCBS_TRAN_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TBCBS_TRAN_DETAILSManager? _mnTBCBS_TRAN_DETAILS;

  /// put the sql keyword 'AND'
  @override
  TBCBS_TRAN_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TBCBS_TRAN_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TBCBS_TRAN_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TBCBS_TRAN_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TBCBS_TRAN_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TBCBS_TRAN_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TBCBS_TRAN_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_TRAN_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_TRAN_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_TRAN_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_TRAN_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TBCBS_TRAN_DETAILSField _setField(
      TBCBS_TRAN_DETAILSField? field, String colName, DbType dbtype) {
    return TBCBS_TRAN_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TBCBS_TRAN_DETAILSField? _TRANSACTION_ID;
  TBCBS_TRAN_DETAILSField get TRANSACTION_ID {
    return _TRANSACTION_ID =
        _setField(_TRANSACTION_ID, 'TRANSACTION_ID', DbType.integer);
  }

  TBCBS_TRAN_DETAILSField? _CUST_ACC_NUM;
  TBCBS_TRAN_DETAILSField get CUST_ACC_NUM {
    return _CUST_ACC_NUM =
        _setField(_CUST_ACC_NUM, 'CUST_ACC_NUM', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _REFERENCE_NO;
  TBCBS_TRAN_DETAILSField get REFERENCE_NO {
    return _REFERENCE_NO =
        _setField(_REFERENCE_NO, 'REFERENCE_NO', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _OFFICE_ACC_NUM;
  TBCBS_TRAN_DETAILSField get OFFICE_ACC_NUM {
    return _OFFICE_ACC_NUM =
        _setField(_OFFICE_ACC_NUM, 'OFFICE_ACC_NUM', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _ACCOUNT_TYPE;
  TBCBS_TRAN_DETAILSField get ACCOUNT_TYPE {
    return _ACCOUNT_TYPE =
        _setField(_ACCOUNT_TYPE, 'ACCOUNT_TYPE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _MAIN_HOLDER_NAME;
  TBCBS_TRAN_DETAILSField get MAIN_HOLDER_NAME {
    return _MAIN_HOLDER_NAME =
        _setField(_MAIN_HOLDER_NAME, 'MAIN_HOLDER_NAME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _MAIN_HOLDER_CIFID;
  TBCBS_TRAN_DETAILSField get MAIN_HOLDER_CIFID {
    return _MAIN_HOLDER_CIFID =
        _setField(_MAIN_HOLDER_CIFID, 'MAIN_HOLDER_CIFID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _JOINT_HOLDER1_NAME;
  TBCBS_TRAN_DETAILSField get JOINT_HOLDER1_NAME {
    return _JOINT_HOLDER1_NAME =
        _setField(_JOINT_HOLDER1_NAME, 'JOINT_HOLDER1_NAME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _JOINT_HOLDER1_CIFID;
  TBCBS_TRAN_DETAILSField get JOINT_HOLDER1_CIFID {
    return _JOINT_HOLDER1_CIFID =
        _setField(_JOINT_HOLDER1_CIFID, 'JOINT_HOLDER1_CIFID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _JOINT_HOLDER2_NAME;
  TBCBS_TRAN_DETAILSField get JOINT_HOLDER2_NAME {
    return _JOINT_HOLDER2_NAME =
        _setField(_JOINT_HOLDER2_NAME, 'JOINT_HOLDER2_NAME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _JOINT_HOLDER2_CIFID;
  TBCBS_TRAN_DETAILSField get JOINT_HOLDER2_CIFID {
    return _JOINT_HOLDER2_CIFID =
        _setField(_JOINT_HOLDER2_CIFID, 'JOINT_HOLDER2_CIFID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TRANSACTION_AMT;
  TBCBS_TRAN_DETAILSField get TRANSACTION_AMT {
    return _TRANSACTION_AMT =
        _setField(_TRANSACTION_AMT, 'TRANSACTION_AMT', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _CURRENCY;
  TBCBS_TRAN_DETAILSField get CURRENCY {
    return _CURRENCY = _setField(_CURRENCY, 'CURRENCY', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TENURE;
  TBCBS_TRAN_DETAILSField get TENURE {
    return _TENURE = _setField(_TENURE, 'TENURE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _REMARKS;
  TBCBS_TRAN_DETAILSField get REMARKS {
    return _REMARKS = _setField(_REMARKS, 'REMARKS', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TRAN_TYPE;
  TBCBS_TRAN_DETAILSField get TRAN_TYPE {
    return _TRAN_TYPE = _setField(_TRAN_TYPE, 'TRAN_TYPE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TRAN_DATE;
  TBCBS_TRAN_DETAILSField get TRAN_DATE {
    return _TRAN_DATE = _setField(_TRAN_DATE, 'TRAN_DATE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TRAN_TIME;
  TBCBS_TRAN_DETAILSField get TRAN_TIME {
    return _TRAN_TIME = _setField(_TRAN_TIME, 'TRAN_TIME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _FIN_SOLBOD_DATE;
  TBCBS_TRAN_DETAILSField get FIN_SOLBOD_DATE {
    return _FIN_SOLBOD_DATE =
        _setField(_FIN_SOLBOD_DATE, 'FIN_SOLBOD_DATE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _MODE_OF_TRAN;
  TBCBS_TRAN_DETAILSField get MODE_OF_TRAN {
    return _MODE_OF_TRAN =
        _setField(_MODE_OF_TRAN, 'MODE_OF_TRAN', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _SCHEME_TYPE;
  TBCBS_TRAN_DETAILSField get SCHEME_TYPE {
    return _SCHEME_TYPE = _setField(_SCHEME_TYPE, 'SCHEME_TYPE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _INSTALMENT_AMT;
  TBCBS_TRAN_DETAILSField get INSTALMENT_AMT {
    return _INSTALMENT_AMT =
        _setField(_INSTALMENT_AMT, 'INSTALMENT_AMT', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _NO_OF_INSTALMENTS;
  TBCBS_TRAN_DETAILSField get NO_OF_INSTALMENTS {
    return _NO_OF_INSTALMENTS =
        _setField(_NO_OF_INSTALMENTS, 'NO_OF_INSTALMENTS', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _REBATE_AMT;
  TBCBS_TRAN_DETAILSField get REBATE_AMT {
    return _REBATE_AMT = _setField(_REBATE_AMT, 'REBATE_AMT', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _DEFAULT_FEE;
  TBCBS_TRAN_DETAILSField get DEFAULT_FEE {
    return _DEFAULT_FEE = _setField(_DEFAULT_FEE, 'DEFAULT_FEE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _APPR_STATUS;
  TBCBS_TRAN_DETAILSField get APPR_STATUS {
    return _APPR_STATUS = _setField(_APPR_STATUS, 'APPR_STATUS', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _TENURE_INW;
  TBCBS_TRAN_DETAILSField get TENURE_INW {
    return _TENURE_INW = _setField(_TENURE_INW, 'TENURE_INW', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _R_CRE_TIME;
  TBCBS_TRAN_DETAILSField get R_CRE_TIME {
    return _R_CRE_TIME = _setField(_R_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _R_MOD_TIME;
  TBCBS_TRAN_DETAILSField get R_MOD_TIME {
    return _R_MOD_TIME = _setField(_R_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _OPERATOR_ID;
  TBCBS_TRAN_DETAILSField get OPERATOR_ID {
    return _OPERATOR_ID = _setField(_OPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _MINOR_FLAG;
  TBCBS_TRAN_DETAILSField get MINOR_FLAG {
    return _MINOR_FLAG = _setField(_MINOR_FLAG, 'MINOR_FLAG', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _GUARDIAN_CIFID;
  TBCBS_TRAN_DETAILSField get GUARDIAN_CIFID {
    return _GUARDIAN_CIFID =
        _setField(_GUARDIAN_CIFID, 'GUARDIAN_CIFID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _GUARDIAN_NAME;
  TBCBS_TRAN_DETAILSField get GUARDIAN_NAME {
    return _GUARDIAN_NAME =
        _setField(_GUARDIAN_NAME, 'GUARDIAN_NAME', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _MINOR_DOB;
  TBCBS_TRAN_DETAILSField get MINOR_DOB {
    return _MINOR_DOB = _setField(_MINOR_DOB, 'MINOR_DOB', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _GUARDIAN_RELATION;
  TBCBS_TRAN_DETAILSField get GUARDIAN_RELATION {
    return _GUARDIAN_RELATION =
        _setField(_GUARDIAN_RELATION, 'GUARDIAN_RELATION', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _DEVICE_TRAN_ID;
  TBCBS_TRAN_DETAILSField get DEVICE_TRAN_ID {
    return _DEVICE_TRAN_ID =
        _setField(_DEVICE_TRAN_ID, 'DEVICE_TRAN_ID', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _STATUS;
  TBCBS_TRAN_DETAILSField get STATUS {
    return _STATUS = _setField(_STATUS, 'STATUS', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _DEVICE_TRAN_TYPE;
  TBCBS_TRAN_DETAILSField get DEVICE_TRAN_TYPE {
    return _DEVICE_TRAN_TYPE =
        _setField(_DEVICE_TRAN_TYPE, 'DEVICE_TRAN_TYPE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _REQUEST_DATE;
  TBCBS_TRAN_DETAILSField get REQUEST_DATE {
    return _REQUEST_DATE =
        _setField(_REQUEST_DATE, 'REQUEST_DATE', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _FUTURE_USE_1;
  TBCBS_TRAN_DETAILSField get FUTURE_USE_1 {
    return _FUTURE_USE_1 =
        _setField(_FUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _FUTURE_USE_2;
  TBCBS_TRAN_DETAILSField get FUTURE_USE_2 {
    return _FUTURE_USE_2 =
        _setField(_FUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _FUTURE_USE_3;
  TBCBS_TRAN_DETAILSField get FUTURE_USE_3 {
    return _FUTURE_USE_3 =
        _setField(_FUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  TBCBS_TRAN_DETAILSField? _FUTURE_USE_4;
  TBCBS_TRAN_DETAILSField get FUTURE_USE_4 {
    return _FUTURE_USE_4 =
        _setField(_FUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }

  /// Deletes List<TBCBS_TRAN_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTBCBS_TRAN_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTBCBS_TRAN_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'TRANSACTION_ID IN (SELECT TRANSACTION_ID from TBCBS_TRAN_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTBCBS_TRAN_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [TBCBS_TRAN_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_TRAN_DETAILS?
  @override
  Future<TBCBS_TRAN_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTBCBS_TRAN_DETAILS!.toList(qparams);
    final data = await objFuture;
    TBCBS_TRAN_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = TBCBS_TRAN_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TBCBS_TRAN_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_TRAN_DETAILS?
  @override
  Future<TBCBS_TRAN_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TBCBS_TRAN_DETAILS();
  }

  /// This method returns int. [TBCBS_TRAN_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? tbcbs_tran_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tbcbs_tran_detailsesFuture =
        await _mnTBCBS_TRAN_DETAILS!.toList(qparams);
    final int count = tbcbs_tran_detailsesFuture[0]['CNT'] as int;
    if (tbcbs_tran_detailsCount != null) {
      tbcbs_tran_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<TBCBS_TRAN_DETAILS> [TBCBS_TRAN_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TBCBS_TRAN_DETAILS>
  @override
  Future<List<TBCBS_TRAN_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TBCBS_TRAN_DETAILS> tbcbs_tran_detailsesData =
        await TBCBS_TRAN_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tbcbs_tran_detailsesData;
  }

  /// This method returns Json String [TBCBS_TRAN_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TBCBS_TRAN_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TBCBS_TRAN_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTBCBS_TRAN_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TBCBS_TRAN_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `TRANSACTION_ID` FROM TBCBS_TRAN_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> TRANSACTION_IDData = <String>[];
    qparams.selectColumns = ['TRANSACTION_ID'];
    final TRANSACTION_IDFuture = await _mnTBCBS_TRAN_DETAILS!.toList(qparams);

    final int count = TRANSACTION_IDFuture.length;
    for (int i = 0; i < count; i++) {
      TRANSACTION_IDData.add(
          TRANSACTION_IDFuture[i]['TRANSACTION_ID'] as String);
    }
    return TRANSACTION_IDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TBCBS_TRAN_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTBCBS_TRAN_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TBCBS_TRAN_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTBCBS_TRAN_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TBCBS_TRAN_DETAILSFilterBuilder

// region TBCBS_TRAN_DETAILSFields
class TBCBS_TRAN_DETAILSFields {
  static TableField? _fTRANSACTION_ID;
  static TableField get TRANSACTION_ID {
    return _fTRANSACTION_ID = _fTRANSACTION_ID ??
        SqlSyntax.setField(_fTRANSACTION_ID, 'transaction_id', DbType.integer);
  }

  static TableField? _fCUST_ACC_NUM;
  static TableField get CUST_ACC_NUM {
    return _fCUST_ACC_NUM = _fCUST_ACC_NUM ??
        SqlSyntax.setField(_fCUST_ACC_NUM, 'CUST_ACC_NUM', DbType.text);
  }

  static TableField? _fREFERENCE_NO;
  static TableField get REFERENCE_NO {
    return _fREFERENCE_NO = _fREFERENCE_NO ??
        SqlSyntax.setField(_fREFERENCE_NO, 'REFERENCE_NO', DbType.text);
  }

  static TableField? _fOFFICE_ACC_NUM;
  static TableField get OFFICE_ACC_NUM {
    return _fOFFICE_ACC_NUM = _fOFFICE_ACC_NUM ??
        SqlSyntax.setField(_fOFFICE_ACC_NUM, 'OFFICE_ACC_NUM', DbType.text);
  }

  static TableField? _fACCOUNT_TYPE;
  static TableField get ACCOUNT_TYPE {
    return _fACCOUNT_TYPE = _fACCOUNT_TYPE ??
        SqlSyntax.setField(_fACCOUNT_TYPE, 'ACCOUNT_TYPE', DbType.text);
  }

  static TableField? _fMAIN_HOLDER_NAME;
  static TableField get MAIN_HOLDER_NAME {
    return _fMAIN_HOLDER_NAME = _fMAIN_HOLDER_NAME ??
        SqlSyntax.setField(_fMAIN_HOLDER_NAME, 'MAIN_HOLDER_NAME', DbType.text);
  }

  static TableField? _fMAIN_HOLDER_CIFID;
  static TableField get MAIN_HOLDER_CIFID {
    return _fMAIN_HOLDER_CIFID = _fMAIN_HOLDER_CIFID ??
        SqlSyntax.setField(
            _fMAIN_HOLDER_CIFID, 'MAIN_HOLDER_CIFID', DbType.text);
  }

  static TableField? _fJOINT_HOLDER1_NAME;
  static TableField get JOINT_HOLDER1_NAME {
    return _fJOINT_HOLDER1_NAME = _fJOINT_HOLDER1_NAME ??
        SqlSyntax.setField(
            _fJOINT_HOLDER1_NAME, 'JOINT_HOLDER1_NAME', DbType.text);
  }

  static TableField? _fJOINT_HOLDER1_CIFID;
  static TableField get JOINT_HOLDER1_CIFID {
    return _fJOINT_HOLDER1_CIFID = _fJOINT_HOLDER1_CIFID ??
        SqlSyntax.setField(
            _fJOINT_HOLDER1_CIFID, 'JOINT_HOLDER1_CIFID', DbType.text);
  }

  static TableField? _fJOINT_HOLDER2_NAME;
  static TableField get JOINT_HOLDER2_NAME {
    return _fJOINT_HOLDER2_NAME = _fJOINT_HOLDER2_NAME ??
        SqlSyntax.setField(
            _fJOINT_HOLDER2_NAME, 'JOINT_HOLDER2_NAME', DbType.text);
  }

  static TableField? _fJOINT_HOLDER2_CIFID;
  static TableField get JOINT_HOLDER2_CIFID {
    return _fJOINT_HOLDER2_CIFID = _fJOINT_HOLDER2_CIFID ??
        SqlSyntax.setField(
            _fJOINT_HOLDER2_CIFID, 'JOINT_HOLDER2_CIFID', DbType.text);
  }

  static TableField? _fTRANSACTION_AMT;
  static TableField get TRANSACTION_AMT {
    return _fTRANSACTION_AMT = _fTRANSACTION_AMT ??
        SqlSyntax.setField(_fTRANSACTION_AMT, 'TRANSACTION_AMT', DbType.text);
  }

  static TableField? _fCURRENCY;
  static TableField get CURRENCY {
    return _fCURRENCY =
        _fCURRENCY ?? SqlSyntax.setField(_fCURRENCY, 'CURRENCY', DbType.text);
  }

  static TableField? _fTENURE;
  static TableField get TENURE {
    return _fTENURE =
        _fTENURE ?? SqlSyntax.setField(_fTENURE, 'TENURE', DbType.text);
  }

  static TableField? _fREMARKS;
  static TableField get REMARKS {
    return _fREMARKS =
        _fREMARKS ?? SqlSyntax.setField(_fREMARKS, 'REMARKS', DbType.text);
  }

  static TableField? _fTRAN_TYPE;
  static TableField get TRAN_TYPE {
    return _fTRAN_TYPE = _fTRAN_TYPE ??
        SqlSyntax.setField(_fTRAN_TYPE, 'TRAN_TYPE', DbType.text);
  }

  static TableField? _fTRAN_DATE;
  static TableField get TRAN_DATE {
    return _fTRAN_DATE = _fTRAN_DATE ??
        SqlSyntax.setField(_fTRAN_DATE, 'TRAN_DATE', DbType.text);
  }

  static TableField? _fTRAN_TIME;
  static TableField get TRAN_TIME {
    return _fTRAN_TIME = _fTRAN_TIME ??
        SqlSyntax.setField(_fTRAN_TIME, 'TRAN_TIME', DbType.text);
  }

  static TableField? _fFIN_SOLBOD_DATE;
  static TableField get FIN_SOLBOD_DATE {
    return _fFIN_SOLBOD_DATE = _fFIN_SOLBOD_DATE ??
        SqlSyntax.setField(_fFIN_SOLBOD_DATE, 'FIN_SOLBOD_DATE', DbType.text);
  }

  static TableField? _fMODE_OF_TRAN;
  static TableField get MODE_OF_TRAN {
    return _fMODE_OF_TRAN = _fMODE_OF_TRAN ??
        SqlSyntax.setField(_fMODE_OF_TRAN, 'MODE_OF_TRAN', DbType.text);
  }

  static TableField? _fSCHEME_TYPE;
  static TableField get SCHEME_TYPE {
    return _fSCHEME_TYPE = _fSCHEME_TYPE ??
        SqlSyntax.setField(_fSCHEME_TYPE, 'SCHEME_TYPE', DbType.text);
  }

  static TableField? _fINSTALMENT_AMT;
  static TableField get INSTALMENT_AMT {
    return _fINSTALMENT_AMT = _fINSTALMENT_AMT ??
        SqlSyntax.setField(_fINSTALMENT_AMT, 'INSTALMENT_AMT', DbType.text);
  }

  static TableField? _fNO_OF_INSTALMENTS;
  static TableField get NO_OF_INSTALMENTS {
    return _fNO_OF_INSTALMENTS = _fNO_OF_INSTALMENTS ??
        SqlSyntax.setField(
            _fNO_OF_INSTALMENTS, 'NO_OF_INSTALMENTS', DbType.text);
  }

  static TableField? _fREBATE_AMT;
  static TableField get REBATE_AMT {
    return _fREBATE_AMT = _fREBATE_AMT ??
        SqlSyntax.setField(_fREBATE_AMT, 'REBATE_AMT', DbType.text);
  }

  static TableField? _fDEFAULT_FEE;
  static TableField get DEFAULT_FEE {
    return _fDEFAULT_FEE = _fDEFAULT_FEE ??
        SqlSyntax.setField(_fDEFAULT_FEE, 'DEFAULT_FEE', DbType.text);
  }

  static TableField? _fAPPR_STATUS;
  static TableField get APPR_STATUS {
    return _fAPPR_STATUS = _fAPPR_STATUS ??
        SqlSyntax.setField(_fAPPR_STATUS, 'APPR_STATUS', DbType.text);
  }

  static TableField? _fTENURE_INW;
  static TableField get TENURE_INW {
    return _fTENURE_INW = _fTENURE_INW ??
        SqlSyntax.setField(_fTENURE_INW, 'TENURE_INW', DbType.text);
  }

  static TableField? _fR_CRE_TIME;
  static TableField get R_CRE_TIME {
    return _fR_CRE_TIME = _fR_CRE_TIME ??
        SqlSyntax.setField(_fR_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  static TableField? _fR_MOD_TIME;
  static TableField get R_MOD_TIME {
    return _fR_MOD_TIME = _fR_MOD_TIME ??
        SqlSyntax.setField(_fR_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  static TableField? _fOPERATOR_ID;
  static TableField get OPERATOR_ID {
    return _fOPERATOR_ID = _fOPERATOR_ID ??
        SqlSyntax.setField(_fOPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  static TableField? _fMINOR_FLAG;
  static TableField get MINOR_FLAG {
    return _fMINOR_FLAG = _fMINOR_FLAG ??
        SqlSyntax.setField(_fMINOR_FLAG, 'MINOR_FLAG', DbType.text);
  }

  static TableField? _fGUARDIAN_CIFID;
  static TableField get GUARDIAN_CIFID {
    return _fGUARDIAN_CIFID = _fGUARDIAN_CIFID ??
        SqlSyntax.setField(_fGUARDIAN_CIFID, 'GUARDIAN_CIFID', DbType.text);
  }

  static TableField? _fGUARDIAN_NAME;
  static TableField get GUARDIAN_NAME {
    return _fGUARDIAN_NAME = _fGUARDIAN_NAME ??
        SqlSyntax.setField(_fGUARDIAN_NAME, 'GUARDIAN_NAME', DbType.text);
  }

  static TableField? _fMINOR_DOB;
  static TableField get MINOR_DOB {
    return _fMINOR_DOB = _fMINOR_DOB ??
        SqlSyntax.setField(_fMINOR_DOB, 'MINOR_DOB', DbType.text);
  }

  static TableField? _fGUARDIAN_RELATION;
  static TableField get GUARDIAN_RELATION {
    return _fGUARDIAN_RELATION = _fGUARDIAN_RELATION ??
        SqlSyntax.setField(
            _fGUARDIAN_RELATION, 'GUARDIAN_RELATION', DbType.text);
  }

  static TableField? _fDEVICE_TRAN_ID;
  static TableField get DEVICE_TRAN_ID {
    return _fDEVICE_TRAN_ID = _fDEVICE_TRAN_ID ??
        SqlSyntax.setField(_fDEVICE_TRAN_ID, 'DEVICE_TRAN_ID', DbType.text);
  }

  static TableField? _fSTATUS;
  static TableField get STATUS {
    return _fSTATUS =
        _fSTATUS ?? SqlSyntax.setField(_fSTATUS, 'STATUS', DbType.text);
  }

  static TableField? _fDEVICE_TRAN_TYPE;
  static TableField get DEVICE_TRAN_TYPE {
    return _fDEVICE_TRAN_TYPE = _fDEVICE_TRAN_TYPE ??
        SqlSyntax.setField(_fDEVICE_TRAN_TYPE, 'DEVICE_TRAN_TYPE', DbType.text);
  }

  static TableField? _fREQUEST_DATE;
  static TableField get REQUEST_DATE {
    return _fREQUEST_DATE = _fREQUEST_DATE ??
        SqlSyntax.setField(_fREQUEST_DATE, 'REQUEST_DATE', DbType.text);
  }

  static TableField? _fFUTURE_USE_1;
  static TableField get FUTURE_USE_1 {
    return _fFUTURE_USE_1 = _fFUTURE_USE_1 ??
        SqlSyntax.setField(_fFUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  static TableField? _fFUTURE_USE_2;
  static TableField get FUTURE_USE_2 {
    return _fFUTURE_USE_2 = _fFUTURE_USE_2 ??
        SqlSyntax.setField(_fFUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  static TableField? _fFUTURE_USE_3;
  static TableField get FUTURE_USE_3 {
    return _fFUTURE_USE_3 = _fFUTURE_USE_3 ??
        SqlSyntax.setField(_fFUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  static TableField? _fFUTURE_USE_4;
  static TableField get FUTURE_USE_4 {
    return _fFUTURE_USE_4 = _fFUTURE_USE_4 ??
        SqlSyntax.setField(_fFUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }
}
// endregion TBCBS_TRAN_DETAILSFields

//region TBCBS_TRAN_DETAILSManager
class TBCBS_TRAN_DETAILSManager extends SqfEntityProvider {
  TBCBS_TRAN_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TBCBS_TRAN_DETAILS';
  static const List<String> _primaryKeyList = ['TRANSACTION_ID'];
  static const String _whereStr = 'TRANSACTION_ID=?';
}

//endregion TBCBS_TRAN_DETAILSManager
// region TBCBS_SOL_DETAILS
class TBCBS_SOL_DETAILS extends TableBase {
  TBCBS_SOL_DETAILS(
      {this.BO_ID,
      this.SOL_ID,
      this.SOL_DESC,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TBCBS_SOL_DETAILS.withFields(
      this.BO_ID,
      this.SOL_ID,
      this.SOL_DESC,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  TBCBS_SOL_DETAILS.withId(
      this.BO_ID,
      this.SOL_ID,
      this.SOL_DESC,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TBCBS_SOL_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    BO_ID = o['BO_ID'].toString();
    if (o['SOL_ID'] != null) {
      SOL_ID = o['SOL_ID'].toString();
    }
    if (o['SOL_DESC'] != null) {
      SOL_DESC = o['SOL_DESC'].toString();
    }
    if (o['R_CRE_TIME'] != null) {
      R_CRE_TIME = o['R_CRE_TIME'].toString();
    }
    if (o['R_MOD_TIME'] != null) {
      R_MOD_TIME = o['R_MOD_TIME'].toString();
    }
    if (o['OPERATOR_ID'] != null) {
      OPERATOR_ID = o['OPERATOR_ID'].toString();
    }
    if (o['FUTURE_USE_1'] != null) {
      FUTURE_USE_1 = o['FUTURE_USE_1'].toString();
    }
    if (o['FUTURE_USE_2'] != null) {
      FUTURE_USE_2 = o['FUTURE_USE_2'].toString();
    }
    if (o['FUTURE_USE_3'] != null) {
      FUTURE_USE_3 = o['FUTURE_USE_3'].toString();
    }
    if (o['FUTURE_USE_4'] != null) {
      FUTURE_USE_4 = o['FUTURE_USE_4'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TBCBS_SOL_DETAILS)
  String? BO_ID;
  String? SOL_ID;
  String? SOL_DESC;
  String? R_CRE_TIME;
  String? R_MOD_TIME;
  String? OPERATOR_ID;
  String? FUTURE_USE_1;
  String? FUTURE_USE_2;
  String? FUTURE_USE_3;
  String? FUTURE_USE_4;
  bool? isSaved;
  // end FIELDS (TBCBS_SOL_DETAILS)

  static const bool _softDeleteActivated = false;
  TBCBS_SOL_DETAILSManager? __mnTBCBS_SOL_DETAILS;

  TBCBS_SOL_DETAILSManager get _mnTBCBS_SOL_DETAILS {
    return __mnTBCBS_SOL_DETAILS =
        __mnTBCBS_SOL_DETAILS ?? TBCBS_SOL_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['BO_ID'] = BO_ID;
    if (SOL_ID != null || !forView) {
      map['SOL_ID'] = SOL_ID;
    }
    if (SOL_DESC != null || !forView) {
      map['SOL_DESC'] = SOL_DESC;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['BO_ID'] = BO_ID;
    if (SOL_ID != null || !forView) {
      map['SOL_ID'] = SOL_ID;
    }
    if (SOL_DESC != null || !forView) {
      map['SOL_DESC'] = SOL_DESC;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  /// This method returns Json String [TBCBS_SOL_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TBCBS_SOL_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      BO_ID,
      SOL_ID,
      SOL_DESC,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      BO_ID,
      SOL_ID,
      SOL_DESC,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  static Future<List<TBCBS_SOL_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_SOL_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TBCBS_SOL_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TBCBS_SOL_DETAILS>[];
    try {
      objList = list
          .map((tbcbs_sol_details) => TBCBS_SOL_DETAILS
              .fromMap(tbcbs_sol_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_SOL_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TBCBS_SOL_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TBCBS_SOL_DETAILS> objList = <TBCBS_SOL_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TBCBS_SOL_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TBCBS_SOL_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? BO_ID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TBCBS_SOL_DETAILS] if exist, otherwise returns null
  Future<TBCBS_SOL_DETAILS?> getById(String? BO_ID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (BO_ID == null) {
      return null;
    }
    TBCBS_SOL_DETAILS? obj;
    final data = await _mnTBCBS_SOL_DETAILS.getById([BO_ID]);
    if (data.length != 0) {
      obj = TBCBS_SOL_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TBCBS_SOL_DETAILS) object. If the Primary Key (BO_ID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same BO_ID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTBCBS_SOL_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO TBCBS_SOL_DETAILS (BO_ID, SOL_ID, SOL_DESC, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TBCBS_SOL_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TBCBS_SOL_DETAILS> tbcbs_sol_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in tbcbs_sol_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_SOL_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO TBCBS_SOL_DETAILS (BO_ID, SOL_ID, SOL_DESC, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            BO_ID,
            SOL_ID,
            SOL_DESC,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TBCBS_SOL_DETAILS BO_ID=$BO_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TBCBS_SOL_DETAILS BO_ID=$BO_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TBCBS_SOL_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_SOL_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO TBCBS_SOL_DETAILS (BO_ID, SOL_ID, SOL_DESC, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?)',
          [
            BO_ID,
            SOL_ID,
            SOL_DESC,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'TBCBS_SOL_DETAILS BO_ID=$BO_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'TBCBS_SOL_DETAILS BO_ID=$BO_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
          'TBCBS_SOL_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes TBCBS_SOL_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete TBCBS_SOL_DETAILS invoked (BO_ID=$BO_ID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTBCBS_SOL_DETAILS
          .delete(QueryParams(whereString: 'BO_ID=?', whereArguments: [BO_ID]));
    } else {
      return _mnTBCBS_SOL_DETAILS.updateBatch(
          QueryParams(whereString: 'BO_ID=?', whereArguments: [BO_ID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TBCBS_SOL_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_SOL_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_SOL_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      BO_ID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tbcbs_sol_details

// region TBCBS_SOL_DETAILSField
class TBCBS_SOL_DETAILSField extends FilterBase {
  TBCBS_SOL_DETAILSField(TBCBS_SOL_DETAILSFilterBuilder tbcbs_sol_detailsFB)
      : super(tbcbs_sol_detailsFB);

  @override
  TBCBS_SOL_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder isNull() {
    return super.isNull() as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TBCBS_SOL_DETAILSFilterBuilder;
  }

  @override
  TBCBS_SOL_DETAILSField get not {
    return super.not as TBCBS_SOL_DETAILSField;
  }
}
// endregion TBCBS_SOL_DETAILSField

// region TBCBS_SOL_DETAILSFilterBuilder
class TBCBS_SOL_DETAILSFilterBuilder extends ConjunctionBase {
  TBCBS_SOL_DETAILSFilterBuilder(TBCBS_SOL_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTBCBS_SOL_DETAILS = obj._mnTBCBS_SOL_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TBCBS_SOL_DETAILSManager? _mnTBCBS_SOL_DETAILS;

  /// put the sql keyword 'AND'
  @override
  TBCBS_SOL_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TBCBS_SOL_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TBCBS_SOL_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TBCBS_SOL_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TBCBS_SOL_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TBCBS_SOL_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TBCBS_SOL_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_SOL_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_SOL_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_SOL_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_SOL_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TBCBS_SOL_DETAILSField _setField(
      TBCBS_SOL_DETAILSField? field, String colName, DbType dbtype) {
    return TBCBS_SOL_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TBCBS_SOL_DETAILSField? _BO_ID;
  TBCBS_SOL_DETAILSField get BO_ID {
    return _BO_ID = _setField(_BO_ID, 'BO_ID', DbType.integer);
  }

  TBCBS_SOL_DETAILSField? _SOL_ID;
  TBCBS_SOL_DETAILSField get SOL_ID {
    return _SOL_ID = _setField(_SOL_ID, 'SOL_ID', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _SOL_DESC;
  TBCBS_SOL_DETAILSField get SOL_DESC {
    return _SOL_DESC = _setField(_SOL_DESC, 'SOL_DESC', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _R_CRE_TIME;
  TBCBS_SOL_DETAILSField get R_CRE_TIME {
    return _R_CRE_TIME = _setField(_R_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _R_MOD_TIME;
  TBCBS_SOL_DETAILSField get R_MOD_TIME {
    return _R_MOD_TIME = _setField(_R_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _OPERATOR_ID;
  TBCBS_SOL_DETAILSField get OPERATOR_ID {
    return _OPERATOR_ID = _setField(_OPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _FUTURE_USE_1;
  TBCBS_SOL_DETAILSField get FUTURE_USE_1 {
    return _FUTURE_USE_1 =
        _setField(_FUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _FUTURE_USE_2;
  TBCBS_SOL_DETAILSField get FUTURE_USE_2 {
    return _FUTURE_USE_2 =
        _setField(_FUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _FUTURE_USE_3;
  TBCBS_SOL_DETAILSField get FUTURE_USE_3 {
    return _FUTURE_USE_3 =
        _setField(_FUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  TBCBS_SOL_DETAILSField? _FUTURE_USE_4;
  TBCBS_SOL_DETAILSField get FUTURE_USE_4 {
    return _FUTURE_USE_4 =
        _setField(_FUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }

  /// Deletes List<TBCBS_SOL_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTBCBS_SOL_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTBCBS_SOL_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'BO_ID IN (SELECT BO_ID from TBCBS_SOL_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTBCBS_SOL_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [TBCBS_SOL_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_SOL_DETAILS?
  @override
  Future<TBCBS_SOL_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTBCBS_SOL_DETAILS!.toList(qparams);
    final data = await objFuture;
    TBCBS_SOL_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = TBCBS_SOL_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TBCBS_SOL_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_SOL_DETAILS?
  @override
  Future<TBCBS_SOL_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TBCBS_SOL_DETAILS();
  }

  /// This method returns int. [TBCBS_SOL_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? tbcbs_sol_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tbcbs_sol_detailsesFuture =
        await _mnTBCBS_SOL_DETAILS!.toList(qparams);
    final int count = tbcbs_sol_detailsesFuture[0]['CNT'] as int;
    if (tbcbs_sol_detailsCount != null) {
      tbcbs_sol_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<TBCBS_SOL_DETAILS> [TBCBS_SOL_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TBCBS_SOL_DETAILS>
  @override
  Future<List<TBCBS_SOL_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TBCBS_SOL_DETAILS> tbcbs_sol_detailsesData =
        await TBCBS_SOL_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tbcbs_sol_detailsesData;
  }

  /// This method returns Json String [TBCBS_SOL_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TBCBS_SOL_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TBCBS_SOL_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTBCBS_SOL_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TBCBS_SOL_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `BO_ID` FROM TBCBS_SOL_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> BO_IDData = <String>[];
    qparams.selectColumns = ['BO_ID'];
    final BO_IDFuture = await _mnTBCBS_SOL_DETAILS!.toList(qparams);

    final int count = BO_IDFuture.length;
    for (int i = 0; i < count; i++) {
      BO_IDData.add(BO_IDFuture[i]['BO_ID'] as String);
    }
    return BO_IDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TBCBS_SOL_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTBCBS_SOL_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TBCBS_SOL_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTBCBS_SOL_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TBCBS_SOL_DETAILSFilterBuilder

// region TBCBS_SOL_DETAILSFields
class TBCBS_SOL_DETAILSFields {
  static TableField? _fBO_ID;
  static TableField get BO_ID {
    return _fBO_ID =
        _fBO_ID ?? SqlSyntax.setField(_fBO_ID, 'bo_id', DbType.integer);
  }

  static TableField? _fSOL_ID;
  static TableField get SOL_ID {
    return _fSOL_ID =
        _fSOL_ID ?? SqlSyntax.setField(_fSOL_ID, 'SOL_ID', DbType.text);
  }

  static TableField? _fSOL_DESC;
  static TableField get SOL_DESC {
    return _fSOL_DESC =
        _fSOL_DESC ?? SqlSyntax.setField(_fSOL_DESC, 'SOL_DESC', DbType.text);
  }

  static TableField? _fR_CRE_TIME;
  static TableField get R_CRE_TIME {
    return _fR_CRE_TIME = _fR_CRE_TIME ??
        SqlSyntax.setField(_fR_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  static TableField? _fR_MOD_TIME;
  static TableField get R_MOD_TIME {
    return _fR_MOD_TIME = _fR_MOD_TIME ??
        SqlSyntax.setField(_fR_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  static TableField? _fOPERATOR_ID;
  static TableField get OPERATOR_ID {
    return _fOPERATOR_ID = _fOPERATOR_ID ??
        SqlSyntax.setField(_fOPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  static TableField? _fFUTURE_USE_1;
  static TableField get FUTURE_USE_1 {
    return _fFUTURE_USE_1 = _fFUTURE_USE_1 ??
        SqlSyntax.setField(_fFUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  static TableField? _fFUTURE_USE_2;
  static TableField get FUTURE_USE_2 {
    return _fFUTURE_USE_2 = _fFUTURE_USE_2 ??
        SqlSyntax.setField(_fFUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  static TableField? _fFUTURE_USE_3;
  static TableField get FUTURE_USE_3 {
    return _fFUTURE_USE_3 = _fFUTURE_USE_3 ??
        SqlSyntax.setField(_fFUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  static TableField? _fFUTURE_USE_4;
  static TableField get FUTURE_USE_4 {
    return _fFUTURE_USE_4 = _fFUTURE_USE_4 ??
        SqlSyntax.setField(_fFUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }
}
// endregion TBCBS_SOL_DETAILSFields

//region TBCBS_SOL_DETAILSManager
class TBCBS_SOL_DETAILSManager extends SqfEntityProvider {
  TBCBS_SOL_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TBCBS_SOL_DETAILS';
  static const List<String> _primaryKeyList = ['BO_ID'];
  static const String _whereStr = 'BO_ID=?';
}

//endregion TBCBS_SOL_DETAILSManager
// region TBCBS_CONFIG_DETAILS
class TBCBS_CONFIG_DETAILS extends TableBase {
  TBCBS_CONFIG_DETAILS(
      {this.CONFIG_NAME,
      this.CONFIG_VALUE,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TBCBS_CONFIG_DETAILS.withFields(
      this.CONFIG_NAME,
      this.CONFIG_VALUE,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  TBCBS_CONFIG_DETAILS.withId(
      this.CONFIG_NAME,
      this.CONFIG_VALUE,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TBCBS_CONFIG_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    CONFIG_NAME = o['CONFIG_NAME'].toString();
    if (o['CONFIG_VALUE'] != null) {
      CONFIG_VALUE = o['CONFIG_VALUE'].toString();
    }
    if (o['R_CRE_TIME'] != null) {
      R_CRE_TIME = o['R_CRE_TIME'].toString();
    }
    if (o['R_MOD_TIME'] != null) {
      R_MOD_TIME = o['R_MOD_TIME'].toString();
    }
    if (o['OPERATOR_ID'] != null) {
      OPERATOR_ID = o['OPERATOR_ID'].toString();
    }
    if (o['FUTURE_USE_1'] != null) {
      FUTURE_USE_1 = o['FUTURE_USE_1'].toString();
    }
    if (o['FUTURE_USE_2'] != null) {
      FUTURE_USE_2 = o['FUTURE_USE_2'].toString();
    }
    if (o['FUTURE_USE_3'] != null) {
      FUTURE_USE_3 = o['FUTURE_USE_3'].toString();
    }
    if (o['FUTURE_USE_4'] != null) {
      FUTURE_USE_4 = o['FUTURE_USE_4'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TBCBS_CONFIG_DETAILS)
  String? CONFIG_NAME;
  String? CONFIG_VALUE;
  String? R_CRE_TIME;
  String? R_MOD_TIME;
  String? OPERATOR_ID;
  String? FUTURE_USE_1;
  String? FUTURE_USE_2;
  String? FUTURE_USE_3;
  String? FUTURE_USE_4;
  bool? isSaved;
  // end FIELDS (TBCBS_CONFIG_DETAILS)

  static const bool _softDeleteActivated = false;
  TBCBS_CONFIG_DETAILSManager? __mnTBCBS_CONFIG_DETAILS;

  TBCBS_CONFIG_DETAILSManager get _mnTBCBS_CONFIG_DETAILS {
    return __mnTBCBS_CONFIG_DETAILS =
        __mnTBCBS_CONFIG_DETAILS ?? TBCBS_CONFIG_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['CONFIG_NAME'] = CONFIG_NAME;
    if (CONFIG_VALUE != null || !forView) {
      map['CONFIG_VALUE'] = CONFIG_VALUE;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['CONFIG_NAME'] = CONFIG_NAME;
    if (CONFIG_VALUE != null || !forView) {
      map['CONFIG_VALUE'] = CONFIG_VALUE;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  /// This method returns Json String [TBCBS_CONFIG_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TBCBS_CONFIG_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      CONFIG_NAME,
      CONFIG_VALUE,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      CONFIG_NAME,
      CONFIG_VALUE,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  static Future<List<TBCBS_CONFIG_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_CONFIG_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TBCBS_CONFIG_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TBCBS_CONFIG_DETAILS>[];
    try {
      objList = list
          .map((tbcbs_config_details) => TBCBS_CONFIG_DETAILS
              .fromMap(tbcbs_config_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_CONFIG_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TBCBS_CONFIG_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TBCBS_CONFIG_DETAILS> objList = <TBCBS_CONFIG_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TBCBS_CONFIG_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TBCBS_CONFIG_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? CONFIG_NAME
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TBCBS_CONFIG_DETAILS] if exist, otherwise returns null
  Future<TBCBS_CONFIG_DETAILS?> getById(String? CONFIG_NAME,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (CONFIG_NAME == null) {
      return null;
    }
    TBCBS_CONFIG_DETAILS? obj;
    final data = await _mnTBCBS_CONFIG_DETAILS.getById([CONFIG_NAME]);
    if (data.length != 0) {
      obj = TBCBS_CONFIG_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TBCBS_CONFIG_DETAILS) object. If the Primary Key (CONFIG_NAME) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same CONFIG_NAME
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTBCBS_CONFIG_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO TBCBS_CONFIG_DETAILS (CONFIG_NAME, CONFIG_VALUE, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TBCBS_CONFIG_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TBCBS_CONFIG_DETAILS> tbcbs_config_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in tbcbs_config_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_CONFIG_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO TBCBS_CONFIG_DETAILS (CONFIG_NAME, CONFIG_VALUE, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            CONFIG_NAME,
            CONFIG_VALUE,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TBCBS_CONFIG_DETAILS CONFIG_NAME=$CONFIG_NAME updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TBCBS_CONFIG_DETAILS CONFIG_NAME=$CONFIG_NAME did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TBCBS_CONFIG_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_CONFIG_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO TBCBS_CONFIG_DETAILS (CONFIG_NAME, CONFIG_VALUE, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?)',
          [
            CONFIG_NAME,
            CONFIG_VALUE,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'TBCBS_CONFIG_DETAILS CONFIG_NAME=$CONFIG_NAME updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'TBCBS_CONFIG_DETAILS CONFIG_NAME=$CONFIG_NAME did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
          'TBCBS_CONFIG_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }

  /// Deletes TBCBS_CONFIG_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete TBCBS_CONFIG_DETAILS invoked (CONFIG_NAME=$CONFIG_NAME)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTBCBS_CONFIG_DETAILS.delete(QueryParams(
          whereString: 'CONFIG_NAME=?', whereArguments: [CONFIG_NAME]));
    } else {
      return _mnTBCBS_CONFIG_DETAILS.updateBatch(
          QueryParams(
              whereString: 'CONFIG_NAME=?', whereArguments: [CONFIG_NAME]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TBCBS_CONFIG_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_CONFIG_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_CONFIG_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      CONFIG_NAME = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tbcbs_config_details

// region TBCBS_CONFIG_DETAILSField
class TBCBS_CONFIG_DETAILSField extends FilterBase {
  TBCBS_CONFIG_DETAILSField(
      TBCBS_CONFIG_DETAILSFilterBuilder tbcbs_config_detailsFB)
      : super(tbcbs_config_detailsFB);

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder isNull() {
    return super.isNull() as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TBCBS_CONFIG_DETAILSFilterBuilder;
  }

  @override
  TBCBS_CONFIG_DETAILSField get not {
    return super.not as TBCBS_CONFIG_DETAILSField;
  }
}
// endregion TBCBS_CONFIG_DETAILSField

// region TBCBS_CONFIG_DETAILSFilterBuilder
class TBCBS_CONFIG_DETAILSFilterBuilder extends ConjunctionBase {
  TBCBS_CONFIG_DETAILSFilterBuilder(
      TBCBS_CONFIG_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTBCBS_CONFIG_DETAILS = obj._mnTBCBS_CONFIG_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TBCBS_CONFIG_DETAILSManager? _mnTBCBS_CONFIG_DETAILS;

  /// put the sql keyword 'AND'
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_CONFIG_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TBCBS_CONFIG_DETAILSField _setField(
      TBCBS_CONFIG_DETAILSField? field, String colName, DbType dbtype) {
    return TBCBS_CONFIG_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TBCBS_CONFIG_DETAILSField? _CONFIG_NAME;
  TBCBS_CONFIG_DETAILSField get CONFIG_NAME {
    return _CONFIG_NAME =
        _setField(_CONFIG_NAME, 'CONFIG_NAME', DbType.integer);
  }

  TBCBS_CONFIG_DETAILSField? _CONFIG_VALUE;
  TBCBS_CONFIG_DETAILSField get CONFIG_VALUE {
    return _CONFIG_VALUE =
        _setField(_CONFIG_VALUE, 'CONFIG_VALUE', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _R_CRE_TIME;
  TBCBS_CONFIG_DETAILSField get R_CRE_TIME {
    return _R_CRE_TIME = _setField(_R_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _R_MOD_TIME;
  TBCBS_CONFIG_DETAILSField get R_MOD_TIME {
    return _R_MOD_TIME = _setField(_R_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _OPERATOR_ID;
  TBCBS_CONFIG_DETAILSField get OPERATOR_ID {
    return _OPERATOR_ID = _setField(_OPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _FUTURE_USE_1;
  TBCBS_CONFIG_DETAILSField get FUTURE_USE_1 {
    return _FUTURE_USE_1 =
        _setField(_FUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _FUTURE_USE_2;
  TBCBS_CONFIG_DETAILSField get FUTURE_USE_2 {
    return _FUTURE_USE_2 =
        _setField(_FUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _FUTURE_USE_3;
  TBCBS_CONFIG_DETAILSField get FUTURE_USE_3 {
    return _FUTURE_USE_3 =
        _setField(_FUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  TBCBS_CONFIG_DETAILSField? _FUTURE_USE_4;
  TBCBS_CONFIG_DETAILSField get FUTURE_USE_4 {
    return _FUTURE_USE_4 =
        _setField(_FUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }

  /// Deletes List<TBCBS_CONFIG_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTBCBS_CONFIG_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTBCBS_CONFIG_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'CONFIG_NAME IN (SELECT CONFIG_NAME from TBCBS_CONFIG_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTBCBS_CONFIG_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [TBCBS_CONFIG_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_CONFIG_DETAILS?
  @override
  Future<TBCBS_CONFIG_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTBCBS_CONFIG_DETAILS!.toList(qparams);
    final data = await objFuture;
    TBCBS_CONFIG_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = TBCBS_CONFIG_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TBCBS_CONFIG_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_CONFIG_DETAILS?
  @override
  Future<TBCBS_CONFIG_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TBCBS_CONFIG_DETAILS();
  }

  /// This method returns int. [TBCBS_CONFIG_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? tbcbs_config_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tbcbs_config_detailsesFuture =
        await _mnTBCBS_CONFIG_DETAILS!.toList(qparams);
    final int count = tbcbs_config_detailsesFuture[0]['CNT'] as int;
    if (tbcbs_config_detailsCount != null) {
      tbcbs_config_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<TBCBS_CONFIG_DETAILS> [TBCBS_CONFIG_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TBCBS_CONFIG_DETAILS>
  @override
  Future<List<TBCBS_CONFIG_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TBCBS_CONFIG_DETAILS> tbcbs_config_detailsesData =
        await TBCBS_CONFIG_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tbcbs_config_detailsesData;
  }

  /// This method returns Json String [TBCBS_CONFIG_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TBCBS_CONFIG_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TBCBS_CONFIG_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTBCBS_CONFIG_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TBCBS_CONFIG_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `CONFIG_NAME` FROM TBCBS_CONFIG_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> CONFIG_NAMEData = <String>[];
    qparams.selectColumns = ['CONFIG_NAME'];
    final CONFIG_NAMEFuture = await _mnTBCBS_CONFIG_DETAILS!.toList(qparams);

    final int count = CONFIG_NAMEFuture.length;
    for (int i = 0; i < count; i++) {
      CONFIG_NAMEData.add(CONFIG_NAMEFuture[i]['CONFIG_NAME'] as String);
    }
    return CONFIG_NAMEData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TBCBS_CONFIG_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTBCBS_CONFIG_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TBCBS_CONFIG_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTBCBS_CONFIG_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TBCBS_CONFIG_DETAILSFilterBuilder

// region TBCBS_CONFIG_DETAILSFields
class TBCBS_CONFIG_DETAILSFields {
  static TableField? _fCONFIG_NAME;
  static TableField get CONFIG_NAME {
    return _fCONFIG_NAME = _fCONFIG_NAME ??
        SqlSyntax.setField(_fCONFIG_NAME, 'config_name', DbType.integer);
  }

  static TableField? _fCONFIG_VALUE;
  static TableField get CONFIG_VALUE {
    return _fCONFIG_VALUE = _fCONFIG_VALUE ??
        SqlSyntax.setField(_fCONFIG_VALUE, 'CONFIG_VALUE', DbType.text);
  }

  static TableField? _fR_CRE_TIME;
  static TableField get R_CRE_TIME {
    return _fR_CRE_TIME = _fR_CRE_TIME ??
        SqlSyntax.setField(_fR_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  static TableField? _fR_MOD_TIME;
  static TableField get R_MOD_TIME {
    return _fR_MOD_TIME = _fR_MOD_TIME ??
        SqlSyntax.setField(_fR_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  static TableField? _fOPERATOR_ID;
  static TableField get OPERATOR_ID {
    return _fOPERATOR_ID = _fOPERATOR_ID ??
        SqlSyntax.setField(_fOPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  static TableField? _fFUTURE_USE_1;
  static TableField get FUTURE_USE_1 {
    return _fFUTURE_USE_1 = _fFUTURE_USE_1 ??
        SqlSyntax.setField(_fFUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  static TableField? _fFUTURE_USE_2;
  static TableField get FUTURE_USE_2 {
    return _fFUTURE_USE_2 = _fFUTURE_USE_2 ??
        SqlSyntax.setField(_fFUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  static TableField? _fFUTURE_USE_3;
  static TableField get FUTURE_USE_3 {
    return _fFUTURE_USE_3 = _fFUTURE_USE_3 ??
        SqlSyntax.setField(_fFUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  static TableField? _fFUTURE_USE_4;
  static TableField get FUTURE_USE_4 {
    return _fFUTURE_USE_4 = _fFUTURE_USE_4 ??
        SqlSyntax.setField(_fFUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }
}
// endregion TBCBS_CONFIG_DETAILSFields

//region TBCBS_CONFIG_DETAILSManager
class TBCBS_CONFIG_DETAILSManager extends SqfEntityProvider {
  TBCBS_CONFIG_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TBCBS_CONFIG_DETAILS';
  static const List<String> _primaryKeyList = ['CONFIG_NAME'];
  static const String _whereStr = 'CONFIG_NAME=?';
}

//endregion TBCBS_CONFIG_DETAILSManager
// region TBCBS_EXCEP_DETAILS
class TBCBS_EXCEP_DETAILS extends TableBase {
  TBCBS_EXCEP_DETAILS(
      {this.REQUEST_NUMBER,
      this.REQUEST_DATE,
      this.ACCOUNT_NUMBER,
      this.REQUEST_STATUS,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  TBCBS_EXCEP_DETAILS.withFields(
      this.REQUEST_NUMBER,
      this.REQUEST_DATE,
      this.ACCOUNT_NUMBER,
      this.REQUEST_STATUS,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  TBCBS_EXCEP_DETAILS.withId(
      this.REQUEST_NUMBER,
      this.REQUEST_DATE,
      this.ACCOUNT_NUMBER,
      this.REQUEST_STATUS,
      this.R_CRE_TIME,
      this.R_MOD_TIME,
      this.OPERATOR_ID,
      this.FUTURE_USE_1,
      this.FUTURE_USE_2,
      this.FUTURE_USE_3,
      this.FUTURE_USE_4) {
    _setDefaultValues();
  }
  // fromMap v2.0
  TBCBS_EXCEP_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    REQUEST_NUMBER = o['REQUEST_NUMBER'].toString();
    if (o['REQUEST_DATE'] != null) {
      REQUEST_DATE = o['REQUEST_DATE'].toString();
    }
    if (o['ACCOUNT_NUMBER'] != null) {
      ACCOUNT_NUMBER = o['ACCOUNT_NUMBER'].toString();
    }
    if (o['REQUEST_STATUS'] != null) {
      REQUEST_STATUS = o['REQUEST_STATUS'].toString();
    }
    if (o['R_CRE_TIME'] != null) {
      R_CRE_TIME = o['R_CRE_TIME'].toString();
    }
    if (o['R_MOD_TIME'] != null) {
      R_MOD_TIME = o['R_MOD_TIME'].toString();
    }
    if (o['OPERATOR_ID'] != null) {
      OPERATOR_ID = o['OPERATOR_ID'].toString();
    }
    if (o['FUTURE_USE_1'] != null) {
      FUTURE_USE_1 = o['FUTURE_USE_1'].toString();
    }
    if (o['FUTURE_USE_2'] != null) {
      FUTURE_USE_2 = o['FUTURE_USE_2'].toString();
    }
    if (o['FUTURE_USE_3'] != null) {
      FUTURE_USE_3 = o['FUTURE_USE_3'].toString();
    }
    if (o['FUTURE_USE_4'] != null) {
      FUTURE_USE_4 = o['FUTURE_USE_4'].toString();
    }

    isSaved = true;
  }
  // FIELDS (TBCBS_EXCEP_DETAILS)
  String? REQUEST_NUMBER;
  String? REQUEST_DATE;
  String? ACCOUNT_NUMBER;
  String? REQUEST_STATUS;
  String? R_CRE_TIME;
  String? R_MOD_TIME;
  String? OPERATOR_ID;
  String? FUTURE_USE_1;
  String? FUTURE_USE_2;
  String? FUTURE_USE_3;
  String? FUTURE_USE_4;
  bool? isSaved;
  // end FIELDS (TBCBS_EXCEP_DETAILS)

  static const bool _softDeleteActivated = false;
  TBCBS_EXCEP_DETAILSManager? __mnTBCBS_EXCEP_DETAILS;

  TBCBS_EXCEP_DETAILSManager get _mnTBCBS_EXCEP_DETAILS {
    return __mnTBCBS_EXCEP_DETAILS =
        __mnTBCBS_EXCEP_DETAILS ?? TBCBS_EXCEP_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['REQUEST_NUMBER'] = REQUEST_NUMBER;
    if (REQUEST_DATE != null || !forView) {
      map['REQUEST_DATE'] = REQUEST_DATE;
    }
    if (ACCOUNT_NUMBER != null || !forView) {
      map['ACCOUNT_NUMBER'] = ACCOUNT_NUMBER;
    }
    if (REQUEST_STATUS != null || !forView) {
      map['REQUEST_STATUS'] = REQUEST_STATUS;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['REQUEST_NUMBER'] = REQUEST_NUMBER;
    if (REQUEST_DATE != null || !forView) {
      map['REQUEST_DATE'] = REQUEST_DATE;
    }
    if (ACCOUNT_NUMBER != null || !forView) {
      map['ACCOUNT_NUMBER'] = ACCOUNT_NUMBER;
    }
    if (REQUEST_STATUS != null || !forView) {
      map['REQUEST_STATUS'] = REQUEST_STATUS;
    }
    if (R_CRE_TIME != null || !forView) {
      map['R_CRE_TIME'] = R_CRE_TIME;
    }
    if (R_MOD_TIME != null || !forView) {
      map['R_MOD_TIME'] = R_MOD_TIME;
    }
    if (OPERATOR_ID != null || !forView) {
      map['OPERATOR_ID'] = OPERATOR_ID;
    }
    if (FUTURE_USE_1 != null || !forView) {
      map['FUTURE_USE_1'] = FUTURE_USE_1;
    }
    if (FUTURE_USE_2 != null || !forView) {
      map['FUTURE_USE_2'] = FUTURE_USE_2;
    }
    if (FUTURE_USE_3 != null || !forView) {
      map['FUTURE_USE_3'] = FUTURE_USE_3;
    }
    if (FUTURE_USE_4 != null || !forView) {
      map['FUTURE_USE_4'] = FUTURE_USE_4;
    }

    return map;
  }

  /// This method returns Json String [TBCBS_EXCEP_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [TBCBS_EXCEP_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      REQUEST_NUMBER,
      REQUEST_DATE,
      ACCOUNT_NUMBER,
      REQUEST_STATUS,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      REQUEST_NUMBER,
      REQUEST_DATE,
      ACCOUNT_NUMBER,
      REQUEST_STATUS,
      R_CRE_TIME,
      R_MOD_TIME,
      OPERATOR_ID,
      FUTURE_USE_1,
      FUTURE_USE_2,
      FUTURE_USE_3,
      FUTURE_USE_4
    ];
  }

  static Future<List<TBCBS_EXCEP_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_EXCEP_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<TBCBS_EXCEP_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <TBCBS_EXCEP_DETAILS>[];
    try {
      objList = list
          .map((tbcbs_excep_details) => TBCBS_EXCEP_DETAILS
              .fromMap(tbcbs_excep_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR TBCBS_EXCEP_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<TBCBS_EXCEP_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<TBCBS_EXCEP_DETAILS> objList = <TBCBS_EXCEP_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = TBCBS_EXCEP_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns TBCBS_EXCEP_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? REQUEST_NUMBER
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [TBCBS_EXCEP_DETAILS] if exist, otherwise returns null
  Future<TBCBS_EXCEP_DETAILS?> getById(String? REQUEST_NUMBER,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (REQUEST_NUMBER == null) {
      return null;
    }
    TBCBS_EXCEP_DETAILS? obj;
    final data = await _mnTBCBS_EXCEP_DETAILS.getById([REQUEST_NUMBER]);
    if (data.length != 0) {
      obj = TBCBS_EXCEP_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (TBCBS_EXCEP_DETAILS) object. If the Primary Key (REQUEST_NUMBER) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same REQUEST_NUMBER
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnTBCBS_EXCEP_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO TBCBS_EXCEP_DETAILS (REQUEST_NUMBER, REQUEST_DATE, ACCOUNT_NUMBER, REQUEST_STATUS, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<TBCBS_EXCEP_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<TBCBS_EXCEP_DETAILS> tbcbs_excep_detailses,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in tbcbs_excep_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_EXCEP_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO TBCBS_EXCEP_DETAILS (REQUEST_NUMBER, REQUEST_DATE, ACCOUNT_NUMBER, REQUEST_STATUS, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            REQUEST_NUMBER,
            REQUEST_DATE,
            ACCOUNT_NUMBER,
            REQUEST_STATUS,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'TBCBS_EXCEP_DETAILS REQUEST_NUMBER=$REQUEST_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'TBCBS_EXCEP_DETAILS REQUEST_NUMBER=$REQUEST_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'TBCBS_EXCEP_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnTBCBS_EXCEP_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO TBCBS_EXCEP_DETAILS (REQUEST_NUMBER, REQUEST_DATE, ACCOUNT_NUMBER, REQUEST_STATUS, R_CRE_TIME, R_MOD_TIME, OPERATOR_ID, FUTURE_USE_1, FUTURE_USE_2, FUTURE_USE_3, FUTURE_USE_4)  VALUES (?,?,?,?,?,?,?,?,?,?,?)',
          [
            REQUEST_NUMBER,
            REQUEST_DATE,
            ACCOUNT_NUMBER,
            REQUEST_STATUS,
            R_CRE_TIME,
            R_MOD_TIME,
            OPERATOR_ID,
            FUTURE_USE_1,
            FUTURE_USE_2,
            FUTURE_USE_3,
            FUTURE_USE_4
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'TBCBS_EXCEP_DETAILS REQUEST_NUMBER=$REQUEST_NUMBER updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'TBCBS_EXCEP_DETAILS REQUEST_NUMBER=$REQUEST_NUMBER did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
          'TBCBS_EXCEP_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes TBCBS_EXCEP_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete TBCBS_EXCEP_DETAILS invoked (REQUEST_NUMBER=$REQUEST_NUMBER)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnTBCBS_EXCEP_DETAILS.delete(QueryParams(
          whereString: 'REQUEST_NUMBER=?', whereArguments: [REQUEST_NUMBER]));
    } else {
      return _mnTBCBS_EXCEP_DETAILS.updateBatch(
          QueryParams(
              whereString: 'REQUEST_NUMBER=?',
              whereArguments: [REQUEST_NUMBER]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [TBCBS_EXCEP_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_EXCEP_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return TBCBS_EXCEP_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      REQUEST_NUMBER = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion tbcbs_excep_details

// region TBCBS_EXCEP_DETAILSField
class TBCBS_EXCEP_DETAILSField extends FilterBase {
  TBCBS_EXCEP_DETAILSField(
      TBCBS_EXCEP_DETAILSFilterBuilder tbcbs_excep_detailsFB)
      : super(tbcbs_excep_detailsFB);

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder isNull() {
    return super.isNull() as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue)
        as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as TBCBS_EXCEP_DETAILSFilterBuilder;
  }

  @override
  TBCBS_EXCEP_DETAILSField get not {
    return super.not as TBCBS_EXCEP_DETAILSField;
  }
}
// endregion TBCBS_EXCEP_DETAILSField

// region TBCBS_EXCEP_DETAILSFilterBuilder
class TBCBS_EXCEP_DETAILSFilterBuilder extends ConjunctionBase {
  TBCBS_EXCEP_DETAILSFilterBuilder(TBCBS_EXCEP_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnTBCBS_EXCEP_DETAILS = obj._mnTBCBS_EXCEP_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  TBCBS_EXCEP_DETAILSManager? _mnTBCBS_EXCEP_DETAILS;

  /// put the sql keyword 'AND'
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  TBCBS_EXCEP_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  TBCBS_EXCEP_DETAILSField _setField(
      TBCBS_EXCEP_DETAILSField? field, String colName, DbType dbtype) {
    return TBCBS_EXCEP_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  TBCBS_EXCEP_DETAILSField? _REQUEST_NUMBER;
  TBCBS_EXCEP_DETAILSField get REQUEST_NUMBER {
    return _REQUEST_NUMBER =
        _setField(_REQUEST_NUMBER, 'REQUEST_NUMBER', DbType.integer);
  }

  TBCBS_EXCEP_DETAILSField? _REQUEST_DATE;
  TBCBS_EXCEP_DETAILSField get REQUEST_DATE {
    return _REQUEST_DATE =
        _setField(_REQUEST_DATE, 'REQUEST_DATE', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _ACCOUNT_NUMBER;
  TBCBS_EXCEP_DETAILSField get ACCOUNT_NUMBER {
    return _ACCOUNT_NUMBER =
        _setField(_ACCOUNT_NUMBER, 'ACCOUNT_NUMBER', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _REQUEST_STATUS;
  TBCBS_EXCEP_DETAILSField get REQUEST_STATUS {
    return _REQUEST_STATUS =
        _setField(_REQUEST_STATUS, 'REQUEST_STATUS', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _R_CRE_TIME;
  TBCBS_EXCEP_DETAILSField get R_CRE_TIME {
    return _R_CRE_TIME = _setField(_R_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _R_MOD_TIME;
  TBCBS_EXCEP_DETAILSField get R_MOD_TIME {
    return _R_MOD_TIME = _setField(_R_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _OPERATOR_ID;
  TBCBS_EXCEP_DETAILSField get OPERATOR_ID {
    return _OPERATOR_ID = _setField(_OPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _FUTURE_USE_1;
  TBCBS_EXCEP_DETAILSField get FUTURE_USE_1 {
    return _FUTURE_USE_1 =
        _setField(_FUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _FUTURE_USE_2;
  TBCBS_EXCEP_DETAILSField get FUTURE_USE_2 {
    return _FUTURE_USE_2 =
        _setField(_FUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _FUTURE_USE_3;
  TBCBS_EXCEP_DETAILSField get FUTURE_USE_3 {
    return _FUTURE_USE_3 =
        _setField(_FUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  TBCBS_EXCEP_DETAILSField? _FUTURE_USE_4;
  TBCBS_EXCEP_DETAILSField get FUTURE_USE_4 {
    return _FUTURE_USE_4 =
        _setField(_FUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }

  /// Deletes List<TBCBS_EXCEP_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnTBCBS_EXCEP_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnTBCBS_EXCEP_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'REQUEST_NUMBER IN (SELECT REQUEST_NUMBER from TBCBS_EXCEP_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnTBCBS_EXCEP_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [TBCBS_EXCEP_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_EXCEP_DETAILS?
  @override
  Future<TBCBS_EXCEP_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnTBCBS_EXCEP_DETAILS!.toList(qparams);
    final data = await objFuture;
    TBCBS_EXCEP_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = TBCBS_EXCEP_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [TBCBS_EXCEP_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> TBCBS_EXCEP_DETAILS?
  @override
  Future<TBCBS_EXCEP_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        TBCBS_EXCEP_DETAILS();
  }

  /// This method returns int. [TBCBS_EXCEP_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? tbcbs_excep_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final tbcbs_excep_detailsesFuture =
        await _mnTBCBS_EXCEP_DETAILS!.toList(qparams);
    final int count = tbcbs_excep_detailsesFuture[0]['CNT'] as int;
    if (tbcbs_excep_detailsCount != null) {
      tbcbs_excep_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<TBCBS_EXCEP_DETAILS> [TBCBS_EXCEP_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<TBCBS_EXCEP_DETAILS>
  @override
  Future<List<TBCBS_EXCEP_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<TBCBS_EXCEP_DETAILS> tbcbs_excep_detailsesData =
        await TBCBS_EXCEP_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return tbcbs_excep_detailsesData;
  }

  /// This method returns Json String [TBCBS_EXCEP_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [TBCBS_EXCEP_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [TBCBS_EXCEP_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnTBCBS_EXCEP_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [TBCBS_EXCEP_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `REQUEST_NUMBER` FROM TBCBS_EXCEP_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> REQUEST_NUMBERData = <String>[];
    qparams.selectColumns = ['REQUEST_NUMBER'];
    final REQUEST_NUMBERFuture = await _mnTBCBS_EXCEP_DETAILS!.toList(qparams);

    final int count = REQUEST_NUMBERFuture.length;
    for (int i = 0; i < count; i++) {
      REQUEST_NUMBERData.add(
          REQUEST_NUMBERFuture[i]['REQUEST_NUMBER'] as String);
    }
    return REQUEST_NUMBERData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [TBCBS_EXCEP_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnTBCBS_EXCEP_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await TBCBS_EXCEP_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnTBCBS_EXCEP_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion TBCBS_EXCEP_DETAILSFilterBuilder

// region TBCBS_EXCEP_DETAILSFields
class TBCBS_EXCEP_DETAILSFields {
  static TableField? _fREQUEST_NUMBER;
  static TableField get REQUEST_NUMBER {
    return _fREQUEST_NUMBER = _fREQUEST_NUMBER ??
        SqlSyntax.setField(_fREQUEST_NUMBER, 'request_number', DbType.integer);
  }

  static TableField? _fREQUEST_DATE;
  static TableField get REQUEST_DATE {
    return _fREQUEST_DATE = _fREQUEST_DATE ??
        SqlSyntax.setField(_fREQUEST_DATE, 'REQUEST_DATE', DbType.text);
  }

  static TableField? _fACCOUNT_NUMBER;
  static TableField get ACCOUNT_NUMBER {
    return _fACCOUNT_NUMBER = _fACCOUNT_NUMBER ??
        SqlSyntax.setField(_fACCOUNT_NUMBER, 'ACCOUNT_NUMBER', DbType.text);
  }

  static TableField? _fREQUEST_STATUS;
  static TableField get REQUEST_STATUS {
    return _fREQUEST_STATUS = _fREQUEST_STATUS ??
        SqlSyntax.setField(_fREQUEST_STATUS, 'REQUEST_STATUS', DbType.text);
  }

  static TableField? _fR_CRE_TIME;
  static TableField get R_CRE_TIME {
    return _fR_CRE_TIME = _fR_CRE_TIME ??
        SqlSyntax.setField(_fR_CRE_TIME, 'R_CRE_TIME', DbType.text);
  }

  static TableField? _fR_MOD_TIME;
  static TableField get R_MOD_TIME {
    return _fR_MOD_TIME = _fR_MOD_TIME ??
        SqlSyntax.setField(_fR_MOD_TIME, 'R_MOD_TIME', DbType.text);
  }

  static TableField? _fOPERATOR_ID;
  static TableField get OPERATOR_ID {
    return _fOPERATOR_ID = _fOPERATOR_ID ??
        SqlSyntax.setField(_fOPERATOR_ID, 'OPERATOR_ID', DbType.text);
  }

  static TableField? _fFUTURE_USE_1;
  static TableField get FUTURE_USE_1 {
    return _fFUTURE_USE_1 = _fFUTURE_USE_1 ??
        SqlSyntax.setField(_fFUTURE_USE_1, 'FUTURE_USE_1', DbType.text);
  }

  static TableField? _fFUTURE_USE_2;
  static TableField get FUTURE_USE_2 {
    return _fFUTURE_USE_2 = _fFUTURE_USE_2 ??
        SqlSyntax.setField(_fFUTURE_USE_2, 'FUTURE_USE_2', DbType.text);
  }

  static TableField? _fFUTURE_USE_3;
  static TableField get FUTURE_USE_3 {
    return _fFUTURE_USE_3 = _fFUTURE_USE_3 ??
        SqlSyntax.setField(_fFUTURE_USE_3, 'FUTURE_USE_3', DbType.text);
  }

  static TableField? _fFUTURE_USE_4;
  static TableField get FUTURE_USE_4 {
    return _fFUTURE_USE_4 = _fFUTURE_USE_4 ??
        SqlSyntax.setField(_fFUTURE_USE_4, 'FUTURE_USE_4', DbType.text);
  }
}
// endregion TBCBS_EXCEP_DETAILSFields

//region TBCBS_EXCEP_DETAILSManager
class TBCBS_EXCEP_DETAILSManager extends SqfEntityProvider {
  TBCBS_EXCEP_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'TBCBS_EXCEP_DETAILS';
  static const List<String> _primaryKeyList = ['REQUEST_NUMBER'];
  static const String _whereStr = 'REQUEST_NUMBER=?';
}

//endregion TBCBS_EXCEP_DETAILSManager
// region IPPBCBS_DETAILS
class IPPBCBS_DETAILS extends TableBase {
  IPPBCBS_DETAILS(
      {this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  IPPBCBS_DETAILS.withFields(
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks) {
    _setDefaultValues();
  }
  IPPBCBS_DETAILS.withId(
      this.TRANSACTION_DATE,
      this.TRANSACTION_TIME,
      this.TOTAL_DEPOSITS,
      this.TOTAL_DEPOSIT_AMOUNT,
      this.TOTAL_WITHDRAWALS,
      this.TOTAL_WITHDRAWAL_AMOUNT,
      this.Remarks) {
    _setDefaultValues();
  }
  // fromMap v2.0
  IPPBCBS_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    TRANSACTION_DATE = o['TRANSACTION_DATE'].toString();
    if (o['TRANSACTION_TIME'] != null) {
      TRANSACTION_TIME = o['TRANSACTION_TIME'].toString();
    }
    if (o['TOTAL_DEPOSITS'] != null) {
      TOTAL_DEPOSITS = o['TOTAL_DEPOSITS'].toString();
    }
    if (o['TOTAL_DEPOSIT_AMOUNT'] != null) {
      TOTAL_DEPOSIT_AMOUNT = o['TOTAL_DEPOSIT_AMOUNT'].toString();
    }
    if (o['TOTAL_WITHDRAWALS'] != null) {
      TOTAL_WITHDRAWALS = o['TOTAL_WITHDRAWALS'].toString();
    }
    if (o['TOTAL_WITHDRAWAL_AMOUNT'] != null) {
      TOTAL_WITHDRAWAL_AMOUNT = o['TOTAL_WITHDRAWAL_AMOUNT'].toString();
    }
    if (o['Remarks'] != null) {
      Remarks = o['Remarks'].toString();
    }

    isSaved = true;
  }
  // FIELDS (IPPBCBS_DETAILS)
  String? TRANSACTION_DATE;
  String? TRANSACTION_TIME;
  String? TOTAL_DEPOSITS;
  String? TOTAL_DEPOSIT_AMOUNT;
  String? TOTAL_WITHDRAWALS;
  String? TOTAL_WITHDRAWAL_AMOUNT;
  String? Remarks;
  bool? isSaved;
  // end FIELDS (IPPBCBS_DETAILS)

  static const bool _softDeleteActivated = false;
  IPPBCBS_DETAILSManager? __mnIPPBCBS_DETAILS;

  IPPBCBS_DETAILSManager get _mnIPPBCBS_DETAILS {
    return __mnIPPBCBS_DETAILS =
        __mnIPPBCBS_DETAILS ?? IPPBCBS_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['TRANSACTION_DATE'] = TRANSACTION_DATE;
    if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = TRANSACTION_TIME;
    }
    if (TOTAL_DEPOSITS != null || !forView) {
      map['TOTAL_DEPOSITS'] = TOTAL_DEPOSITS;
    }
    if (TOTAL_DEPOSIT_AMOUNT != null || !forView) {
      map['TOTAL_DEPOSIT_AMOUNT'] = TOTAL_DEPOSIT_AMOUNT;
    }
    if (TOTAL_WITHDRAWALS != null || !forView) {
      map['TOTAL_WITHDRAWALS'] = TOTAL_WITHDRAWALS;
    }
    if (TOTAL_WITHDRAWAL_AMOUNT != null || !forView) {
      map['TOTAL_WITHDRAWAL_AMOUNT'] = TOTAL_WITHDRAWAL_AMOUNT;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['TRANSACTION_DATE'] = TRANSACTION_DATE;
    if (TRANSACTION_TIME != null || !forView) {
      map['TRANSACTION_TIME'] = TRANSACTION_TIME;
    }
    if (TOTAL_DEPOSITS != null || !forView) {
      map['TOTAL_DEPOSITS'] = TOTAL_DEPOSITS;
    }
    if (TOTAL_DEPOSIT_AMOUNT != null || !forView) {
      map['TOTAL_DEPOSIT_AMOUNT'] = TOTAL_DEPOSIT_AMOUNT;
    }
    if (TOTAL_WITHDRAWALS != null || !forView) {
      map['TOTAL_WITHDRAWALS'] = TOTAL_WITHDRAWALS;
    }
    if (TOTAL_WITHDRAWAL_AMOUNT != null || !forView) {
      map['TOTAL_WITHDRAWAL_AMOUNT'] = TOTAL_WITHDRAWAL_AMOUNT;
    }
    if (Remarks != null || !forView) {
      map['Remarks'] = Remarks;
    }

    return map;
  }

  /// This method returns Json String [IPPBCBS_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [IPPBCBS_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      TRANSACTION_DATE,
      TRANSACTION_TIME,
      TOTAL_DEPOSITS,
      TOTAL_DEPOSIT_AMOUNT,
      TOTAL_WITHDRAWALS,
      TOTAL_WITHDRAWAL_AMOUNT,
      Remarks
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      TRANSACTION_DATE,
      TRANSACTION_TIME,
      TOTAL_DEPOSITS,
      TOTAL_DEPOSIT_AMOUNT,
      TOTAL_WITHDRAWALS,
      TOTAL_WITHDRAWAL_AMOUNT,
      Remarks
    ];
  }

  static Future<List<IPPBCBS_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR IPPBCBS_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<IPPBCBS_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <IPPBCBS_DETAILS>[];
    try {
      objList = list
          .map((ippbcbs_details) =>
              IPPBCBS_DETAILS.fromMap(ippbcbs_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR IPPBCBS_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<IPPBCBS_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<IPPBCBS_DETAILS> objList = <IPPBCBS_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = IPPBCBS_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns IPPBCBS_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? TRANSACTION_DATE
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [IPPBCBS_DETAILS] if exist, otherwise returns null
  Future<IPPBCBS_DETAILS?> getById(String? TRANSACTION_DATE,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (TRANSACTION_DATE == null) {
      return null;
    }
    IPPBCBS_DETAILS? obj;
    final data = await _mnIPPBCBS_DETAILS.getById([TRANSACTION_DATE]);
    if (data.length != 0) {
      obj = IPPBCBS_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (IPPBCBS_DETAILS) object. If the Primary Key (TRANSACTION_DATE) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same TRANSACTION_DATE
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnIPPBCBS_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO IPPBCBS_DETAILS (TRANSACTION_DATE, TRANSACTION_TIME, TOTAL_DEPOSITS, TOTAL_DEPOSIT_AMOUNT, TOTAL_WITHDRAWALS, TOTAL_WITHDRAWAL_AMOUNT, Remarks)  VALUES (?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<IPPBCBS_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<IPPBCBS_DETAILS> ippbcbs_detailses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in ippbcbs_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnIPPBCBS_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO IPPBCBS_DETAILS (TRANSACTION_DATE, TRANSACTION_TIME, TOTAL_DEPOSITS, TOTAL_DEPOSIT_AMOUNT, TOTAL_WITHDRAWALS, TOTAL_WITHDRAWAL_AMOUNT, Remarks)  VALUES (?,?,?,?,?,?,?)',
          [
            TRANSACTION_DATE,
            TRANSACTION_TIME,
            TOTAL_DEPOSITS,
            TOTAL_DEPOSIT_AMOUNT,
            TOTAL_WITHDRAWALS,
            TOTAL_WITHDRAWAL_AMOUNT,
            Remarks
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'IPPBCBS_DETAILS TRANSACTION_DATE=$TRANSACTION_DATE updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'IPPBCBS_DETAILS TRANSACTION_DATE=$TRANSACTION_DATE did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'IPPBCBS_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnIPPBCBS_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO IPPBCBS_DETAILS (TRANSACTION_DATE, TRANSACTION_TIME, TOTAL_DEPOSITS, TOTAL_DEPOSIT_AMOUNT, TOTAL_WITHDRAWALS, TOTAL_WITHDRAWAL_AMOUNT)  VALUES (?,?,?,?,?,?)',
          [
            TRANSACTION_DATE,
            TRANSACTION_TIME,
            TOTAL_DEPOSITS,
            TOTAL_DEPOSIT_AMOUNT,
            TOTAL_WITHDRAWALS,
            TOTAL_WITHDRAWAL_AMOUNT
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'IPPBCBS_DETAILS TRANSACTION_DATE=$TRANSACTION_DATE updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'IPPBCBS_DETAILS TRANSACTION_DATE=$TRANSACTION_DATE did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'IPPBCBS_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes IPPBCBS_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete IPPBCBS_DETAILS invoked (TRANSACTION_DATE=$TRANSACTION_DATE)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnIPPBCBS_DETAILS.delete(QueryParams(
          whereString: 'TRANSACTION_DATE=?',
          whereArguments: [TRANSACTION_DATE]));
    } else {
      return _mnIPPBCBS_DETAILS.updateBatch(
          QueryParams(
              whereString: 'TRANSACTION_DATE=?',
              whereArguments: [TRANSACTION_DATE]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [IPPBCBS_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  IPPBCBS_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IPPBCBS_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return IPPBCBS_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      TRANSACTION_DATE = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion ippbcbs_details

// region IPPBCBS_DETAILSField
class IPPBCBS_DETAILSField extends FilterBase {
  IPPBCBS_DETAILSField(IPPBCBS_DETAILSFilterBuilder ippbcbs_detailsFB)
      : super(ippbcbs_detailsFB);

  @override
  IPPBCBS_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder isNull() {
    return super.isNull() as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as IPPBCBS_DETAILSFilterBuilder;
  }

  @override
  IPPBCBS_DETAILSField get not {
    return super.not as IPPBCBS_DETAILSField;
  }
}
// endregion IPPBCBS_DETAILSField

// region IPPBCBS_DETAILSFilterBuilder
class IPPBCBS_DETAILSFilterBuilder extends ConjunctionBase {
  IPPBCBS_DETAILSFilterBuilder(IPPBCBS_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnIPPBCBS_DETAILS = obj._mnIPPBCBS_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  IPPBCBS_DETAILSManager? _mnIPPBCBS_DETAILS;

  /// put the sql keyword 'AND'
  @override
  IPPBCBS_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  IPPBCBS_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  IPPBCBS_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  IPPBCBS_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  IPPBCBS_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  IPPBCBS_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  IPPBCBS_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  IPPBCBS_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  IPPBCBS_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  IPPBCBS_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  IPPBCBS_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  IPPBCBS_DETAILSField _setField(
      IPPBCBS_DETAILSField? field, String colName, DbType dbtype) {
    return IPPBCBS_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  IPPBCBS_DETAILSField? _TRANSACTION_DATE;
  IPPBCBS_DETAILSField get TRANSACTION_DATE {
    return _TRANSACTION_DATE =
        _setField(_TRANSACTION_DATE, 'TRANSACTION_DATE', DbType.integer);
  }

  IPPBCBS_DETAILSField? _TRANSACTION_TIME;
  IPPBCBS_DETAILSField get TRANSACTION_TIME {
    return _TRANSACTION_TIME =
        _setField(_TRANSACTION_TIME, 'TRANSACTION_TIME', DbType.text);
  }

  IPPBCBS_DETAILSField? _TOTAL_DEPOSITS;
  IPPBCBS_DETAILSField get TOTAL_DEPOSITS {
    return _TOTAL_DEPOSITS =
        _setField(_TOTAL_DEPOSITS, 'TOTAL_DEPOSITS', DbType.text);
  }

  IPPBCBS_DETAILSField? _TOTAL_DEPOSIT_AMOUNT;
  IPPBCBS_DETAILSField get TOTAL_DEPOSIT_AMOUNT {
    return _TOTAL_DEPOSIT_AMOUNT =
        _setField(_TOTAL_DEPOSIT_AMOUNT, 'TOTAL_DEPOSIT_AMOUNT', DbType.text);
  }

  IPPBCBS_DETAILSField? _TOTAL_WITHDRAWALS;
  IPPBCBS_DETAILSField get TOTAL_WITHDRAWALS {
    return _TOTAL_WITHDRAWALS =
        _setField(_TOTAL_WITHDRAWALS, 'TOTAL_WITHDRAWALS', DbType.text);
  }

  IPPBCBS_DETAILSField? _TOTAL_WITHDRAWAL_AMOUNT;
  IPPBCBS_DETAILSField get TOTAL_WITHDRAWAL_AMOUNT {
    return _TOTAL_WITHDRAWAL_AMOUNT = _setField(
        _TOTAL_WITHDRAWAL_AMOUNT, 'TOTAL_WITHDRAWAL_AMOUNT', DbType.text);
  }

  IPPBCBS_DETAILSField? _Remarks;
  IPPBCBS_DETAILSField get Remarks {
    return _Remarks = _setField(_Remarks, 'Remarks', DbType.text);
  }

  /// Deletes List<IPPBCBS_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnIPPBCBS_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnIPPBCBS_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'TRANSACTION_DATE IN (SELECT TRANSACTION_DATE from IPPBCBS_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnIPPBCBS_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [IPPBCBS_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> IPPBCBS_DETAILS?
  @override
  Future<IPPBCBS_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnIPPBCBS_DETAILS!.toList(qparams);
    final data = await objFuture;
    IPPBCBS_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = IPPBCBS_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [IPPBCBS_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> IPPBCBS_DETAILS?
  @override
  Future<IPPBCBS_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        IPPBCBS_DETAILS();
  }

  /// This method returns int. [IPPBCBS_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? ippbcbs_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final ippbcbs_detailsesFuture = await _mnIPPBCBS_DETAILS!.toList(qparams);
    final int count = ippbcbs_detailsesFuture[0]['CNT'] as int;
    if (ippbcbs_detailsCount != null) {
      ippbcbs_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<IPPBCBS_DETAILS> [IPPBCBS_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<IPPBCBS_DETAILS>
  @override
  Future<List<IPPBCBS_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<IPPBCBS_DETAILS> ippbcbs_detailsesData =
        await IPPBCBS_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return ippbcbs_detailsesData;
  }

  /// This method returns Json String [IPPBCBS_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [IPPBCBS_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [IPPBCBS_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnIPPBCBS_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [IPPBCBS_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `TRANSACTION_DATE` FROM IPPBCBS_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> TRANSACTION_DATEData = <String>[];
    qparams.selectColumns = ['TRANSACTION_DATE'];
    final TRANSACTION_DATEFuture = await _mnIPPBCBS_DETAILS!.toList(qparams);

    final int count = TRANSACTION_DATEFuture.length;
    for (int i = 0; i < count; i++) {
      TRANSACTION_DATEData.add(
          TRANSACTION_DATEFuture[i]['TRANSACTION_DATE'] as String);
    }
    return TRANSACTION_DATEData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [IPPBCBS_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnIPPBCBS_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await IPPBCBS_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnIPPBCBS_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion IPPBCBS_DETAILSFilterBuilder

// region IPPBCBS_DETAILSFields
class IPPBCBS_DETAILSFields {
  static TableField? _fTRANSACTION_DATE;
  static TableField get TRANSACTION_DATE {
    return _fTRANSACTION_DATE = _fTRANSACTION_DATE ??
        SqlSyntax.setField(
            _fTRANSACTION_DATE, 'transaction_date', DbType.integer);
  }

  static TableField? _fTRANSACTION_TIME;
  static TableField get TRANSACTION_TIME {
    return _fTRANSACTION_TIME = _fTRANSACTION_TIME ??
        SqlSyntax.setField(_fTRANSACTION_TIME, 'TRANSACTION_TIME', DbType.text);
  }

  static TableField? _fTOTAL_DEPOSITS;
  static TableField get TOTAL_DEPOSITS {
    return _fTOTAL_DEPOSITS = _fTOTAL_DEPOSITS ??
        SqlSyntax.setField(_fTOTAL_DEPOSITS, 'TOTAL_DEPOSITS', DbType.text);
  }

  static TableField? _fTOTAL_DEPOSIT_AMOUNT;
  static TableField get TOTAL_DEPOSIT_AMOUNT {
    return _fTOTAL_DEPOSIT_AMOUNT = _fTOTAL_DEPOSIT_AMOUNT ??
        SqlSyntax.setField(
            _fTOTAL_DEPOSIT_AMOUNT, 'TOTAL_DEPOSIT_AMOUNT', DbType.text);
  }

  static TableField? _fTOTAL_WITHDRAWALS;
  static TableField get TOTAL_WITHDRAWALS {
    return _fTOTAL_WITHDRAWALS = _fTOTAL_WITHDRAWALS ??
        SqlSyntax.setField(
            _fTOTAL_WITHDRAWALS, 'TOTAL_WITHDRAWALS', DbType.text);
  }

  static TableField? _fTOTAL_WITHDRAWAL_AMOUNT;
  static TableField get TOTAL_WITHDRAWAL_AMOUNT {
    return _fTOTAL_WITHDRAWAL_AMOUNT = _fTOTAL_WITHDRAWAL_AMOUNT ??
        SqlSyntax.setField(
            _fTOTAL_WITHDRAWAL_AMOUNT, 'TOTAL_WITHDRAWAL_AMOUNT', DbType.text);
  }

  static TableField? _fRemarks;
  static TableField get Remarks {
    return _fRemarks =
        _fRemarks ?? SqlSyntax.setField(_fRemarks, 'Remarks', DbType.text);
  }
}
// endregion IPPBCBS_DETAILSFields

//region IPPBCBS_DETAILSManager
class IPPBCBS_DETAILSManager extends SqfEntityProvider {
  IPPBCBS_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'IPPBCBS_DETAILS';
  static const List<String> _primaryKeyList = ['TRANSACTION_DATE'];
  static const String _whereStr = 'TRANSACTION_DATE=?';
}

//endregion IPPBCBS_DETAILSManager
// region LEAVE_DETAILS
class LEAVE_DETAILS extends TableBase {
  LEAVE_DETAILS(
      {this.REQUEST_ID,
      this.GDS_ID,
      this.GENDER,
      this.TYPE_OF_LEAVE,
      this.LEAVE_REASON,
      this.LEAVE_FROM_DATE,
      this.LEAVE_TO_DATE,
      this.EMP_ADDRESS1,
      this.EMP_ADDRESS2,
      this.SUBSTITUTE_ID,
      this.SUBSTITUTE_NAME,
      this.SUBSTITUTE_ADDRESS1,
      this.SUBSTITUTE_ADDRESS2,
      this.SUBSTITUTE_AGE,
      this.SUBSTITUTE_QUALIFICATION,
      this.STATUS}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  LEAVE_DETAILS.withFields(
      this.REQUEST_ID,
      this.GDS_ID,
      this.GENDER,
      this.TYPE_OF_LEAVE,
      this.LEAVE_REASON,
      this.LEAVE_FROM_DATE,
      this.LEAVE_TO_DATE,
      this.EMP_ADDRESS1,
      this.EMP_ADDRESS2,
      this.SUBSTITUTE_ID,
      this.SUBSTITUTE_NAME,
      this.SUBSTITUTE_ADDRESS1,
      this.SUBSTITUTE_ADDRESS2,
      this.SUBSTITUTE_AGE,
      this.SUBSTITUTE_QUALIFICATION,
      this.STATUS) {
    _setDefaultValues();
  }
  LEAVE_DETAILS.withId(
      this.REQUEST_ID,
      this.GDS_ID,
      this.GENDER,
      this.TYPE_OF_LEAVE,
      this.LEAVE_REASON,
      this.LEAVE_FROM_DATE,
      this.LEAVE_TO_DATE,
      this.EMP_ADDRESS1,
      this.EMP_ADDRESS2,
      this.SUBSTITUTE_ID,
      this.SUBSTITUTE_NAME,
      this.SUBSTITUTE_ADDRESS1,
      this.SUBSTITUTE_ADDRESS2,
      this.SUBSTITUTE_AGE,
      this.SUBSTITUTE_QUALIFICATION,
      this.STATUS) {
    _setDefaultValues();
  }
  // fromMap v2.0
  LEAVE_DETAILS.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    REQUEST_ID = o['REQUEST_ID'].toString();
    if (o['GDS_ID'] != null) {
      GDS_ID = o['GDS_ID'].toString();
    }
    if (o['GENDER'] != null) {
      GENDER = o['GENDER'].toString();
    }
    if (o['TYPE_OF_LEAVE'] != null) {
      TYPE_OF_LEAVE = o['TYPE_OF_LEAVE'].toString();
    }
    if (o['LEAVE_REASON'] != null) {
      LEAVE_REASON = o['LEAVE_REASON'].toString();
    }
    if (o['LEAVE_FROM_DATE'] != null) {
      LEAVE_FROM_DATE = o['LEAVE_FROM_DATE'].toString();
    }
    if (o['LEAVE_TO_DATE'] != null) {
      LEAVE_TO_DATE = o['LEAVE_TO_DATE'].toString();
    }
    if (o['EMP_ADDRESS1'] != null) {
      EMP_ADDRESS1 = o['EMP_ADDRESS1'].toString();
    }
    if (o['EMP_ADDRESS2'] != null) {
      EMP_ADDRESS2 = o['EMP_ADDRESS2'].toString();
    }
    if (o['SUBSTITUTE_ID'] != null) {
      SUBSTITUTE_ID = o['SUBSTITUTE_ID'].toString();
    }
    if (o['SUBSTITUTE_NAME'] != null) {
      SUBSTITUTE_NAME = o['SUBSTITUTE_NAME'].toString();
    }
    if (o['SUBSTITUTE_ADDRESS1'] != null) {
      SUBSTITUTE_ADDRESS1 = o['SUBSTITUTE_ADDRESS1'].toString();
    }
    if (o['SUBSTITUTE_ADDRESS2'] != null) {
      SUBSTITUTE_ADDRESS2 = o['SUBSTITUTE_ADDRESS2'].toString();
    }
    if (o['SUBSTITUTE_AGE'] != null) {
      SUBSTITUTE_AGE = o['SUBSTITUTE_AGE'].toString();
    }
    if (o['SUBSTITUTE_QUALIFICATION'] != null) {
      SUBSTITUTE_QUALIFICATION = o['SUBSTITUTE_QUALIFICATION'].toString();
    }
    if (o['STATUS'] != null) {
      STATUS = o['STATUS'].toString();
    }

    isSaved = true;
  }
  // FIELDS (LEAVE_DETAILS)
  String? REQUEST_ID;
  String? GDS_ID;
  String? GENDER;
  String? TYPE_OF_LEAVE;
  String? LEAVE_REASON;
  String? LEAVE_FROM_DATE;
  String? LEAVE_TO_DATE;
  String? EMP_ADDRESS1;
  String? EMP_ADDRESS2;
  String? SUBSTITUTE_ID;
  String? SUBSTITUTE_NAME;
  String? SUBSTITUTE_ADDRESS1;
  String? SUBSTITUTE_ADDRESS2;
  String? SUBSTITUTE_AGE;
  String? SUBSTITUTE_QUALIFICATION;
  String? STATUS;
  bool? isSaved;
  // end FIELDS (LEAVE_DETAILS)

  static const bool _softDeleteActivated = false;
  LEAVE_DETAILSManager? __mnLEAVE_DETAILS;

  LEAVE_DETAILSManager get _mnLEAVE_DETAILS {
    return __mnLEAVE_DETAILS = __mnLEAVE_DETAILS ?? LEAVE_DETAILSManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['REQUEST_ID'] = REQUEST_ID;
    if (GDS_ID != null || !forView) {
      map['GDS_ID'] = GDS_ID;
    }
    if (GENDER != null || !forView) {
      map['GENDER'] = GENDER;
    }
    if (TYPE_OF_LEAVE != null || !forView) {
      map['TYPE_OF_LEAVE'] = TYPE_OF_LEAVE;
    }
    if (LEAVE_REASON != null || !forView) {
      map['LEAVE_REASON'] = LEAVE_REASON;
    }
    if (LEAVE_FROM_DATE != null || !forView) {
      map['LEAVE_FROM_DATE'] = LEAVE_FROM_DATE;
    }
    if (LEAVE_TO_DATE != null || !forView) {
      map['LEAVE_TO_DATE'] = LEAVE_TO_DATE;
    }
    if (EMP_ADDRESS1 != null || !forView) {
      map['EMP_ADDRESS1'] = EMP_ADDRESS1;
    }
    if (EMP_ADDRESS2 != null || !forView) {
      map['EMP_ADDRESS2'] = EMP_ADDRESS2;
    }
    if (SUBSTITUTE_ID != null || !forView) {
      map['SUBSTITUTE_ID'] = SUBSTITUTE_ID;
    }
    if (SUBSTITUTE_NAME != null || !forView) {
      map['SUBSTITUTE_NAME'] = SUBSTITUTE_NAME;
    }
    if (SUBSTITUTE_ADDRESS1 != null || !forView) {
      map['SUBSTITUTE_ADDRESS1'] = SUBSTITUTE_ADDRESS1;
    }
    if (SUBSTITUTE_ADDRESS2 != null || !forView) {
      map['SUBSTITUTE_ADDRESS2'] = SUBSTITUTE_ADDRESS2;
    }
    if (SUBSTITUTE_AGE != null || !forView) {
      map['SUBSTITUTE_AGE'] = SUBSTITUTE_AGE;
    }
    if (SUBSTITUTE_QUALIFICATION != null || !forView) {
      map['SUBSTITUTE_QUALIFICATION'] = SUBSTITUTE_QUALIFICATION;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['REQUEST_ID'] = REQUEST_ID;
    if (GDS_ID != null || !forView) {
      map['GDS_ID'] = GDS_ID;
    }
    if (GENDER != null || !forView) {
      map['GENDER'] = GENDER;
    }
    if (TYPE_OF_LEAVE != null || !forView) {
      map['TYPE_OF_LEAVE'] = TYPE_OF_LEAVE;
    }
    if (LEAVE_REASON != null || !forView) {
      map['LEAVE_REASON'] = LEAVE_REASON;
    }
    if (LEAVE_FROM_DATE != null || !forView) {
      map['LEAVE_FROM_DATE'] = LEAVE_FROM_DATE;
    }
    if (LEAVE_TO_DATE != null || !forView) {
      map['LEAVE_TO_DATE'] = LEAVE_TO_DATE;
    }
    if (EMP_ADDRESS1 != null || !forView) {
      map['EMP_ADDRESS1'] = EMP_ADDRESS1;
    }
    if (EMP_ADDRESS2 != null || !forView) {
      map['EMP_ADDRESS2'] = EMP_ADDRESS2;
    }
    if (SUBSTITUTE_ID != null || !forView) {
      map['SUBSTITUTE_ID'] = SUBSTITUTE_ID;
    }
    if (SUBSTITUTE_NAME != null || !forView) {
      map['SUBSTITUTE_NAME'] = SUBSTITUTE_NAME;
    }
    if (SUBSTITUTE_ADDRESS1 != null || !forView) {
      map['SUBSTITUTE_ADDRESS1'] = SUBSTITUTE_ADDRESS1;
    }
    if (SUBSTITUTE_ADDRESS2 != null || !forView) {
      map['SUBSTITUTE_ADDRESS2'] = SUBSTITUTE_ADDRESS2;
    }
    if (SUBSTITUTE_AGE != null || !forView) {
      map['SUBSTITUTE_AGE'] = SUBSTITUTE_AGE;
    }
    if (SUBSTITUTE_QUALIFICATION != null || !forView) {
      map['SUBSTITUTE_QUALIFICATION'] = SUBSTITUTE_QUALIFICATION;
    }
    if (STATUS != null || !forView) {
      map['STATUS'] = STATUS;
    }

    return map;
  }

  /// This method returns Json String [LEAVE_DETAILS]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [LEAVE_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [
      REQUEST_ID,
      GDS_ID,
      GENDER,
      TYPE_OF_LEAVE,
      LEAVE_REASON,
      LEAVE_FROM_DATE,
      LEAVE_TO_DATE,
      EMP_ADDRESS1,
      EMP_ADDRESS2,
      SUBSTITUTE_ID,
      SUBSTITUTE_NAME,
      SUBSTITUTE_ADDRESS1,
      SUBSTITUTE_ADDRESS2,
      SUBSTITUTE_AGE,
      SUBSTITUTE_QUALIFICATION,
      STATUS
    ];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [
      REQUEST_ID,
      GDS_ID,
      GENDER,
      TYPE_OF_LEAVE,
      LEAVE_REASON,
      LEAVE_FROM_DATE,
      LEAVE_TO_DATE,
      EMP_ADDRESS1,
      EMP_ADDRESS2,
      SUBSTITUTE_ID,
      SUBSTITUTE_NAME,
      SUBSTITUTE_ADDRESS1,
      SUBSTITUTE_ADDRESS2,
      SUBSTITUTE_AGE,
      SUBSTITUTE_QUALIFICATION,
      STATUS
    ];
  }

  static Future<List<LEAVE_DETAILS>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LEAVE_DETAILS.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<LEAVE_DETAILS>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <LEAVE_DETAILS>[];
    try {
      objList = list
          .map((leave_details) =>
              LEAVE_DETAILS.fromMap(leave_details as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR LEAVE_DETAILS.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<LEAVE_DETAILS>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<LEAVE_DETAILS> objList = <LEAVE_DETAILS>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = LEAVE_DETAILS.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns LEAVE_DETAILS by ID if exist, otherwise returns null
  /// Primary Keys: String? REQUEST_ID
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [LEAVE_DETAILS] if exist, otherwise returns null
  Future<LEAVE_DETAILS?> getById(String? REQUEST_ID,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (REQUEST_ID == null) {
      return null;
    }
    LEAVE_DETAILS? obj;
    final data = await _mnLEAVE_DETAILS.getById([REQUEST_ID]);
    if (data.length != 0) {
      obj = LEAVE_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (LEAVE_DETAILS) object. If the Primary Key (REQUEST_ID) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same REQUEST_ID
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnLEAVE_DETAILS.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO LEAVE_DETAILS (REQUEST_ID, GDS_ID, GENDER, TYPE_OF_LEAVE, LEAVE_REASON, LEAVE_FROM_DATE, LEAVE_TO_DATE, EMP_ADDRESS1, EMP_ADDRESS2, SUBSTITUTE_ID, SUBSTITUTE_NAME, SUBSTITUTE_ADDRESS1, SUBSTITUTE_ADDRESS2, SUBSTITUTE_AGE, SUBSTITUTE_QUALIFICATION, STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<LEAVE_DETAILS> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<LEAVE_DETAILS> leave_detailses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in leave_detailses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLEAVE_DETAILS.rawInsert(
          'INSERT OR REPLACE INTO LEAVE_DETAILS (REQUEST_ID, GDS_ID, GENDER, TYPE_OF_LEAVE, LEAVE_REASON, LEAVE_FROM_DATE, LEAVE_TO_DATE, EMP_ADDRESS1, EMP_ADDRESS2, SUBSTITUTE_ID, SUBSTITUTE_NAME, SUBSTITUTE_ADDRESS1, SUBSTITUTE_ADDRESS2, SUBSTITUTE_AGE, SUBSTITUTE_QUALIFICATION, STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            REQUEST_ID,
            GDS_ID,
            GENDER,
            TYPE_OF_LEAVE,
            LEAVE_REASON,
            LEAVE_FROM_DATE,
            LEAVE_TO_DATE,
            EMP_ADDRESS1,
            EMP_ADDRESS2,
            SUBSTITUTE_ID,
            SUBSTITUTE_NAME,
            SUBSTITUTE_ADDRESS1,
            SUBSTITUTE_ADDRESS2,
            SUBSTITUTE_AGE,
            SUBSTITUTE_QUALIFICATION,
            STATUS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'LEAVE_DETAILS REQUEST_ID=$REQUEST_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'LEAVE_DETAILS REQUEST_ID=$REQUEST_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LEAVE_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnLEAVE_DETAILS.rawInsert(
          'INSERT OR IGNORE INTO LEAVE_DETAILS (REQUEST_ID, GDS_ID, GENDER, TYPE_OF_LEAVE, LEAVE_REASON, LEAVE_FROM_DATE, LEAVE_TO_DATE, EMP_ADDRESS1, EMP_ADDRESS2, SUBSTITUTE_ID, SUBSTITUTE_NAME, SUBSTITUTE_ADDRESS1, SUBSTITUTE_ADDRESS2, SUBSTITUTE_AGE, SUBSTITUTE_QUALIFICATION, STATUS)  VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [
            REQUEST_ID,
            GDS_ID,
            GENDER,
            TYPE_OF_LEAVE,
            LEAVE_REASON,
            LEAVE_FROM_DATE,
            LEAVE_TO_DATE,
            EMP_ADDRESS1,
            EMP_ADDRESS2,
            SUBSTITUTE_ID,
            SUBSTITUTE_NAME,
            SUBSTITUTE_ADDRESS1,
            SUBSTITUTE_ADDRESS2,
            SUBSTITUTE_AGE,
            SUBSTITUTE_QUALIFICATION,
            STATUS
          ],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'LEAVE_DETAILS REQUEST_ID=$REQUEST_ID updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'LEAVE_DETAILS REQUEST_ID=$REQUEST_ID did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'LEAVE_DETAILS Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes LEAVE_DETAILS

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete LEAVE_DETAILS invoked (REQUEST_ID=$REQUEST_ID)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnLEAVE_DETAILS.delete(QueryParams(
          whereString: 'REQUEST_ID=?', whereArguments: [REQUEST_ID]));
    } else {
      return _mnLEAVE_DETAILS.updateBatch(
          QueryParams(
              whereString: 'REQUEST_ID=?', whereArguments: [REQUEST_ID]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [LEAVE_DETAILS] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  LEAVE_DETAILSFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LEAVE_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  LEAVE_DETAILSFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return LEAVE_DETAILSFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      REQUEST_ID = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion leave_details

// region LEAVE_DETAILSField
class LEAVE_DETAILSField extends FilterBase {
  LEAVE_DETAILSField(LEAVE_DETAILSFilterBuilder leave_detailsFB)
      : super(leave_detailsFB);

  @override
  LEAVE_DETAILSFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder isNull() {
    return super.isNull() as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as LEAVE_DETAILSFilterBuilder;
  }

  @override
  LEAVE_DETAILSField get not {
    return super.not as LEAVE_DETAILSField;
  }
}
// endregion LEAVE_DETAILSField

// region LEAVE_DETAILSFilterBuilder
class LEAVE_DETAILSFilterBuilder extends ConjunctionBase {
  LEAVE_DETAILSFilterBuilder(LEAVE_DETAILS obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnLEAVE_DETAILS = obj._mnLEAVE_DETAILS;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  LEAVE_DETAILSManager? _mnLEAVE_DETAILS;

  /// put the sql keyword 'AND'
  @override
  LEAVE_DETAILSFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  LEAVE_DETAILSFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  LEAVE_DETAILSFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  LEAVE_DETAILSFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  LEAVE_DETAILSFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  LEAVE_DETAILSFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  LEAVE_DETAILSFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LEAVE_DETAILSFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LEAVE_DETAILSFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  LEAVE_DETAILSFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  LEAVE_DETAILSFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  LEAVE_DETAILSField _setField(
      LEAVE_DETAILSField? field, String colName, DbType dbtype) {
    return LEAVE_DETAILSField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  LEAVE_DETAILSField? _REQUEST_ID;
  LEAVE_DETAILSField get REQUEST_ID {
    return _REQUEST_ID = _setField(_REQUEST_ID, 'REQUEST_ID', DbType.integer);
  }

  LEAVE_DETAILSField? _GDS_ID;
  LEAVE_DETAILSField get GDS_ID {
    return _GDS_ID = _setField(_GDS_ID, 'GDS_ID', DbType.text);
  }

  LEAVE_DETAILSField? _GENDER;
  LEAVE_DETAILSField get GENDER {
    return _GENDER = _setField(_GENDER, 'GENDER', DbType.text);
  }

  LEAVE_DETAILSField? _TYPE_OF_LEAVE;
  LEAVE_DETAILSField get TYPE_OF_LEAVE {
    return _TYPE_OF_LEAVE =
        _setField(_TYPE_OF_LEAVE, 'TYPE_OF_LEAVE', DbType.text);
  }

  LEAVE_DETAILSField? _LEAVE_REASON;
  LEAVE_DETAILSField get LEAVE_REASON {
    return _LEAVE_REASON =
        _setField(_LEAVE_REASON, 'LEAVE_REASON', DbType.text);
  }

  LEAVE_DETAILSField? _LEAVE_FROM_DATE;
  LEAVE_DETAILSField get LEAVE_FROM_DATE {
    return _LEAVE_FROM_DATE =
        _setField(_LEAVE_FROM_DATE, 'LEAVE_FROM_DATE', DbType.text);
  }

  LEAVE_DETAILSField? _LEAVE_TO_DATE;
  LEAVE_DETAILSField get LEAVE_TO_DATE {
    return _LEAVE_TO_DATE =
        _setField(_LEAVE_TO_DATE, 'LEAVE_TO_DATE', DbType.text);
  }

  LEAVE_DETAILSField? _EMP_ADDRESS1;
  LEAVE_DETAILSField get EMP_ADDRESS1 {
    return _EMP_ADDRESS1 =
        _setField(_EMP_ADDRESS1, 'EMP_ADDRESS1', DbType.text);
  }

  LEAVE_DETAILSField? _EMP_ADDRESS2;
  LEAVE_DETAILSField get EMP_ADDRESS2 {
    return _EMP_ADDRESS2 =
        _setField(_EMP_ADDRESS2, 'EMP_ADDRESS2', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_ID;
  LEAVE_DETAILSField get SUBSTITUTE_ID {
    return _SUBSTITUTE_ID =
        _setField(_SUBSTITUTE_ID, 'SUBSTITUTE_ID', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_NAME;
  LEAVE_DETAILSField get SUBSTITUTE_NAME {
    return _SUBSTITUTE_NAME =
        _setField(_SUBSTITUTE_NAME, 'SUBSTITUTE_NAME', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_ADDRESS1;
  LEAVE_DETAILSField get SUBSTITUTE_ADDRESS1 {
    return _SUBSTITUTE_ADDRESS1 =
        _setField(_SUBSTITUTE_ADDRESS1, 'SUBSTITUTE_ADDRESS1', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_ADDRESS2;
  LEAVE_DETAILSField get SUBSTITUTE_ADDRESS2 {
    return _SUBSTITUTE_ADDRESS2 =
        _setField(_SUBSTITUTE_ADDRESS2, 'SUBSTITUTE_ADDRESS2', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_AGE;
  LEAVE_DETAILSField get SUBSTITUTE_AGE {
    return _SUBSTITUTE_AGE =
        _setField(_SUBSTITUTE_AGE, 'SUBSTITUTE_AGE', DbType.text);
  }

  LEAVE_DETAILSField? _SUBSTITUTE_QUALIFICATION;
  LEAVE_DETAILSField get SUBSTITUTE_QUALIFICATION {
    return _SUBSTITUTE_QUALIFICATION = _setField(
        _SUBSTITUTE_QUALIFICATION, 'SUBSTITUTE_QUALIFICATION', DbType.text);
  }

  LEAVE_DETAILSField? _STATUS;
  LEAVE_DETAILSField get STATUS {
    return _STATUS = _setField(_STATUS, 'STATUS', DbType.text);
  }

  /// Deletes List<LEAVE_DETAILS> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnLEAVE_DETAILS!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnLEAVE_DETAILS!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'REQUEST_ID IN (SELECT REQUEST_ID from LEAVE_DETAILS ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnLEAVE_DETAILS!.updateBatch(qparams, values);
  }

  /// This method always returns [LEAVE_DETAILS] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LEAVE_DETAILS?
  @override
  Future<LEAVE_DETAILS?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnLEAVE_DETAILS!.toList(qparams);
    final data = await objFuture;
    LEAVE_DETAILS? obj;
    if (data.isNotEmpty) {
      obj = LEAVE_DETAILS.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [LEAVE_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> LEAVE_DETAILS?
  @override
  Future<LEAVE_DETAILS> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        LEAVE_DETAILS();
  }

  /// This method returns int. [LEAVE_DETAILS]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? leave_detailsCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final leave_detailsesFuture = await _mnLEAVE_DETAILS!.toList(qparams);
    final int count = leave_detailsesFuture[0]['CNT'] as int;
    if (leave_detailsCount != null) {
      leave_detailsCount(count);
    }
    return count;
  }

  /// This method returns List<LEAVE_DETAILS> [LEAVE_DETAILS]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<LEAVE_DETAILS>
  @override
  Future<List<LEAVE_DETAILS>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<LEAVE_DETAILS> leave_detailsesData =
        await LEAVE_DETAILS.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return leave_detailsesData;
  }

  /// This method returns Json String [LEAVE_DETAILS]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [LEAVE_DETAILS]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [LEAVE_DETAILS]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnLEAVE_DETAILS!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [LEAVE_DETAILS]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `REQUEST_ID` FROM LEAVE_DETAILS WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> REQUEST_IDData = <String>[];
    qparams.selectColumns = ['REQUEST_ID'];
    final REQUEST_IDFuture = await _mnLEAVE_DETAILS!.toList(qparams);

    final int count = REQUEST_IDFuture.length;
    for (int i = 0; i < count; i++) {
      REQUEST_IDData.add(REQUEST_IDFuture[i]['REQUEST_ID'] as String);
    }
    return REQUEST_IDData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [LEAVE_DETAILS]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnLEAVE_DETAILS!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await LEAVE_DETAILS.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnLEAVE_DETAILS!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion LEAVE_DETAILSFilterBuilder

// region LEAVE_DETAILSFields
class LEAVE_DETAILSFields {
  static TableField? _fREQUEST_ID;
  static TableField get REQUEST_ID {
    return _fREQUEST_ID = _fREQUEST_ID ??
        SqlSyntax.setField(_fREQUEST_ID, 'request_id', DbType.integer);
  }

  static TableField? _fGDS_ID;
  static TableField get GDS_ID {
    return _fGDS_ID =
        _fGDS_ID ?? SqlSyntax.setField(_fGDS_ID, 'GDS_ID', DbType.text);
  }

  static TableField? _fGENDER;
  static TableField get GENDER {
    return _fGENDER =
        _fGENDER ?? SqlSyntax.setField(_fGENDER, 'GENDER', DbType.text);
  }

  static TableField? _fTYPE_OF_LEAVE;
  static TableField get TYPE_OF_LEAVE {
    return _fTYPE_OF_LEAVE = _fTYPE_OF_LEAVE ??
        SqlSyntax.setField(_fTYPE_OF_LEAVE, 'TYPE_OF_LEAVE', DbType.text);
  }

  static TableField? _fLEAVE_REASON;
  static TableField get LEAVE_REASON {
    return _fLEAVE_REASON = _fLEAVE_REASON ??
        SqlSyntax.setField(_fLEAVE_REASON, 'LEAVE_REASON', DbType.text);
  }

  static TableField? _fLEAVE_FROM_DATE;
  static TableField get LEAVE_FROM_DATE {
    return _fLEAVE_FROM_DATE = _fLEAVE_FROM_DATE ??
        SqlSyntax.setField(_fLEAVE_FROM_DATE, 'LEAVE_FROM_DATE', DbType.text);
  }

  static TableField? _fLEAVE_TO_DATE;
  static TableField get LEAVE_TO_DATE {
    return _fLEAVE_TO_DATE = _fLEAVE_TO_DATE ??
        SqlSyntax.setField(_fLEAVE_TO_DATE, 'LEAVE_TO_DATE', DbType.text);
  }

  static TableField? _fEMP_ADDRESS1;
  static TableField get EMP_ADDRESS1 {
    return _fEMP_ADDRESS1 = _fEMP_ADDRESS1 ??
        SqlSyntax.setField(_fEMP_ADDRESS1, 'EMP_ADDRESS1', DbType.text);
  }

  static TableField? _fEMP_ADDRESS2;
  static TableField get EMP_ADDRESS2 {
    return _fEMP_ADDRESS2 = _fEMP_ADDRESS2 ??
        SqlSyntax.setField(_fEMP_ADDRESS2, 'EMP_ADDRESS2', DbType.text);
  }

  static TableField? _fSUBSTITUTE_ID;
  static TableField get SUBSTITUTE_ID {
    return _fSUBSTITUTE_ID = _fSUBSTITUTE_ID ??
        SqlSyntax.setField(_fSUBSTITUTE_ID, 'SUBSTITUTE_ID', DbType.text);
  }

  static TableField? _fSUBSTITUTE_NAME;
  static TableField get SUBSTITUTE_NAME {
    return _fSUBSTITUTE_NAME = _fSUBSTITUTE_NAME ??
        SqlSyntax.setField(_fSUBSTITUTE_NAME, 'SUBSTITUTE_NAME', DbType.text);
  }

  static TableField? _fSUBSTITUTE_ADDRESS1;
  static TableField get SUBSTITUTE_ADDRESS1 {
    return _fSUBSTITUTE_ADDRESS1 = _fSUBSTITUTE_ADDRESS1 ??
        SqlSyntax.setField(
            _fSUBSTITUTE_ADDRESS1, 'SUBSTITUTE_ADDRESS1', DbType.text);
  }

  static TableField? _fSUBSTITUTE_ADDRESS2;
  static TableField get SUBSTITUTE_ADDRESS2 {
    return _fSUBSTITUTE_ADDRESS2 = _fSUBSTITUTE_ADDRESS2 ??
        SqlSyntax.setField(
            _fSUBSTITUTE_ADDRESS2, 'SUBSTITUTE_ADDRESS2', DbType.text);
  }

  static TableField? _fSUBSTITUTE_AGE;
  static TableField get SUBSTITUTE_AGE {
    return _fSUBSTITUTE_AGE = _fSUBSTITUTE_AGE ??
        SqlSyntax.setField(_fSUBSTITUTE_AGE, 'SUBSTITUTE_AGE', DbType.text);
  }

  static TableField? _fSUBSTITUTE_QUALIFICATION;
  static TableField get SUBSTITUTE_QUALIFICATION {
    return _fSUBSTITUTE_QUALIFICATION = _fSUBSTITUTE_QUALIFICATION ??
        SqlSyntax.setField(_fSUBSTITUTE_QUALIFICATION,
            'SUBSTITUTE_QUALIFICATION', DbType.text);
  }

  static TableField? _fSTATUS;
  static TableField get STATUS {
    return _fSTATUS =
        _fSTATUS ?? SqlSyntax.setField(_fSTATUS, 'STATUS', DbType.text);
  }
}
// endregion LEAVE_DETAILSFields

//region LEAVE_DETAILSManager
class LEAVE_DETAILSManager extends SqfEntityProvider {
  LEAVE_DETAILSManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'LEAVE_DETAILS';
  static const List<String> _primaryKeyList = ['REQUEST_ID'];
  static const String _whereStr = 'REQUEST_ID=?';
}

//endregion LEAVE_DETAILSManager
// region CBS_ERROR_CODES
class CBS_ERROR_CODES extends TableBase {
  CBS_ERROR_CODES({this.Error_code, this.Error_message}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CBS_ERROR_CODES.withFields(this.Error_code, this.Error_message) {
    _setDefaultValues();
  }
  CBS_ERROR_CODES.withId(this.Error_code, this.Error_message) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CBS_ERROR_CODES.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    Error_code = o['Error_code'].toString();
    if (o['Error_message'] != null) {
      Error_message = o['Error_message'].toString();
    }

    isSaved = true;
  }
  // FIELDS (CBS_ERROR_CODES)
  String? Error_code;
  String? Error_message;
  bool? isSaved;
  // end FIELDS (CBS_ERROR_CODES)

  static const bool _softDeleteActivated = false;
  CBS_ERROR_CODESManager? __mnCBS_ERROR_CODES;

  CBS_ERROR_CODESManager get _mnCBS_ERROR_CODES {
    return __mnCBS_ERROR_CODES =
        __mnCBS_ERROR_CODES ?? CBS_ERROR_CODESManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['Error_code'] = Error_code;
    if (Error_message != null || !forView) {
      map['Error_message'] = Error_message;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['Error_code'] = Error_code;
    if (Error_message != null || !forView) {
      map['Error_message'] = Error_message;
    }

    return map;
  }

  /// This method returns Json String [CBS_ERROR_CODES]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CBS_ERROR_CODES]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [Error_code, Error_message];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [Error_code, Error_message];
  }

  static Future<List<CBS_ERROR_CODES>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CBS_ERROR_CODES.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CBS_ERROR_CODES>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CBS_ERROR_CODES>[];
    try {
      objList = list
          .map((cbs_error_codes) =>
              CBS_ERROR_CODES.fromMap(cbs_error_codes as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CBS_ERROR_CODES.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CBS_ERROR_CODES>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CBS_ERROR_CODES> objList = <CBS_ERROR_CODES>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CBS_ERROR_CODES.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CBS_ERROR_CODES by ID if exist, otherwise returns null
  /// Primary Keys: String? Error_code
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CBS_ERROR_CODES] if exist, otherwise returns null
  Future<CBS_ERROR_CODES?> getById(String? Error_code,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (Error_code == null) {
      return null;
    }
    CBS_ERROR_CODES? obj;
    final data = await _mnCBS_ERROR_CODES.getById([Error_code]);
    if (data.length != 0) {
      obj = CBS_ERROR_CODES.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CBS_ERROR_CODES) object. If the Primary Key (Error_code) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same Error_code
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCBS_ERROR_CODES.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO CBS_ERROR_CODES (Error_code, Error_message)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<CBS_ERROR_CODES> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(List<CBS_ERROR_CODES> cbs_error_codeses,
      {bool? exclusive, bool? noResult, bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in cbs_error_codeses) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCBS_ERROR_CODES.rawInsert(
          'INSERT OR REPLACE INTO CBS_ERROR_CODES (Error_code, Error_message)  VALUES (?,?)',
          [Error_code, Error_message],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CBS_ERROR_CODES Error_code=$Error_code updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
                'CBS_ERROR_CODES Error_code=$Error_code did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CBS_ERROR_CODES Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCBS_ERROR_CODES.rawInsert(
          'INSERT OR IGNORE INTO CBS_ERROR_CODES (Error_code, Error_message)  VALUES (?,?)',
          [Error_code, Error_message],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'CBS_ERROR_CODES Error_code=$Error_code updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage:
            'CBS_ERROR_CODES Error_code=$Error_code did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage: 'CBS_ERROR_CODES Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes CBS_ERROR_CODES

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint(
        'SQFENTITIY: delete CBS_ERROR_CODES invoked (Error_code=$Error_code)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCBS_ERROR_CODES.delete(QueryParams(
          whereString: 'Error_code=?', whereArguments: [Error_code]));
    } else {
      return _mnCBS_ERROR_CODES.updateBatch(
          QueryParams(
              whereString: 'Error_code=?', whereArguments: [Error_code]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CBS_ERROR_CODES] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CBS_ERROR_CODESFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CBS_ERROR_CODESFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CBS_ERROR_CODESFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CBS_ERROR_CODESFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      Error_code = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cbs_error_codes

// region CBS_ERROR_CODESField
class CBS_ERROR_CODESField extends FilterBase {
  CBS_ERROR_CODESField(CBS_ERROR_CODESFilterBuilder cbs_error_codesFB)
      : super(cbs_error_codesFB);

  @override
  CBS_ERROR_CODESFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder isNull() {
    return super.isNull() as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CBS_ERROR_CODESFilterBuilder;
  }

  @override
  CBS_ERROR_CODESField get not {
    return super.not as CBS_ERROR_CODESField;
  }
}
// endregion CBS_ERROR_CODESField

// region CBS_ERROR_CODESFilterBuilder
class CBS_ERROR_CODESFilterBuilder extends ConjunctionBase {
  CBS_ERROR_CODESFilterBuilder(CBS_ERROR_CODES obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCBS_ERROR_CODES = obj._mnCBS_ERROR_CODES;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CBS_ERROR_CODESManager? _mnCBS_ERROR_CODES;

  /// put the sql keyword 'AND'
  @override
  CBS_ERROR_CODESFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CBS_ERROR_CODESFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CBS_ERROR_CODESFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CBS_ERROR_CODESFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CBS_ERROR_CODESFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CBS_ERROR_CODESFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CBS_ERROR_CODESFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CBS_ERROR_CODESFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CBS_ERROR_CODESFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CBS_ERROR_CODESFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CBS_ERROR_CODESFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CBS_ERROR_CODESField _setField(
      CBS_ERROR_CODESField? field, String colName, DbType dbtype) {
    return CBS_ERROR_CODESField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CBS_ERROR_CODESField? _Error_code;
  CBS_ERROR_CODESField get Error_code {
    return _Error_code = _setField(_Error_code, 'Error_code', DbType.integer);
  }

  CBS_ERROR_CODESField? _Error_message;
  CBS_ERROR_CODESField get Error_message {
    return _Error_message =
        _setField(_Error_message, 'Error_message', DbType.text);
  }

  /// Deletes List<CBS_ERROR_CODES> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCBS_ERROR_CODES!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCBS_ERROR_CODES!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'Error_code IN (SELECT Error_code from CBS_ERROR_CODES ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCBS_ERROR_CODES!.updateBatch(qparams, values);
  }

  /// This method always returns [CBS_ERROR_CODES] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CBS_ERROR_CODES?
  @override
  Future<CBS_ERROR_CODES?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCBS_ERROR_CODES!.toList(qparams);
    final data = await objFuture;
    CBS_ERROR_CODES? obj;
    if (data.isNotEmpty) {
      obj = CBS_ERROR_CODES.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CBS_ERROR_CODES]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CBS_ERROR_CODES?
  @override
  Future<CBS_ERROR_CODES> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CBS_ERROR_CODES();
  }

  /// This method returns int. [CBS_ERROR_CODES]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cbs_error_codesCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cbs_error_codesesFuture = await _mnCBS_ERROR_CODES!.toList(qparams);
    final int count = cbs_error_codesesFuture[0]['CNT'] as int;
    if (cbs_error_codesCount != null) {
      cbs_error_codesCount(count);
    }
    return count;
  }

  /// This method returns List<CBS_ERROR_CODES> [CBS_ERROR_CODES]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CBS_ERROR_CODES>
  @override
  Future<List<CBS_ERROR_CODES>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CBS_ERROR_CODES> cbs_error_codesesData =
        await CBS_ERROR_CODES.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cbs_error_codesesData;
  }

  /// This method returns Json String [CBS_ERROR_CODES]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CBS_ERROR_CODES]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CBS_ERROR_CODES]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCBS_ERROR_CODES!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CBS_ERROR_CODES]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `Error_code` FROM CBS_ERROR_CODES WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> Error_codeData = <String>[];
    qparams.selectColumns = ['Error_code'];
    final Error_codeFuture = await _mnCBS_ERROR_CODES!.toList(qparams);

    final int count = Error_codeFuture.length;
    for (int i = 0; i < count; i++) {
      Error_codeData.add(Error_codeFuture[i]['Error_code'] as String);
    }
    return Error_codeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CBS_ERROR_CODES]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCBS_ERROR_CODES!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CBS_ERROR_CODES.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCBS_ERROR_CODES!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CBS_ERROR_CODESFilterBuilder

// region CBS_ERROR_CODESFields
class CBS_ERROR_CODESFields {
  static TableField? _fError_code;
  static TableField get Error_code {
    return _fError_code = _fError_code ??
        SqlSyntax.setField(_fError_code, 'error_code', DbType.integer);
  }

  static TableField? _fError_message;
  static TableField get Error_message {
    return _fError_message = _fError_message ??
        SqlSyntax.setField(_fError_message, 'Error_message', DbType.text);
  }
}
// endregion CBS_ERROR_CODESFields

//region CBS_ERROR_CODESManager
class CBS_ERROR_CODESManager extends SqfEntityProvider {
  CBS_ERROR_CODESManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CBS_ERROR_CODES';
  static const List<String> _primaryKeyList = ['Error_code'];
  static const String _whereStr = 'Error_code=?';
}

//endregion CBS_ERROR_CODESManager
// region CBS_LIMITS_CONFIG
class CBS_LIMITS_CONFIG extends TableBase {
  CBS_LIMITS_CONFIG({this.type, this.tranlimits}) {
    _setDefaultValues();
    softDeleteActivated = false;
  }
  CBS_LIMITS_CONFIG.withFields(this.type, this.tranlimits) {
    _setDefaultValues();
  }
  CBS_LIMITS_CONFIG.withId(this.type, this.tranlimits) {
    _setDefaultValues();
  }
  // fromMap v2.0
  CBS_LIMITS_CONFIG.fromMap(Map<String, dynamic> o,
      {bool setDefaultValues = true}) {
    if (setDefaultValues) {
      _setDefaultValues();
    }
    type = o['type'].toString();
    if (o['tranlimits'] != null) {
      tranlimits = o['tranlimits'].toString();
    }

    isSaved = true;
  }
  // FIELDS (CBS_LIMITS_CONFIG)
  String? type;
  String? tranlimits;
  bool? isSaved;
  // end FIELDS (CBS_LIMITS_CONFIG)

  static const bool _softDeleteActivated = false;
  CBS_LIMITS_CONFIGManager? __mnCBS_LIMITS_CONFIG;

  CBS_LIMITS_CONFIGManager get _mnCBS_LIMITS_CONFIG {
    return __mnCBS_LIMITS_CONFIG =
        __mnCBS_LIMITS_CONFIG ?? CBS_LIMITS_CONFIGManager();
  }

  // METHODS
  @override
  Map<String, dynamic> toMap(
      {bool forQuery = false, bool forJson = false, bool forView = false}) {
    final map = <String, dynamic>{};
    map['type'] = type;
    if (tranlimits != null || !forView) {
      map['tranlimits'] = tranlimits;
    }

    return map;
  }

  @override
  Future<Map<String, dynamic>> toMapWithChildren(
      [bool forQuery = false,
      bool forJson = false,
      bool forView = false]) async {
    final map = <String, dynamic>{};
    map['type'] = type;
    if (tranlimits != null || !forView) {
      map['tranlimits'] = tranlimits;
    }

    return map;
  }

  /// This method returns Json String [CBS_LIMITS_CONFIG]
  @override
  String toJson() {
    return json.encode(toMap(forJson: true));
  }

  /// This method returns Json String [CBS_LIMITS_CONFIG]
  @override
  Future<String> toJsonWithChilds() async {
    return json.encode(await toMapWithChildren(false, true));
  }

  @override
  List<dynamic> toArgs() {
    return [type, tranlimits];
  }

  @override
  List<dynamic> toArgsWithIds() {
    return [type, tranlimits];
  }

  static Future<List<CBS_LIMITS_CONFIG>?> fromWebUrl(Uri uri,
      {Map<String, String>? headers}) async {
    try {
      final response = await http.get(uri, headers: headers);
      return await fromJson(response.body);
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CBS_LIMITS_CONFIG.fromWebUrl: ErrorMessage: ${e.toString()}');
      return null;
    }
  }

  Future<http.Response> postUrl(Uri uri, {Map<String, String>? headers}) {
    return http.post(uri, headers: headers, body: toJson());
  }

  static Future<List<CBS_LIMITS_CONFIG>> fromJson(String jsonBody) async {
    final Iterable list = await json.decode(jsonBody) as Iterable;
    var objList = <CBS_LIMITS_CONFIG>[];
    try {
      objList = list
          .map((cbs_limits_config) => CBS_LIMITS_CONFIG
              .fromMap(cbs_limits_config as Map<String, dynamic>))
          .toList();
    } catch (e) {
      debugPrint(
          'SQFENTITY ERROR CBS_LIMITS_CONFIG.fromJson: ErrorMessage: ${e.toString()}');
    }
    return objList;
  }

  static Future<List<CBS_LIMITS_CONFIG>> fromMapList(List<dynamic> data,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields,
      bool setDefaultValues = true}) async {
    final List<CBS_LIMITS_CONFIG> objList = <CBS_LIMITS_CONFIG>[];
    loadedFields = loadedFields ?? [];
    for (final map in data) {
      final obj = CBS_LIMITS_CONFIG.fromMap(map as Map<String, dynamic>,
          setDefaultValues: setDefaultValues);

      objList.add(obj);
    }
    return objList;
  }

  /// returns CBS_LIMITS_CONFIG by ID if exist, otherwise returns null
  /// Primary Keys: String? type
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: getById(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: getById(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>returns [CBS_LIMITS_CONFIG] if exist, otherwise returns null
  Future<CBS_LIMITS_CONFIG?> getById(String? type,
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    if (type == null) {
      return null;
    }
    CBS_LIMITS_CONFIG? obj;
    final data = await _mnCBS_LIMITS_CONFIG.getById([type]);
    if (data.length != 0) {
      obj = CBS_LIMITS_CONFIG.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// Saves the (CBS_LIMITS_CONFIG) object. If the Primary Key (type) field is null, returns Error.
  /// INSERTS (If not exist) OR REPLACES (If exist) data while Primary Key is not null.
  /// Call the saveAs() method if you do not want to save it when there is another row with the same type
  /// <returns>Returns BoolResult
  @override
  Future<BoolResult> save({bool ignoreBatch = true}) async {
    final result = BoolResult(success: false);
    try {
      await _mnCBS_LIMITS_CONFIG.rawInsert(
          'INSERT ${isSaved! ? 'OR REPLACE' : ''} INTO CBS_LIMITS_CONFIG (type, tranlimits)  VALUES (?,?)',
          toArgsWithIds(),
          ignoreBatch);
      result.success = true;
      isSaved = true;
    } catch (e) {
      result.errorMessage = e.toString();
    }

    saveResult = result;
    return result;
  }

  /// saveAll method saves the sent List<CBS_LIMITS_CONFIG> as a bulk in one transaction
  /// Returns a <List<BoolResult>>
  static Future<List<dynamic>> saveAll(
      List<CBS_LIMITS_CONFIG> cbs_limits_configs,
      {bool? exclusive,
      bool? noResult,
      bool? continueOnError}) async {
    List<dynamic>? result = [];
    // If there is no open transaction, start one
    final isStartedBatch = await CBS().batchStart();
    for (final obj in cbs_limits_configs) {
      await obj.save();
    }
    if (!isStartedBatch) {
      result = await CBS().batchCommit(
          exclusive: exclusive,
          noResult: noResult,
          continueOnError: continueOnError);
    }
    return result!;
  }

  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCBS_LIMITS_CONFIG.rawInsert(
          'INSERT OR REPLACE INTO CBS_LIMITS_CONFIG (type, tranlimits)  VALUES (?,?)',
          [type, tranlimits],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
                'CBS_LIMITS_CONFIG type=$type updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CBS_LIMITS_CONFIG type=$type did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
              'CBS_LIMITS_CONFIG Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Updates if the record exists, otherwise adds a new row
  /// <returns>Returns 1
  @override
  Future<int?> upsert1({bool ignoreBatch = true}) async {
    try {
      final result = await _mnCBS_LIMITS_CONFIG.rawInsert(
          'INSERT OR IGNORE INTO CBS_LIMITS_CONFIG (type, tranlimits)  VALUES (?,?)',
          [type, tranlimits],
          ignoreBatch);
      if (result! > 0) {
        saveResult = BoolResult(
            success: true,
            successMessage:
            'CBS_LIMITS_CONFIG type=$type updated successfully');
      } else {
        saveResult = BoolResult(
            success: false,
            errorMessage: 'CBS_LIMITS_CONFIG type=$type did not update');
      }
      return 1;
    } catch (e) {
      saveResult = BoolResult(
          success: false,
          errorMessage:
          'CBS_LIMITS_CONFIG Save failed. Error: ${e.toString()}');
      return null;
    }
  }
  /// Deletes CBS_LIMITS_CONFIG

  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    debugPrint('SQFENTITIY: delete CBS_LIMITS_CONFIG invoked (type=$type)');
    if (!_softDeleteActivated || hardDelete) {
      return _mnCBS_LIMITS_CONFIG
          .delete(QueryParams(whereString: 'type=?', whereArguments: [type]));
    } else {
      return _mnCBS_LIMITS_CONFIG.updateBatch(
          QueryParams(whereString: 'type=?', whereArguments: [type]),
          {'isDeleted': 1});
    }
  }

  @override
  Future<BoolResult> recover([bool recoverChilds = true]) {
    // not implemented because:
    final msg =
        'set useSoftDeleting:true in the table definition of [CBS_LIMITS_CONFIG] to use this feature';
    throw UnimplementedError(msg);
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder select(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CBS_LIMITS_CONFIGFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder distinct(
      {List<String>? columnsToSelect, bool? getIsDeleted}) {
    return CBS_LIMITS_CONFIGFilterBuilder(this, getIsDeleted)
      ..qparams.selectColumns = columnsToSelect
      ..qparams.distinct = true;
  }

  void _setDefaultValues() {
    isSaved = false;
  }

  @override
  void rollbackPk() {
    if (isInsert == true) {
      type = null;
    }
  }

  // END METHODS
  // BEGIN CUSTOM CODE
  /*
      you can define customCode property of your SqfEntityTable constant. For example:
      const tablePerson = SqfEntityTable(
      tableName: 'person',
      primaryKeyName: 'id',
      primaryKeyType: PrimaryKeyType.integer_auto_incremental,
      fields: [
        SqfEntityField('firstName', DbType.text),
        SqfEntityField('lastName', DbType.text),
      ],
      customCode: '''
       String fullName()
       { 
         return '$firstName $lastName';
       }
      ''');
     */
  // END CUSTOM CODE
}
// endregion cbs_limits_config

// region CBS_LIMITS_CONFIGField
class CBS_LIMITS_CONFIGField extends FilterBase {
  CBS_LIMITS_CONFIGField(CBS_LIMITS_CONFIGFilterBuilder cbs_limits_configFB)
      : super(cbs_limits_configFB);

  @override
  CBS_LIMITS_CONFIGFilterBuilder equals(dynamic pValue) {
    return super.equals(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder equalsOrNull(dynamic pValue) {
    return super.equalsOrNull(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder isNull() {
    return super.isNull() as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder contains(dynamic pValue) {
    return super.contains(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder startsWith(dynamic pValue) {
    return super.startsWith(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder endsWith(dynamic pValue) {
    return super.endsWith(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder between(dynamic pFirst, dynamic pLast) {
    return super.between(pFirst, pLast) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder greaterThan(dynamic pValue) {
    return super.greaterThan(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder lessThan(dynamic pValue) {
    return super.lessThan(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder greaterThanOrEquals(dynamic pValue) {
    return super.greaterThanOrEquals(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder lessThanOrEquals(dynamic pValue) {
    return super.lessThanOrEquals(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGFilterBuilder inValues(dynamic pValue) {
    return super.inValues(pValue) as CBS_LIMITS_CONFIGFilterBuilder;
  }

  @override
  CBS_LIMITS_CONFIGField get not {
    return super.not as CBS_LIMITS_CONFIGField;
  }
}
// endregion CBS_LIMITS_CONFIGField

// region CBS_LIMITS_CONFIGFilterBuilder
class CBS_LIMITS_CONFIGFilterBuilder extends ConjunctionBase {
  CBS_LIMITS_CONFIGFilterBuilder(CBS_LIMITS_CONFIG obj, bool? getIsDeleted)
      : super(obj, getIsDeleted) {
    _mnCBS_LIMITS_CONFIG = obj._mnCBS_LIMITS_CONFIG;
    _softDeleteActivated = obj.softDeleteActivated;
  }

  bool _softDeleteActivated = false;
  CBS_LIMITS_CONFIGManager? _mnCBS_LIMITS_CONFIG;

  /// put the sql keyword 'AND'
  @override
  CBS_LIMITS_CONFIGFilterBuilder get and {
    super.and;
    return this;
  }

  /// put the sql keyword 'OR'
  @override
  CBS_LIMITS_CONFIGFilterBuilder get or {
    super.or;
    return this;
  }

  /// open parentheses
  @override
  CBS_LIMITS_CONFIGFilterBuilder get startBlock {
    super.startBlock;
    return this;
  }

  /// String whereCriteria, write raw query without 'where' keyword. Like this: 'field1 like 'test%' and field2 = 3'
  @override
  CBS_LIMITS_CONFIGFilterBuilder where(String? whereCriteria,
      {dynamic parameterValue}) {
    super.where(whereCriteria, parameterValue: parameterValue);
    return this;
  }

  /// page = page number,
  /// pagesize = row(s) per page
  @override
  CBS_LIMITS_CONFIGFilterBuilder page(int page, int pagesize) {
    super.page(page, pagesize);
    return this;
  }

  /// int count = LIMIT
  @override
  CBS_LIMITS_CONFIGFilterBuilder top(int count) {
    super.top(count);
    return this;
  }

  /// close parentheses
  @override
  CBS_LIMITS_CONFIGFilterBuilder get endBlock {
    super.endBlock;
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CBS_LIMITS_CONFIGFilterBuilder orderBy(dynamic argFields) {
    super.orderBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CBS_LIMITS_CONFIGFilterBuilder orderByDesc(dynamic argFields) {
    super.orderByDesc(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='field1, field2'
  /// Example 2: argFields = ['field1', 'field2']
  @override
  CBS_LIMITS_CONFIGFilterBuilder groupBy(dynamic argFields) {
    super.groupBy(argFields);
    return this;
  }

  /// argFields might be String or List<String>.
  /// Example 1: argFields='name, date'
  /// Example 2: argFields = ['name', 'date']
  @override
  CBS_LIMITS_CONFIGFilterBuilder having(dynamic argFields) {
    super.having(argFields);
    return this;
  }

  CBS_LIMITS_CONFIGField _setField(
      CBS_LIMITS_CONFIGField? field, String colName, DbType dbtype) {
    return CBS_LIMITS_CONFIGField(this)
      ..param = DbParameter(
          dbType: dbtype, columnName: colName, wStartBlock: openedBlock);
  }

  CBS_LIMITS_CONFIGField? _type;
  CBS_LIMITS_CONFIGField get type {
    return _type = _setField(_type, 'type', DbType.integer);
  }

  CBS_LIMITS_CONFIGField? _tranlimits;
  CBS_LIMITS_CONFIGField get tranlimits {
    return _tranlimits = _setField(_tranlimits, 'tranlimits', DbType.text);
  }

  /// Deletes List<CBS_LIMITS_CONFIG> bulk by query
  ///
  /// <returns>BoolResult res.success= true (Deleted), false (Could not be deleted)
  @override
  Future<BoolResult> delete([bool hardDelete = false]) async {
    buildParameters();
    var r = BoolResult(success: false);

    if (_softDeleteActivated && !hardDelete) {
      r = await _mnCBS_LIMITS_CONFIG!.updateBatch(qparams, {'isDeleted': 1});
    } else {
      r = await _mnCBS_LIMITS_CONFIG!.delete(qparams);
    }
    return r;
  }

  /// using:
  /// update({'fieldName': Value})
  /// fieldName must be String. Value is dynamic, it can be any of the (int, bool, String.. )
  @override
  Future<BoolResult> update(Map<String, dynamic> values) {
    buildParameters();
    if (qparams.limit! > 0 || qparams.offset! > 0) {
      qparams.whereString =
          'type IN (SELECT type from CBS_LIMITS_CONFIG ${qparams.whereString!.isNotEmpty ? 'WHERE ${qparams.whereString}' : ''}${qparams.limit! > 0 ? ' LIMIT ${qparams.limit}' : ''}${qparams.offset! > 0 ? ' OFFSET ${qparams.offset}' : ''})';
    }
    return _mnCBS_LIMITS_CONFIG!.updateBatch(qparams, values);
  }

  /// This method always returns [CBS_LIMITS_CONFIG] Obj if exist, otherwise returns null
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CBS_LIMITS_CONFIG?
  @override
  Future<CBS_LIMITS_CONFIG?> toSingle(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    buildParameters(pSize: 1);
    final objFuture = _mnCBS_LIMITS_CONFIG!.toList(qparams);
    final data = await objFuture;
    CBS_LIMITS_CONFIG? obj;
    if (data.isNotEmpty) {
      obj = CBS_LIMITS_CONFIG.fromMap(data[0] as Map<String, dynamic>);
    } else {
      obj = null;
    }
    return obj;
  }

  /// This method always returns [CBS_LIMITS_CONFIG]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toSingle(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toSingle(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns> CBS_LIMITS_CONFIG?
  @override
  Future<CBS_LIMITS_CONFIG> toSingleOrDefault(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    return await toSingle(
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields) ??
        CBS_LIMITS_CONFIG();
  }

  /// This method returns int. [CBS_LIMITS_CONFIG]
  /// <returns>int
  @override
  Future<int> toCount(
      [VoidCallback Function(int c)? cbs_limits_configCount]) async {
    buildParameters();
    qparams.selectColumns = ['COUNT(1) AS CNT'];
    final cbs_limits_configsFuture =
        await _mnCBS_LIMITS_CONFIG!.toList(qparams);
    final int count = cbs_limits_configsFuture[0]['CNT'] as int;
    if (cbs_limits_configCount != null) {
      cbs_limits_configCount(count);
    }
    return count;
  }

  /// This method returns List<CBS_LIMITS_CONFIG> [CBS_LIMITS_CONFIG]
  /// bool preload: if true, loads all related child objects (Set preload to true if you want to load all fields related to child or parent)
  /// ex: toList(preload:true) -> Loads all related objects
  /// List<String> preloadFields: specify the fields you want to preload (preload parameter's value should also be "true")
  /// ex: toList(preload:true, preloadFields:['plField1','plField2'... etc])  -> Loads only certain fields what you specified
  /// bool loadParents: if true, loads all parent objects until the object has no parent

  /// <returns>List<CBS_LIMITS_CONFIG>
  @override
  Future<List<CBS_LIMITS_CONFIG>> toList(
      {bool preload = false,
      List<String>? preloadFields,
      bool loadParents = false,
      List<String>? loadedFields}) async {
    final data = await toMapList();
    final List<CBS_LIMITS_CONFIG> cbs_limits_configsData =
        await CBS_LIMITS_CONFIG.fromMapList(data,
            preload: preload,
            preloadFields: preloadFields,
            loadParents: loadParents,
            loadedFields: loadedFields,
            setDefaultValues: qparams.selectColumns == null);
    return cbs_limits_configsData;
  }

  /// This method returns Json String [CBS_LIMITS_CONFIG]
  @override
  Future<String> toJson() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(o.toMap(forJson: true));
    }
    return json.encode(list);
  }

  /// This method returns Json String. [CBS_LIMITS_CONFIG]
  @override
  Future<String> toJsonWithChilds() async {
    final list = <dynamic>[];
    final data = await toList();
    for (var o in data) {
      list.add(await o.toMapWithChildren(false, true));
    }
    return json.encode(list);
  }

  /// This method returns List<dynamic>. [CBS_LIMITS_CONFIG]
  /// <returns>List<dynamic>
  @override
  Future<List<dynamic>> toMapList() async {
    buildParameters();
    return await _mnCBS_LIMITS_CONFIG!.toList(qparams);
  }

  /// This method returns Primary Key List SQL and Parameters retVal = Map<String,dynamic>. [CBS_LIMITS_CONFIG]
  /// retVal['sql'] = SQL statement string, retVal['args'] = whereArguments List<dynamic>;
  /// <returns>List<String>
  @override
  Map<String, dynamic> toListPrimaryKeySQL([bool buildParams = true]) {
    final Map<String, dynamic> _retVal = <String, dynamic>{};
    if (buildParams) {
      buildParameters();
    }
    _retVal['sql'] =
        'SELECT `type` FROM CBS_LIMITS_CONFIG WHERE ${qparams.whereString}';
    _retVal['args'] = qparams.whereArguments;
    return _retVal;
  }

  /// This method returns Primary Key List<String>.
  /// <returns>List<String>
  @override
  Future<List<String>> toListPrimaryKey([bool buildParams = true]) async {
    if (buildParams) {
      buildParameters();
    }
    final List<String> typeData = <String>[];
    qparams.selectColumns = ['type'];
    final typeFuture = await _mnCBS_LIMITS_CONFIG!.toList(qparams);

    final int count = typeFuture.length;
    for (int i = 0; i < count; i++) {
      typeData.add(typeFuture[i]['type'] as String);
    }
    return typeData;
  }

  /// Returns List<dynamic> for selected columns. Use this method for 'groupBy' with min,max,avg..  [CBS_LIMITS_CONFIG]
  /// Sample usage: (see EXAMPLE 4.2 at https://github.com/hhtokpinar/sqfEntity#group-by)
  @override
  Future<List<dynamic>> toListObject() async {
    buildParameters();

    final objectFuture = _mnCBS_LIMITS_CONFIG!.toList(qparams);

    final List<dynamic> objectsData = <dynamic>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i]);
    }
    return objectsData;
  }

  /// Returns List<String> for selected first column
  /// Sample usage: await CBS_LIMITS_CONFIG.select(columnsToSelect: ['columnName']).toListString()
  @override
  Future<List<String>> toListString(
      [VoidCallback Function(List<String> o)? listString]) async {
    buildParameters();

    final objectFuture = _mnCBS_LIMITS_CONFIG!.toList(qparams);

    final List<String> objectsData = <String>[];
    final data = await objectFuture;
    final int count = data.length;
    for (int i = 0; i < count; i++) {
      objectsData.add(data[i][qparams.selectColumns![0]].toString());
    }
    if (listString != null) {
      listString(objectsData);
    }
    return objectsData;
  }
}
// endregion CBS_LIMITS_CONFIGFilterBuilder

// region CBS_LIMITS_CONFIGFields
class CBS_LIMITS_CONFIGFields {
  static TableField? _fType;
  static TableField get type {
    return _fType =
        _fType ?? SqlSyntax.setField(_fType, 'type', DbType.integer);
  }

  static TableField? _fTranlimits;
  static TableField get tranlimits {
    return _fTranlimits = _fTranlimits ??
        SqlSyntax.setField(_fTranlimits, 'tranlimits', DbType.text);
  }
}
// endregion CBS_LIMITS_CONFIGFields

//region CBS_LIMITS_CONFIGManager
class CBS_LIMITS_CONFIGManager extends SqfEntityProvider {
  CBS_LIMITS_CONFIGManager()
      : super(CBS(),
            tableName: _tableName,
            primaryKeyList: _primaryKeyList,
            whereStr: _whereStr);
  static const String _tableName = 'CBS_LIMITS_CONFIG';
  static const List<String> _primaryKeyList = ['type'];
  static const String _whereStr = 'type=?';
}

//endregion CBS_LIMITS_CONFIGManager
class CBSSequenceManager extends SqfEntityProvider {
  CBSSequenceManager() : super(CBS());
}
// END OF ENTITIES
